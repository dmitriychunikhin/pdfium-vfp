*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="pdfium-vfp.vcx" CPID="1251" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS pdfium_env AS custom 		&& Pdfium Environment Configuration Object. Usage: create, setup and pass as first parameter of PdfiumViewer.Init, PdfiumReport.Init
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: declaredll		&& Declares dll functions
		*m: errmsg
		*m: getpdfdpi		&& PDF standart resolution (72 DPI)
		*m: getscreendpix		&& Screen horizontal DPI (constant 96 DPI)
		*m: getscreendpiy		&& Screen vertical DPI (constant 96 DPI)
		*m: getuniquetempfilename		&& Returns uniquie not existent filename in %userprofile%\AppData\Local\Temp
		*m: ok		&& Return TRUE if enviroment setup ended up with success
		*m: setup		&& Setup environment (from external environment if neccessary)
		*m: setuprelease
		*p: declaredll_ok
		*p: libhpdf_dll_path		&& Path to file libhpdf.dll. Filename without path also accepted
		*p: pdfium_dll_path		&& Path to file pdfium.dll. Filename without path also accepted
		*p: privatefonts		&& Collection of non system (custom / private) fonts. Key must be the font face name, Value - path to the font file
		*p: system		&& GDIPlusX System object
		*p: system_app_path		&& Path to file GDIPlusX system.app Filename without path also accepted
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,ClassLibrary,Class,CloneObject,Comment,ControlCount,Controls,declaredll_ok,Error,Height,HelpContextID,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		declaredll_ok = .F.
		Height = 27
		libhpdf_dll_path = (IIF(FILE(ADDBS(JUSTPATH(This.ClassLibrary))+"libhpdf.dll",1), ADDBS(JUSTPATH(This.ClassLibrary)), "") +  IIF(ATC("x64", SYS(17))<>0 , "libhpdf64.dll", "libhpdf.dll"))
		Name = "pdfium_env"
		pdfium_dll_path = (IIF(FILE(ADDBS(JUSTPATH(This.ClassLibrary))+"pdfium.dll",1), ADDBS(JUSTPATH(This.ClassLibrary)), "") + IIF(ATC("x64", SYS(17))<>0 , "pdfium64.dll", "pdfium.dll"))
		privatefonts = .F.
		system = .F.
		system_app_path = (IIF(FILE(ADDBS(JUSTPATH(This.ClassLibrary))+"system.app",1), ADDBS(JUSTPATH(This.ClassLibrary)), "") + "system.app")
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="pdfium_dll_path" type="property" display="pdfium_dll_path"/>
			<memberdata name="system" type="property" display="System"/>
			<memberdata name="declaredll" type="method" display="DeclareDll"/>
			<memberdata name="declaredll_ok" type="property" display="DeclareDll_ok"/>
			<memberdata name="errmsg" type="method" display="ErrMsg"/>
			<memberdata name="ok" type="method" display="ok"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="setuprelease" type="method" display="SetupRelease"/>
			<memberdata name="getpdfdpi" type="method" display="GetPDFDPI"/>
			<memberdata name="getscreendpix" type="method" display="GetScreenDPIX"/>
			<memberdata name="getscreendpiy" type="method" display="GetScreenDPIY"/>
			<memberdata name="libhpdf_dll_path" type="property" display="libhpdf_dll_path"/>
			<memberdata name="getuniquetempfilename" type="method" display="GetUniqueTempFileName"/>
			<memberdata name="system_app_path" type="property" display="system_app_path"/>
			<memberdata name="privatefonts" type="property" display="PrivateFonts"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE declaredll		&& Declares dll functions
		
		
		************************************************************************
		LOCAL lcPdfiumVfpDll
		lcPdfiumVfpDll = ADDBS(JUSTPATH(This.pdfium_dll_path)) + IIF(ATC("x64", SYS(17))<>0, "pdfium-vfp64.dll", "pdfium-vfp.dll")
		
		DECLARE LONG FPDF_SaveDocument IN (lcPdfiumVfpDll) AS FPDF_SaveDocument LONG document, STRING filepath, STRING@ errMsg, LONG errMsgSize &&errMsgSize: errMsg buffer size in chars, not in bytes
		DECLARE LONG FPDF_GetFontFileName IN (lcPdfiumVfpDll) AS FPDF_GetFontFileName STRING@ family_name, LONG is_bold, LONG is_italic, LONG nCharset, STRING@ buffer, LONG buflen, LONG@ nFontSimulations, LONG@ bSymbolFont
		
		
		************************************************************************
		LOCAL lcPdfiumDll
		lcPdfiumDll = This.pdfium_dll_path
		
		DECLARE FPDF_InitLibraryWithConfig IN (lcPdfiumDll) AS FPDF_InitLibraryWithConfig STRING config
		DECLARE FPDF_DestroyLibrary IN (lcPdfiumDll) AS FPDF_DestroyLibrary
		
		DECLARE LONG FPDF_LoadDocument IN (lcPdfiumDll) AS FPDF_LoadDocument STRING file_path, STRING password
		DECLARE LONG FPDF_LoadMemDocument IN (lcPdfiumDll) AS FPDF_LoadMemDocument STRING@ data_buf, integer size, STRING password
		DECLARE FPDF_CloseDocument IN (lcPdfiumDll) AS FPDF_CloseDocument LONG document
		
		DECLARE INTEGER FPDF_GetPageCount IN (lcPdfiumDll) AS FPDF_GetPageCount LONG document
		
		DECLARE LONG FPDF_LoadPage IN (lcPdfiumDll) AS FPDF_LoadPage LONG document, INTEGER page_index
		DECLARE FPDF_ClosePage IN (lcPdfiumDll) AS FPDF_ClosePage LONG page
		
		DECLARE FPDF_RenderPage IN (lcPdfiumDll) AS FPDF_RenderPage LONG dc, LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer flags
		DECLARE FPDF_RenderPageBitmap IN (lcPdfiumDll) AS FPDF_RenderPageBitmap LONG bitmap, LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer flags
		
		DECLARE LONG FPDFText_LoadPage IN (lcPdfiumDll) AS FPDFText_LoadPage LONG page
		DECLARE FPDFText_ClosePage IN (lcPdfiumDll) AS FPDFText_ClosePage LONG text_page
		
		DECLARE INTEGER FPDF_GetPageSizeByIndex IN (lcPdfiumDll) AS FPDF_GetPageSizeByIndex LONG document, integer page_index, double@ width, double@ height
		DECLARE double FPDF_GetPageWidth IN (lcPdfiumDll) AS FPDF_GetPageWidth LONG page
		DECLARE double FPDF_GetPageHeight IN (lcPdfiumDll) AS FPDF_GetPageHeight LONG page
		
		DECLARE INTEGER FPDFText_CountChars IN (lcPdfiumDll) AS FPDFText_CountChars LONG text_page
		
		DECLARE INTEGER FPDFText_GetCharIndexAtPos IN (lcPdfiumDll) AS FPDFText_GetCharIndexAtPos LONG text_page, double x, double y, double xTolerance, double yTolerance
		DECLARE INTEGER FPDFText_GetCharBox IN (lcPdfiumDll) AS FPDFText_GetCharBox LONG text_page, INTEGER index, double@ left, double@ right, double@ bottom, double@ top
		
		DECLARE INTEGER FPDFText_GetText IN (lcPdfiumDll) AS FPDFText_GetText LONG text_page, integer start_index, integer count, STRING@ result
		DECLARE LONG FPDFText_GetUnicode IN (lcPdfiumDll) AS FPDFText_GetUnicode LONG text_page, integer index
		
		DECLARE INTEGER FPDFText_CountRects IN (lcPdfiumDll) AS FPDFText_CountRects LONG text_page, integer start_index, integer count
		DECLARE INTEGER FPDFText_GetRect IN (lcPdfiumDll) AS FPDFText_GetRect LONG text_page, integer rect_index, double@ left, double@ top, double@ right, double@ bottom
		DECLARE INTEGER FPDFText_GetBoundedText IN (lcPdfiumDll) AS FPDFText_GetBoundedText LONG text_page, double left, double top, double right, double bottom, STRING@ buffer, integer buflen
		
		DECLARE INTEGER FPDF_DeviceToPage IN (lcPdfiumDll) AS FPDF_DeviceToPage LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer device_x, integer device_y, double@ page_x, double@ page_y
		DECLARE INTEGER FPDF_PageToDevice IN (lcPdfiumDll) AS FPDF_PageToDevice LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, double page_x, double page_y, string@ device_x, string@ device_y
		
		DECLARE LONG FPDFBitmap_Create IN (lcPdfiumDll) AS FPDFBitmap_Create integer width, integer height, integer alpha
		DECLARE LONG FPDFBitmap_CreateEx IN (lcPdfiumDll) AS FPDFBitmap_CreateEx integer width, integer height, integer format, LONG first_scan, integer stride
		DECLARE FPDFBitmap_Destroy IN (lcPdfiumDll) AS FPDFBitmap_Destroy LONG bitmap
		
		DECLARE LONG FPDFText_FindStart IN (lcPdfiumDll) AS FPDFText_FindStart LONG text_page, STRING findwhat, LONG flags, INTEGER start_index
		DECLARE LONG FPDFText_FindNext IN (lcPdfiumDll) AS FPDFText_FindNext LONG handle
		DECLARE LONG FPDFText_FindPrev IN (lcPdfiumDll) AS FPDFText_FindPrev LONG handle
		DECLARE INTEGER FPDFText_GetSchResultIndex IN (lcPdfiumDll) AS FPDFText_GetSchResultIndex LONG handle
		DECLARE INTEGER FPDFText_GetSchCount IN (lcPdfiumDll) AS FPDFText_GetSchCount LONG handle
		DECLARE FPDFText_FindClose IN (lcPdfiumDll) AS FPDFText_FindClose LONG handle
		
		
		
		
		************************************************************************
		LOCAL lcLibHaruDll
		lcLibhpdfDll = This.libhpdf_dll_path
		IF EMPTY(lcLibhpdfDll)=.F.
		    DECLARE INTEGER HPDF_New IN (lcLibhpdfDll) AS HPDF_New INTEGER user_error_fn, INTEGER user_data
		    DECLARE INTEGER HPDF_Free IN (lcLibhpdfDll) AS HPDF_Free INTEGER pdf
		    DECLARE INTEGER HPDF_SaveToFile IN (lcLibhpdfDll) AS HPDF_SaveToFile INTEGER pdf, STRING file_name
		    DECLARE INTEGER HPDF_SaveToStream IN (lcLibhpdfDll) AS HPDF_SaveToStream INTEGER pdf
		    DECLARE INTEGER HPDF_ReadFromStream IN (lcLibhpdfDll) AS HPDF_ReadFromStream INTEGER pdf, STRING@ buf, INTEGER@ size
		    DECLARE INTEGER HPDF_GetStreamSize IN (lcLibhpdfDll) AS HPDF_GetStreamSize INTEGER pdf
		    DECLARE INTEGER HPDF_GetError IN (lcLibhpdfDll) AS HPDF_GetError INTEGER pdf
		    DECLARE INTEGER HPDF_ResetError IN (lcLibhpdfDll) AS HPDF_ResetError INTEGER pdf
		    DECLARE INTEGER HPDF_SetPageMode IN (lcLibhpdfDll) AS HPDF_SetPageMode INTEGER pdf, INTEGER mode
		    DECLARE INTEGER HPDF_GetCurrentPage IN (lcLibhpdfDll) AS HPDF_GetCurrentPage INTEGER pdf
		    DECLARE INTEGER HPDF_AddPage IN (lcLibhpdfDll) AS HPDF_AddPage INTEGER pdf
		    DECLARE INTEGER HPDF_Page_SetWidth IN (lcLibhpdfDll) AS HPDF_Page_SetWidth INTEGER page, SINGLE value
		    DECLARE INTEGER HPDF_Page_SetHeight IN (lcLibhpdfDll) AS HPDF_Page_SetHeight INTEGER page, SINGLE value
		    DECLARE INTEGER HPDF_Page_SetSize IN (lcLibhpdfDll) AS HPDF_Page_SetSize INTEGER page, SINGLE size, SINGLE direction
		    DECLARE INTEGER HPDF_GetFont IN (lcLibhpdfDll) AS HPDF_GetFont INTEGER, STRING, STRING
		    DECLARE STRING  HPDF_LoadTTFontFromFile IN (lcLibhpdfDll) AS HPDF_LoadTTFontFromFile INTEGER, STRING, INTEGER
		    DECLARE INTEGER HPDF_GetEncoder IN (lcLibhpdfDll) AS HPDF_GetEncoder INTEGER, STRING
		    DECLARE INTEGER HPDF_GetCurrentEncoder IN (lcLibhpdfDll) AS HPDF_GetCurrentEncoder INTEGER
		    DECLARE INTEGER HPDF_SetCurrentEncoder IN (lcLibhpdfDll) AS HPDF_SetCurrentEncoder INTEGER, STRING
		    DECLARE INTEGER HPDF_Encoder_GetType IN (lcLibhpdfDll) AS HPDF_Encoder_GetType INTEGER
		    DECLARE INTEGER HPDF_Encoder_GetByteType IN (lcLibhpdfDll) AS HPDF_Encoder_GetByteType INTEGER, STRING, INTEGER
		    DECLARE STRING  HPDF_Encoder_GetUnicode IN (lcLibhpdfDll) AS HPDF_Encoder_GetUnicode INTEGER, STRING
		    DECLARE INTEGER HPDF_Encoder_GetWritingMode IN (lcLibhpdfDll) AS HPDF_Encoder_GetWritingMode INTEGER
		    DECLARE INTEGER HPDF_UseJPEncodings IN (lcLibhpdfDll) AS HPDF_UseJPEncodings INTEGER
		    DECLARE INTEGER HPDF_UseKREncodings IN (lcLibhpdfDll) AS HPDF_UseKREncodings INTEGER
		    DECLARE INTEGER HPDF_UseCNSEncodings IN (lcLibhpdfDll) AS HPDF_UseCNSEncodings INTEGER
		    DECLARE INTEGER HPDF_UseCNTEncodings IN (lcLibhpdfDll) AS HPDF_UseCNTEncodings INTEGER
		    DECLARE INTEGER HPDF_UseUTFEncodings IN (lcLibhpdfDll) AS HPDF_UseUTFEncodings INTEGER
		
		    DECLARE INTEGER HPDF_UseJPFonts IN (lcLibhpdfDll) AS HPDF_UseJPFonts INTEGER
		    DECLARE INTEGER HPDF_UseKRFonts IN (lcLibhpdfDll) AS HPDF_UseKRFonts INTEGER
		    DECLARE INTEGER HPDF_UseCNSFonts IN (lcLibhpdfDll) AS HPDF_UseCNSFonts INTEGER
		    DECLARE INTEGER HPDF_UseCNTFonts IN (lcLibhpdfDll) AS HPDF_UseCNTFonts INTEGER
		
		    DECLARE INTEGER HPDF_LoadPngImageFromFile IN (lcLibhpdfDll) AS HPDF_LoadPngImageFromFile INTEGER, STRING
		    DECLARE INTEGER HPDF_LoadJpegImageFromFile IN (lcLibhpdfDll) AS HPDF_LoadJpegImageFromFile INTEGER, STRING
		    DECLARE INTEGER HPDF_Image_GetWidth IN (lcLibhpdfDll) AS HPDF_Image_GetWidth INTEGER
		    DECLARE INTEGER HPDF_Image_GetHeight IN (lcLibhpdfDll) AS HPDF_Image_GetHeight INTEGER
		    DECLARE INTEGER HPDF_SetInfoAttr IN (lcLibhpdfDll) AS HPDF_SetInfoAttr INTEGER, INTEGER, STRING
		    DECLARE INTEGER HPDF_SetPassword IN (lcLibhpdfDll) AS HPDF_SetPassword INTEGER, STRING, STRING
		    DECLARE INTEGER HPDF_SetPermission IN (lcLibhpdfDll) AS HPDF_SetPermission INTEGER, INTEGER
		    DECLARE INTEGER HPDF_SetEncryptionMode IN (lcLibhpdfDll) AS HPDF_SetEncryptionMode INTEGER, INTEGER, INTEGER
		    DECLARE INTEGER HPDF_SetCompressionMode IN (lcLibhpdfDll) AS HPDF_SetCompressionMode INTEGER, INTEGER
		    DECLARE INTEGER HPDF_Font_MeasureText IN (lcLibhpdfDll) AS HPDF_Font_MeasureText INTEGER, STRING, INTEGER, SINGLE, SINGLE, SINGLE, SINGLE, INTEGER, SINGLE @
		    DECLARE SINGLE  HPDF_Page_GetWidth IN (lcLibhpdfDll) AS  HPDF_Page_GetWidth INTEGER
		    DECLARE SINGLE  HPDF_Page_GetHeight IN (lcLibhpdfDll) AS  HPDF_Page_GetHeight INTEGER
		    DECLARE SINGLE  HPDF_Page_TextWidth IN (lcLibhpdfDll) AS  HPDF_Page_TextWidth INTEGER, STRING
		    DECLARE INTEGER HPDF_Page_MeasureText IN (lcLibhpdfDll) AS HPDF_Page_MeasureText INTEGER, STRING, SINGLE, INTEGER, SINGLE @
		    DECLARE INTEGER HPDF_Page_GetRGBFill IN (lcLibhpdfDll) AS HPDF_Page_GetRGBFill INTEGER
		    DECLARE INTEGER HPDF_Page_GetCurrentFont IN (lcLibhpdfDll) AS HPDF_Page_GetCurrentFont INTEGER
		    DECLARE SINGLE  HPDF_Page_GetCurrentFontSize IN (lcLibhpdfDll) AS  HPDF_Page_GetCurrentFontSize INTEGER
		    DECLARE INTEGER HPDF_Page_SetLineWidth IN (lcLibhpdfDll) AS HPDF_Page_SetLineWidth INTEGER, SINGLE
		    DECLARE INTEGER HPDF_Page_SetDash IN (lcLibhpdfDll) AS HPDF_Page_SetDash INTEGER, STRING @, INTEGER, SINGLE
		    DECLARE INTEGER HPDF_Page_MoveTo IN (lcLibhpdfDll) AS HPDF_Page_MoveTo INTEGER, SINGLE, SINGLE
		    DECLARE INTEGER HPDF_Page_LineTo IN (lcLibhpdfDll) AS HPDF_Page_LineTo INTEGER, SINGLE, SINGLE
		    DECLARE INTEGER HPDF_Page_ClosePath IN (lcLibhpdfDll) AS HPDF_Page_ClosePath INTEGER
		    DECLARE INTEGER HPDF_Page_Rectangle IN (lcLibhpdfDll) AS HPDF_Page_Rectangle INTEGER, SINGLE, SINGLE, SINGLE, SINGLE
		    DECLARE INTEGER HPDF_Page_Concat IN (lcLibhpdfDll) AS HPDF_Page_Concat INTEGER, SINGLE, SINGLE, SINGLE, SINGLE, SINGLE, SINGLE
		    DECLARE INTEGER HPDF_Page_SetCharSpace IN (lcLibhpdfDll) AS HPDF_Page_SetCharSpace INTEGER, SINGLE
		    DECLARE INTEGER HPDF_Page_SetWordSpace IN (lcLibhpdfDll) AS HPDF_Page_SetWordSpace INTEGER, SINGLE
		    DECLARE INTEGER HPDF_Page_SetHorizontalScalling IN (lcLibhpdfDll) AS HPDF_Page_SetHorizontalScalling INTEGER, SINGLE
		    DECLARE INTEGER HPDF_Page_SetTextLeading IN (lcLibhpdfDll) AS HPDF_Page_SetTextLeading INTEGER, SINGLE
		    DECLARE INTEGER HPDF_Page_SetTextRise IN (lcLibhpdfDll) AS HPDF_Page_SetTextRise INTEGER, SINGLE
		    DECLARE INTEGER HPDF_Page_Stroke IN (lcLibhpdfDll) AS HPDF_Page_Stroke INTEGER
		    DECLARE INTEGER HPDF_Page_ClosePathStroke IN (lcLibhpdfDll) AS HPDF_Page_ClosePathStroke INTEGER
		    DECLARE INTEGER HPDF_Page_Fill IN (lcLibhpdfDll) AS HPDF_Page_Fill INTEGER
		    DECLARE INTEGER HPDF_Page_FillStroke IN (lcLibhpdfDll) AS HPDF_Page_FillStroke INTEGER
		    DECLARE INTEGER HPDF_Page_EndPath IN (lcLibhpdfDll) AS HPDF_Page_EndPath INTEGER
		    DECLARE INTEGER HPDF_Page_BeginText IN (lcLibhpdfDll) AS HPDF_Page_BeginText INTEGER
		    DECLARE INTEGER HPDF_Page_EndText IN (lcLibhpdfDll) AS HPDF_Page_EndText INTEGER
		    DECLARE INTEGER HPDF_Page_SetFontAndSize IN (lcLibhpdfDll) AS HPDF_Page_SetFontAndSize INTEGER, INTEGER, SINGLE
		    DECLARE INTEGER HPDF_Page_SetTextRenderingMode IN (lcLibhpdfDll) AS HPDF_Page_SetTextRenderingMode INTEGER, INTEGER
		    DECLARE INTEGER HPDF_Page_MoveTextPos IN (lcLibhpdfDll) AS HPDF_Page_MoveTextPos INTEGER, SINGLE, SINGLE
		    DECLARE INTEGER HPDF_Page_MoveToNextLine IN (lcLibhpdfDll) AS HPDF_Page_MoveToNextLine INTEGER
		    DECLARE INTEGER HPDF_Page_SetRGBFill IN (lcLibhpdfDll) AS HPDF_Page_SetRGBFill INTEGER, SINGLE, SINGLE, SINGLE
		    DECLARE INTEGER HPDF_Page_SetRGBStroke IN (lcLibhpdfDll) AS HPDF_Page_SetRGBStroke INTEGER, SINGLE, SINGLE, SINGLE
		    DECLARE INTEGER HPDF_Page_Ellipse IN (lcLibhpdfDll) AS HPDF_Page_Ellipse INTEGER, SINGLE, SINGLE, SINGLE, SINGLE
		    DECLARE INTEGER HPDF_Page_DrawImage IN (lcLibhpdfDll) AS HPDF_Page_DrawImage INTEGER, INTEGER, SINGLE, SINGLE, SINGLE, SINGLE
		    DECLARE INTEGER HPDF_Page_TextRect IN (lcLibhpdfDll) AS HPDF_Page_TextRect INTEGER, SINGLE, SINGLE, SINGLE, SINGLE, STRING, INTEGER, INTEGER
		    DECLARE INTEGER HPDF_Page_TextOut IN (lcLibhpdfDll) AS HPDF_Page_TextOut INTEGER, SINGLE, SINGLE, STRING
		    DECLARE INTEGER HPDF_Page_SetTextMatrix IN (lcLibhpdfDll) AS HPDF_Page_SetTextMatrix INTEGER ,SINGLE, SINGLE, SINGLE, SINGLE, SINGLE, SINGLE
		    DECLARE INTEGER HPDF_Page_ShowText IN (lcLibhpdfDll) AS HPDF_Page_ShowText INTEGER, STRING
		    DECLARE INTEGER HPDF_Page_CurveTo IN (lcLibhpdfDll) AS HPDF_Page_CurveTo INTEGER, SINGLE, SINGLE, SINGLE, SINGLE, SINGLE, SINGLE
		    
		    DECLARE INTEGER HPDF_Page_GSave IN (lcLibhpdfDll) AS HPDF_Page_GSave INTEGER page
		    DECLARE INTEGER HPDF_Page_GRestore IN (lcLibhpdfDll) AS HPDF_Page_GRestore INTEGER page
		    DECLARE INTEGER HPDF_Page_ExecuteXObject IN (lcLibhpdfDll) AS HPDF_Page_ExecuteXObject INTEGER page, INTEGER obj
		    
		    DECLARE INTEGER HPDF_CreateExtGState IN (lcLibhpdfDll) AS HPDF_CreateExtGState INTEGER pdf
		    DECLARE INTEGER HPDF_ExtGState_SetAlphaFill IN (lcLibhpdfDll) AS HPDF_ExtGState_SetAlphaFill INTEGER page, SINGLE value
		    DECLARE INTEGER HPDF_ExtGState_SetAlphaStroke IN (lcLibhpdfDll) AS HPDF_ExtGState_SetAlphaStroke INTEGER page, SINGLE value
		    DECLARE INTEGER HPDF_Page_SetExtGState IN (lcLibhpdfDll) AS HPDF_Page_SetExtGState INTEGER page, INTEGER ext_gstate
		    
		ENDIF
		
		
		************************************************************************
		DECLARE INTEGER GetModuleHandle IN kernel32 AS WinApi_GetModuleHandle LONG lpModuleName
		
		DECLARE LONG GetWindowLong IN user32 AS WinApi_GetWindowLong LONG hWnd, INTEGER nIndex
		DECLARE LONG SetWindowLong IN user32 AS WinApi_SetWindowLong LONG hWnd, INTEGER nIndex, LONG dwNewLong
		
		DECLARE INTEGER GetClassInfoEx IN user32 AS WinApi_GetClassInfoEx LONG hInstance, STRING lpClassName, STRING@ lpWndClassEx
		DECLARE LONG RegisterClassEx IN user32 AS WinApi_RegisterClassEx STRING lpWndClassEx
		
		DECLARE LONG CreateWindowEx IN user32 AS WinApi_CreateWindowEx  ;
		    LONG dwExStyle, ;
		    STRING lpClassName,;
		    STRING lpWindowName, LONG dwStyle,;
		    INTEGER x, INTEGER y, INTEGER nWidth, INTEGER nHeight,;
		    LONG hWndParent, LONG hMenu, LONG hInstance,;
		    LONG lpParam  
		
		DECLARE LONG MoveWindow IN user32 AS WinApi_MoveWindow LONG hWnd, INTEGER X, INTEGER Y, INTEGER nWidth, INTEGER nHeight, INTEGER bRepaint
		
		DECLARE LONG SetWindowPos IN user32 AS WinApi_SetWindowPos ;
		    LONG hWnd, ;
		    LONG hWndInsertAfter, ;
		    INTEGER X, INTEGER Y,;
		    INTEGER nWidth, INTEGER nHeight, ;
		    LONG uFlags
		
		DECLARE LONG DestroyWindow IN user32 AS WinApi_DestroyWindow LONG hWnd
		
		DECLARE LONG GetWindow IN user32 AS WinApi_GetWindow LONG hWnd, LONG uCmd
		
		
		DECLARE INTEGER BitBlt IN WIN32API AS WinApi_BitBlt INTEGER hdc, INTEGER nXDest, INTEGER nYDest, INTEGER nWidth, INTEGER nHeight, Long hdcSrc, INTEGER nXSrc, INTEGER nYSrc, INTEGER nRop
		DECLARE INTEGER CreateDIBSection IN WIN32API AS WinApi_CreateDIBSection INTEGER hdc, STRING pbmi, LONG iUsage, INTEGER @ppvBits, INTEGER hSection, LONG dwOffset
		DECLARE INTEGER CreateCompatibleBitmap IN WIN32API AS WinApi_CreateCompatibleBitmap INTEGER hdc, INTEGER cx, INTEGER cy
		DECLARE INTEGER SelectObject IN WIN32API AS WinApi_SelectObject INTEGER hdc, INTEGER hgdiobj
		DECLARE INTEGER DeleteObject IN WIN32API AS WinApi_DeleteObject INTEGER hObject
		DECLARE INTEGER CreateCompatibleDC IN WIN32API AS WinApi_CreateCompatibleDC INTEGER hDC
		DECLARE INTEGER GetDC IN WIN32API AS WinApi_GetDC INTEGER hWnd
		DECLARE Long ReleaseDC IN WIN32API AS WinApi_ReleaseDC Long hWnd, Long hDC
		DECLARE Long DeleteDC IN WIN32API AS WinApi_DeleteDC Long hdc
		DECLARE INTEGER SaveDC IN WIN32API AS WinApi_SaveDC LONG hdc
		DECLARE INTEGER RestoreDC IN WIN32API AS WinApi_RestoreDC LONG hdc, INTEGER nSavedDC
		DECLARE INTEGER CancelDC IN WIN32API AS WinApi_CancelDC LONG hdc
		
		DECLARE Long GlobalAlloc IN WIN32API AS WinApi_GlobalAlloc Long nFlags, Long nSize
		DECLARE Long GlobalFree IN WIN32API AS WinApi_GlobalFree Long nHandle
		DECLARE INTEGER GdiFlush IN WIN32API AS WinApi_GdiFlush
		DECLARE LONG GlobalLock IN WIN32API AS WinApi_GlobalLock LONG hMem
		DECLARE LONG GlobalUnlock IN WIN32API AS WinApi_GlobalUnlock LONG hMem
		
		
		DECLARE INTEGER GetStockObject IN WIN32API AS WinApi_GetStockObject INTEGER index
		
		DECLARE LONG BeginPaint IN WIN32API AS WinApi_BeginPaint LONG hWnd, STRING@ lpPaint
		DECLARE INTEGER EndPaint IN WIN32API AS WinApi_EndPaint LONG hWnd, STRING lpPaint
		
		DECLARE LONG InvalidateRect IN WIN32API AS WinApi_InvalidateRect LONG hWnd, LONG lpRect, LONG bErase
		DECLARE LONG UpdateWindow IN WIN32API AS WinApi_UpdateWindow LONG hWnd
		DECLARE LONG GetWindowRect IN WIN32API AS WinApi_GetWindowRect LONG hWnd, STRING@ lpRect
		
		DECLARE LONG CallWindowProc IN WIN32API AS WinApi_CallWindowProc LONG lpPrevWndFunc, LONG hWnd, LONG Msg, LONG wParam, LONG lParam
		
		DECLARE LONG EnableScrollBar IN WIN32API AS WinApi_EnableScrollBar LONG hWnd, LONG wSBflags, LONG wArrows
		DECLARE LONG ShowScrollBar IN WIN32API AS WinApi_ShowScrollBar LONG hWnd, LONG wBar, LONG bShow
		DECLARE INTEGER SetScrollInfo IN WIN32API AS WinApi_SetScrollInfo LONG hwnd, INTEGER nBar, STRING lpsi, LONG redraw
		DECLARE LONG GetScrollInfo IN WIN32API AS WinApi_GetScrollInfo LONG hwnd, INTEGER nBar, STRING@ lpsi
		
		DECLARE LONG ShowWindow IN WIN32API AS WinApi_ShowWindow LONG hWnd, INTEGER nCmdShow
		
		DECLARE LONG SetActiveWindow IN WIN32API AS WinApi_SetActiveWindow LONG hWnd
		DECLARE LONG SetFocus IN WIN32API AS WinApi_SetFocus LONG hWnd
		
		DECLARE SHORT GetAsyncKeyState IN WIN32API AS WinApi_GetAsyncKeyState INTEGER vKey
		DECLARE SHORT GetKeyState IN WIN32API AS WinApi_GetKeyState INTEGER vKey
		
		DECLARE INTEGER SetClipboardData IN user32 AS WinApi_SetClipboardData INTEGER uFormat, INTEGER hMem
		DECLARE INTEGER GetClipboardData IN user32 AS WinApi_GetClipboardData INTEGER uFormat
		DECLARE INTEGER OpenClipboard IN user32 AS WinApi_OpenClipboard INTEGER hWndNewOwner
		DECLARE INTEGER CloseClipboard IN user32 AS WinApi_CloseClipboard
		DECLARE INTEGER EmptyClipboard IN user32 AS WinApi_EmptyClipboard
		DECLARE INTEGER GetOpenClipboardWindow IN user32 AS WinApi_GetOpenClipboardWindow
		DECLARE INTEGER IsClipboardFormatAvailable IN user32 AS WinApi_IsClipboardFormatAvailable INTEGER uFormat
		DECLARE INTEGER GetSystemDefaultLCID IN WIN32API AS WinApi_GetSystemDefaultLCID
		
		DECLARE LONG GetTickCount IN WIN32API AS WinApi_GetTickCount
		
		DECLARE Long GdipMeasureString IN GDIPLUS.DLL AS WinApi_GdipMeasureString Long graphics, String str, Long length, Long thefont, String @layoutRect, Long StringFormat, String @boundingBox, Long @codepointsFitted, Long @linesFilled
		DECLARE Long GdipDrawString IN GDIPLUS.DLL AS WinApi_GdipDrawString Long graphics, String str, Long length, Long thefont, String @layoutRect, Long StringFormat, Long brush
		
	ENDPROC

	PROCEDURE Destroy
		This.PrivateFonts = .F.
		This.System = .F.
		This.SetupRelease()
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		lcMsg = ""
		
		DO CASE
		CASE VARTYPE(m.tvMsg)="O"
		    lcMsg = ;
		        m.tvMsg.Message + ;
		        RTRIM(" " + NVL(m.tvMsg.Details,"")) + ;
		        RTRIM(" " + NVL(m.tvMsg.UserValue,"")) + ;
		        CHR(13) + "Procedure: " + m.tvMsg.Procedure + ;
		        CHR(13) + "LineContents: " + m.tvMsg.LineContents
		
		CASE VARTYPE(m.tvMsg)="C"
		    lcMsg = ALLTRIM(m.tvMsg)
		
		ENDCASE
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		MESSAGEBOX(m.lcMsg, 0+48, This.Class + " ("+This.ClassLibrary+")")
		
		
	ENDPROC

	PROCEDURE getpdfdpi		&& PDF standart resolution (72 DPI)
		RETURN 72
		
	ENDPROC

	PROCEDURE getscreendpix		&& Screen horizontal DPI (constant 96 DPI)
		RETURN 96
		
	ENDPROC

	PROCEDURE getscreendpiy		&& Screen vertical DPI (constant 96 DPI)
		RETURN 96
		
	ENDPROC

	PROCEDURE getuniquetempfilename		&& Returns uniquie not existent filename in %userprofile%\AppData\Local\Temp
		LPARAMETERS tcFileExt
		
		LOCAL lcFileExt
		lcFileExt = ALLTRIM(EVL(NVL(m.tcFileExt,""),""), 1, " ", ".")
		
		LOCAL lcPath
		lcPath = ADDBS(SYS(2023))
		
		LOCAL lcFilename
		lcFilename = ""
		
		LOCAL i
		FOR i = 1 TO 500
		    lcFilename = lcPath + "pdfium_vfp" + SYS(2015) + IIF(EMPTY(lcFileExt), "", "." + lcFileExt)
		    
		    IF FILE(lcFilename,1) OR DIRECTORY(lcFilename,1)
		        lcFilename = ""
		        LOOP
		    ENDIF
		
		    EXIT
		ENDFOR
		
		RETURN lcFilename
		
		
	ENDPROC

	PROCEDURE Init
		This.PrivateFonts = NEWOBJECT("Collection")
		
	ENDPROC

	PROCEDURE ok		&& Return TRUE if enviroment setup ended up with success
		RETURN This.declaredll_ok
		
	ENDPROC

	PROCEDURE setup		&& Setup environment (from external environment if neccessary)
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.SetupRelease()
		
		IF VARTYPE(m.toEnv)="O"
		    This.System = IIF(VARTYPE(m.toEnv.System)="O", m.toEnv.System, This.System)
		    This.pdfium_dll_path = EVL(NVL(m.toEnv.pdfium_dll_path,""), This.pdfium_dll_path)
		    This.libhpdf_dll_path = EVL(NVL(m.toEnv.libhpdf_dll_path,""), "")
		    This.system_app_path = EVL(NVL(m.toEnv.system_app_path,""), This.system_app_path)  
		
		    This.PrivateFonts = IIF(VARTYPE(m.toEnv.PrivateFonts)="O", m.toEnv.PrivateFonts, This.PrivateFonts)
		ENDIF
		
		IF VARTYPE(This.System)<>"O" AND FILE(This.system_app_path,1)
		    LOCAL loTemp
		    loTemp = NEWOBJECT("Empty")
		    DO (This.system_app_path) WITH loTemp
		    This.System = loTemp.System
		    loTemp = .F.
		ENDIF
		
		IF VARTYPE(This.System)<>"O" AND TYPE("_SCREEN.System")="O"
		    This.System = _SCREEN.System
		ENDIF
		
		IF VARTYPE(This.System)<>"O"
		    This.errMsg(TEXTMERGE("<<This.Class>>.System: GDIPlusX System object wasn't found. It must be passed through <<This.Class>>.Init toConf parameter or as _SCREEN.System"))
		    RETURN .F.
		ENDIF
		
		
		This.pdfium_dll_path = FULLPATH(ALLTRIM(EVL(NVL(This.pdfium_dll_path,""),"")))
		
		IF FILE(This.pdfium_dll_path,1)=.F.
		    This.errMsg(TEXTMERGE("<<This.Class>>.pdfium_dll_path: File <<This.pdfium_dll_path>> does not exist"))
		    RETURN .F.
		ENDIF
		
		
		IF EMPTY(This.libhpdf_dll_path)=.F.
		    This.libhpdf_dll_path = FULLPATH(ALLTRIM(EVL(NVL(This.libhpdf_dll_path,""),"")))
		
		    IF FILE(This.libhpdf_dll_path,1)=.F.
		        This.errMsg(TEXTMERGE("<<This.Class>>.libhpdf_dll_path: File <<This.libhpdf_dll_path>> does not exist"))
		        RETURN .F.
		    ENDIF
		ENDIF
		
		
		
		This.declaredll_ok = .F.
		LOCAL loErr
		loErr = .F.
		TRY
		    This.declaredll()
		
		    IF PEMSTATUS(Application, "pdfium_instance_count", 5)=.F.
		        ADDPROPERTY(Application, "pdfium_instance_count", 0)
		    ENDIF
		
		    IF Application.pdfium_instance_count = 0
		        LOCAL lcConfig
		        lcConfig = REPLICATE(CHR(0),24)
		        lcConfig = STUFF(lcConfig, 1,4, BINTOC(2, "4RS"))
		
		        FPDF_InitLibraryWithConfig(lcConfig)
		    ENDIF
		    Application.pdfium_instance_count = Application.pdfium_instance_count + 1
		
		    This.declaredll_ok = .T.
		
		CATCH TO loErr
		    This.errMsg(loErr)
		ENDTRY
		
		IF This.declaredll_ok = .F.
		    RETURN .F.
		ENDIF
		
		
		* Private fonts installing
		LOCAL loErr
		loErr = .F.
		TRY
		
		    LOCAL lcFontPath
		    lcFontPath = ""
		    FOR EACH lcFontPath IN This.PrivateFonts FOXOBJECT
		        IF FILE(ALLTRIM(lcFontPath),1)
		            This.System.Drawing.Text.PrivateFontCollection.AddFontFile(ALLTRIM(lcFontPath) + CHR(0))
		        ENDIF
		    ENDFOR
		
		CATCH TO loErr
		    This.errMsg(loErr)
		ENDTRY
		
		
	ENDPROC

	HIDDEN PROCEDURE setuprelease
		
		IF This.declaredll_ok = .F.
		    RETURN
		ENDIF
		
		This.declaredll_ok = .F.
		
		IF PEMSTATUS(Application, "pdfium_instance_count", 5)=.T.
		
		    IF Application.pdfium_instance_count = 1
		        FPDF_DestroyLibrary()
		    ENDIF
		
		    Application.pdfium_instance_count = MAX(Application.pdfium_instance_count - 1, 0)
		
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_i18n AS custom 		&& PdfiumViewer Internationalization Helper. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: getlocaleid		&& Returns system locale id
		*m: text		&& Returns all of the text in a text-entry area of a control.
		*m: text_cn
		*m: text_de
		*m: text_en
		*m: text_es
		*m: text_fr
		*m: text_ru
		*p: localeid
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,ClassLibrary,Class,CloneObject,Comment,ControlCount,Controls,Error,Height,HelpContextID,localeid,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		localeid = 1033
		Name = "pdfium_i18n"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="localeid" type="property" display="LocaleID"/>
			<memberdata name="getlocaleid" type="method" display="GetLocaleID"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE getlocaleid		&& Returns system locale id
		RETURN This.LocaleID
		
	ENDPROC

	PROCEDURE Init
		DECLARE INTEGER GetSystemDefaultLCID IN WIN32API AS WinApi_GetSystemDefaultLCID
		This.LocaleID = WinApi_GetSystemDefaultLCID()
		
		
	ENDPROC

	PROCEDURE text		&& Returns all of the text in a text-entry area of a control.
		LPARAMETERS tcTxtID
		
		LOCAL lcTxtID
		lcTxtID = UPPER(ALLTRIM(EVL(NVL(m.tcTxtID,""),"")))
		
		IF EMPTY(lcTxtID)
		    RETURN ""
		ENDIF
		
		
		DO CASE 
		CASE This.LocaleID = 1031
		    RETURN This.text_de(lcTxtID)
		
		CASE This.LocaleID = 1033
		    RETURN This.text_en(lcTxtID)
		
		CASE This.LocaleID = 1034
		    RETURN This.text_es(lcTxtID)
		
		CASE This.LocaleID = 1036
		    RETURN This.text_fr(lcTxtID)
		
		CASE This.LocaleID = 1049
		    RETURN This.text_ru(lcTxtID)
		
		CASE This.LocaleID = 2052
		    RETURN This.text_cn(lcTxtID)
		
		OTHERWISE
		    RETURN This.text_en(lcTxtID)
		
		ENDCASE
		
	ENDPROC

	HIDDEN PROCEDURE text_cn
		LPARAMETERS tcTxtID
		* This code is generated by Pdfiumbuild of pdfium-vfp-build.vcx
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(63) + CHR(63)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(63) + CHR(63) + CHR(63) + CHR(63)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(63)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
	ENDPROC

	HIDDEN PROCEDURE text_de
		LPARAMETERS tcTxtID
		* This code is generated by Pdfiumbuild of pdfium-vfp-build.vcx
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(75) + CHR(111) + CHR(112) + CHR(105) + CHR(101) + CHR(114) + CHR(101) + CHR(110)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(65) + CHR(108) + CHR(108) + CHR(101) + CHR(115) + CHR(32) + CHR(109) + CHR(97) + CHR(114) + CHR(107) + CHR(105) + CHR(101) + CHR(114) + CHR(101) + CHR(110)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
	ENDPROC

	HIDDEN PROCEDURE text_en
		LPARAMETERS tcTxtID
		* This code is generated by Pdfiumbuild of pdfium-vfp-build.vcx
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(121)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(83) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(116) + CHR(32) + CHR(97) + CHR(108) + CHR(108)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(67) + CHR(117) + CHR(116)
		
		
		CASE m.tcTxtID == "MNU_PASTE"
		RETURN CHR(80) + CHR(97) + CHR(115) + CHR(116) + CHR(101)
		
		
		CASE m.tcTxtID == "MNU_CLEAR"
		RETURN CHR(67) + CHR(108) + CHR(101) + CHR(97) + CHR(114)
		
		
		CASE m.tcTxtID == "REPORTVIEWER_TITLE"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(32) + CHR(112) + CHR(114) + CHR(101) + CHR(118) + CHR(105) + CHR(101) + CHR(119)
		
		
		CASE m.tcTxtID == "SEARCH_NOT_FOUND"
		RETURN CHR(78) + CHR(111) + CHR(116) + CHR(32) + CHR(102) + CHR(111) + CHR(117) + CHR(110) + CHR(100)
		
		
		CASE m.tcTxtID == "SEARCH_ENDED"
		RETURN CHR(83) + CHR(101) + CHR(97) + CHR(114) + CHR(99) + CHR(104) + CHR(32) + CHR(101) + CHR(110) + CHR(100) + CHR(101) + CHR(100)
		
		
		CASE m.tcTxtID == "BTN_PRINT"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PRINTENV_TITLE"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(32) + CHR(115) + CHR(101) + CHR(116) + CHR(116) + CHR(105) + CHR(110) + CHR(103)
		
		
		CASE m.tcTxtID == "PRINTENV_OK"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PRINTENV_CANCEL"
		RETURN CHR(67) + CHR(97) + CHR(110) + CHR(99) + CHR(101) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTENV_PRINTER"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(101) + CHR(114)
		
		
		CASE m.tcTxtID == "PRINTENV_COPIES"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(105) + CHR(101) + CHR(115)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE"
		RETURN CHR(80) + CHR(97) + CHR(103) + CHR(101) + CHR(115)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ALL"
		RETURN CHR(65) + CHR(108) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ODD"
		RETURN CHR(79) + CHR(100) + CHR(100) + CHR(32) + CHR(112) + CHR(97) + CHR(103) + CHR(101) + CHR(115) + CHR(32) + CHR(111) + CHR(110) + CHR(108) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_EVEN"
		RETURN CHR(69) + CHR(118) + CHR(101) + CHR(110) + CHR(32) + CHR(112) + CHR(97) + CHR(103) + CHR(101) + CHR(115) + CHR(32) + CHR(111) + CHR(110) + CHR(108) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_PAGELIST"
		RETURN CHR(69) + CHR(120) + CHR(97) + CHR(109) + CHR(112) + CHR(108) + CHR(101) + CHR(58) + CHR(32) + CHR(49) + CHR(45) + CHR(51) + CHR(44) + CHR(32) + CHR(53) + CHR(45) + CHR(56) + CHR(44) + CHR(32) + CHR(57)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_DUPLEX"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(32) + CHR(111) + CHR(110) + CHR(32) + CHR(98) + CHR(111) + CHR(116) + CHR(104) + CHR(32) + CHR(115) + CHR(105) + CHR(100) + CHR(101) + CHR(115)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE"
		RETURN CHR(80) + CHR(97) + CHR(112) + CHR(101) + CHR(114) + CHR(32) + CHR(115) + CHR(105) + CHR(122) + CHR(101)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE_AUTO"
		RETURN CHR(65) + CHR(117) + CHR(116) + CHR(111) + CHR(109) + CHR(97) + CHR(116) + CHR(105) + CHR(99) + CHR(32) + CHR(99) + CHR(104) + CHR(111) + CHR(105) + CHR(99) + CHR(101)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_TITLE"
		RETURN CHR(73) + CHR(110) + CHR(112) + CHR(117) + CHR(116) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_PROMPT"
		RETURN CHR(80) + CHR(68) + CHR(70) + CHR(32) + CHR(102) + CHR(105) + CHR(108) + CHR(101) + CHR(32) + CHR(105) + CHR(115) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100) + CHR(32) + CHR(112) + CHR(114) + CHR(111) + CHR(116) + CHR(101) + CHR(99) + CHR(116) + CHR(101) + CHR(100) + CHR(46) + CHR(32) + CHR(73) + CHR(110) + CHR(112) + CHR(117) + CHR(116) + CHR(32) + CHR(97) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100) + CHR(32) + CHR(116) + CHR(111) + CHR(32) + CHR(111) + CHR(112) + CHR(101) + CHR(110) + CHR(32) + CHR(116) + CHR(104) + CHR(101) + CHR(32) + CHR(102) + CHR(105) + CHR(108) + CHR(101) + CHR(46)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_INCORRECTPASSWORD"
		RETURN CHR(73) + CHR(110) + CHR(99) + CHR(111) + CHR(114) + CHR(114) + CHR(101) + CHR(99) + CHR(116) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_OK"
		RETURN CHR(79) + CHR(112) + CHR(101) + CHR(110) + CHR(32) + CHR(100) + CHR(111) + CHR(99) + CHR(117) + CHR(109) + CHR(101) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_CANCEL"
		RETURN CHR(67) + CHR(97) + CHR(110) + CHR(99) + CHR(101) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_BORDERLESS"
		RETURN CHR(66) + CHR(111) + CHR(114) + CHR(100) + CHR(101) + CHR(114) + CHR(108) + CHR(101) + CHR(115) + CHR(115) + CHR(32) + CHR(112) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(105) + CHR(110) + CHR(103)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_TITLE"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(101) + CHR(114) + CHR(32) + CHR(115) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(116) + CHR(105) + CHR(111) + CHR(110)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_OK"
		RETURN CHR(65) + CHR(112) + CHR(112) + CHR(108) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_CANCEL"
		RETURN CHR(67) + CHR(97) + CHR(110) + CHR(99) + CHR(101) + CHR(108)
		
		OTHERWISE
		RETURN m.tcTxtID
		
		ENDCASE
		
		RETURN m.tcTxtID
	ENDPROC

	HIDDEN PROCEDURE text_es
		LPARAMETERS tcTxtID
		* This code is generated by Pdfiumbuild of pdfium-vfp-build.vcx
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(105) + CHR(97) + CHR(114)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(83) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(99) + CHR(105) + CHR(111) + CHR(110) + CHR(97) + CHR(114) + CHR(32) + CHR(116) + CHR(111) + CHR(100) + CHR(111)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
	ENDPROC

	HIDDEN PROCEDURE text_fr
		LPARAMETERS tcTxtID
		* This code is generated by Pdfiumbuild of pdfium-vfp-build.vcx
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(105) + CHR(101) + CHR(114)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(83) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(116) + CHR(105) + CHR(111) + CHR(110) + CHR(110) + CHR(101) + CHR(114) + CHR(32) + CHR(116) + CHR(111) + CHR(117) + CHR(116)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
	ENDPROC

	HIDDEN PROCEDURE text_ru
		LPARAMETERS tcTxtID
		* This code is generated by Pdfiumbuild of pdfium-vfp-build.vcx
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(202) + CHR(238) + CHR(239) + CHR(232) + CHR(240) + CHR(238) + CHR(226) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(194) + CHR(251) + CHR(225) + CHR(240) + CHR(224) + CHR(242) + CHR(252) + CHR(32) + CHR(226) + CHR(241) + CHR(229)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(194) + CHR(251) + CHR(240) + CHR(229) + CHR(231) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "MNU_PASTE"
		RETURN CHR(194) + CHR(241) + CHR(242) + CHR(224) + CHR(226) + CHR(232) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "MNU_CLEAR"
		RETURN CHR(211) + CHR(228) + CHR(224) + CHR(235) + CHR(232) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "REPORTVIEWER_TITLE"
		RETURN CHR(207) + CHR(240) + CHR(238) + CHR(241) + CHR(236) + CHR(238) + CHR(242) + CHR(240) + CHR(32) + CHR(239) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(232)
		
		
		CASE m.tcTxtID == "SEARCH_NOT_FOUND"
		RETURN CHR(205) + CHR(229) + CHR(32) + CHR(237) + CHR(224) + CHR(233) + CHR(228) + CHR(229) + CHR(237) + CHR(238)
		
		
		CASE m.tcTxtID == "SEARCH_ENDED"
		RETURN CHR(207) + CHR(238) + CHR(232) + CHR(241) + CHR(234) + CHR(32) + CHR(231) + CHR(224) + CHR(226) + CHR(229) + CHR(240) + CHR(248) + CHR(229) + CHR(237)
		
		
		CASE m.tcTxtID == "BTN_PRINT"
		RETURN CHR(207) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTENV_TITLE"
		RETURN CHR(207) + CHR(224) + CHR(240) + CHR(224) + CHR(236) + CHR(229) + CHR(242) + CHR(240) + CHR(251) + CHR(32) + CHR(239) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(232)
		
		
		CASE m.tcTxtID == "PRINTENV_OK"
		RETURN CHR(207) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTENV_CANCEL"
		RETURN CHR(206) + CHR(242) + CHR(236) + CHR(229) + CHR(237) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTENV_PRINTER"
		RETURN CHR(207) + CHR(240) + CHR(232) + CHR(237) + CHR(242) + CHR(229) + CHR(240)
		
		
		CASE m.tcTxtID == "PRINTENV_COPIES"
		RETURN CHR(202) + CHR(238) + CHR(239) + CHR(232) + CHR(232)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE"
		RETURN CHR(209) + CHR(242) + CHR(240) + CHR(224) + CHR(237) + CHR(232) + CHR(246) + CHR(251)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ALL"
		RETURN CHR(194) + CHR(241) + CHR(229)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ODD"
		RETURN CHR(210) + CHR(238) + CHR(235) + CHR(252) + CHR(234) + CHR(238) + CHR(32) + CHR(237) + CHR(229) + CHR(247) + CHR(229) + CHR(242) + CHR(237) + CHR(251) + CHR(229)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_EVEN"
		RETURN CHR(210) + CHR(238) + CHR(235) + CHR(252) + CHR(234) + CHR(238) + CHR(32) + CHR(247) + CHR(229) + CHR(242) + CHR(237) + CHR(251) + CHR(229)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_PAGELIST"
		RETURN CHR(205) + CHR(224) + CHR(239) + CHR(240) + CHR(232) + CHR(236) + CHR(229) + CHR(240) + CHR(58) + CHR(32) + CHR(49) + CHR(45) + CHR(51) + CHR(44) + CHR(32) + CHR(53) + CHR(45) + CHR(56) + CHR(44) + CHR(32) + CHR(57)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_DUPLEX"
		RETURN CHR(196) + CHR(226) + CHR(243) + CHR(241) + CHR(242) + CHR(238) + CHR(240) + CHR(238) + CHR(237) + CHR(237) + CHR(255) + CHR(255) + CHR(32) + CHR(239) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE"
		RETURN CHR(208) + CHR(224) + CHR(231) + CHR(236) + CHR(229) + CHR(240) + CHR(32) + CHR(225) + CHR(243) + CHR(236) + CHR(224) + CHR(227) + CHR(232)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE_AUTO"
		RETURN CHR(192) + CHR(226) + CHR(242) + CHR(238) + CHR(226) + CHR(251) + CHR(225) + CHR(238) + CHR(240)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_TITLE"
		RETURN CHR(194) + CHR(226) + CHR(229) + CHR(228) + CHR(232) + CHR(242) + CHR(229) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(252)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_PROMPT"
		RETURN CHR(80) + CHR(68) + CHR(70) + CHR(32) + CHR(244) + CHR(224) + CHR(233) + CHR(235) + CHR(32) + CHR(231) + CHR(224) + CHR(249) + CHR(232) + CHR(249) + CHR(229) + CHR(237) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(229) + CHR(236) + CHR(46) + CHR(32) + CHR(194) + CHR(226) + CHR(229) + CHR(228) + CHR(232) + CHR(242) + CHR(229) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(252) + CHR(32) + CHR(228) + CHR(235) + CHR(255) + CHR(32) + CHR(238) + CHR(242) + CHR(234) + CHR(240) + CHR(251) + CHR(242) + CHR(232) + CHR(255) + CHR(32) + CHR(244) + CHR(224) + CHR(233) + CHR(235) + CHR(224) + CHR(46)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_INCORRECTPASSWORD"
		RETURN CHR(205) + CHR(229) + CHR(239) + CHR(240) + CHR(224) + CHR(226) + CHR(232) + CHR(235) + CHR(252) + CHR(237) + CHR(251) + CHR(233) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(252)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_OK"
		RETURN CHR(206) + CHR(242) + CHR(234) + CHR(240) + CHR(251) + CHR(242) + CHR(252) + CHR(32) + CHR(228) + CHR(238) + CHR(234) + CHR(243) + CHR(236) + CHR(229) + CHR(237) + CHR(242)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_CANCEL"
		RETURN CHR(206) + CHR(242) + CHR(236) + CHR(229) + CHR(237) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_BORDERLESS"
		RETURN CHR(207) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252) + CHR(32) + CHR(225) + CHR(229) + CHR(231) + CHR(32) + CHR(239) + CHR(238) + CHR(235) + CHR(229) + CHR(233)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_TITLE"
		RETURN CHR(194) + CHR(251) + CHR(225) + CHR(238) + CHR(240) + CHR(32) + CHR(239) + CHR(240) + CHR(232) + CHR(237) + CHR(242) + CHR(229) + CHR(240) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_OK"
		RETURN CHR(209) + CHR(238) + CHR(245) + CHR(240) + CHR(224) + CHR(237) + CHR(232) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_CANCEL"
		RETURN CHR(206) + CHR(242) + CHR(236) + CHR(229) + CHR(237) + CHR(224)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_print_env AS custom 		&& Print configuration for PdfiumReport.printreport
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: getprinterdevmode		&& Return output structure DEVMODE from DocumentProperties win32api function
		*m: getprinterduplex		&& Returns printer duplex support: .T. - duplex is supported, .F. - duplex is not supported.
		*m: getprinterforms		&& Return full list of paper forms with the flag indicating that  form is supported by printer
		*m: pagelist_parse		&& Parse page list input (string), returns valid string of page list
		*m: setup		&& Setup print configuration (from external printenv if needed). Set default foxpro (not system) printer to Printer property
		*m: sysdefaultprinter_restore		&& Restore system default printer to the value before SysDefaultPrinter_Set call
		*m: sysdefaultprinter_set		&& Set system default printer
		*p: copies		&& Number of  copies
		*p: duplex		&& Duplex mode .T. | .F.
		*p: pagelist		&& List of pages to print (comma separated), supports intervals: 1,2-5,10
		*p: pagemode		&& 1 - all, 2 - only odd, 3 - only even, 4 - PageList
		*p: papersize		&& Paper size index (like PRTINFO(2) returns); -1 - auto choice the fittest to the document; 0 - unknown paper size
		*p: printer		&& Printer name
		*p: sysdefaultprinter_prev		&& System default printer before SysDefaultPrinter_Set call
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,ClassLibrary,Class,CloneObject,Comment,ControlCount,Controls,Error,Height,HelpContextID,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,sysdefaultprinter_prev,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		copies = 1
		duplex = .F.
		Height = 27
		Name = "pdfium_print_env"
		pagelist = ("")
		pagemode = 1
		papersize = 0
		printer = ("")
		sysdefaultprinter_prev = ("")
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="duplex" type="property" display="Duplex"/>
			<memberdata name="printer" type="property" display="Printer"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="sysdefaultprinter_restore" type="method" display="SysDefaultPrinter_Restore"/>
			<memberdata name="sysdefaultprinter_set" type="method" display="SysDefaultPrinter_Set"/>
			<memberdata name="sysdefaultprinter_prev" type="property" display="SysDefaultPrinter_Prev"/>
			<memberdata name="copies" type="property" display="Copies"/>
			<memberdata name="pagelist" type="property" display="PageList"/>
			<memberdata name="pagemode" type="property" display="PageMode"/>
			<memberdata name="pagelist_parse" type="method" display="PageList_Parse"/>
			<memberdata name="getprinterforms" type="method" display="GetPrinterForms"/>
			<memberdata name="getprinterdevmode" type="method" display="GetPrinterDevMode"/>
			<memberdata name="papersize" type="property" display="PaperSize"/>
			<memberdata name="getprinterduplex" type="method" display="GetPrinterDuplex"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE getprinterdevmode		&& Return output structure DEVMODE from DocumentProperties win32api function
		LPARAMETERS lcPrinter
		
		* lcPrinter - printer name
		* Return: DEVMODE structure (as STRING)
		
		IF EMPTY(NVL(lcPrinter,""))
		    RETURN ""
		ENDIF
		
		DECLARE INTEGER OpenPrinter IN winspool.drv AS WinApi_OpenPrinter STRING  @pPrinterName, INTEGER @phPrinter, INTEGER pDefault
		DECLARE INTEGER ClosePrinter IN winspool.drv AS WinApi_ClosePrinter INTEGER hPrinter
		
		DECLARE INTEGER DocumentProperties IN winspool.drv AS WinApi_DocumentProperties INTEGER hWnd, INTEGER hPrinter, STRING pDeviceName, STRING@ pDevModeOutput, STRING@ pDevModeInput, INTEGER fMode
		
		#define DM_OUT_BUFFER 2
		#define DM_IN_BUFFER  8
		#define DM_IN_PROMPT  4
		
		LOCAL lcPrnDevMode
		lcPrnDevMode = ""
		
		LOCAL lhPrinter
		lhPrinter = 0
		
		WinApi_OpenPrinter(lcPrinter, @lhPrinter, 0)
		
		IF lhPrinter = 0 
		    RETURN ""
		ENDIF
		
		LOCAL lnBufSize
		lnBufsize = WinApi_DocumentProperties(Application.HWnd, lhPrinter, lcPrinter, 0, 0, 0)
		
		IF lnBufSize > 0
		    lcPrnDevMode = REPLICATE(CHR(0), lnBufsize)
		    WinApi_DocumentProperties(Application.HWnd, lhPrinter, lcPrinter, @lcPrnDevMode, 0, DM_OUT_BUFFER)
		ENDIF
		
		IF LEN(CHRTRAN(lcPrnDevMode, CHR(0), "")) = 0
		    lcPrnDevMode = ""
		ENDIF
		
		WinApi_ClosePrinter(lhPrinter)
		
		RETURN lcPrnDevMode
		
	ENDPROC

	PROCEDURE getprinterduplex		&& Returns printer duplex support: .T. - duplex is supported, .F. - duplex is not supported.
		LPARAMETERS lcPrinter
		
		IF EMPTY(NVL(lcPrinter,""))
		    RETURN 0
		ENDIF
		
		#define DC_DUPLEX 7
		
		DECLARE INTEGER DeviceCapabilities IN winspool.drv AS WinApi_DeviceCapabilities STRING pDevice, STRING pPort, INTEGER fwCapability, STRING@ pOutput, STRING@ pDevMode
		
		RETURN EMPTY(WinApi_DeviceCapabilities(lcPrinter, NULL, DC_DUPLEX, NULL, NULL)) = .F.
		
		
	ENDPROC

	PROCEDURE getprinterforms		&& Return full list of paper forms with the flag indicating that  form is supported by printer
		LPARAMETERS laPrnForm, lcPrinter
		
		* laPrnForm - output array (form-info-1 of EnumForms + additional columns)
		* lcPrinter - printer name
		* Return: number of forms of printer 
		
		* laPrnForm[,1] - Flags
		* laPrnForm[,2] - pName
		* laPrnForm[,3] - Size width
		* laPrnForm[,4] - Size height
		* laPrnForm[,5] - ImageableArea Left
		* laPrnForm[,6] - ImageableArea Top
		* laPrnForm[,7] - ImageableArea Width
		* laPrnForm[,8] - ImageableArea Height
		* laPrnForm[,9] - Form is supported by the printer .T. | .F.
		
		IF EMPTY(NVL(lcPrinter,""))
		    RETURN 0
		ENDIF
		
		#define DC_PAPERS 2
		
		
		DECLARE INTEGER OpenPrinter IN winspool.drv AS WinApi_OpenPrinter STRING  @pPrinterName, INTEGER @phPrinter, INTEGER pDefault
		DECLARE INTEGER ClosePrinter IN winspool.drv AS WinApi_ClosePrinter INTEGER hPrinter
		DECLARE LONG EnumForms IN winspool.drv  AS WinApi_EnumForms LONG hPrinter, LONG Level, LONG pForm, LONG cbBuf, LONG @pcbNeeded, LONG @ pcReturned
		DECLARE INTEGER HeapCreate IN WIN32API AS WinApi_HeapCreate INTEGER dwOptions, INTEGER dwInitialSize, INTEGER dwMaxSize
		DECLARE INTEGER HeapAlloc IN WIN32API AS WinApi_HeapAlloc INTEGER hHeap, INTEGER dwFlags, INTEGER dwBytes
		DECLARE INTEGER HeapFree IN WIN32API AS WinApi_HeapFree INTEGER hHeap, INTEGER dwFlags, INTEGER lpMem
		DECLARE INTEGER HeapDestroy IN WIN32API AS WinApi_HeapDestroy INTEGER hHeap
		DECLARE INTEGER DeviceCapabilities IN winspool.drv AS WinApi_DeviceCapabilities STRING pDevice, STRING pPort, INTEGER fwCapability, STRING@ pOutput, STRING@ pDevMode
		
		
		LOCAL lhPrinter
		lhPrinter = 0
		
		WinApi_OpenPrinter(lcPrinter, @lhPrinter, 0)
		
		IF lhPrinter = 0 
		    RETURN 0
		ENDIF
		
		LOCAL lnPrnFormCnt
		lnPrnFormCnt = 0
		
		TRY
		    LOCAL lnBufSize, lnFormHeap, lnFormHeapPtr
		    STORE 0 TO lnBufSize, lnFormHeap, lnFormHeapPtr
		
		    WinApi_EnumForms(lhPrinter, 1,  0, 0, @lnBufSize, 0)
		    IF lnBufSize = 0
		        EXIT
		    ENDIF
		    lnFormHeap = WinApi_HeapCreate(0, lnBufSize, 0)
		    IF EMPTY(lnFormHeap)
		        EXIT
		    ENDIF
		    lnFormHeapPtr = WinApi_HeapAlloc(lnFormHeap, 0, lnBufSize)
		    IF EMPTY(lnFormHeapPtr)
		        EXIT
		    ENDIF
		    WinApi_EnumForms(lhPrinter, 1, lnFormHeapPtr, lnBufSize, @lnBufSize, @lnPrnFormCnt)
		    IF EMPTY(lnPrnFormCnt)
		        EXIT
		    ENDIF
		    
		    DIMENSION laPrnForm(lnPrnFormCnt, 9)
		    
		    LOCAL liForm, lnFormOffs
		    liForm = 1
		    lnFormOffs = lnFormHeapPtr
		    FOR liForm = 1 TO lnPrnFormCnt
		        laPrnForm[liForm,1] = CTOBIN(SYS(2600, lnFormOffs, 4),"4RS") && Flags
		        laPrnForm[liForm,2] = SYS(2600, CTOBIN(SYS(2600, lnFormOffs+4, 4),"4RS"), 31) &&pName
		        laPrnForm[liForm,3] = CTOBIN(SYS(2600, lnFormOffs+8, 4),"4RS") &&Size width
		        laPrnForm[liForm,4] = CTOBIN(SYS(2600, lnFormOffs+12, 4),"4RS") &&Size height
		        laPrnForm[liForm,5] = CTOBIN(SYS(2600, lnFormOffs+16, 4),"4RS") && ImageableArea Left
		        laPrnForm[liForm,6] = CTOBIN(SYS(2600, lnFormOffs+20, 4),"4RS") && ImageableArea Top
		        laPrnForm[liForm,7] = CTOBIN(SYS(2600, lnFormOffs+24, 4),"4RS") && ImageableArea Width
		        laPrnForm[liForm,8] = CTOBIN(SYS(2600, lnFormOffs+28, 4),"4RS") && ImageableArea Height
		        laPrnForm[liForm,9] = .F.
		        lnFormOffs = lnFormOffs + 32        
		    ENDFOR
		
		FINALLY
		    IF EMPTY(lnFormHeap) = .F.
		        WinApi_HeapDestroy(lnFormHeap)
		    ENDIF
		ENDTRY
		
		WinApi_ClosePrinter(lhPrinter)
		
		
		LOCAL lcPapers, lnPaperCnt, liPaper, lnFormID
		lnPaperCnt = WinApi_DeviceCapabilities(lcPrinter, NULL, DC_PAPERS, NULL, NULL)
		
		IF lnPaperCnt <> 0
		    lcPapers = REPLICATE(CHR(0), lnPaperCnt * 2)
		    lnPaperCnt = WinApi_DeviceCapabilities(lcPrinter, NULL, DC_PAPERS, @lcPapers, NULL)
		    liPaper = 1
		    FOR liPaper = 1 TO lnPaperCnt
		        lnFormID = CTOBIN(SUBSTR(lcPapers, (liPaper-1)*2 + 1, 2), "2RS")
		        IF BETWEEN(lnFormID, 1, lnPrnFormCnt)
		            laPrnForm[lnFormID,9] = .T.
		        ENDIF
		    ENDFOR
		ENDIF
		
		
		RETURN lnPrnFormCnt
		
	ENDPROC

	PROCEDURE Init
		This.printer = EVL(SET("Printer",3),"")
		
		
	ENDPROC

	PROCEDURE pagelist_parse		&& Parse page list input (string), returns valid string of page list
		LPARAMETERS m.tcPageList
		
		LOCAL lcPageList
		lcPageList = m.tcPageList
		
		IF INLIST(VARTYPE(lcPageList), "C", "N") = .F.
		    lcPageList = ""
		ENDIF
		
		lcPageList = LEFT(ALLTRIM(EVL(NVL(lcPageList,""),"")),200)
		lcPageList = CHRTRAN(lcPageList, ";.Ee", ",")
		
		
		LOCAL ARRAY laGroups(1)
		LOCAL lnGroups
		lnGroups = ALINES(laGroups, lcPageList, 1+4, ",")
		
		IF lnGroups = 0
		    RETURN ""
		ENDIF
		
		LOCAL ARRAY laGroups2(lnGroups * 2)
		LOCAL lnGroups2
		lnGroups2 = 0
		
		LOCAL i, lcGroup, lnLVal, lnRVal, lnEVal
		i = 1
		FOR i = 1 TO lnGroups
		    lcGroup = laGroups[i]
		    
		    lnLVal = MAX(INT(VAL(LEFT(STREXTRACT(lcGroup, "", "-",1,2),10))), 0)
		    lnRVal = MAX(INT(VAL(LEFT(STREXTRACT(lcGroup, "-", "",1,2),10))), 0)
		
		    lnEVal = lnLVal
		    lnLVal = EVL(MIN(lnEVal, lnRVal), lnEVal)
		    lnRVal = MAX(lnEVal, lnRVal)
		
		    IF EMPTY(lnLVal)
		        LOOP
		    ENDIF
		    
		    lnGroups2 = lnGroups2 + 1 
		    laGroups2[lnGroups2] = lnLVal
		    
		    lnGroups2 = lnGroups2 + 1 
		    laGroups2[lnGroups2] = lnRVal
		    
		ENDFOR
		
		
		
		LOCAL i, lnLInd, lnLVal, lnRVal
		
		DO WHILE .T.
		    i = 1
		    lnLInd = 1
		    lnLVal = 0
		    lnRVal = 0
		    DO WHILE i < lnGroups2 
		        
		        DO CASE
		        CASE laGroups2[lnLInd] > laGroups2[i]
		            lnLVal = laGroups2[lnLInd]
		            laGroups2[lnLInd] = laGroups2[i]
		            laGroups2[lnLInd+1] = laGroups2[i+1]
		               
		            laGroups2[i] = lnLVal
		            laGroups2[i+1] = lnRVal
		            lnLInd = i
		
		        CASE lnRVal < laGroups2[i]
		            lnLInd = i
		            lnRVal = laGroups2[i+1]
		
		        
		        CASE lnRVal = laGroups2[i]
		            lnRVal = laGroups2[i+1]
		
		        CASE lnRVal < laGroups2[i+1]
		            laGroups2[i] = lnRVal
		            lnRVal = laGroups2[i+1]
		
		        OTHERWISE
		            laGroups2[i] = lnRVal
		            laGroups2[i+1] = lnRVal
		        ENDCASE
		        
		        i = i + 2
		        
		    ENDDO
		
		    IF lnLVal = 0
		        EXIT
		    ENDIF
		ENDDO
		
		
		
		lcPageList = ""
		
		LOCAL i, lnLVal, lnRVal
		i = 1
		lnLVal = 0
		lnRVal = 0
		DO WHILE i < lnGroups2
		    
		    IF lnRVal = laGroups2[i+1]
		        i = i + 2
		        LOOP
		    ENDIF
		    
		    IF lnRVal = laGroups2[i]
		        lnLVal = laGroups2[i]
		        lnRVal = laGroups2[i+1]
		        i = i + 2
		        LOOP
		    ENDIF
		    
		    lcPageList = lcPageList + ;
		        IIF(lnLVal = lnRVal, "", "-" + TRANSFORM(lnRVal)) + ;
		        IIF(EMPTY(lcPageList), "", ", ") + ;
		        TRANSFORM(laGroups2[i])
		   
		    lnLVal = laGroups2[i]
		    lnRVal = laGroups2[i+1]
		    i = i + 2
		ENDDO
		
		lcPageList = lcPageList + IIF(lnLVal = lnRVal, "", "-" + TRANSFORM(lnRVal))
		
		
		RETURN lcPageList
		
		
	ENDPROC

	PROCEDURE setup		&& Setup print configuration (from external printenv if needed). Set default foxpro (not system) printer to Printer property
		LPARAMETERS toPrintEnv as pdfium_print_env of pdfium-vfp
		
		IF VARTYPE(m.toPrintEnv)="O"
		    IF NOT ALLTRIM(LOWER(EVL(NVL(m.toPrintEnv.Printer,""), This.Printer))) == ALLTRIM(LOWER(This.Printer))
		        This.PaperSize = 0
		    ENDIF
		    This.Printer = EVL(NVL(m.toPrintEnv.Printer,""), This.Printer)
		    This.Copies = EVL(NVL(m.toPrintEnv.Copies, 0), This.Copies)
		    This.PageMode = EVL(NVL(m.toPrintEnv.PageMode, 0), This.PageMode)
		    This.PageList = EVL(NVL(m.toPrintEnv.PageList, ""), This.PageList)    
		    This.Duplex = NVL(m.toPrintEnv.Duplex, This.Duplex)
		    This.PaperSize = EVL(EVL(NVL(m.toPrintEnv.PaperSize, 0), This.PaperSize), EVL(MAX(PRTINFO(2, This.Printer),0), -1))
		ENDIF
		
		IF EMPTY(This.Printer)=.F.
		    SET PRINTER TO NAME (This.Printer)
		ENDIF
		
		
	ENDPROC

	PROCEDURE sysdefaultprinter_restore		&& Restore system default printer to the value before SysDefaultPrinter_Set call
		IF EMPTY(This.SysDefaultPrinter_Prev)
		    RETURN
		ENDIF
		
		DECLARE INTEGER SetDefaultPrinter IN WINSPOOL.DRV  AS WinApi_SetDefaultPrinter STRING pszPrinter
		
		IF WinApi_SetDefaultPrinter(This.SysDefaultPrinter_Prev) = 0
		    This.SysDefaultPrinter_Prev = ""
		    RETURN
		ENDIF
		
		This.SysDefaultPrinter_Prev = ""
		
	ENDPROC

	PROCEDURE sysdefaultprinter_set		&& Set system default printer
		
		IF EMPTY(This.Printer)
		    RETURN
		ENDIF    
		
		DECLARE INTEGER GetDefaultPrinter IN WINSPOOL.DRV  AS WinApi_GetDefaultPrinter STRING@ pszBuffer, LONG@ pcchBuffer
		
		LOCAL lcBuf, lnBufLen
		lcBuf = REPLICATE(CHR(0),2000)
		lnBufLen = LEN(lcBuf)
		
		This.SysDefaultPrinter_Prev = ""
		IF WinApi_GetDefaultPrinter(@lcBuf, @lnBufLen) <> 0
		    IF lnBufLen > 0
		        This.SysDefaultPrinter_Prev = SUBSTR(lcBuf, 1, lnBufLen)
		    ENDIF        
		ENDIF    
		
		DECLARE INTEGER SetDefaultPrinter IN WINSPOOL.DRV  AS WinApi_SetDefaultPrinter STRING pszPrinter
		
		IF WinApi_SetDefaultPrinter(This.Printer) = 0
		    RETURN
		ENDIF
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_print_env_setup AS form 		&& Print settings dialog. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmbPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDuplex" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOk" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="PrintEnv" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCopies" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCopies" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ogrPageMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPageMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtPageList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPageList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFocusHolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmbPaperSize" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPaperSize" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: papersizerequery
		*p: out_ok		&& .T. - User pressed ok button, .F. - user pressed cancel
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BindControls = .F.
		BorderStyle = 2
		Caption = "Print setup"
		DoCreate = .T.
		Height = 297
		Icon = ("images\wwrite.ico")
		KeyPreview = .T.
		MaxButton = .F.
		MinButton = .F.
		Name = "pdfium_print_env_setup"
		out_ok = .F.
		ShowWindow = 1
		Visible = .T.
		Width = 435
		WindowType = 1
		_memberdata = <VFPData>
			<memberdata name="out_ok" type="property" display="Out_Ok"/>
			<memberdata name="papersizerequery" type="method" display="PaperSizeRequery"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'chkDuplex' AS checkbox WITH ;
		Alignment = 4, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Duplex printing", ;
		ControlSource = "Thisform.PrintEnv.duplex", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 24, ;
		Left = 12, ;
		Name = "chkDuplex", ;
		TabIndex = 4, ;
		Top = 125, ;
		Width = 177, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmbPaperSize' AS combobox WITH ;
		BoundColumn = 2, ;
		BoundTo = .T., ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "160,0", ;
		ControlSource = "", ;
		DisplayCount = 21, ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 28, ;
		Left = 12, ;
		Name = "cmbPaperSize", ;
		Style = 2, ;
		TabIndex = 5, ;
		Top = 180, ;
		Width = 180
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmbPrinters' AS combobox WITH ;
		BoundColumn = 1, ;
		BoundTo = .T., ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "370,200", ;
		ControlSource = "Thisform.PrintEnv.printer", ;
		DisplayCount = 30, ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 28, ;
		Left = 12, ;
		Name = "cmbPrinters", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 28, ;
		Width = 408
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Cancel", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 237, ;
		Name = "cmdCancel", ;
		TabIndex = 9, ;
		Top = 246, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFocusHolder' AS commandbutton WITH ;
		Caption = "", ;
		Height = 27, ;
		Left = 444, ;
		Name = "cmdFocusHolder", ;
		Style = 1, ;
		TabIndex = 1, ;
		Top = 276, ;
		Width = 36
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOk' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Ok", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 74, ;
		Name = "cmdOk", ;
		TabIndex = 8, ;
		Top = 246, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 336, ;
		Name = "i18n", ;
		Top = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'lblCopies' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Copies", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblCopies", ;
		TabIndex = 11, ;
		Top = 69, ;
		Width = 117
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPageList' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "For example: 1,2, 4 -5", ;
		Enabled = .T., ;
		FontBold = .F., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 248, ;
		Name = "lblPageList", ;
		TabIndex = 10, ;
		Top = 183, ;
		Width = 143
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPageMode' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Pages", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 227, ;
		Name = "lblPageMode", ;
		TabIndex = 14, ;
		Top = 69, ;
		Width = 171
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPaperSize' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Paper size", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblPaperSize", ;
		TabIndex = 13, ;
		Top = 158, ;
		Width = 173
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPrinters' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Printer", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblPrinters", ;
		TabIndex = 12, ;
		Top = 4, ;
		Width = 173
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'ogrPageMode' AS optiongroup WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		ButtonCount = 4, ;
		ControlSource = "Thisform.PrintEnv.PageMode", ;
		Height = 121, ;
		Left = 221, ;
		Name = "ogrPageMode", ;
		TabIndex = 6, ;
		Top = 90, ;
		Value = 1, ;
		Width = 208, ;
		Option1.AutoSize = .F., ;
		Option1.Caption = "All", ;
		Option1.FontName = "Segoe UI", ;
		Option1.FontSize = 10, ;
		Option1.Height = 19, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 5, ;
		Option1.Value = 1, ;
		Option1.Width = 193, ;
		Option2.AutoSize = .F., ;
		Option2.Caption = "Odd pages only", ;
		Option2.FontName = "Segoe UI", ;
		Option2.FontSize = 10, ;
		Option2.Height = 19, ;
		Option2.Left = 5, ;
		Option2.Name = "Option2", ;
		Option2.Top = 34, ;
		Option2.Width = 193, ;
		Option3.AutoSize = .F., ;
		Option3.Caption = "Even pages only", ;
		Option3.FontName = "Segoe UI", ;
		Option3.FontSize = 10, ;
		Option3.Height = 19, ;
		Option3.Left = 5, ;
		Option3.Name = "Option3", ;
		Option3.PictureMargin = 0, ;
		Option3.PictureSpacing = 0, ;
		Option3.Top = 63, ;
		Option3.Width = 193, ;
		Option4.AutoSize = .F., ;
		Option4.Caption = "", ;
		Option4.FontName = "Segoe UI", ;
		Option4.FontSize = 10, ;
		Option4.Height = 19, ;
		Option4.Left = 5, ;
		Option4.Name = "Option4", ;
		Option4.Top = 94, ;
		Option4.Width = 19
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'PrintEnv' AS pdfium_print_env WITH ;
		Left = 288, ;
		Name = "PrintEnv", ;
		Top = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'txtCopies' AS pdfium_textbox WITH ;
		ControlSource = "Thisform.PrintEnv.copies", ;
		Height = 27, ;
		InputMask = "9999", ;
		Left = 12, ;
		Name = "txtCopies", ;
		TabIndex = 3, ;
		Top = 90, ;
		Width = 113
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtPageList' AS pdfium_textbox WITH ;
		ControlSource = "Thisform.PrintEnv.PageList", ;
		Height = 27, ;
		InputMask = "", ;
		Left = 242, ;
		Name = "txtPageList", ;
		TabIndex = 7, ;
		TabStop = .F., ;
		Top = 180, ;
		Width = 173
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />
	
	PROCEDURE Init
		LPARAMETERS toPrintEnv as pdfium_print_env OF pdfium-vfp
		
		This.PrintEnv.Setup(m.toPrintEnv)
		
		This.BindControls = .T.
		
		LOCAL ARRAY laPrinters(1)
		LOCAL lnPrinters
		lnPrinters = APRINTERS(laPrinters,1)
		
		LOCAL i, llHasComments
		llHasComments = .F.
		FOR i = 1 TO lnPrinters
		    LOCAL lcPrinter, lcComment
		    lcPrinter = RTRIM(EVL(NVL(laPrinters[i,1], ""),""))
		    lcComment = RTRIM(EVL(NVL(laPrinters[i,4],""),""))
		
		    IF EMPTY(lcPrinter)
		        LOOP
		    ENDIF
		    
		    IF EMPTY(lcComment)=.F.
		        llHasComments = .T.
		    ENDIF
		
		    This.cmbPrinters.AddItem(lcPrinter)
		    This.cmbPrinters.AddListItem(lcComment, i, 2)
		    
		    IF ALLTRIM(LOWER(This.PrintEnv.Printer)) == ALLTRIM(LOWER(lcPrinter))
		        This.PrintEnv.Printer = lcPrinter &&Fix uppercase printer name of set(printer,3) result
		    ENDIF
		ENDFOR
		
		IF llHasComments = .F.
		    This.cmbPrinters.ColumnWidths = STREXTRACT(This.cmbPrinters.ColumnWidths, "", ",",1,2) + ",0"
		ENDIF
		
		This.PaperSizeRequery()
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 27 AND EMPTY(m.nShiftAltCtrl)
		    This.Hide()
		ENDIF
		
		
	ENDPROC

	PROCEDURE Load
		CLEAR TYPEAHEAD 
		
		
		
		
	ENDPROC

	PROCEDURE papersizerequery
		
		#define FORM_BUILTIN 0x00000001
		#define FORM_PRINTER 0x00000002
		
		This.cmbPaperSize.Clear()
		
		LOCAL lnPrnFormCnt
		LOCAL ARRAY laPrnForm(1,9)
		lnPrnFormCnt = This.PrintEnv.GetPrinterForms(@laPrnForm, This.PrintEnv.Printer)
		IF EMPTY(lnPrnFormCnt)
		    RETURN
		ENDIF
		
		This.cmbPaperSize.AddItem(Thisform.i18n.text("PRINTENV_PAPERSIZE_AUTO"))
		This.cmbPaperSize.AddListItem("-1", 1, 2)
		
		LOCAL liPrnForm, lcPrnForm, llPrnFormFound
		liPrnForm = 1
		llPrnFormFound = .F.
		FOR liPrnForm = 1 TO lnPrnFormCnt
		    lcPrnForm = RTRIM(TRANSFORM(EVL(NVL(laPrnForm[liPrnForm,2], ""),"")))
		
		    IF EMPTY(lcPrnForm)
		        LOOP
		    ENDIF
		    
		    IF laPrnForm[liPrnForm,9] = .F.
		        LOOP
		    ENDIF
		    
		    IF BITAND(laPrnForm[liPrnForm,1], FORM_BUILTIN) = 0
		        LOOP
		    ENDIF
		    
		    This.cmbPaperSize.AddItem(lcPrnForm)
		    This.cmbPaperSize.AddListItem(TRANSFORM(liPrnForm), This.cmbPaperSize.ListCount, 2)
		
		    IF liPrnForm = This.PrintEnv.PaperSize
		        llPrnFormFound = .T.
		    ENDIF
		ENDFOR
		
		IF llPrnFormFound = .F. AND This.PrintEnv.PaperSize <> -1
		    This.PrintEnv.PaperSize = EVL(MAX(PRTINFO(2, This.PrintEnv.Printer),0), -1)
		ENDIF
		
		This.cmbPaperSize.Value = TRANSFORM(This.Printenv.PaperSize)
		
	ENDPROC

	PROCEDURE Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_TITLE")
		
	ENDPROC

	PROCEDURE chkDuplex.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_DUPLEX")
		
		
	ENDPROC

	PROCEDURE cmbPaperSize.InteractiveChange
		Thisform.PrintEnv.PaperSize = INT(VAL(This.Value))
	ENDPROC

	PROCEDURE cmbPrinters.InteractiveChange
		Thisform.PrintEnv.Printer = This.Value
		Thisform.PaperSizeRequery()
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdCancel.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_CANCEL")
		
	ENDPROC

	PROCEDURE cmdOk.Click
		
		Thisform.Out_Ok = .T.
		
		Thisform.Hide()
		
		
	ENDPROC

	PROCEDURE cmdOk.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_OK")
		
	ENDPROC

	PROCEDURE lblCopies.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_COPIES")
	ENDPROC

	PROCEDURE lblPageList.Init
		DODEFAULT()
		
		This.ForeColor = This.DisabledForeColor
		
		
	ENDPROC

	PROCEDURE lblPageList.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.Parent.txtPageList.SetFocus()
		
	ENDPROC

	PROCEDURE lblPageList.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_PAGELIST")
		
		This.Visible = EMPTY(This.Parent.txtPageList.Value)
		
		
	ENDPROC

	PROCEDURE lblPageMode.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE")
		
		
	ENDPROC

	PROCEDURE lblPaperSize.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAPERSIZE")
		
	ENDPROC

	PROCEDURE lblPrinters.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PRINTER")
		
	ENDPROC

	PROCEDURE ogrPageMode.InteractiveChange
		Thisform.txtPageList.TabStop = (This.Value = 4)
		
	ENDPROC

	PROCEDURE ogrPageMode.Option1.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_ALL")
	ENDPROC

	PROCEDURE ogrPageMode.Option2.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_ODD")
	ENDPROC

	PROCEDURE ogrPageMode.Option3.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_EVEN")
		
	ENDPROC

	PROCEDURE ogrPageMode.ProgrammaticChange
		Thisform.txtPageList.TabStop = (This.Value = 4)
		
	ENDPROC

	PROCEDURE txtPageList.GotFocus
		DODEFAULT()
		
		This.Parent.lblPageList.Visible = .F.
		This.Parent.ogrPageMode.Value = 4
		
	ENDPROC

	PROCEDURE txtPageList.LostFocus
		DODEFAULT()
		
		Thisform.Refresh()
		This.Parent.ogrPageMode.Value = IIF(EMPTY(This.Value), 1, 4)
		
		This.Value = Thisform.PrintEnv.PageList_Parse(This.Value)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_textbox AS textbox 		&& Pdfium-vfp Textbox. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: contextmenu
		*m: selectall
		*p: allow_lost_focus
		*p: changed		&& .T. on InteractiveChange
		*p: mousefocused		&& Focused by Click
		*p: prevvalue		&& Value on GotFocus event
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN allow_lost_focus
	PROTECTED changed,mousefocused,prevvalue
	*<PropValue>
		Alignment = 0
		allow_lost_focus = .T.
		changed = .F.
		EnableHyperlinks = .F.
		FontName = "Segoe UI"
		FontSize = 10
		Format = "K"
		Height = 27
		mousefocused = 0
		Name = "pdfium_textbox"
		prevvalue = 
		SelectOnEntry = .T.
		Width = 173
		_memberdata = <VFPData>
			<memberdata name="changed" type="property" display="Changed"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="mousefocused" type="property" display="MouseFocused"/>
			<memberdata name="prevvalue" type="property" display="PrevValue"/>
			<memberdata name="selectall" type="method" display="SelectAll"/>
			<memberdata name="allow_lost_focus" type="property" display="allow_lost_focus"/>
		</VFPData>
	*</PropValue>
	
	PROTECTED PROCEDURE contextmenu
		LOCAL lcMenuName
		lcMenuName = "_context_menu"
		
		DEFINE POPUP (lcMenuName) FROM MROW(), MCOL() MARGIN RELATIVE SHORTCUT FONT 'Segoe UI', 10
		
		LOCAL lcSelect, lcClipboard
		lcSelect = IIF(EMPTY(This.SelLength)=.T., "SKIP FOR .T.", "")
		lcClipboard = IIF(EMPTY(_CLIPTEXT)=.T., "SKIP FOR .T.", "")
		
		LOCAL i
		i=9000
		
		i=i+1
		DEFINE BAR (i) OF _context_menu PROMPT (Thisform.i18n.text("MNU_CUT")) PICTRES _MED_CUT  &lcSelect
		ON SELECTION BAR (i) OF _context_menu poThis.KeyPress(24,2)
		
		i=i+1
		DEFINE BAR (i) OF _context_menu PROMPT (Thisform.i18n.text("MNU_COPY")) PICTRES _MED_COPY &lcSelect
		ON SELECTION BAR (i) OF _context_menu poThis.KeyPress(3,2)
		
		DEFINE BAR _med_paste OF _context_menu PROMPT (Thisform.i18n.text("MNU_PASTE")) PICTRES _MED_PASTE &lcClipboard
		DEFINE BAR _med_slcta OF _context_menu PROMPT (Thisform.i18n.text("MNU_SLCTA"))
		DEFINE BAR _med_clear OF _context_menu PROMPT (Thisform.i18n.text("MNU_CLEAR")) &lcSelect
		
		RETURN lcMenuName
		
	ENDPROC

	PROCEDURE GotFocus
		DODEFAULT()
		
		This.PrevValue = This.Value
		
		IF This.SelectOnEntry
			This.MouseFocused = MDOWN()
			This.SelectAll()
		ENDIF
		
		This.allow_lost_focus = .T.
		
	ENDPROC

	PROCEDURE InteractiveChange
		This.Changed = .T.
		
		This.allow_lost_focus = .F.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode=44 AND VARTYPE(This.Value) = 'N'
			KEYBOARD '.' PLAIN CLEAR
		ENDIF
		
		IF m.nKeyCode=3 AND m.nShiftAltCtrl=2
			IF INLIST(VARTYPE(This.SelText),'C')
				_cliptext = ALLTRIM(NVL(This.SelText,''))
				NODEFAULT
			ENDIF
		ENDIF
		
		IF m.nKeyCode=24 AND m.nShiftAltCtrl=2
			IF INLIST(VARTYPE(This.SelText),'C')
				_cliptext = ALLTRIM(NVL(This.SelText,''))
				This.SelText = ''
				NODEFAULT
			ENDIF
		ENDIF
		
		
		IF INLIST(m.nKeyCode, 13, 27, 9)
		    This.allow_lost_focus = .T.
		ENDIF
		
	ENDPROC

	PROCEDURE LostFocus
		IF VARTYPE(This.Value)="C"
		    IF NOT (This.Value == ALLTRIM(This.Value,1,CHR(13),CHR(10)))
		        This.Value = ALLTRIM(This.Value,1,CHR(13),CHR(10))
		    ENDIF
		ENDIF
		
		*******************************************************
		LOCAL lcInvalidChars
		lcInvalidChars = ""
		LOCAL i
		FOR i=0x1 TO 0x1F
			lcInvalidChars = lcInvalidChars + CHR(i)
		ENDFOR
		FOR i=0x7F TO 0x84
			lcInvalidChars = lcInvalidChars + CHR(i)
		ENDFOR
		FOR i=0x86 TO 0x9F
			lcInvalidChars = lcInvalidChars + CHR(i)
		ENDFOR
		
		IF VARTYPE(This.Value) = 'C'
			IF NOT (This.Value == CHRTRAN(This.Value, lcInvalidChars, ''))
				This.Value = CHRTRAN(This.Value, lcInvalidChars, '')
			ENDIF	
		ENDIF
		*******************************************************
		
		#define VK_LBUTTON 0x01
		#define VK_RBUTTON 0x02
		IF This.allow_lost_focus = .F. AND This.SelStart+1 >= LEN(This.Text) AND NOT EMPTY(This.Value) AND NOT MDOWN() 
		    IF WinApi_GetKeyState(VK_LBUTTON)>=0 AND WinApi_GetKeyState(VK_RBUTTON)>=0 
		        This.SelStart = LEN(This.Text)
		        NODEFAULT
		        RETURN
		    ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.SelectOnEntry
			IF This.SelLength <> 0 AND This.MouseFocused
				NODEFAULT
			ENDIF
		ENDIF
		This.MouseFocused = .F.
		
	ENDPROC

	PROCEDURE RightClick
		LOCAL lcMenuName
		lcMenuName = This.ContextMenu()
		
		PRIVATE poThis
		poThis = This
		IF CNTBAR(lcMenuName)<>0
			ACTIVATE POPUP &lcMenuName
		ENDIF
		poThis = NULL
		
		
	ENDPROC

	PROCEDURE selectall
		This.SelStart = 0
		This.SelLength = 255
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_uistate AS custom 		&& UI states handling (visible, enable) respecting PageFrames. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: geteffectivelyenabled
		*m: geteffectivelyvisible
		*m: getispageframe
		*m: objtoclient
		*m: onenabled
		*m: onvisible
		*m: setstate
		*m: _onactivate
		*m: _ondeactivate
		*m: _onenabled
		*m: _onvisible
		*p: effectivelyenabled
		*p: effectivelyvisible
		*p: ispageframe
		*p: _ispagedeactivated
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,ClassLibrary,Class,CloneObject,Comment,ControlCount,Controls,effectivelyenabled,effectivelyvisible,Error,Height,HelpContextID,ispageframe,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod,_ispagedeactivated
	*<PropValue>
		effectivelyenabled = .F.
		effectivelyvisible = .F.
		Height = 24
		ispageframe = .F.
		Name = "pdfium_uistate"
		Tag = ""
		Width = 37
		_ispagedeactivated = .F.
		_memberdata = <VFPData>
			<memberdata name="objtoclient" display="ObjToClient"/>
			<memberdata name="addobject" display="AddObject"/>
			<memberdata name="writemethod" display="WriteMethod"/>
			<memberdata name="writeexpression" display="WriteExpression"/>
			<memberdata name="whatsthishelpid" display="WhatsThisHelpID"/>
			<memberdata name="tag" display="Tag"/>
			<memberdata name="showwhatsthis" display="ShowWhatsThis"/>
			<memberdata name="saveasclass" display="SaveAsClass"/>
			<memberdata name="resettodefault" display="ResetToDefault"/>
			<memberdata name="removeobject" display="RemoveObject"/>
			<memberdata name="readmethod" display="ReadMethod"/>
			<memberdata name="readexpression" display="ReadExpression"/>
			<memberdata name="picture" display="Picture"/>
			<memberdata name="parentclass" display="ParentClass"/>
			<memberdata name="parent" display="Parent"/>
			<memberdata name="objects" display="Objects"/>
			<memberdata name="newobject" display="Newobject"/>
			<memberdata name="helpcontextid" display="HelpContextID"/>
			<memberdata name="error" display="Error"/>
			<memberdata name="controls" display="Controls"/>
			<memberdata name="classlibrary" display="ClassLibrary"/>
			<memberdata name="addproperty" display="AddProperty"/>
			<memberdata name="setstate" display="SetState"/>
			<memberdata name="effectivelyenabled" display="EffectivelyEnabled"/>
			<memberdata name="effectivelyvisible" display="EffectivelyVisible"/>
			<memberdata name="geteffectivelyenabled" display="GetEffectivelyEnabled"/>
			<memberdata name="geteffectivelyvisible" display="GetEffectivelyVisible"/>
			<memberdata name="ispageframe" display="IsPageFrame"/>
			<memberdata name="getispageframe" display="GetIsPageFrame"/>
			<memberdata name="onenabled" display="OnEnabled"/>
			<memberdata name="onvisible" display="OnVisible"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE Destroy
		UNBINDEVENTS(This)
		
	ENDPROC

	PROCEDURE geteffectivelyenabled
		RETURN This.EffectivelyEnabled
		
	ENDPROC

	PROCEDURE geteffectivelyvisible
		RETURN This.EffectivelyVisible
		
	ENDPROC

	PROCEDURE getispageframe
		RETURN This.IsPageFrame
		
	ENDPROC

	PROCEDURE Init
		LOCAL loControl
		loControl = This.Parent
		
		This.IsPageFrame = .F.
		
		BINDEVENT(m.loControl, "Visible", This, "_OnVisible",1)
		BINDEVENT(m.loControl, "Enabled", This, "_OnEnabled",1)
		
		DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		    IF UPPER(m.loControl.BASECLASS) == [PAGE] THEN
		        This.IsPageFrame = .T.
		
		        BINDEVENT(m.loControl, "Activate", This, "_OnActivate",1)
		        BINDEVENT(m.loControl, "Deactivate", This, "_OnDeactivate",1)
		        BINDEVENT(m.loControl, "Enabled", This, "_OnEnabled",1)
		        BINDEVENT(m.loControl.Parent, "Visible", This, "_OnVisible",1)
		        BINDEVENT(m.loControl.Parent, "Enabled", This, "_OnEnabled",1)
		    ENDIF
		    m.loControl = m.loControl.PARENT
		ENDDO
		
		This.SetState()
		
	ENDPROC

	PROCEDURE objtoclient
		*********************************************************************
		** opied from GDPIPlusX xfcBitmap.ObjToClientEx
		**
		** This replaces OBJTOCLIENT that has bugs with pageframes and SP2
		*********************************************************************
		PARAMETERS tnType && 1 = Top  2 = Left
		
		IF This.GetIsPageframe() = .F.
		    RETURN OBJTOCLIENT(This.Parent, m.tnType)
		ENDIF
		
		LOCAL loControl
		loControl = This.Parent
		
		
		*!* TabOrientation parameters
		#DEFINE CON_TABOR_TOP    0
		#DEFINE CON_TABOR_BOTTOM 1
		#DEFINE CON_TABOR_LEFT   2
		#DEFINE CON_TABOR_RIGHT  3
		
		LOCAL lnPosition AS INTEGER
		m.lnPosition = 0
		
		DO CASE
		
		CASE m.tnType = 1 && Top
		    DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		        IF PEMSTATUS(m.loControl, [Top],5) THEN && Defined Property
		            m.lnPosition = m.lnPosition + m.loControl.TOP
		        ENDIF
		        IF UPPER(m.loControl.BASECLASS) == [PAGE] THEN
		            IF m.loControl.PARENT.TABORIENTATION = CON_TABOR_TOP THEN    && Top
		                m.lnPosition = m.lnPosition + ;
		                    m.loControl.PARENT.HEIGHT - ;
		                    m.loControl.PARENT.PAGEHEIGHT - ;
		                    m.loControl.PARENT.BORDERWIDTH * 2
		            ELSE
		                m.lnPosition = m.lnPosition + 1
		            ENDIF
		        ENDIF
		        m.loControl = m.loControl.PARENT
		    ENDDO
		
		CASE m.tnType = 2 && Left
		    DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		        IF PEMSTATUS(m.loControl, [Left], 5) THEN && Defined Property
		            m.lnPosition = m.lnPosition + m.loControl.LEFT
		        ENDIF
		        IF UPPER(m.loControl.BASECLASS) == [PAGE]
		            IF m.loControl.PARENT.TABORIENTATION = CON_TABOR_LEFT THEN    && Left
		                m.lnPosition = m.lnPosition + ;
		                    m.loControl.PARENT.WIDTH - ;
		                    m.loControl.PARENT.PAGEWIDTH - ;
		                    m.loControl.PARENT.BORDERWIDTH * 2
		            ELSE
		                m.lnPosition = m.lnPosition + 1
		            ENDIF
		        ENDIF
		        m.loControl = m.loControl.PARENT
		    ENDDO
		
		ENDCASE
		
		RETURN m.lnPosition
		
	ENDPROC

	PROCEDURE onenabled
	ENDPROC

	PROCEDURE onvisible
	ENDPROC

	HIDDEN PROCEDURE setstate
		LOCAL loControl
		loControl = This.Parent
		
		
		LOCAL llPrevVisible, llPrevEnabled
		llPrevVisible = This.EffectivelyVisible
		llPrevEnabled = This.EffectivelyEnabled
		
		This.EffectivelyVisible = loControl.Visible
		This.EffectivelyEnabled = loControl.Enabled
		
		
		IF This._IsPageDeactivated
		    This.EffectivelyVisible = .F.
		ENDIF
		
		DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		    IF UPPER(m.loControl.BASECLASS) == [PAGE] THEN
		        IF m.loControl.Enabled = .F.
		            This.EffectivelyEnabled = .F.
		        ENDIF
		       IF m.loControl.Parent.Enabled = .F.
		            This.EffectivelyEnabled = .F.
		        ENDIF
		
		        IF m.loControl.Parent.Visible = .F.
		            This.EffectivelyVisible = .F.
		        ENDIF
		        
		        IF BETWEEN(m.loControl.Parent.ActivePage, 1, m.loControl.Parent.PageCount)
		            IF m.loControl.Parent.Pages(m.loControl.Parent.ActivePage) != m.loControl
		                This.EffectivelyVisible = .F.
		            ENDIF
		        ENDIF
		    ENDIF
		    m.loControl = m.loControl.PARENT
		ENDDO
		
		DO CASE
		CASE llPrevVisible <> This.EffectivelyVisible
		    This.OnVisible()
		CASE llPrevEnabled <> This.EffectivelyEnabled
		    This.OnEnabled()
		ENDCASE
		
	ENDPROC

	PROCEDURE _onactivate
		This.SetState()
		
	ENDPROC

	PROCEDURE _ondeactivate
		This._IsPageDeactivated = .T.
		This.SetState()
		This._IsPageDeactivated = .F.
		
		
	ENDPROC

	PROCEDURE _onenabled
		LPARAMETERS tlEnabled
		This.SetState()
		
	ENDPROC

	PROCEDURE _onvisible
		LPARAMETERS tlVisible
		This.SetState()
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport AS reportlistener 		&& Report listener with integrated report preview base on PdfiumViewer control
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: batchbegin
		*m: batchend
		*m: closepdf
		*m: createpdf
		*m: errlogshow
		*m: errmsg
		*m: finalize
		*m: getfontgdi
		*m: getfontpdf
		*m: measurestring
		*m: render_frxdynamics
		*m: render_frxfield
		*m: render_frxlabel
		*m: render_frxline
		*m: render_frxpicture
		*m: render_frxrectangle
		*m: render_text
		*m: render_textasimage		&& Fallback rendering text as images (case of symbolic and non ttf fonts)
		*p: batchmode
		*p: batchmodeauto		&& .T. if report was created by  _REPORTOUTPUT (= PdfiumReport.app)  and NOPAGEEJECT was set
		*p: env		&& pdfium_env object
		*p: errlog
		*p: frx_pagecount
		*p: gdi_fonts
		*p: hpdf_doc
		*p: hpdf_fonts		&& Font collection for caching purporses
		*p: hpdf_pagecount
		*p: ogfx
		*p: saveas_filename		&& Filename suggestion for "save as" dialog
		*a: hpdf_pages[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN batchmodeauto,batchmode,env,errlog,frx_pagecount,gdi_fonts,hpdf_doc,hpdf_fonts,hpdf_pagecount,hpdf_pages,ogfx
	*<PropValue>
		AllowModalMessages = .T.
		batchmode = .F.
		batchmodeauto = .F.
		DynamicLineHeight = .T.
		env = .F.
		errlog = ("")
		FRXDataSession = 0
		frx_pagecount = 0
		gdi_fonts = .F.
		Height = 23
		hpdf_doc = 0
		hpdf_fonts = .F.
		hpdf_pagecount = 0
		ListenerType = -1
		Name = "pdfiumreport"
		ogfx = .F.
		QuietMode = .F.
		saveas_filename = ("")
		SendGDIPlusImage = 1
		TwoPassProcess = .T.
		Width = 23
		_memberdata = <VFPData>
			<memberdata name="hpdf_pages" type="property" display="hpdf_pages"/>
			<memberdata name="measurestring" type="method" display="MeasureString"/>
			<memberdata name="frx_pagecount" type="property" display="frx_pagecount"/>
			<memberdata name="getfontgdi" type="method" display="GetFontGDI"/>
			<memberdata name="getfontpdf" type="method" display="GetFontPDF"/>
			<memberdata name="hpdf_doc" type="property" display="hpdf_doc"/>
			<memberdata name="hpdf_pagecount" type="property" display="hpdf_pagecount"/>
			<memberdata name="ogfx" type="property" display="oGfx"/>
			<memberdata name="render_frxfield" type="method" display="Render_FrxField"/>
			<memberdata name="render_frxlabel" type="method" display="Render_FrxLabel"/>
			<memberdata name="render_frxline" type="method" display="Render_FrxLine"/>
			<memberdata name="render_frxpicture" type="method" display="Render_FrxPicture"/>
			<memberdata name="render_frxrectangle" type="method" display="Render_FrxRectangle"/>
			<memberdata name="render_text" type="method" display="Render_Text"/>
			<memberdata name="env" type="property" display="env"/>
			<memberdata name="errlog" type="property" display="ErrLog"/>
			<memberdata name="errlogshow" type="method" display="ErrLogShow"/>
			<memberdata name="errmsg" type="method" display="ErrMsg"/>
			<memberdata name="finalize" type="method" display="Finalize"/>
			<memberdata name="batchbegin" type="method" display="BatchBegin"/>
			<memberdata name="batchend" type="method" display="BatchEnd"/>
			<memberdata name="batchmode" type="property" display="BatchMode"/>
			<memberdata name="closepdf" type="method" display="ClosePDF"/>
			<memberdata name="createpdf" type="method" display="CreatePDF"/>
			<memberdata name="hpdf_fonts" type="property" display="hpdf_Fonts"/>
			<memberdata name="frx_printenv_set" type="method" display="frx_printenv_set"/>
			<memberdata name="render_textasimage" type="method" display="Render_TextAsImage"/>
			<memberdata name="gdi_fonts" type="property" display="gdi_fonts"/>
			<memberdata name="batchmodeauto" type="property" display="BatchModeAuto"/>
			<memberdata name="saveas_filename" type="property" display="SaveAs_Filename"/>
			<memberdata name="render_frxdynamics" type="method" display="Render_FrxDynamics"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE batchbegin
		This.BatchMode = .T.
		
		
	ENDPROC

	PROCEDURE batchend
		IF This.BatchMode = .F.
		    RETURN
		ENDIF
		
		This.Finalize()
		
		This.BatchMode = .F.
		
	ENDPROC

	HIDDEN PROCEDURE closepdf
		IF EMPTY(This.hpdf_doc)
		    RETURN
		ENDIF
		
		**************************************************
		* Release resources
		**************************************************
		HPDF_Free(This.hpdf_doc)
		
		DIMENSION This.hpdf_pages(1)
		This.hpdf_pages[1] = 0
		
		This.hpdf_pagecount = 0
		This.hpdf_doc = 0
		This.hpdf_fonts = .F.
		
		
	ENDPROC

	HIDDEN PROCEDURE createpdf
		#define HPDF_COMP_ALL 5
		#define HPDF_PAGE_MODE_USE_NONE 0
		#define HPDF_PAGE_MODE_USE_OUTLINE 1
		
		This.ClosePDF()
		
		This.hpdf_doc = HPDF_New(0,0)
		
		This.hpdf_fonts = NEWOBJECT("Collection")
		This.ErrLog = ""
		
		IF EMPTY(This.hpdf_doc) = .F.
		    HPDF_SetCompressionMode(This.hpdf_doc, HPDF_COMP_ALL)
		    HPDF_SetPageMode(This.hpdf_doc, HPDF_PAGE_MODE_USE_NONE)
		
		    HPDF_UseUTFEncodings(This.hpdf_doc)
		    HPDF_SetCurrentEncoder(This.hpdf_doc, "UTF-8")
		ENDIF
		
		
	ENDPROC

	PROCEDURE Destroy
		
		This.ClosePDF()
		
		This.env = .F.
		This.oGfx = .F.
		This.gdi_fonts = .F.
		
		This.PreviewContainer = NULL
		
		
	ENDPROC

	HIDDEN PROCEDURE errlogshow
		IF EMPTY(This.errLog)
		    RETURN
		ENDIF
		
		IF This.QuietMode
		    RETURN
		ENDIF
		
		IF This.AllowModalMessages
		    This.DoMessage(LEFT(This.errLog, 500), 0+48, This.Class + " ("+This.ClassLibrary+")")
		ELSE
		    This.DoStatus(LEFT(This.errLog, 250))
		ENDIF
		
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		lcMsg = ""
		
		DO CASE
		CASE VARTYPE(m.tvMsg)="O"
		    lcMsg = ;
		        m.tvMsg.Message + ;
		        RTRIM(" " + NVL(m.tvMsg.Details,"")) + ;
		        RTRIM(" " + NVL(m.tvMsg.UserValue,"")) + ;
		        CHR(13) + "Procedure: " + m.tvMsg.Procedure + ;
		        CHR(13) + "LineContents: " + m.tvMsg.LineContents
		
		CASE VARTYPE(m.tvMsg)="C"
		    lcMsg = ALLTRIM(m.tvMsg)
		
		ENDCASE
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		This.errLog = LEFT(IIF(EMPTY(This.errLog), "", This.errLog + CHR(13) + CHR(13)) + m.lcMsg, 10000)
		
		
	ENDPROC

	HIDDEN PROCEDURE finalize
		
		IF EMPTY(This.hpdf_doc)
		    RETURN
		ENDIF
		
		This.errLogShow()
		
		LOCAL lcTempFileName
		lcTempFileName = This.env.GetUniqueTempFileName("pdf")
		
		LOCAL loErr
		loErr = .F.
		TRY
		    IF This.CommandClauses.PREVIEW = .F. AND This.CommandClauses.OUTPUTTO != 2 && not preview or output to file
		        EXIT
		    ENDIF
		
		    IF HPDF_SaveToFile(This.hpdf_doc, lcTempFileName) <> 0
		        EXIT
		    ENDIF
		    
		    This.ClosePDF()    
		    
		    DO CASE
		    CASE This.CommandClauses.OUTPUTTO = 2 && output to file
		        IF EMPTY(This.CommandClauses.TOFILE) = .F.
		            COPY FILE (lcTempFileName) TO (This.CommandClauses.TOFILE)
		        ENDIF
		
		    CASE This.CommandClauses.PREVIEW 
		
		        This.PreviewContainer = NEWOBJECT("PdfiumReportViewer", This.ClassLibrary, "", This.env)
		        This.PreviewContainer.SetReport(This)
		        This.PreviewContainer.OpenPDF(lcTempFileName)
		        This.PreviewContainer.SaveAs_Filename = This.SaveAs_Filename
		        This.PreviewContainer.Show(1)
		    
		    ENDCASE
		
		CATCH TO loErr
		    LOCAL llShowErrLog
		    llShowErrLog = EMPTY(This.ErrLog)
		    
		    This.ErrMsg(loErr)
		    
		    IF llShowErrLog
		        This.errLogShow()
		    ENDIF
		
		FINALLY
		
		    This.PreviewContainer = NULL
		    
		    This.ClosePDF()
		    
		    TRY
		        IF FILE(lcTempFileName,1)
		            DELETE FILE (lcTempFileName)
		        ENDIF
		    CATCH
		    ENDTRY
		
		ENDTRY
		
		
	ENDPROC

	HIDDEN PROCEDURE getfontgdi
		LPARAMETERS loRepObj
		
		LOCAL lcFontID
		lcFontID = ALLTRIM(loRepObj.FontFace)
		lcFontID = lcFontID + "<"+TRANSFORM(loRepObj.FontSize)+">"
		IF loRepObj.FontBold
		    lcFontID = lcFontID + "<B>"
		ENDIF
		IF loRepObj.FontItalic
		    lcFontID = lcFontID + "<I>"
		ENDIF
		IF loRepObj.FontUnderline
		    lcFontID = lcFontID + "<U>"
		ENDIF
		lcFontID = lcFontID + "<"+TRANSFORM(loRepObj.FontCharset)+">"
		
		
		***********************************************************
		* Font has been found
		***********************************************************
		LOCAL lnFontIndex
		lnFontIndex = This.gdi_fonts.GetKey(lcFontID)
		IF lnFontIndex > 0
		    RETURN This.gdi_fonts[lnFontIndex]
		ENDIF
		***********************************************************
		
		
		***********************************************************
		* Font hasn't been found, create it
		***********************************************************
		LOCAL loGDIFont, loGDIFontFamily, liFont, lcFontFace
		STORE .F. TO loGDIFont, loGDIFontFamily
		liFont = 1
		FOR liFont = 1 TO 3
		
		    lcFontFace = ICASE(liFont=1, loRepObj.FontFace, liFont=2, "Helvetica", "Arial") && If report font is not found, take fallback font
		
		    loGDIFont = This.env.System.Drawing.Font.New( ;
		        lcFontFace, ;
		        loRepObj.FontSize, ;
		        ( ;
		            IIF(loRepObj.FontBold, This.env.System.Drawing.FontStyle.Bold, 0) + ;
		            IIF(loRepObj.FontItalic, This.env.System.Drawing.FontStyle.Italic, 0) + ; 
		            IIF(loRepObj.FontUnderline, This.env.System.Drawing.FontStyle.Underline, 0) ;
		        ),;
		        This.env.System.Drawing.GraphicsUnit.Point, ;
		        loRepObj.FontCharset, ;
		        .F.)
		
		
		    IF EMPTY(loGDIFont.GetHandle()) = .F.
		        loGDIFontFamily = loGDIFont.FontFamily
		        EXIT
		    ENDIF
		    
		    LOOP
		
		
		    IF EMPTY(This.env.System.Drawing.Text.PrivateFontCollection.Families.GetKey(lcFontFace)) = .F. && Try to get font from private font collection
		        
		        loGDIFontFamily = This.env.System.Drawing.Text.PrivateFontCollection.Families.Item(lcFontFace)
		        
		        loGDIFont = This.env.System.Drawing.Font.New( ;
		            loGDIFontFamily, ;
		            loRepObj.FontSize, ;
		            ( ;
		                IIF(loRepObj.FontBold, This.env.System.Drawing.FontStyle.Bold, 0) + ;
		                IIF(loRepObj.FontItalic, This.env.System.Drawing.FontStyle.Italic, 0) + ; 
		                IIF(loRepObj.FontUnderline, This.env.System.Drawing.FontStyle.Underline, 0) ;
		            ),;
		            This.env.System.Drawing.GraphicsUnit.Point, ;
		            loRepObj.FontCharset, ;
		            .F.)
		
		    ENDIF    
		
		    IF EMPTY(loGDIFont.GetHandle()) = .F.
		        EXIT
		    ENDIF
		    
		    loGDIFont = .F.
		    loGDIFontFamily = .F.
		
		ENDFOR
		
		
		LOCAL loFont
		loFont = NEWOBJECT("Empty")
		ADDPROPERTY(loFont, "GDIFont", loGDIFont)
		ADDPROPERTY(loFont, "Handle", loGDIFont.GetHandle())
		ADDPROPERTY(loFont, "Height", EVL(MAX(loGDIFont.GetHeight(), 0), 15.7))
		ADDPROPERTY(loFont, "HeightCeil", EVL(MAX(loGDIFont.Height, 0), 16))
		
		TRY
		    ADDPROPERTY(loFont, "CellDescent", loGDIFontFamily.GetCellDescent())
		    ADDPROPERTY(loFont, "CellAscent", loGDIFontFamily.GetCellAscent())
		    ADDPROPERTY(loFont, "EmHeight", loGDIFontFamily.GetEmHeight())
		CATCH
		    ADDPROPERTY(loFont, "CellDescent", 434)
		    ADDPROPERTY(loFont, "CellAscent", 1854)
		    ADDPROPERTY(loFont, "EmHeight", 2048)
		ENDTRY
		
		
		This.gdi_fonts.Add(loFont, lcFontID)
		
		RETURN loFont
		
		
	ENDPROC

	HIDDEN PROCEDURE getfontpdf
		LPARAMETERS loRepObj
		
		IF EMPTY(This.hpdf_doc)
		    RETURN 0
		ENDIF
		
		#define DWRITE_FONT_SIMULATIONS_NONE 0x0000
		* Algorithmic emboldening is performed.
		#define DWRITE_FONT_SIMULATIONS_BOLD 0x0001
		* Algorithmic italicization is performed.
		#define DWRITE_FONT_SIMULATIONS_OBLIQUE 0x0002
		
		
		LOCAL lcFontID
		lcFontID = ALLTRIM(loRepObj.FontFace)
		IF loRepObj.FontBold
		    lcFontID = lcFontID + "<B>"
		ENDIF
		IF loRepObj.FontItalic
		    lcFontID = lcFontID + "<I>"
		ENDIF
		
		
		***********************************************************
		* Font has been found
		***********************************************************
		LOCAL lnFontIndex
		lnFontIndex = This.hpdf_fonts.GetKey(lcFontID)
		IF lnFontIndex > 0
		    RETURN This.hpdf_fonts[lnFontIndex]
		ENDIF
		***********************************************************
		
		
		***********************************************************
		* Font hasn't been found, load it from file
		***********************************************************
		LOCAL lnHPDF_Font
		lnHPDF_Font = 0
		
		LOCAL lnFontSimulations
		lnFontSimulations = 0
		
		LOCAL lnIsSymbolFont
		lnIsSymbolFont = 0
		
		LOCAL lcFontFileName
		lcFontFileName = ""
		
		TRY
		    
		    lcFontFileName = REPLICATE(CHR(0),255*2)
		
		    LOCAL lnGetFont
		    lnGetFont = FPDF_GetFontFileName( ;
		                    STRCONV(ALLTRIM(loRepObj.FontFace),5)+CHR(0), ;
		                    IIF(loRepObj.FontBold,1,0), ;
		                    IIF(loRepObj.FontItalic,1,0), ;
		                    loRepObj.FontCharset, ;
		                    @lcFontFileName, ;
		                    LEN(lcFontFileName), ;
		                    @lnFontSimulations, ;
		                    @lnIsSymbolFont)
		                    
		    IF lnGetFont = 1
		        lcFontFileName = STRCONV(lcFontFileName,6)
		        lcFontFileName = ALLTRIM(lcFontFileName, 1, CHR(0), " ")
		
		    ELSE    
		        * Font is not found
		        
		        * Private font collection searching
		        LOCAL lnPrivateFontKey
		        lnPrivateFontKey = This.env.PrivateFonts.GetKey(ALLTRIM(loRepObj.FontFace)) 
		        IF EMPTY(lnPrivateFontKey)
		            EXIT
		        ENDIF
		        
		        lcFontFileName = ALLTRIM(This.env.PrivateFonts.Item(lnPrivateFontKey))
		        
		        lnIsSymbolFont = 0
		        lnFontSimulations = 0
		        
		        IF EMPTY(This.env.System.Drawing.Text.PrivateFontCollection.Families.GetKey(ALLTRIM(loRepObj.FontFace))) = .F.
		            LOCAL loGDIFontFamily
		            loGDIFontFamily = This.env.System.Drawing.Text.PrivateFontCollection.Families.Item(ALLTRIM(loRepObj.FontFace))
		
		            lnFontSimulations = lnFontSimulations + IIF(loGDIFontFamily.IsStyleAvailable(This.env.System.Drawing.FontStyle.Bold), 0, DWRITE_FONT_SIMULATIONS_BOLD)
		            lnFontSimulations = lnFontSimulations + IIF(loGDIFontFamily.IsStyleAvailable(This.env.System.Drawing.FontStyle.Italic), 0, DWRITE_FONT_SIMULATIONS_OBLIQUE)
		            
		            loGDIFontFamily = .F.
		        ENDIF
		
		    ENDIF
		
		    IF EMPTY(lnIsSymbolFont)=.F.
		        * LibHARU fails on HPDF_LoadTTFontFromFile with Symbol fonts (Windings*...)    
		        EXIT
		    ENDIF
		
		
		    IF FILE(lcFontFileName,1) = .F.
		        EXIT && Font file doesn't exist OR FILENAME HAS UNICODE SYMBOLS
		    ENDIF
		      
		    IF NOT LOWER(ALLTRIM(JUSTEXT(lcFontFileName))) == "ttf"
		        EXIT && Only TTF files supported
		    ENDIF
		
		
		    * Check if font file has been loaded earlier
		    LOCAL loFont
		    FOR EACH loFont IN This.hpdf_fonts FOXOBJECT
		        IF ALLTRIM(loFont.FontFileName) == ALLTRIM(lcFontFileName)
		            lnHPDF_Font = loFont.FontHandle
		            EXIT
		        ENDIF
		    ENDFOR
		
		    * Load font from file if file hasn't been loaded yet
		    IF EMPTY(lnHPDF_Font)
		        LOCAL lcHPDF_FontName
		        lcHPDF_FontName = HPDF_LoadTTFontFromFile(This.hpdf_doc, lcFontFileName, 1)
		
		        IF EMPTY(lcHPDF_FontName)=.F.
		            lnHPDF_Font = HPDF_GetFont(This.hpdf_doc, lcHPDF_FontName, "UTF-8")
		        ENDIF
		    ENDIF
		
		FINALLY
		
		    IF EMPTY(lnHPDF_Font)=.T. AND EMPTY(lnIsSymbolFont)=.T. && Get Fallback Font
		        lnFontSimulations = 0
		        lcFontFileName = ""
		
		        lnHPDF_Font = HPDF_GetFont( ;
		            This.hpdf_doc, ;
		            ICASE( ;
		                loRepObj.FontBold and loRepObj.FontItalic, "Helvetica-BoldOblique", ;
		                loRepObj.FontBold, "Helvetica-Bold", ;
		                loRepObj.FontItalic, "Helvetica-Oblique", ;
		                "Helvetica"), ;
		            ICASE(;
		                loRepObj.FontCharset=161, "CP1253",;
		                loRepObj.FontCharset=162, "CP1254",;
		                loRepObj.FontCharset=163, "CP1258",;
		                loRepObj.FontCharset=177, "CP1255",;
		                loRepObj.FontCharset=178, "CP1256",;
		                loRepObj.FontCharset=186, "CP1257",;
		                loRepObj.FontCharset=204, "CP1251",;
		                loRepObj.FontCharset=238, "CP1250",;
		                "CP1252"))
		    ENDIF
		
		ENDTRY
		
		
		* Create and store font object
		IF EMPTY(lnHPDF_Font)=.F.
		    LOCAL loPDFFont
		    loPDFFont = NEWOBJECT("Empty")
		    
		    ADDPROPERTY(loPDFFont, "FontFileName", lcFontFileName)
		    ADDPROPERTY(loPDFFont, "FontHandle", lnHPDF_Font)
		    ADDPROPERTY(loPDFFont, "FontFace", loRepObj.FontFace)
		    ADDPROPERTY(loPDFFont, "FontBold", (loRepObj.FontBold and BITAND(lnFontSimulations, DWRITE_FONT_SIMULATIONS_BOLD)=0))
		    ADDPROPERTY(loPDFFont, "FontItalic", (loRepObj.FontItalic and BITAND(lnFontSimulations, DWRITE_FONT_SIMULATIONS_OBLIQUE)=0))
		
		    This.hpdf_fonts.Add(loPDFFont, lcFontID)
		ENDIF
		
		
		LOCAL lnFontIndex
		lnFontIndex = This.hpdf_fonts.GetKey(lcFontID)
		IF lnFontIndex > 0
		    RETURN This.hpdf_fonts[lnFontIndex]
		ENDIF
		
		RETURN .F.
		
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.env = NEWOBJECT("pdfium_env", This.ClassLibrary)
		This.env.Setup(m.toEnv)
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		
		This.oGfx = This.env.System.Drawing.Graphics.FromHWND(_SCREEN.HWnd)
		This.gdi_fonts = NEWOBJECT("Collection")
		
	ENDPROC

	PROCEDURE LoadReport
		
		This.env.declaredll()
		
		This.frx_pagecount = 0
		
		This.ListenerType = -1
		
		DO CASE
		 CASE This.CommandClauses.ISDESIGNERLOADED
		     This.CommandClauses.PREVIEW = .T.
		 
		 CASE This.CommandClauses.OUTPUTTO = 1 &&Output to printer, do nothing
		    This.ListenerType = 0
		    RETURN
		ENDCASE
		
		IF EMPTY(This.hpdf_doc)
		    This.CreatePDF()
		ENDIF
		
		This.BatchModeAuto = This.CommandClauses.NOPAGEEJECT
		This.CommandClauses.NOPAGEEJECT = .F.
		
		
	ENDPROC

	HIDDEN PROCEDURE measurestring
		LPARAMETERS tcTextUnicode, toFont, toLayoutRectF, toObjRectF, tnCharsFitted, tnLinesFitted
		
		STORE 0 TO tnCharsFitted, tnLinesFitted
		
		m.toObjRectF = This.env.system.Drawing.RectangleF.New(0,0,0,0)
		
		LOCAL lcObjBBox
		lcObjBBox = m.toObjRectF.ToVarBinary()
		
		* Plain Api call because GDIPluxX Graphics.MeasureString performs STRCONV(...,5) on input text while loRepObj.Text is in Unicode
		WinApi_GdipMeasureString (;
		    This.oGfx.GetHandle(), ;
		    m.tcTextUnicode + CHR(0), ;
		    LEN(m.tcTextUnicode) / 2, ;
		    toFont.Handle, ;
		    toLayoutRectF.ToVarBinary(), ;
		    This.env.system.Drawing.StringFormat.GenericTypographic.GetHandle(), ;
		    @lcObjBBox, ;
		    @tnCharsFitted, ;
		    @tnLinesFitted)
		
		
		m.toObjRectF = m.toObjRectF.New(lcObjBBox)
		
		
	ENDPROC

	PROCEDURE OnPreviewClose
		LPARAMETERS lPrint
		
		This.PreviewContainer = NULL
		
	ENDPROC

	PROCEDURE Render
		LPARAMETERS nFRXRecno, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage
		
		IF This.TwoPassProcess AND This.CurrentPass = 0
		    RETURN DODEFAULT(m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
		ENDIF
		
		IF This.ListenerType = 0 &&Output to printer, do nothing
		    RETURN DODEFAULT(m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
		ENDIF
		
		
		IF This.PageNo < This.CommandClauses.RANGEFROM
		    RETURN 
		ENDIF
		    
		IF This.PageNo > This.CommandClauses.RANGETO AND This.CommandClauses.RANGETO > 0
		    RETURN
		ENDIF
		
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		IF EMPTY(This.hpdf_doc)
		    RETURN
		ENDIF
		
		
		LOCAL lnDpiCoef
		lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL lnPageWidth, lnPageHeight
		lnPageWidth = ROUND(This.GetPageWidth() / 10, 0)
		lnPageHeight = ROUND(This.GetPageHeight() / 10, 0)
		
		
		HPDF_ResetError(This.hpdf_doc)
		
		
		*************************************************
		* Create new page
		*************************************************
		IF This.PageNo > This.frx_pagecount
		
		    This.env.declaredll()
		   
		    This.frx_pagecount = This.frx_pagecount + 1
		    This.hpdf_pagecount = This.hpdf_pagecount + 1 &&It may be greater than frx_pagecount if PDF comprise output of many reports when This.BatchMode=.T.
		
		    DIMENSION This.hpdf_pages(This.hpdf_pagecount)
		
		    LOCAL lnHPDF_Page
		    lnHPDF_Page = HPDF_AddPage(This.hpdf_doc)
		
		    IF EMPTY(lnHPDF_Page)=.F.
		        HPDF_Page_SetWidth(lnHPDF_Page,  lnPageWidth * lnDpiCoef)
		        HPDF_Page_SetHeight(lnHPDF_Page, lnPageHeight * lnDpiCoef)
		    ENDIF
		    
		    This.hpdf_pages[This.hpdf_pagecount] = lnHPDF_Page
		
		ENDIF
		
		IF EMPTY(This.hpdf_pages[This.hpdf_pagecount])
		    RETURN
		ENDIF
		
		
		
		*************************************************
		#define FRX_OBJ_COMMENT     0
		#define FRX_OBJ_LABEL       5
		#define FRX_OBJ_LINE        6
		#define FRX_OBJ_RECTANGLE   7
		#define FRX_OBJ_FIELD       8
		#define FRX_OBJ_PICTURE     17
		#define FRX_OBJ_VARIABLE    18
		
		
		*************************************************
		IF (This.FRXDatasession > -1) AND (This.FRXDatasession <> SET("DATASESSION"))
		    SET DATASESSION TO (This.FRXDatasession)
		ENDIF
		
		GO m.nFRXRecNo IN FRX
		
		LOCAL loFrx
		SCATTER NAME loFrx MEMO
		
		SET DATASESSION TO (This.CurrentDataSession)
		*************************************************
		
		
		*************************************************
		LOCAL loRepObj
		
		loRepObj = NEWOBJECT("Empty")
		
		
		ADDPROPERTY(loRepObj, "ObjType", loFrx.ObjType)
		
		ADDPROPERTY(loRepObj, "Text", "")
		ADDPROPERTY(loRepObj, "FileName", "")
		
		IF INLIST(loFrx.ObjType, FRX_OBJ_FIELD, FRX_OBJ_LABEL)
		    loRepObj.Text = m.cContentsToBeRendered
		ENDIF
		
		IF INLIST(loFrx.ObjType, FRX_OBJ_PICTURE)
		    loRepObj.FileName = m.cContentsToBeRendered
		ENDIF
		
		
		ADDPROPERTY(loRepObj, "Left", ROUND(m.nLeft / 10,0))
		ADDPROPERTY(loRepObj, "Top", ROUND(m.nTop / 10,0))
		ADDPROPERTY(loRepObj, "TopRev", lnPageHeight - ROUND(m.nTop / 10,0))
		ADDPROPERTY(loRepObj, "Width", ROUND(m.nWidth / 10,0))
		ADDPROPERTY(loRepObj, "Height", ROUND(m.nHeight / 10,0))
		
		ADDPROPERTY(loRepObj, "FontFace", LTRIM(ALLTRIM(loFrx.FontFace), "@"))
		ADDPROPERTY(loRepObj, "FontSize", loFrx.FontSize)
		ADDPROPERTY(loRepObj, "FontBold", BITTEST(loFrx.FontStyle,0))
		ADDPROPERTY(loRepObj, "FontItalic", BITTEST(loFrx.FontStyle,1))
		ADDPROPERTY(loRepObj, "FontUnderline", BITTEST(loFrx.FontStyle,2))
		ADDPROPERTY(loRepObj, "FontStrikeout", BITTEST(loFrx.FontStyle,7))
		ADDPROPERTY(loRepObj, "FontCharset", loFrx.ResOID)
		
		
		* (-1,-1,-1) - default color
		ADDPROPERTY(loRepObj, "FillRed", IIF(loFrx.FillRed=-1, 255, loFrx.FillRed))
		ADDPROPERTY(loRepObj, "FillGreen", IIF(loFrx.FillGreen=-1, 255, loFrx.FillGreen))
		ADDPROPERTY(loRepObj, "FillBlue", IIF(loFrx.FillBlue=-1, 255, loFrx.FillBlue))
		ADDPROPERTY(loRepObj, "FillAlpha", 255)
		
		* (-1,-1,-1) - default color
		ADDPROPERTY(loRepObj, "PenRed", IIF(loFrx.PenRed=-1, 0, loFrx.PenRed))
		ADDPROPERTY(loRepObj, "PenGreen", IIF(loFrx.PenGreen=-1, 0, loFrx.PenGreen))
		ADDPROPERTY(loRepObj, "PenBlue", IIF(loFrx.PenBlue=-1, 0, loFrx.PenBlue))
		ADDPROPERTY(loRepObj, "PenAlpha", 255)
		
		ADDPROPERTY(loRepObj, "PenPat", loFrx.PenPat)
		ADDPROPERTY(loRepObj, "PenSize", loFrx.PenSize)
		
		ADDPROPERTY(loRepObj, "FillPat", loFrx.FillPat)
		ADDPROPERTY(loRepObj, "Mode", loFrx.Mode) &&Transparency: 0 - Opaque, 1 - Transparent
		ADDPROPERTY(loRepObj, "Offset", loFrx.Offset) &&Alignment: 0 - left, 1 - right, 2 - center
		ADDPROPERTY(loRepObj, "ContinuationType", m.nObjectContinuationType)
		ADDPROPERTY(loRepObj, "GDIPlusImage", m.GDIPlusImage)
		ADDPROPERTY(loRepObj, "General", loFrx.General)
		ADDPROPERTY(loRepObj, "Style", loFrx.Style)
		ADDPROPERTY(loRepObj, "Rotate", 0)
		
		This.Render_FrxDynamics(loRepObj)
		
		
		*************************************************
		DO CASE
		CASE loFrx.ObjType = FRX_OBJ_FIELD
		    This.Render_FrxField(loRepObj)
		   
		CASE loFrx.ObjType = FRX_OBJ_LABEL
		    This.Render_FrxLabel(loRepObj)
		
		CASE loFrx.ObjType = FRX_OBJ_LINE
		    This.Render_FrxLine(loRepObj)
		
		CASE loFrx.ObjType = FRX_OBJ_RECTANGLE
		    This.Render_FrxRectangle(loRepObj)
		
		CASE loFrx.ObjType = FRX_OBJ_PICTURE
		    This.Render_FrxPicture(loRepObj)
		
		ENDCASE
		*************************************************
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxdynamics
		LPARAMETERS loRepObj
		
		IF EMPTY(NVL(loRepObj.Style,""))
		    RETURN
		ENDIF
		
		#define FRX_OBJ_RECTANGLE   7
		#define FRX_OBJ_FIELD       8
		#define FRX_OBJ_PICTURE     17
		
		
		LOCAL lSaveArea
		lSaveArea = SELECT()
		
		LOCAL lSetNull
		lSetNull = SET("Null")
		
		SET NULL OFF
		
		LOCAL lcAliasCursor, llRes
		lcAliasCursor = "curTempFrxDynamics"+SYS(2015)
		
		CREATE CURSOR &lcAliasCursor (Name c(100), Execute c(10), ExecWhen M, Script M, FName c(100), FSize c(10), FStyle c(10), Width c(10), Height c(10), penrgb c(10), pena c(5), fillrgb c(10), filla c(5))
		
		SET NULL &lSetNull
		
		llRes = .T.
		TRY
		    XMLTOCURSOR(loRepObj.Style, lcAliasCursor,1024+8192)
		CATCH
		    llRes = .F.
		FINALLY    
		    IF llRes = .F.
		        USE IN (lcAliasCursor)
		        SELECT (lSaveArea)
		        RETURN
		    ENDIF
		ENDTRY
		
		
		SELECT (m.lcAliasCursor)
		GO TOP
		SCAN
		    SELECT (m.lcAliasCursor)
		
		    LOCAL loDS
		    SCATTER NAME loDS MEMO
		    
		    SELECT (lSaveArea)
		
		    DO CASE
		    CASE ALLTRIM(loDS.Name) == "Microsoft.VFP.Reporting.Builder.Rotate"
		        loRepObj.Rotate = CAST(loDS.Execute AS I)
		        
		    CASE EMPTY(loDS.ExecWhen)
		
		    CASE EVALUATE(loDS.ExecWhen) = .F.
		    
		    
		    CASE loRepObj.ObjType = FRX_OBJ_FIELD
		        IF EMPTY(loDS.Script) = .F.
		            IF INLIST(loRepObj.FontCharset,0,1)=.F.
		                loRepObj.Text = STRCONV(RTRIM(EVALUATE(loDS.Script)),5,loRepObj.FontCharset,2)
		            ELSE
		                loRepObj.Text = STRCONV(RTRIM(EVALUATE(loDS.Script)),5)
		            ENDIF
		        ENDIF
		        
		        IF EMPTY(loDS.FName) = .F.
		            loRepObj.FontFace = LTRIM(ALLTRIM(loDS.FName), "@")
		        ENDIF
		
		        IF EMPTY(CAST(loDS.FSize as I)) = .F.
		            loRepObj.FontSize = CAST(loDS.FSize as I)
		        ENDIF
		        
		        IF EMPTY(CAST(loDS.FStyle as I)) = .F.
		            loRepObj.FontBold = BITTEST(CAST(loDS.FStyle as I),0)
		            loRepObj.FontItalic = BITTEST(CAST(loDS.FStyle as I),1)
		            loRepObj.FontUnderline = BITTEST(CAST(loDS.FStyle as I),2)
		            loRepObj.FontStrikeout = BITTEST(CAST(loDS.FStyle as I),7)                                    
		        ENDIF
		        
		        IF CAST(loDS.FillRgb as I) >= 0 AND EMPTY(loDS.FillRgb)=.F.
		            loRepObj.FillRed = BITRSHIFT(BITAND(CAST(loDS.FillRgb as I), 0x0000FF),0)
		            loRepObj.FillGreen = BITRSHIFT(BITAND(CAST(loDS.FillRgb as I), 0x00FF00),8)
		            loRepObj.FillBlue = BITRSHIFT(BITAND(CAST(loDS.FillRgb as I), 0xFF0000),16)
		        ENDIF
		        
		        IF CAST(loDS.PenA as I) >= 0 AND EMPTY(loDS.PenA)=.F.
		            loRepObj.PenAlpha = BITAND(CAST(loDS.PenA as I), 0xFF)
		        ENDIF
		
		        IF CAST(loDS.PenRgb as I) >= 0 AND EMPTY(loDS.PenRgb)=.F.
		            loRepObj.PenRed = BITRSHIFT(BITAND(CAST(loDS.PenRgb as I), 0x0000FF),0)
		            loRepObj.PenGreen = BITRSHIFT(BITAND(CAST(loDS.PenRgb as I), 0x00FF00),8)
		            loRepObj.PenBlue = BITRSHIFT(BITAND(CAST(loDS.PenRgb as I), 0xFF0000),16)
		        ENDIF
		
		        IF CAST(loDS.FillA as I) >= 0 AND EMPTY(loDS.FillA)=.F.
		            loRepObj.FillAlpha = BITAND(CAST(loDS.FillA as I), 0xFF)
		            loRepObj.Mode = IIF(loRepObj.FillAlpha = 0, 1, 0)
		        ENDIF
		
		    
		    CASE INLIST(loRepObj.ObjType, FRX_OBJ_RECTANGLE, FRX_OBJ_PICTURE)
		        loRepObj.Width = IIF(CAST(loDS.Width AS I) >= 0, ROUND(CAST(loDS.Width AS I) / 10, 0), loRepObj.Width)
		        loRepObj.Height = IIF(CAST(loDS.Height AS I) >= 0, ROUND(CAST(loDS.Height AS I) / 10, 0), loRepObj.Height)
		    
		    ENDCASE
		    
		ENDSCAN
		GO TOP
		
		USE IN (m.lcAliasCursor)
		SELECT (lSaveArea)
		
	ENDPROC

	HIDDEN PROCEDURE render_frxfield
		LPARAMETERS loRepObj
		
		This.render_text(loRepObj)
		
	ENDPROC

	HIDDEN PROCEDURE render_frxlabel
		LPARAMETERS loRepObj
		
		This.render_text(loRepObj)
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxline
		LPARAMETERS loRepObj
		
		LOCAL lnHPDF_Page
		lnHPDF_Page = This.hpdf_pages[This.hpdf_pagecount]
		
		LOCAL lnDpiCoef
		lnDpiCoef = This.env.GetPDFDPI() / 96
		
		HPDF_Page_GSave(lnHPDF_Page)
		
		IF EMPTY(loRepObj.Rotate) = .F.
		    LOCAL lnRad
		    lnRad = -loRepObj.Rotate * PI() / 180
		
		    HPDF_Page_Concat(;
		        lnHPDF_Page, ;
		        COS(lnRad), ;
		        SIN(lnRad), ;
		        -SIN(lnRad), ;
		        COS(lnRad), ;
		        lnDpiCoef * loRepObj.Left, ;
		        lnDpiCoef * loRepObj.TopRev)
		ENDIF
		
		HPDF_Page_SetRGBStroke(lnHPDF_Page, loRepObj.PenRed / 255, loRepObj.PenGreen / 255, loRepObj.PenBlue / 255)
		
		IF loRepObj.PenSize >= 1
		    HPDF_Page_SetLineWidth(lnHPDF_Page, loRepObj.PenSize * IIF(INLIST(loRepObj.PenPat,1,2,3,4), 0.5, 1) )
		ELSE
		    HPDF_Page_SetLineWidth(lnHPDF_Page,  0)
		ENDIF
		
		
		LOCAL lcDash
		
		DO CASE
		CASE loRepObj.PenPat = 8 && Normal
		    HPDF_Page_SetDash(lnHPDF_Page, NULL, 0, 0)
		
		CASE loRepObj.PenPat = 1 && Dot
		    lcDash = BINTOC(1, "F")
		    HPDF_Page_SetDash(lnHPDF_Page, @lcDash, 1, 1)
		    
		CASE loRepObj.PenPat = 2 && Dash
		    lcDash = BINTOC(6, "F") + BINTOC(6, "F")
		    HPDF_Page_SetDash(lnHPDF_Page, @lcDash, 2, 2)
		    
		CASE loRepObj.PenPat = 3 && Dash-dot
		    lcDash = BINTOC(6, "F") + BINTOC(6, "F") + BINTOC(1, "F") + BINTOC(6, "F")
		    HPDF_Page_SetDash(lnHPDF_Page, @lcDash, 4, 0)
		    
		CASE loRepObj.PenPat = 4 && Dash-dot-dot
		    lcDash = BINTOC(6, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F")
		    HPDF_Page_SetDash(lnHPDF_Page, @lcDash, 6, 0)
		
		OTHERWISE && Normal
		    HPDF_Page_SetDash(lnHPDF_Page, NULL, 0, 0)
		
		ENDCASE
		
		
		IF loRepObj.OffSet = 1
		    * Horizontal line
		    IF EMPTY(loRepObj.Rotate) = .F.
		        HPDF_Page_MoveTo(lnHPDF_Page, 0, 0)
		        HPDF_Page_LineTo(lnHPDF_Page, lnDpiCoef * loRepObj.Width, 0)
		    ELSE
		        HPDF_Page_MoveTo(lnHPDF_Page, ;
		            lnDpiCoef * loRepObj.Left, ;
		            lnDpiCoef * loRepObj.TopRev)
		            
		        HPDF_Page_LineTo(lnHPDF_Page, ;
		            lnDpiCoef * (loRepObj.Left + loRepObj.Width), ;
		            lnDpiCoef * loRepObj.TopRev)
		
		    ENDIF
		        
		ELSE
		    * Vertical line
		    IF EMPTY(loRepObj.Rotate) = .F.
		        HPDF_Page_MoveTo(lnHPDF_Page, 0, 0)
		        HPDF_Page_LineTo(lnHPDF_Page, 0, lnDpiCoef * -loRepObj.Height)
		    ELSE
		        HPDF_Page_MoveTo(lnHPDF_Page, ;
		            lnDpiCoef * loRepObj.Left, ;
		            lnDpiCoef * (loRepObj.TopRev - loRepObj.Height)) 
		            
		        HPDF_Page_LineTo(lnHPDF_Page, ;
		            lnDpiCoef * loRepObj.Left, ;
		            lnDpiCoef * loRepObj.TopRev)
		    ENDIF
		ENDIF
		    
		
		HPDF_Page_Stroke(lnHPDF_Page)
		    
		HPDF_Page_GRestore(lnHPDF_Page)
		
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxpicture
		LPARAMETERS loRepObj
		
		LOCAL lnHPDF_Page
		lnHPDF_Page = This.hpdf_pages[This.hpdf_pagecount]
		
		LOCAL lnDpiCoef
		lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		LOCAL lcTempFileName
		lcTempFileName = This.env.GetUniqueTempFileName("png")
		
		
		LOCAL loErr
		loErr = .F.
		TRY
		
		    LOCAL loImage
		    loImage = .F.
		
		    DO CASE
		    CASE EMPTY(loRepObj.GDIPlusImage)=.F.
		        
		        loImage = This.env.System.Drawing.Bitmap.FromHbitmap(loRepObj.GDIPlusImage)
		       
		    CASE EMPTY(loRepObj.FileName) = .F.
		    
		        loImage = This.env.System.Drawing.Bitmap.FromVarBinary(FILETOSTR(loRepObj.FileName))
		
		    ENDCASE
		       
		    IF VARTYPE(loImage) <> "O"
		        EXIT
		    ENDIF
		
		
		    **************************************************
		    * Image scaling
		    **************************************************
		    LOCAL lnImgWidth, lnImgHeight
		    STORE 0 TO lnImgWidth, lnImgHeight
		
		    DO CASE
		    CASE loRepObj.General = 0 && Crop
		        lnImgWidth = MIN(loImage.Width, loRepObj.Width)
		        lnImgHeight = MIN(loImage.Height, loRepObj.Height)
		        
		    CASE loRepObj.General = 1 && Scale Keep shape
		        LOCAL lnScale
		        lnScale = MIN(loRepObj.Width / EVL(loImage.Width,1), loRepObj.Height / EVL(loImage.Height,1))
		
		        lnImgWidth = loImage.Width * lnScale
		        lnImgHeight = loImage.Height * lnScale
		
		    OTHERWISE && Scale Stretch
		        lnImgWidth = loRepObj.Width
		        lnImgHeight = loRepObj.Height
		
		    ENDCASE
		
		
		    **************************************************
		    * Image compression
		    **************************************************
		    LOCAL loImageScaled, loGfxScaled
		    loImageScaled = This.env.System.Drawing.Bitmap.New(lnImgWidth, lnImgHeight, loImage.PixelFormat)
		
		    loGfxScaled = This.env.System.Drawing.Graphics.New()
		    loGfxScaled = loGfxScaled.FromImage(loImageScaled)
		
		    DO CASE
		    CASE loRepObj.General = 0 && Crop
		        loGfxScaled.DrawImageUnscaled(loImage, 0, 0, lnImgWidth, lnImgHeight)
		        loImage = loImageScaled
		        
		    CASE loImage.Width * loImage.Height > lnImgWidth * lnImgHeight && Scale and compress
		        loGfxScaled.DrawImage(loImage, 0, 0, lnImgWidth, lnImgHeight)
		        loImage = loImageScaled
		        
		    ENDCASE
		
		    loGfxScaled = .F.
		    loImageScaled = .F.
		
		
		    loImage.Save(lcTempFileName, This.env.System.Drawing.Imaging.ImageFormat.Png)
		    loImage = .F.
		
		
		    **************************************************
		    * Draw image
		    **************************************************
		    LOCAL lnHPDF_Image
		    lnHPDF_Image = 0
		    
		    IF FILE(lcTempFileName, 1)
		        lnHPDF_Image = HPDF_LoadPngImageFromFile(This.hpdf_doc, lcTempFileName)
		    ENDIF
		
		    IF EMPTY(lnHPDF_Image)
		        EXIT
		    ENDIF
		    
		
		    HPDF_Page_GSave(lnHPDF_Page)
		    
		    LOCAL lnRad
		    lnRad = -loRepObj.Rotate * PI() / 180
		    
		    HPDF_Page_Concat(;
		        lnHPDF_Page, ;
		        lnDpiCoef * MAX(lnImgWidth,1) * COS(lnRad), ;
		        lnDpiCoef * MAX(lnImgWidth,1) * SIN(lnRad), ;
		        lnDpiCoef * MAX(lnImgHeight,1) * -SIN(lnRad), ;
		        lnDpiCoef * MAX(lnImgHeight,1) * COS(lnRad), ;
		        lnDpiCoef * (loRepObj.Left + SIN(lnRad) * lnImgHeight), ;
		        lnDpiCoef * (loRepObj.TopRev - COS(lnRad) * lnImgHeight))
		
		    HPDF_Page_ExecuteXObject(lnHPDF_Page, lnHPDF_Image)
		    
		    HPDF_Page_GRestore(lnHPDF_Page)
		    
		CATCH TO loErr
		    This.ErrMsg(loErr)
		FINALLY
		    IF FILE(lcTempFileName,1)
		        DELETE FILE (lcTempFileName)
		    ENDIF
		ENDTRY
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxrectangle
		LPARAMETERS loRepObj
		
		
		LOCAL lnHPDF_Page
		lnHPDF_Page = This.hpdf_pages[This.hpdf_pagecount]
		
		LOCAL lnDpiCoef
		lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		HPDF_Page_GSave(lnHPDF_Page)
		
		IF EMPTY(loRepObj.Rotate) = .F.
		    LOCAL lnRad
		    lnRad = -loRepObj.Rotate * PI() / 180
		
		    HPDF_Page_Concat(;
		        lnHPDF_Page, ;
		        COS(lnRad), ;
		        SIN(lnRad), ;
		        -SIN(lnRad), ;
		        COS(lnRad), ;
		        lnDpiCoef * loRepObj.Left, ;
		        lnDpiCoef * loRepObj.TopRev)
		ENDIF
		
		
		HPDF_Page_SetRGBFill(lnHPDF_Page, loRepObj.FillRed / 255, loRepObj.FillGreen / 255, loRepObj.FillBlue / 255)
		HPDF_Page_SetRGBStroke(lnHPDF_Page, loRepObj.PenRed / 255, loRepObj.PenGreen / 255, loRepObj.PenBlue / 255)
		
		IF loRepObj.PenSize >= 1
		    HPDF_Page_SetLineWidth(lnHPDF_Page, loRepObj.PenSize  * IIF(INLIST(loRepObj.PenPat,1,2,3,4), 0.5, 1))
		ELSE
		    HPDF_Page_SetLineWidth(lnHPDF_Page,  0)
		ENDIF
		
		
		*******************************************************
		LOCAL lcDash
		DO CASE
		CASE loRepObj.PenPat = 8 && Normal
		    HPDF_Page_SetDash(lnHPDF_Page, NULL, 0, 0)
		
		CASE loRepObj.PenPat = 1 && Dot
		    lcDash = BINTOC(1, "F")
		    HPDF_Page_SetDash(lnHPDF_Page, @lcDash, 1, 1)
		    
		CASE loRepObj.PenPat = 2 && Dash
		    lcDash = BINTOC(6, "F") + BINTOC(6, "F")
		    HPDF_Page_SetDash(lnHPDF_Page, @lcDash, 2, 2)
		    
		CASE loRepObj.PenPat = 3 && Dash-dot
		    lcDash = BINTOC(6, "F") + BINTOC(6, "F") + BINTOC(1, "F") + BINTOC(6, "F")
		    HPDF_Page_SetDash(lnHPDF_Page, @lcDash, 4, 0)
		    
		CASE loRepObj.PenPat = 4 && Dash-dot-dot
		    lcDash = BINTOC(6, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F")
		    HPDF_Page_SetDash(lnHPDF_Page, @lcDash, 6, 0)
		
		OTHERWISE && Normal
		    HPDF_Page_SetDash(lnHPDF_Page, NULL, 0, 0)
		
		ENDCASE
		*******************************************************
		
		
		DO CASE
		CASE loRepObj.OffSet = 0 && Normal rectangle
		    LOCAL lnLeft, lnTop
		    IF EMPTY(loRepObj.Rotate) = .F.
		        lnLeft = 0
		        lnTop = 0
		    ELSE
		        lnLeft = loRepObj.Left
		        lnTop = loRepObj.TopRev
		    ENDIF
		
		    HPDF_Page_Rectangle(lnHPDF_Page, ;
		        lnDpiCoef * (lnLeft), ;
		        lnDpiCoef * (lnTop - loRepObj.Height), ;
		        lnDpiCoef * (loRepObj.Width), ;
		        lnDpiCoef * (loRepObj.Height))
		    
		
		CASE BETWEEN(loRepObj.OffSet, 1, 98) AND loRepObj.OffSet <= MAX(loRepObj.Width, loRepObj.Height)/2  && Rounded rectangle
		    LOCAL lnRay
		    lnRay = ROUND(IIF(loRepObj.Width > loRepObj.Height, MIN(loRepObj.OffSet, INT(loRepObj.Height / 2)), MIN(loRepObj.OffSet, INT(loRepObj.Width / 2))), 0)
		    
		    LOCAL lnLeft, lnRight, lnTop, lnBottom
		
		    LOCAL lnLeft, lnTop
		    IF EMPTY(loRepObj.Rotate) = .F.
		        lnLeft = 0
		        lnRight = lnDpiCoef * loRepObj.Width
		        lnTop = 0
		        lnBottom = lnDpiCoef * -loRepObj.Height
		    ELSE
		        lnLeft = lnDpiCoef * (loRepObj.Left)
		        lnRight = lnDpiCoef * (loRepObj.Left + loRepObj.Width)
		        lnTop = lnDpiCoef * (loRepObj.TopRev)
		        lnBottom = lnDpiCoef * (loRepObj.TopRev - loRepObj.Height)
		    ENDIF
		
		    
		    HPDF_Page_MoveTo(lnHPDF_Page, lnLeft + lnRay, lnBottom)
		    HPDF_Page_LineTo(lnHPDF_Page, lnRight - lnRay, lnBottom)
		    HPDF_Page_CurveTo(lnHPDF_Page, lnRight, lnBottom, lnRight, lnBottom, lnRight, lnBottom + lnRay) 
		    HPDF_Page_LineTo(lnHPDF_Page, lnRight, lnTop - lnRay)
		    HPDF_Page_CurveTo(lnHPDF_Page, lnRight, lnTop, lnRight, lnTop, lnRight - lnRay, lnTop)
		    HPDF_Page_LineTo(lnHPDF_Page, lnLeft + lnRay, lnTop)
		    HPDF_Page_CurveTo(lnHPDF_Page, lnLeft, lnTop, lnLeft, lnTop, lnLeft, lnTop - lnRay)
		    HPDF_Page_LineTo(lnHPDF_Page, lnLeft , lnBottom + lnRay)
		    HPDF_Page_CurveTo(lnHPDF_Page, lnLeft, lnBottom, lnLeft, lnBottom, lnLeft + lnRay, lnBottom)
		
		OTHERWISE && Ellipsis
		    LOCAL lnLeft, lnTop
		    IF EMPTY(loRepObj.Rotate) = .F.
		        lnLeft = 0
		        lnTop = 0
		    ELSE
		        lnLeft = loRepObj.Left
		        lnTop = loRepObj.TopRev
		    ENDIF
		
		    HPDF_Page_Ellipse(lnHPDF_Page, ;
		        lnDpiCoef * (lnLeft + loRepObj.Width / 2), ;
		        lnDpiCoef * (lnTop - loRepObj.Height / 2), ;
		        lnDpiCoef * (loRepObj.Width / 2), ;
		        lnDpiCoef * (loRepObj.Height / 2))
		
		ENDCASE
		
		DO CASE
		CASE loRepObj.Mode = 0 AND loRepObj.FillPat > 0 AND loRepObj.PenPat = 0
		    HPDF_Page_Fill(lnHPDF_Page)
		CASE loRepObj.Mode = 0 AND loRepObj.FillPat > 0
		    HPDF_Page_FillStroke(lnHPDF_Page)
		
		OTHERWISE 
		    HPDF_Page_Stroke(lnHPDF_Page)
		
		ENDCASE
		
		HPDF_Page_GRestore(lnHPDF_Page)
		
	ENDPROC

	HIDDEN PROCEDURE render_text
		LPARAMETERS loRepObj
		
		#define HPDF_TALIGN_LEFT    0
		#define HPDF_TALIGN_RIGHT   1
		#define HPDF_TALIGN_CENTER  2
		#define HPDF_TALIGN_JUSTIFY 3
		
		#define HPDF_FILL 0
		#define HPDF_STROKE 1
		#define HPDF_FILL_THEN_STROKE 2
		
		#define FRX_OBJ_LABEL       5
		
		
		
		LOCAL lnHPDF_Page
		lnHPDF_Page = This.hpdf_pages[This.hpdf_pagecount]
		
		
		LOCAL lnDpiCoef
		lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		LOCAL loGDIFont
		loGDIFont = This.GetFontGDI(loRepObj)
		
		LOCAL loPDFFont
		loPDFFont = This.GetFontPDF(loRepObj)
		
		IF VARTYPE(loPDFFont) <> "O"
		    This.Render_TextAsImage(loRepObj)
		    RETURN
		ENDIF
		
		IF EMPTY(loRepObj.Rotate)=.F.
		    This.Render_TextAsImage(loRepObj)
		    RETURN
		ENDIF
		
		*******************************************************
		* Background mode 0 - Opaque, 1 - Transparent
		IF loRepObj.Mode = 0 
		    HPDF_Page_GSave(lnHPDF_Page)
		
		    IF loRepObj.FillAlpha <> 255
		        LOCAL lnExtGState
		        lnExtGState = HPDF_CreateExtGState(This.hpdf_doc)
		        IF lnExtGState <> 0
		            HPDF_ExtGState_SetAlphaFill(lnExtGState, loRepObj.FillAlpha / 255)
		            HPDF_Page_SetExtGState(lnHPDF_Page, lnExtGState)
		        ENDIF
		    ENDIF
		    
		    HPDF_Page_SetRGBFill(lnHPDF_Page, loRepObj.FillRed / 255, loRepObj.FillGreen / 255, loRepObj.FillBlue / 255)
		
		    HPDF_Page_Rectangle(lnHPDF_Page, ;
		        lnDpiCoef * loRepObj.Left, ;
		        lnDpiCoef * (loRepObj.TopRev - loRepObj.Height), ;
		        lnDpiCoef * loRepObj.Width, ;
		        lnDpiCoef * loRepObj.Height)
		        
		    HPDF_Page_Fill(lnHPDF_Page)
		
		    HPDF_Page_GRestore(lnHPDF_Page)
		ENDIF
		*******************************************************
		
		
		HPDF_Page_GSave(lnHPDF_Page)
		
		IF loRepObj.PenAlpha <> 255
		    LOCAL lnExtGState
		    lnExtGState = HPDF_CreateExtGState(This.hpdf_doc)
		    IF lnExtGState <> 0
		        HPDF_ExtGState_SetAlphaFill(lnExtGState, loRepObj.PenAlpha / 255)
		        HPDF_ExtGState_SetAlphaStroke(lnExtGState, loRepObj.PenAlpha / 255)
		        HPDF_Page_SetExtGState(lnHPDF_Page, lnExtGState)
		    ENDIF
		ENDIF
		
		
		HPDF_Page_SetFontAndSize(lnHPDF_Page, loPDFFont.FontHandle, loRepObj.FontSize)
		HPDF_Page_SetRGBFill(lnHPDF_Page, loRepObj.PenRed / 255, loRepObj.PenGreen / 255, loRepObj.PenBlue / 255)
		HPDF_Page_SetRGBStroke(lnHPDF_Page, loRepObj.PenRed / 255, loRepObj.PenGreen / 255, loRepObj.PenBlue / 255)
		HPDF_Page_SetLineWidth(lnHPDF_Page, 0.5)
		HPDF_Page_SetDash(lnHPDF_Page, NULL, 0, 0)
		
		
		IF loRepObj.ObjType = FRX_OBJ_LABEL
		    loRepObj.Width = loRepObj.Width + loGDIFont.HeightCeil
		ENDIF
		
		*******************************************************
		LOCAL loLineRect
		loLineRect = This.env.system.Drawing.RectangleF.New(0, 0, loRepObj.Width, loGDIFont.HeightCeil)
		
		LOCAL lnLineHeight
		lnLineHeight = loGDIFont.Height
		
		LOCAL lnFontDescent
		lnFontDescent = lnLineHeight * loGDIFont.CellDescent / loGDIFont.EmHeight
		
		LOCAL lnFontAscent
		lnFontAscent = lnLineHeight * loGDIFont.CellAscent / loGDIFont.EmHeight
		
		LOCAL lnAlign
		lnAlign = ICASE(loRepObj.Offset = 0, HPDF_TALIGN_LEFT, loRepObj.Offset = 1, HPDF_TALIGN_RIGHT, loRepObj.Offset = 2, HPDF_TALIGN_CENTER, HPDF_TALIGN_LEFT)
		
		LOCAL lnPadX, lnPadY
		lnPadX = ICASE(lnAlign = HPDF_TALIGN_RIGHT, -1, lnAlign = HPDF_TALIGN_LEFT, 1, 0) * 2
		lnPadY = 2
		
		*******************************************************
		
		
		LOCAL lnLine, lnCharIndex, lnLineCharsFitted, lcLineText, lcLineTextUTF
		lnLine = 0
		lnCharIndex = 1
		DO WHILE .T.
		
		    lnLine = lnLine + 1
		    
		    IF lnLine * lnLineHeight > loRepObj.Height
		        EXIT
		    ENDIF
		
		    
		    lcLineText = SUBSTR(loRepObj.Text, lnCharIndex * 2 - 1)
		
		    lnLineCharsFitted = 0
		
		    LOCAL loLineTextRect
		    This.MeasureString(lcLineText, loGDIFont, loLineRect, @loLineTextRect, @lnLineCharsFitted)
		    
		    lcLineText = SUBSTR(lcLineText, 1, lnLineCharsFitted * 2)
		    lcLineTextUTF = STRCONV(lcLineText, 10)
		    
		    lnCharIndex = lnCharIndex + lnLineCharsFitted
		    
		    
		    HPDF_Page_BeginText(lnHPDF_Page)
		
		        HPDF_Page_SetTextRenderingMode(lnHPDF_Page, HPDF_FILL)
		        HPDF_Page_SetTextMatrix(lnHPDF_Page, 1, 0, 0, 1, 0, 0)
		
		
		        IF loRepObj.FontBold AND loPDFFont.FontBold = .F.
		            HPDF_Page_SetTextRenderingMode(lnHPDF_Page, HPDF_FILL_THEN_STROKE) && Bold imitation
		        ENDIF
		
		        LOCAL llFakeItalic
		        llFakeItalic = loRepObj.FontItalic AND loPDFFont.FontItalic = .F.
		        IF llFakeItalic
		            HPDF_Page_SetTextMatrix(lnHPDF_Page, 1, 0, 0.3333, 1, 0, 0) && Italic imitation
		        ENDIF
		
		        HPDF_Page_SetTextLeading(lnHPDF_Page, 0) && reset line spacing
		        
		        HPDF_Page_TextRect(lnHPDF_Page, ;
		            lnDpiCoef * (loRepObj.Left + lnPadX) + IIF(llFakeItalic, loRepObj.FontSize * 0.5, 0), ;
		            lnDpiCoef * (loRepObj.TopRev - (lnLine-1) * lnLineHeight + lnFontDescent - lnPadY), ;
		            lnDpiCoef * (loRepObj.Left + loRepObj.Width + lnPadX) + IIF(llFakeItalic, loRepObj.FontSize * 0.5, 0), ;
		            lnDpiCoef * (loRepObj.TopRev - lnLine * lnLineHeight - lnPadY), ;
		            lcLineTextUTF + CHR(0), ;
		            lnAlign, ;
		            0)
		    
		    HPDF_Page_EndText(lnHPDF_Page)
		
		    
		    LOCAL lnStrokeLeft
		    lnStrokeLeft = ICASE(lnAlign=HPDF_TALIGN_RIGHT, loRepObj.Width - loLineTextRect.Width, lnAlign=HPDF_TALIGN_CENTER, 0.5 * (loRepObj.Width - loLineTextRect.Width), 0)
		    
		    IF loRepObj.FontUnderline
		        HPDF_Page_MoveTo(lnHPDF_Page, ;
		            lnDpiCoef * (loRepObj.Left + lnStrokeLeft + lnPadX), ;
		            lnDpiCoef * (loRepObj.TopRev - lnLine * lnLineHeight + lnFontDescent - lnPadY))
		        
		        HPDF_Page_LineTo(lnHPDF_Page, ;
		            lnDpiCoef * (loRepObj.Left + lnStrokeLeft + loLineTextRect.Width + lnPadX), ;
		            lnDpiCoef * (loRepObj.TopRev - lnLine * lnLineHeight + lnFontDescent - lnPadY))
		        
		        HPDF_Page_Stroke(lnHPDF_Page)
		    ENDIF
		
		    IF loRepObj.FontStrikeout
		        HPDF_Page_MoveTo(lnHPDF_Page, ;
		            lnDpiCoef * (loRepObj.Left + lnStrokeLeft + lnPadX), ;
		            lnDpiCoef * (loRepObj.TopRev - lnLine * lnLineHeight + (lnFontDescent + lnFontAscent) * 0.5 -  lnPadY))
		        
		        HPDF_Page_LineTo(lnHPDF_Page, ;
		            lnDpiCoef * (loRepObj.Left + lnStrokeLeft + loLineTextRect.Width + lnPadX), ;
		            lnDpiCoef * (loRepObj.TopRev - lnLine * lnLineHeight + (lnFontDescent + lnFontAscent) * 0.5 -  lnPadY))
		        
		        HPDF_Page_Stroke(lnHPDF_Page)
		    ENDIF
		    
		ENDDO
		
		HPDF_Page_GRestore(lnHPDF_Page)
		
	ENDPROC

	HIDDEN PROCEDURE render_textasimage		&& Fallback rendering text as images (case of symbolic and non ttf fonts)
		LPARAMETERS loRepObj
		
		#define FRX_OBJ_LABEL       5
		
		LOCAL lnHPDF_Page
		lnHPDF_Page = This.hpdf_pages[This.hpdf_pagecount]
		
		LOCAL lnDpiCoef
		lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL loGDIFont
		loGDIFont = This.GetFontGDI(loRepObj)
		
		
		
		LOCAL lcTempFileName
		lcTempFileName = This.env.GetUniqueTempFileName("png")
		
		LOCAL loErr
		loErr = .F.
		TRY
		    IF loRepObj.ObjType = FRX_OBJ_LABEL
		        loRepObj.Width = loRepObj.Width + loGDIFont.HeightCeil
		    ENDIF
		
		    LOCAL loImage, loGfx, loColor, loBrush
		    loImage = This.env.System.Drawing.Bitmap.New(loRepObj.Width, loRepObj.Height, This.env.System.Drawing.Imaging.PixelFormat.Format32bppARGB)
		    loGfx = This.env.System.Drawing.Graphics.New()
		    loGfx = loGfx.FromImage(loImage)
		    loGfx.CompositingMode = 0
		    loGfx.CompositingQuality = 2
		    loGfx.PixelOffsetMode = 2
		    loGfx.TextRenderingHint = 4
		    loGfx.TextContrast = 0    
		    
		    
		    *******************************************************
		    * Background mode 0 - Opaque, 1 - Transparent
		    IF loRepObj.Mode = 0
		        loColor = This.env.System.Drawing.Color.FromARGB(loRepObj.FillAlpha, loRepObj.FillRed, loRepObj.FillGreen, loRepObj.FillBlue)
		        loBrush = This.env.System.Drawing.SolidBrush.New(loColor)
		        loGfx.FillRectangle(loBrush, 0, 0, loRepObj.Width, loRepObj.Height)
		    ENDIF
		    *******************************************************
		    
		    loColor = This.env.System.Drawing.Color.FromARGB(loRepObj.PenAlpha, loRepObj.PenRed, loRepObj.PenGreen, loRepObj.PenBlue)
		    loBrush = This.env.System.Drawing.SolidBrush.New(loColor)
		
		    LOCAL lqLayoutRect
		    lqLayoutRect = BINTOC(0,"F")+BINTOC(0,"F")+BINTOC(0,"F")+BINTOC(0,"F")
		    
		    * Plain Api call because GDIPluxX Graphics.DrawString performs STRCONV(...,5) on input text while loRepObj.Text is in Unicode
		    WinApi_GdipDrawString(;
		        loGfx.Handle, ;
		        loRepObj.Text + CHR(0), ;
		        LEN(loRepObj.Text) / 2, ;
		        loGDIFont.GDIFont.Handle, ;
		        @lqLayoutRect, ;
		        This.env.System.Drawing.StringFormat.GenericDefault.Handle, ;
		        loBrush.Handle)
		    
		
		    loImage.Save(lcTempFileName, This.env.System.Drawing.Imaging.ImageFormat.Png)
		    loImage = .F.
		
		    LOCAL lnHPDF_Image
		    lnHPDF_Image = 0
		
		    IF FILE(lcTempFileName, 1)
		        lnHPDF_Image = HPDF_LoadPngImageFromFile(This.hpdf_doc, lcTempFileName)
		    ENDIF
		
		    IF EMPTY(lnHPDF_Image)
		        EXIT
		    ENDIF
		
		
		    HPDF_Page_GSave(lnHPDF_Page)
		    
		    LOCAL lnRad
		    lnRad = -loRepObj.Rotate * PI() / 180
		    
		    HPDF_Page_Concat(;
		        lnHPDF_Page, ;
		        lnDpiCoef * MAX(loRepObj.Width,1) * COS(lnRad), ;
		        lnDpiCoef * MAX(loRepObj.Width,1) * SIN(lnRad), ;
		        lnDpiCoef * MAX(loRepObj.Height,1) * -SIN(lnRad), ;
		        lnDpiCoef * MAX(loRepObj.Height,1) * COS(lnRad), ;
		        lnDpiCoef * (loRepObj.Left + SIN(lnRad) * loRepObj.Height), ;
		        lnDpiCoef * (loRepObj.TopRev - COS(lnRad) * loRepObj.Height))
		
		    HPDF_Page_ExecuteXObject(lnHPDF_Page, lnHPDF_Image)
		    
		    HPDF_Page_GRestore(lnHPDF_Page)
		    
		CATCH TO loErr
		    This.ErrMsg(loErr)
		FINALLY
		    IF FILE(lcTempFileName,1)
		        DELETE FILE (lcTempFileName)
		    ENDIF
		ENDTRY
		
		
	ENDPROC

	PROCEDURE UnloadReport
		This.env.declaredll()
		
		IF This.BatchModeAuto = .F. AND This.BatchMode = .F.
		    This.Finalize()
		ENDIF
		
		IF VARTYPE(_PdfiumReport) = "O" AND _PdfiumReport = This
		    IF This.BatchModeAuto = .F.
		        _PdfiumReport = .F.
		    ENDIF
		ENDIF
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreportviewer AS form 		&& Report preview for PdfiumReport. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="PdfiumViewer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSaveAs" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFitWidth" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFitPage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="PrintEnv" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmbScale" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPageInfo" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: close		&& Close preview window
		*m: openpdf		&& Open pdf file
		*m: printreport		&& Print report
		*m: scalechanged		&& Scale change handling
		*m: setreport		&& ReportPreviewer interface requirement (reead docs on ReportPreviewer, ReportListener)
		*p: listenerref
		*p: saveas_filename		&& Filename suggestion for "save as" dialog
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN listenerref
	*<PropValue>
		Caption = "Pdfium report preview"
		Desktop = .F.
		DoCreate = .T.
		Height = 741
		Icon = ("images\wwrite.ico")
		KeyPreview = .T.
		Left = 0
		listenerref = .F.
		MaxButton = .T.
		MinButton = .F.
		Name = "pdfiumreportviewer"
		saveas_filename = ("")
		ScrollBars = 0
		ShowWindow = 1
		Top = 0
		Visible = .T.
		Width = 747
		WindowState = 0
		WindowType = 1
		_memberdata = <VFPData>
			<memberdata name="openpdf" type="method" display="OpenPDF"/>
			<memberdata name="setreport" type="method" display="SetReport"/>
			<memberdata name="listenerref" type="property" display="ListenerRef"/>
			<memberdata name="printreport" type="method" display="PrintReport"/>
			<memberdata name="close" type="method" display="Close"/>
			<memberdata name="scalechanged" type="method" display="ScaleChanged"/>
			<memberdata name="saveas_filename" type="property" display="SaveAs_Filename"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cmbScale' AS combobox WITH ;
		BoundColumn = 1, ;
		BoundTo = .F., ;
		ColumnCount = 1, ;
		ColumnLines = .F., ;
		ColumnWidths = "80,0", ;
		ControlSource = "", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 27, ;
		Left = 534, ;
		Name = "cmbScale", ;
		Style = 2, ;
		TabIndex = 8, ;
		TabStop = .F., ;
		Top = 11, ;
		Width = 65
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdClose' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 685, ;
		Name = "cmdClose", ;
		Picture = ("images\close.bmp"), ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 9, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFitPage' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 483, ;
		Name = "cmdFitPage", ;
		Picture = ("images\fitpage.bmp"), ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 7, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFitWidth' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 437, ;
		Name = "cmdFitWidth", ;
		Picture = ("images\fitwidth.bmp"), ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 6, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrint' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "  Print", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 237, ;
		Name = "cmdPrint", ;
		Picture = ("images\print.bmp"), ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 4, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 135
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSaveAs' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 384, ;
		Name = "cmdSaveAs", ;
		Picture = ("images\saveas.bmp"), ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 5, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSearch' AS commandbutton WITH ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 189, ;
		Name = "cmdSearch", ;
		Picture = ("images\search.bmp"), ;
		PictureMargin = 0, ;
		PicturePosition = 14, ;
		PictureSpacing = 0, ;
		TabIndex = 3, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 192, ;
		Name = "i18n", ;
		Top = 72
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'lblPageInfo' AS label WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "1234 / 1234", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 603, ;
		Name = "lblPageInfo", ;
		Top = 15, ;
		Width = 76
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'PdfiumViewer' AS pdfiumviewer WITH ;
		Anchor = 15, ;
		Enabled = .T., ;
		Height = 681, ;
		Left = 12, ;
		Name = "PdfiumViewer", ;
		scrollbars = 3, ;
		TabIndex = 1, ;
		TabStop = .T., ;
		Top = 48, ;
		Visible = .T., ;
		Width = 723, ;
		cmdFocus.Name = "cmdFocus", ;
		env.Name = "env", ;
		i18n.Name = "i18n", ;
		UIState.Name = "UIState"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="control" />

	ADD OBJECT 'PrintEnv' AS pdfium_print_env WITH ;
		Left = 228, ;
		Name = "PrintEnv", ;
		Top = 72
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'txtSearch' AS pdfium_textbox WITH ;
		Anchor = 0, ;
		InputMask = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", ;
		Left = 12, ;
		Name = "txtSearch", ;
		TabIndex = 2, ;
		TabStop = .F., ;
		Top = 11
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />
	
	PROCEDURE close		&& Close preview window
		IF VARTYPE(This.ListenerRef)="O"
		    This.ListenerRef.OnPreviewClose()
		    This.ListenerRef = .F.
		ENDIF
		
		This.Hide()
		
	ENDPROC

	PROCEDURE Destroy
		This.Pdfiumviewer.Destroy()
		
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.Pdfiumviewer.Init(m.toEnv)
		
		BINDEVENT(This.PdfiumViewer, "scale", This, "scalechanged", 1)
		
		
		This.Caption = This.i18n.text("REPORTVIEWER_TITLE")
		
		This.MinWidth = This.Width
		This.MinHeight = 300
		
		
		LOCAL loTopLevelForm
		IF TYPE("Application.ActiveForm") = "O"
		    loTopLevelForm = Application.ActiveForm
		ELSE
		    loTopLevelForm = _SCREEN    
		ENDIF
		
		IF loTopLevelForm.ShowWindow <> 2
		    loTopLevelForm = _SCREEN
		ENDIF
		
		
		IF loTopLevelForm = _SCREEN
		    LOCAL lnTop, lnBottom
		    lnTop = 0
		    lnBottom = loTopLevelForm.Height
		
		
		    LOCAL i, loForm
		    FOR i = 1 TO loTopLevelForm.FormCount
		        loForm = loTopLevelForm.Forms[i]
		        
		        IF loForm = Thisform
		            LOOP
		        ENDIF
		
		        IF loForm.DockPosition = 0
		            lnTop = MAX(lnTop, loForm.Top + loForm.Height)
		        ENDIF
		
		        IF loForm.DockPosition = 3
		            lnBottom = MIN(lnBottom, loForm.Height - laDockState[i,6].Top)
		        ENDIF
		        
		    ENDFOR
		
		    This.Width = MAX(MIN(loTopLevelForm.Height, loTopLevelForm.Width) - SYSMETRIC(3) , This.MinWidth) 
		    This.Height = MAX(MAX(lnBottom - lnTop, This.Height) - SYSMETRIC(4), This.MinHeight)
		
		ENDIF
		
		This.WindowState = 2
		This.TitleBar = 0
		This.BorderStyle = 0
		
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		DO CASE
		CASE m.nKeyCode = 6 AND m.nShiftAltCtrl = 2 && Ctrl + F
		    NODEFAULT
		    This.txtSearch.SetFocus()
		
		CASE m.nKeyCode = -2 AND m.nShiftAltCtrl = 0 && F3
		    NODEFAULT
		    Thisform.cmdSearch.Click()
		
		ENDCASE
		
	ENDPROC

	PROCEDURE openpdf		&& Open pdf file
		LPARAMETERS tcFilename
		
		RETURN This.pdfiumviewer.OpenPDF(m.tcFilename)
		
	ENDPROC

	PROCEDURE printreport		&& Print report
		This.PdfiumViewer.PrintDocument()
		
	ENDPROC

	PROCEDURE QueryUnload
		
		This.Close()
		
		
	ENDPROC

	PROCEDURE Resize
		IF This.ScrollBars > 0 AND Thisform.WindowState = 2
		    This.Cls()
		ENDIF
		This.Refresh()
		
	ENDPROC

	PROCEDURE scalechanged		&& Scale change handling
		LOCAL lnScale, lcScale
		lnScale = This.PdfiumViewer.Scale
		lcScale = TRANSFORM(INT(lnScale*100)) + "%"
		
		IF INLIST(lnScale,1,2,3,4)=.F.
		    This.cmbScale.List[1] = lcScale
		ELSE
		    This.cmbScale.List[1] = ""
		ENDIF
		
		This.cmbScale.Value = lcScale
		
	ENDPROC

	PROCEDURE setreport		&& ReportPreviewer interface requirement (reead docs on ReportPreviewer, ReportListener)
		LPARAMETERS toListenerRef 
		
		This.ListenerRef = m.toListenerRef 
		
	ENDPROC

	PROCEDURE cmbScale.Init
		This.AddItem("")
		This.AddItem("100%")
		This.AddItem("200%")
		This.AddItem("300%")
		This.AddItem("400%")
		
	ENDPROC

	PROCEDURE cmbScale.InteractiveChange
		Thisform.pdfiumviewer.Scale = MIN(MAX(INT(VAL(EVL(This.Value,"100")))/100,0.25),4)
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdClose.Click
		Thisform.Close()
		
		
	ENDPROC

	PROCEDURE cmdFitPage.Click
		Thisform.pdfiumviewer.FitWidth = .F.
		Thisform.pdfiumviewer.Scale = 1
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdFitPage.Refresh
		IF Thisform.pdfiumviewer.FitWidth = .T. and This.Enabled = .F.
		    This.Enabled = .T.
		ENDIF
		
		IF Thisform.pdfiumviewer.FitWidth = .F. and This.Enabled = .T.
		    This.Enabled = .F.
		ENDIF
		
		
	ENDPROC

	PROCEDURE cmdFitWidth.Click
		Thisform.pdfiumviewer.FitWidth = .T.
		Thisform.pdfiumviewer.Scale = 1
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdFitWidth.Refresh
		IF Thisform.pdfiumviewer.FitWidth = .T. and This.Enabled = .T.
		    This.Enabled = .F.
		ENDIF
		
		IF Thisform.pdfiumviewer.FitWidth = .F. and This.Enabled = .F.
		    This.Enabled = .T.
		ENDIF
		
		
	ENDPROC

	PROCEDURE cmdPrint.Click
		Thisform.PrintReport()
		
	ENDPROC

	PROCEDURE cmdPrint.Refresh
		This.Caption = SPACE(2) + Thisform.i18n.text("BTN_PRINT")
		
	ENDPROC

	PROCEDURE cmdSaveAs.Click
		LOCAL lcFilename
		lcFilename = PUTFILE("", Thisform.SaveAs_Filename, "pdf")
		
		IF EMPTY(lcFilename)
		    RETURN
		ENDIF
		
		Thisform.pdfiumviewer.SaveDocument(lcFileName)
		
	ENDPROC

	PROCEDURE cmdSearch.Click
		CLEAR TYPEAHEAD 
		
		IF EMPTY(Thisform.txtSearch.Value)
		    Thisform.pdfiumviewer.SearchClose()
		ELSE
		    LOCAL lnRes
		    lnRes = Thisform.Pdfiumviewer.SearchText(Thisform.txtSearch.Value)
		    DO CASE
		    CASE lnRes = 0
		        WAIT WINDOW Thisform.i18n.text("SEARCH_NOT_FOUND") NOWAIT
		    CASE lnRes = 2
		        WAIT WINDOW Thisform.i18n.text("SEARCH_ENDED") NOWAIT
		    ENDCASE
		    
		ENDIF
		
	ENDPROC

	PROCEDURE lblPageInfo.Refresh
		This.Caption = TRANSFORM(Thisform.PdfiumViewer.GetCurrentPage()) + " / " + TRANSFORM(Thisform.PdfiumViewer.GetPageCount())
		
	ENDPROC

	PROCEDURE PdfiumViewer.afterviewportupdate
		Thisform.lblPageInfo.Refresh()
		
	ENDPROC

	PROCEDURE txtSearch.GotFocus
		Thisform.pdfiumviewer.SearchClose()
		
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE txtSearch.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 13 AND EMPTY(m.nShiftAltCtrl) AND EMPTY(This.Value)=.F.
		    NODEFAULT
		    Thisform.cmdSearch.Click()
		ENDIF    
		
		DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumviewer AS control 		&& PDF viewer control.
 	*< CLASSDATA: Baseclass="control" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdFocus" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="env" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="UIState" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: afterviewportupdate		&& Event. Triggered after ViewPortUpdate call
		*m: backcolor_assign
		*m: closepdf		&& Close pdf file, previously opened by PdfiumViewer.openpdf
		*m: contextmenu
		*m: drawbufcreate
		*m: drawbufrelease
		*m: errmsg
		*m: fitwidth_assign
		*m: getcurrentpage		&& Current page number. First page has number = 1
		*m: getpagecount		&& Returns page count
		*m: getpagesize		&& Returns page dimensions (see comment in source code)
		*m: keypress		&& Occurs when the user presses and releases a key.
		*m: openpdf		&& Open pdf file. Returns: .T. on success, .F. if file was not loaded
		*m: pagepick
		*m: printdocument		&& Send document to printer with preceding setup dialog
		*m: redraw
		*m: renderpagefromcache
		*m: renderpages
		*m: rendersearch
		*m: renderselection
		*m: savedocument		&& Save document to file
		*m: scale_assign
		*m: scrollbars_assign
		*m: scrollhorz
		*m: scrollvert
		*m: searchclose		&& Stop search
		*m: searchtext		&& Text for searching. SearchClose must be called to stop search results rendering
		*m: selectioncopy		&& Copy selected text to clipboard
		*m: selecttext
		*m: selecttextall		&& Select all text in the document
		*m: viewportupdate
		*m: wndcreate
		*m: wndproc		&& Events handler of PdfiumViewer internal window. Developer must not use or redefine this method
		*m: wndredraw
		*m: wndrelease
		*m: wndresize
		*m: wndshow		&& Show child window (for internal use, public for bindevent)
		*p: backcolorbrush
		*p: dblclickbegin
		*p: drawbufdc
		*p: drawbufdib
		*p: drawbufgfx
		*p: fitwidth
		*p: fpdf_doc
		*p: fpdf_opened
		*p: fpdf_pagecount
		*p: fpdf_page_first_visible		&& Index of the page that appears first after rendering
		*p: fpdf_page_last_visible
		*p: isfocused		&& .T. if control has input focus
		*p: printenv
		*p: scale
		*p: scrollbars		&& Specifies the type of scroll bars that an EditBox control, Form object, or Grid control has. 0 - None (Default); 1 - Horizontal; 2 - Vertical; 3 - Both vertical and horizontal
		*p: searchbrush
		*p: searchstate_dir
		*p: searchstate_findwhat
		*p: searchstate_flags
		*p: searchstate_rescount
		*p: searchstate_resindex
		*p: searchstate_respage
		*p: searchstate_resrect
		*p: selectionbrush
		*p: selectioncharindexprev
		*p: selectioncharindexstart
		*p: tplclickbegin
		*p: viewportmaxx
		*p: viewportmaxy
		*p: viewportsizex
		*p: viewportsizey
		*p: viewportx
		*p: viewporty
		*p: wndclassname
		*p: wnddc
		*p: wndhandle		&& Specifies the Window handle of the Window.
		*a: fpdf_pages[1,0]
		*a: fpdf_pages_pos[1,4]
		*a: fpdf_pages_render_cache[1,4]
		*a: fpdf_pages_search[1,0]
		*a: fpdf_pages_selection[1,3]
		*a: fpdf_pages_size[1,4]
		*a: fpdf_text_pages[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN ActiveControl,AddProperty,backcolorbrush,BackStyle,BorderColor,BorderWidth,ClassLibrary,Click,CloneObject,ColorSource,ControlCount,Controls,dblclickbegin,DblClick,DragDrop,DragIcon,DragMode,DragOver,Drag,drawbufdc,drawbufdib,drawbufgfx,Draw,Error,ForeColor,fpdf_doc,fpdf_opened,fpdf_pagecount,fpdf_pages,fpdf_pages_pos,fpdf_pages_render_cache,fpdf_pages_search,fpdf_pages_selection,fpdf_pages_size,fpdf_page_first_visible,fpdf_page_last_visible,fpdf_text_pages,GotFocus,HelpContextID,isfocused,LostFocus,MiddleClick,MouseDown,MouseEnter,MouseIcon,MouseLeave,MouseMove,MousePointer,MouseUp,MouseWheel,Moved,Objects,OLECompleteDrag,OLEDragDrop,OLEDragMode,OLEDragOver,OLEDragPicture,OLEDrag,OLEDropEffects,OLEDropHasData,OLEDropMode,OLEGiveFeedback,OLESetData,OLEStartDrag,ParentClass,Picture,printenv,ReadExpression,ReadMethod,Refresh,ResetToDefault,Resize,RightClick,SaveAsClass,searchbrush,searchstate_dir,searchstate_findwhat,searchstate_flags,searchstate_rescount,searchstate_resindex,searchstate_respage,searchstate_resrect,selectionbrush,selectioncharindexprev,selectioncharindexstart,ShowWhatsThis,SpecialEffect,Style,Tag,tplclickbegin,UIEnable,viewportmaxx,viewportmaxy,viewportsizex,viewportsizey,viewportx,viewporty,WhatsThisHelpID,wndclassname,wnddc,wndhandle,WriteExpression,WriteMethod,ZOrder
	*<PropValue>
		backcolorbrush = .F.
		BackStyle = 1
		dblclickbegin = 0
		drawbufdc = 0
		drawbufdib = 0
		drawbufgfx = 0
		fitwidth = .F.
		fpdf_doc = 0
		fpdf_opened = .F.
		fpdf_pagecount = 0
		fpdf_page_first_visible = 0
		fpdf_page_last_visible = 0
		Height = 622
		isfocused = .F.
		Name = "pdfiumviewer"
		printenv = .F.
		scale = 1
		scrollbars = 0
		searchbrush = .F.
		searchstate_dir = 0
		searchstate_findwhat = ("")
		searchstate_flags = 0
		searchstate_rescount = 0
		searchstate_resindex = 0
		searchstate_respage = 0
		searchstate_resrect = ("")
		selectionbrush = .F.
		selectioncharindexprev = -1
		selectioncharindexstart = 0
		tplclickbegin = 0
		viewportmaxx = 0
		viewportmaxy = 0
		viewportsizex = 0
		viewportsizey = 0
		viewportx = 0
		viewporty = 0
		Visible = .T.
		Width = 445
		wndclassname = ("PDFIUM-VFP-VIEWER")
		wnddc = 0
		wndhandle = 0
		_memberdata = <VFPData>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cmdFocus' AS pdfiumviewer_cmdfocus WITH ;
		Left = -100, ;
		Name = "cmdFocus", ;
		Top = -100
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'env' AS pdfium_env WITH ;
		Left = 69, ;
		libhpdf_dll_path = (""), ;
		Name = "env", ;
		Top = 24
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 108, ;
		Name = "i18n", ;
		Top = 24
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'UIState' AS pdfium_uistate WITH ;
		Left = 24, ;
		Name = "UIState", ;
		Top = 24
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE afterviewportupdate		&& Event. Triggered after ViewPortUpdate call
	ENDPROC

	HIDDEN PROCEDURE backcolor_assign
		LPARAMETERS vNewVal
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.BackColor = m.vNewVal
		
		LOCAL loBackColor
		loBackColor = This.env.System.Drawing.Color.FromRgb(This.BackColor)
		This.BackColorBrush.Color = loBackColor
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE closepdf		&& Close pdf file, previously opened by PdfiumViewer.openpdf
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.fpdf_opened = .F.
		
		This.SearchClose()
		
		LOCAL lnPage, lnPageCount
		lnPageCount = This.fpdf_pagecount
		
		This.fpdf_pagecount = 0
		
		This.fpdf_page_first_visible = 0
		This.fpdf_page_last_visible = 0
		
		This.ViewPortX = 0
		This.ViewPortY = 0
		This.ViewPortSizeX = 0
		This.ViewPortSizeY = 0
		This.ViewPortMaxX = 0
		This.ViewPortMaxY = 0
		
		This.scale = 1
		
		LOCAL lnPage
		FOR lnPage = 1 TO lnPageCount
		    FPDFText_ClosePage(This.fpdf_text_pages[lnPage])
		    FPDF_ClosePage(This.fpdf_pages[lnPage])
		    
		    This.fpdf_pages[lnPage] = 0
		    This.fpdf_text_pages[lnPage] = 0
		    This.fpdf_pages_selection[lnPage,1] = ""
		    This.fpdf_pages_selection[lnPage,2] = 0
		    This.fpdf_pages_selection[lnPage,3] = 0
		    
		    LOCAL j
		    FOR j = 1 TO ALEN(This.fpdf_pages_render_cache,2)
		        This.fpdf_pages_render_cache[lnPage,j] = .F.
		    ENDFOR
		ENDFOR
		
		DIMENSION This.fpdf_pages(1)
		DIMENSION This.fpdf_text_pages(1)
		DIMENSION This.fpdf_pages_selection(1,3)
		DIMENSION This.fpdf_pages_pos(1,4)
		DIMENSION This.fpdf_pages_size(1,2)
		DIMENSION This.fpdf_pages_search(1)
		DIMENSION This.fpdf_pages_render_cache(1, ALEN(This.fpdf_pages_render_cache,2))
		
		STORE 0 TO This.fpdf_pages_pos, This.fpdf_pages_size, This.fpdf_pages_search
		
		IF EMPTY(This.fpdf_doc)=.F.
		    FPDF_CloseDocument(This.fpdf_doc)
		    This.fpdf_doc = 0
		ENDIF
		
		This.ViewPortUpdate()
		This.wndredraw()
		
	ENDPROC

	HIDDEN PROCEDURE contextmenu
		
		LOCAL lcMenuName
		lcMenuName = "_context_menu"
		
		DEFINE POPUP (lcMenuName) FROM MROW(), MCOL() MARGIN RELATIVE SHORTCUT FONT 'Segoe UI', 10
		
		LOCAL lcSelectCopy, lcSelectAll
		lcSelectCopy = "SKIP FOR .T."
		lcSelectAll = ""
		
		IF This.fpdf_opened = .T.
		    LOCAL lnPage
		    FOR lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		        IF This.fpdf_pages_selection[lnPage,3] > 0
		            lcSelectCopy = ""
		            EXIT
		        ENDIF
		    ENDFOR
		ELSE
		    lcSelectAll = "SKIP FOR .T."
		ENDIF
		
		
		LOCAL i
		i=0
		
		i=i+1
		DEFINE BAR (i) OF (lcMenuName) PROMPT (This.i18n.text("MNU_COPY")) PICTRES _MED_COPY &lcSelectCopy
		ON SELECTION BAR (i) OF (lcMenuName) poThis.SelectionCopy()
		
		i=i+1
		DEFINE BAR (i) OF (lcMenuName) PROMPT (This.i18n.text("MNU_SLCTA")) &lcSelectAll
		ON SELECTION BAR (i) OF (lcMenuName) poThis.SelectTextAll()
		
		
		PRIVATE poThis
		poThis = This
		IF CNTBAR(lcMenuName)<>0
		    ACTIVATE POPUP &lcMenuName
		ENDIF
		poThis = .F.
		
		
	ENDPROC

	PROCEDURE Destroy
		
		This.PrintEnv = .F.
		
		This.ClosePdf()
		
		This.DrawBufRelease()
		
		This.WndRelease()
		
		
	ENDPROC

	HIDDEN PROCEDURE drawbufcreate
		
		#DEFINE FF_RGBQUAD_SIZE     4
		#DEFINE FF_DIB_RGB_COLORS   0
		#DEFINE FF_BFHDR_SIZE      14
		#DEFINE FF_BHDR_SIZE       40
		#DEFINE FF_BI_RGB           0
		
		IF EMPTY(This.WndDC)
		    RETURN
		ENDIF
		
		IF VARTYPE(This.env.System)<>"O"
		    RETURN
		ENDIF
		
		
		This.DrawBufRelease()
		
		
		***********************************************************************************
		IF EMPTY(This.DrawBufDC)
		    This.DrawBufDC = WinApi_CreateCompatibleDC(This.WndDC)
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		LOCAL lnWidth, lnHeight, lnBitsPerPixel
		lnWidth = This.Width
		lnHeight = This.Height
		lnBitsPerPixel = 16
		
		LOCAL lcBMI
		lcBMI = BINTOC(FF_BHDR_SIZE ,"4RS") + BINTOC(lnWidth,"4RS") + BINTOC(lnHeight, "4RS") + ;
		        (CHR(MOD(1,256)) + CHR(INT(1/256))) + (CHR(MOD(lnBitsPerPixel,256))+ CHR(INT(lnBitsPerPixel/256))) +;
		        BINTOC(FF_BI_RGB, "4RS") + REPLICATE(0h00, 20)
		
		
		LOCAL lnDibDataPtr
		lnDibDataPtr = 0
		
		This.DrawBufDIB = WinApi_CreateDIBSection(This.DrawBufDC, lcBMI, FF_DIB_RGB_COLORS, @lnDibDataPtr, 0, 0)
		WinApi_SelectObject(This.DrawBufDC, This.DrawBufDIB)
		
		This.DrawBufGfx = This.env.System.Drawing.Graphics.FromHDC(This.DrawBufDC)
		
		
	ENDPROC

	HIDDEN PROCEDURE drawbufrelease
		This.DrawBufGfx = .F.
		
		IF EMPTY(This.DrawBufDC) = .F.
		    WinApi_DeleteDC(This.DrawBufDC)
		    This.DrawBufDC = 0
		ENDIF
		
		IF EMPTY(This.DrawBufDIB) = .F.
		    WinApi_DeleteObject(This.DrawBufDIB)
		    This.DrawBufDIB = 0
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		lcMsg = ""
		
		DO CASE
		 CASE VARTYPE(m.tvMsg)="O"
		    lcMsg = ;
		        m.tvMsg.Message + ;
		        RTRIM(" " + NVL(m.tvMsg.Details,"")) + ;
		        RTRIM(" " + NVL(m.tvMsg.UserValue,"")) + ;
		        CHR(13) + "Procedure: " + m.tvMsg.Procedure + ;
		        CHR(13) + "LineContents: " + m.tvMsg.LineContents
		
		 CASE VARTYPE(m.tvMsg)="C"
		    lcMsg = ALLTRIM(m.tvMsg)
		
		ENDCASE
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		MESSAGEBOX(m.lcMsg, 0+48, This.Class + " ("+This.ClassLibrary+")")
		
		
	ENDPROC

	HIDDEN PROCEDURE fitwidth_assign
		LPARAMETERS vNewVal
		
		This.FitWidth = m.vNewVal
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
		
	ENDPROC

	PROCEDURE getcurrentpage		&& Current page number. First page has number = 1
		RETURN This.fpdf_page_first_visible
	ENDPROC

	PROCEDURE getpagecount		&& Returns page count
		RETURN This.fpdf_pagecount
		
	ENDPROC

	PROCEDURE getpagesize		&& Returns page dimensions (see comment in source code)
		LPARAMETERS tnPageIndex, tnPosition
		
		*tnPageIndex: page number from 1 to This.fpdf_pagecount
		*tnPosition: 1 - width in pdf units  (1/72 on inch)
		*tnPosition: 2 - height in pdf units  (1/72 on inch)
		*tnPosition: 3 - width in pixels
		*tnPosition: 4 - height in pixels
		*tnPosition: 5 - width / height relation
		
		IF BETWEEN(m.tnPageIndex, 1, This.fpdf_pagecount)=.F.
		    RETURN 0
		ENDIF
		
		LOCAL lnPdfPageWidth, lnPdfPageHeight
		lnPdfPageWidth = This.fpdf_pages_size[tnPageIndex,1]
		lnPdfPageHeight = This.fpdf_pages_size[tnPageIndex,2]
		
		LOCAL lnPageWidth, lnPageHeight
		lnPageWidth = INT(lnPdfPageWidth * This.env.GetScreenDPIX() / This.env.GetPDFDPI())
		lnPageHeight = INT(lnPdfPageHeight * This.env.GetScreenDPIY() / This.env.GetPDFDPI())
		
		DO CASE
		
		CASE m.tnPosition = 1
		    RETURN lnPdfPageWidth
		
		CASE m.tnPosition = 2
		    RETURN lnPdfPageHeight
		
		CASE m.tnPosition = 3
		    RETURN lnPageWidth
		    
		CASE m.tnPosition = 4
		    RETURN lnPageHeight
		
		CASE m.tnPosition = 5
		    RETURN lnPdfPageWidth / EVL(lnPdfPageHeight,1)
		
		ENDCASE
		
		RETURN 0
		
	ENDPROC

	HIDDEN PROCEDURE GotFocus
		This.IsFocused = .T.
		
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.env.Setup(m.toEnv)
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.PrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary, "")
		
		*********************************************************
		This.BorderWidth = 0
		
		
		*********************************************************
		IF This.WndCreate() = .F.
		    RETURN
		ENDIF
		
		LOCAL loBackColor
		loBackColor = This.env.System.Drawing.Color.FromRgb(This.BackColor)
		This.BackColorBrush = This.env.System.Drawing.SolidBrush.New(loBackColor)
		
		LOCAL loSelectionColor
		loSelectionColor = This.env.System.Drawing.Color.New(This.env.System.Drawing.Color.SteelBlue.ToArgb())
		loSelectionColor.A = 72
		This.SelectionBrush = This.env.System.Drawing.SolidBrush.New(loSelectionColor)
		
		LOCAL loSearchColor
		loSearchColor = This.env.System.Drawing.Color.New(This.env.System.Drawing.Color.Yellow.ToArgb())
		loSearchColor.A = 96
		This.SearchBrush = This.env.System.Drawing.SolidBrush.New(loSearchColor)
		
		
		
		
		*********************************************************
		This.Resize()
		This.WndShow()
		
	ENDPROC

	PROCEDURE keypress		&& Occurs when the user presses and releases a key.
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		#define KEY_LEFT_ARROW 19
		#define KEY_RIGHT_ARROW 4
		#define KEY_UP_ARROW 5
		#define KEY_DOWN_ARROW 24
		#define KEY_PAGE_UP 18
		#define KEY_PAGE_DOWN 3
		#define KEY_HOME 1
		#define KEY_END 6
		
		DO CASE
		
		CASE This.fpdf_opened = .F.
		 
		CASE This.UIState.GetEffectivelyVisible() = .F.
		
		CASE This.UIState.GetEffectivelyEnabled() = .F. 
		 
		CASE m.nKeyCode = KEY_LEFT_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollHorz(-0.05 * This.Width, .F., .T.)
		
		CASE m.nKeyCode = KEY_RIGHT_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollHorz(0.05 * This.Width, .F., .T.)
		
		CASE m.nKeyCode = KEY_UP_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(-0.05 * This.Height, .F., .T.)
		
		CASE m.nKeyCode = KEY_DOWN_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(0.05 * This.Height, .F., .T.)
		
		CASE m.nKeyCode = KEY_PAGE_UP AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(-1, .T., .T.)
		
		CASE m.nKeyCode = KEY_PAGE_DOWN AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(1, .T., .T.)
		
		CASE m.nKeyCode = KEY_HOME AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(1, .T., .F.)
		
		CASE m.nKeyCode = KEY_END AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(This.ViewPortMaxY, .T., .F.)
		
		CASE m.nKeyCode = 3 AND m.nShiftAltCtrl = 2
		    NODEFAULT
		    This.SelectionCopy()
		    
		ENDCASE
		
		
	ENDPROC

	HIDDEN PROCEDURE LostFocus
		This.IsFocused = .F.
		
		
		
	ENDPROC

	HIDDEN PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		This.SelectionCharIndexStart = 0
		
		IF m.nButton <> 1
		    RETURN 
		ENDIF
		
		
		LOCAL lnMouseX, lnMouseY
		lnMouseX = m.nXCoord
		lnMouseY = m.nYCoord
		
		LOCAL llDblClick, llTplClick
		llDblClick = .F.
		llTplClick = .F.
		
		********************************************************************
		LOCAL lnTick
		lnTick = WinApi_GetTickCount()
		lnTick = IIF(lnTick < 0, 0x80000000 + BITCLEAR(lnTick,31), lnTick)
		
		DO CASE 
		
		CASE This.DblClickBegin = 0 AND This.TplClickBegin = 0
		    This.DblClickBegin = -lnTick
		    This.TplClickBegin = -lnTick
		
		CASE This.DblClickBegin < 0
		    This.DblClickBegin = -This.DblClickBegin
		    
		    IF ABS(lnTick - This.DblClickBegin)/1000 <= _DBLCLICK
		        llDblClick = .T.
		        This.DblClickBegin = 0
		    ELSE
		        This.DblClickBegin = -lnTick
		        This.TplClickBegin = -lnTick
		    ENDIF
		
		CASE This.TplClickBegin < 0
		    This.TplClickBegin = -This.TplClickBegin
		    IF ABS(lnTick - This.TplClickBegin)/1000 <= _DBLCLICK 
		        llTplClick = .T.
		        This.DblClickBegin = 0
		        This.TplClickBegin = 0
		    ELSE
		        This.DblClickBegin = -lnTick
		        This.TplClickBegin = -lnTick
		    ENDIF
		
		ENDCASE
		
		
		********************************************************************
		LOCAL lnPage, lnFPDF_Page, lnFPDF_Text_Page
		lnPage = This.PagePick(lnMouseX, lnMouseY)
		
		IF EMPTY(lnPage) = .T.
		    RETURN
		ENDIF
		
		lnFPDF_Page = This.fpdf_pages[lnPage]
		lnFPDF_Text_Page = This.fpdf_text_pages[lnPage]
		
		LOCAL lnPageX as Double, lnPageY as Double
		STORE 0 TO lnPageX, lnPageY
		
		IF FPDF_DeviceToPage(lnFPDF_Page, This.fpdf_pages_pos[lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[lnPage,3], This.fpdf_pages_pos[lnPage,4], 0, lnMouseX, lnMouseY, @lnPageX, @lnPageY) <> 1
		    RETURN
		ENDIF
		
		
		********************************************************************
		LOCAL lnCharIndexStart
		lnCharIndexStart = FPDFText_GetCharIndexAtPos(lnFPDF_Text_Page, lnPageX, lnPageY, 10, 0)
		
		IF lnCharIndexStart > 0
		    This.SelectionCharIndexStart = lnCharIndexStart
		ENDIF
		
		IF lnCharIndexStart < 0
		    * TEXT MISCLICK
		    This.SelectText()
		    RETURN
		ENDIF
		
		
		IF llDblClick = .F. AND llTplClick = .F.
		    * TEXT SINGLE CLICK
		    This.SelectText()
		    RETURN
		ENDIF
		
		
		********************************************************************
		* TEXT DOUBLE CLICK, TRIPLE CLICK
		********************************************************************
		
		LOCAL lnCharCountMax
		lnCharCountMax = FPDFText_CountChars(lnFPDF_Text_Page)
		IF lnCharCountMax < 0
		    RETURN
		ENDIF
		
		LOCAL lnCharCount
		lnCharCount = 1
		
		LOCAL lnCharIndexLeft
		lnCharIndexLeft = lnCharIndexStart
		
		DO WHILE lnCharIndexLeft > 0
		    LOCAL lcChar
		    lcChar = LEFT(STRCONV(STRCONV(BINTOC(FPDFText_GetUnicode(lnFPDF_Text_Page, lnCharIndexLeft-1), "4RS"),6),2),1)
		    
		    IF INLIST(lcChar, CHR(10),CHR(13))
		        EXIT
		    ENDIF
		    
		    IF EMPTY(lcChar) AND llTplClick = .F.
		        EXIT
		    ENDIF
		    
		    lnCharIndexLeft = lnCharIndexLeft - 1
		    lnCharCount = lnCharCount + 1
		ENDDO
		
		
		DO WHILE lnCharIndexLeft + lnCharCount < lnCharCountMax
		    LOCAL lcChar
		    lcChar = LEFT(STRCONV(STRCONV(BINTOC(FPDFText_GetUnicode(lnFPDF_Text_Page, lnCharIndexLeft + lnCharCount), "4RS"),6),2),1)
		
		    IF INLIST(lcChar, CHR(10),CHR(13))
		        EXIT
		    ENDIF
		
		    IF EMPTY(lcChar) AND llTplClick = .F.
		        EXIT
		    ENDIF
		
		    lnCharCount = lnCharCount + 1
		ENDDO
		
		
		This.SelectText(lnPage, lnCharIndexLeft, lnCharCount)
		
		
	ENDPROC

	HIDDEN PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		LOCAL lnMouseX, lnMouseY
		lnMouseX = m.nXCoord
		lnMouseY = m.nYCoord
		
		LOCAL lnPage, lnFPDF_Page, lnFPDF_Text_Page
		lnPage = This.PagePick(lnMouseX, lnMouseY)
		IF EMPTY(lnPage)
		    RETURN
		ENDIF
		
		lnFPDF_Page = This.fpdf_pages[lnPage]
		lnFPDF_Text_Page = This.fpdf_text_pages[lnPage]
		
		LOCAL lnPageX as Double, lnPageY as Double
		STORE 0 TO lnPageX, lnPageY
		
		IF FPDF_DeviceToPage(lnFPDF_Page, This.fpdf_pages_pos[lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[lnPage,3], This.fpdf_pages_pos[lnPage,4], 0, lnMouseX, lnMouseY, @lnPageX, @lnPageY) <> 1
		    RETURN
		ENDIF
		
		LOCAL lnCharIndex
		lnCharIndex = FPDFText_GetCharIndexAtPos(lnFPDF_Text_Page, lnPageX, lnPageY, 10, 0)
		
		DO CASE
		CASE lnCharIndex >= 0
		    This.MousePointer = 3
		    
		    IF m.nButton = 1 AND lnCharIndex <> This.SelectionCharindexPrev
		        This.selecttext(lnPage, MIN(This.SelectionCharIndexStart,lnCharIndex), ABS(lnCharIndex-This.SelectionCharIndexStart)+1)
		    ENDIF
		    
		OTHERWISE
		    This.MousePointer = 0
		ENDCASE
		
		This.SelectionCharindexPrev = lnCharIndex
		
	ENDPROC

	HIDDEN PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		IF m.nButton = 2
		    This.contextmenu()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE MouseWheel
		LPARAMETERS nDirection, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		DO CASE
		CASE EVL(m.nShift,0)=2
		     This.scale = This.scale + (SIGN(m.nDirection) * 0.1)
		 
		CASE EVL(m.nShift,0)=0
		    This.ScrollVert(-0.05 * This.Height * m.nDirection/120, .F., .T.)
		
		ENDCASE
		
	ENDPROC

	PROCEDURE openpdf		&& Open pdf file. Returns: .T. on success, .F. if file was not loaded
		LPARAMETERS tcFilename
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.closepdf()
		
		
		LOCAL lcFilename
		lcFilename = ALLTRIM(EVL(NVL(m.tcFilename,""),""))
		
		IF EMPTY(lcFilename)
		    RETURN .F.
		ENDIF
		
		IF FILE(lcFilename,1)=.F.
		    This.errMsg(TEXTMERGE("File <<FULLPATH(lcFilename)>> not found"))
		    RETURN .F.
		ENDIF    
		
		This.fpdf_doc = FPDF_LoadDocument(STRCONV(lcFilename,9)+CHR(0), "")
		
		
		
		IF EMPTY(This.fpdf_doc)
		    RETURN .F.
		ENDIF
		
		This.fpdf_pagecount = FPDF_GetPageCount(This.fpdf_doc)
		
		IF This.fpdf_pagecount > 0
		    DIMENSION This.fpdf_pages(This.fpdf_pagecount)
		    DIMENSION This.fpdf_text_pages(This.fpdf_pagecount)
		    DIMENSION This.fpdf_pages_selection(This.fpdf_pagecount,3)
		    DIMENSION This.fpdf_pages_pos(This.fpdf_pagecount,4)
		    DIMENSION This.fpdf_pages_size(This.fpdf_pagecount,2)
		    DIMENSION This.fpdf_pages_search(This.fpdf_pagecount)
		    STORE 0 TO This.fpdf_pages, This.fpdf_text_pages, This.fpdf_pages_pos, This.fpdf_pages_size, This.fpdf_pages_search
		    
		    DIMENSION This.fpdf_pages_render_cache(This.fpdf_pagecount,4) && Max 4 rendered samples for page
		    STORE .F. TO This.fpdf_pages_render_cache
		ENDIF
		
		LOCAL lnPage
		FOR lnPage = 1 TO This.FPDF_PageCount
		    This.fpdf_pages[lnPage] = FPDF_LoadPage(This.FPDF_Doc, lnPage-1)
		    
		    This.fpdf_text_pages[lnPage] = FPDFText_LoadPage(This.fpdf_pages[lnPage])
		    
		    This.fpdf_pages_selection[lnPage,1] = ""
		    This.fpdf_pages_selection[lnPage,2] = 0
		    This.fpdf_pages_selection[lnPage,3] = 0
		    
		    This.fpdf_pages_size[lnPage,1] = FPDF_GetPageWidth(This.fpdf_pages[lnPage])
		    This.fpdf_pages_size[lnPage,2] = FPDF_GetPageHeight(This.fpdf_pages[lnPage])
		ENDFOR
		
		This.ViewPortUpdate()
		
		This.fpdf_opened = .T.
		
		This.WndRedraw()
		
	ENDPROC

	HIDDEN PROCEDURE pagepick
		LPARAMETERS lnCoordX, lnCoordY
		
		* lnCoordX, lnCoordY coordinates in the control space (0,0) is top left corner of the control
		
		IF This.fpdf_opened = .F.
		    RETURN 0
		ENDIF
		
		IF This.fpdf_page_first_visible = 0
		    RETURN 0
		ENDIF
		
		
		LOCAL lnPage, lnPageFound
		lnPageFound = 0
		FOR lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		    DO CASE
		    CASE BETWEEN(lnCoordX, This.fpdf_pages_pos[lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[lnPage,1]-This.ViewPortX + This.fpdf_pages_pos[lnPage,3]) = .F.
		         LOOP
		    CASE BETWEEN(lnCoordY, This.fpdf_pages_pos[lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[lnPage,2]-This.ViewPortY + This.fpdf_pages_pos[lnPage,4]) = .F.
		         LOOP
		    OTHERWISE
		        lnPageFound = lnPage
		        EXIT
		    ENDCASE
		ENDFOR
		
		RETURN lnPageFound
		
	ENDPROC

	PROCEDURE printdocument		&& Send document to printer with preceding setup dialog
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		IF EMPTY(This.fpdf_doc)
		    RETURN
		ENDIF
		
		*********************************************************************
		LOCAL loFrmSetup
		loFrmSetup = NEWOBJECT("Pdfium_print_env_setup", This.ClassLibrary, "", This.PrintEnv)
		loFrmSetup.Show(1)
		
		This.SetFocus()
		
		IF VARTYPE(loFrmSetup)<>"O"
		    RETURN
		ENDIF    
		
		IF loFrmSetup.out_ok = .F.
		    RETURN
		ENDIF
		
		This.PrintEnv.Setup(loFrmSetup.PrintEnv)
		loFrmSetup = .F.
		
		IF EMPTY(This.PrintEnv.Printer)
		    RETURN
		ENDIF
		*********************************************************************
		
		
		*********************************************************************
		DECLARE INTEGER StartPage IN GDI32 AS WinApi_StartPage INTEGER hdc
		DECLARE INTEGER EndPage IN GDI32 AS WinApi_EndPage INTEGER hdc
		DECLARE INTEGER EndDoc IN GDI32 AS WinApi_EndDoc INTEGER hdc
		DECLARE INTEGER StartDoc IN GDI32 AS WinApi_StartDoc INTEGER hdc, STRING lpdi
		
		DECLARE INTEGER HeapCreate IN WIN32API AS WinApi_HeapCreate INTEGER dwOptions, INTEGER dwInitialSize, INTEGER dwMaxSize
		DECLARE INTEGER HeapAlloc IN WIN32API AS WinApi_HeapAlloc INTEGER hHeap, INTEGER dwFlags, INTEGER dwBytes
		DECLARE INTEGER HeapFree IN WIN32API AS WinApi_HeapFree INTEGER hHeap, INTEGER dwFlags, INTEGER lpMem
		DECLARE INTEGER HeapDestroy IN WIN32API AS WinApi_HeapDestroy INTEGER hHeap
		
		DECLARE LONG CreateDC IN WIN32API AS WinApi_CreateDC STRING cDriver, STRING cDevice, STRING cOutput, STRING @cInitData
		DECLARE LONG DeleteDC IN WIN32API AS WinApi_DeleteDC LONG hdc
		DECLARE LONG GetDeviceCaps IN WIN32API AS WinApi_GetDeviceCaps LONG hdc, LONG nIndex 
		
		#define FPDF_PRINTING 0x800
		
		#define PHYSICALOFFSETX 112
		#define PHYSICALOFFSETY 113    
		
		#define DM_ORIENTATION  1
		#define DM_PAPERSIZE    2
		#define DM_PAPERLENGTH  4
		#define DM_PAPERWIDTH   8
		#define DM_COPIES 0x00000100
		#define DM_DUPLEX 0x00001000
		#define DM_YRESOLUTION 0x00002000
		
		#DEFINE DM_OFFSET_DMFIELDS 41  && DEVMODE dmFields offset
		#define DM_OFFSET_ORIENTATION 45  && DEVMODE dmOrientation offset
		#define DM_OFFSET_PAPERSIZE 47  && DEVMODE dmPaperSize offset
		#define DM_OFFSET_PAPERLENGTH 49  && DEVMODE dmPaperLength offset
		#define DM_OFFSET_PAPERWIDTH 51  && DEVMODE dmPaperWidth offset
		#define DM_OFFSET_COPIES 55  && DEVMODE dmCopies offset
		#define DM_OFFSET_DUPLEX 63 && DEVMODE dmDuplex offset
		#define DM_OFFSET_YRESOLUTION 65 && DEVMODE dmYResolution offset
		#define DMDUP_SIMPLEX    1
		#define DMDUP_VERTICAL   2
		#define DMDUP_HORIZONTAL 3
		#define DMORIENT_PORTRAIT 1
		#define DMORIENT_LANDSCAPE 2
		
		#define DMPAPER_A4 9
		
		#define FORM_BUILTIN 0x00000001
		#define FORM_PRINTER 0x00000002
		*********************************************************************
		* Get printer document properties and printer forms
		*********************************************************************
		
		LOCAL lcPrnDevMode
		lcPrnDevMode = This.PrintEnv.GetPrinterDevMode(This.PrintEnv.Printer)
		
		IF EMPTY(lcPrnDevMode)
		    This.ErrMsg(TEXTMERGE("PrintEnv.GetPrinterDevMode returned empty value for <<This.PrintEnv.Printer>>"))
		    RETURN
		ENDIF
		
		LOCAL lnPrnFormCnt
		LOCAL laPrnForm(1,9)
		lnPrnFormCnt = This.PrintEnv.GetPrinterForms(@laPrnForm, This.PrintEnv.Printer)
		IF EMPTY(lnPrnFormCnt)
		    This.ErrMsg(TEXTMERGE("PrintEnv.GetPrinterForms returned empty value for <<This.PrintEnv.Printer>>"))
		    RETURN
		ENDIF
		
		LOCAL lnPrnDevModeFlags
		lnPrnDevModeFlags = CTOBIN(SUBSTR(lcPrnDevMode, DM_OFFSET_DMFIELDS, 4),"4RS")
		
		
		*********************************************************************
		* Setup page ranges according to PrintEnv.PageMode 
		*********************************************************************
		LOCAL lnPageMode, lcPageList
		lnPageMode = 1
		lcPageList = ""
		
		lnPageMode = This.printEnv.PageMode
		lcPageList = This.printEnv.PageList_Parse(This.printEnv.PageList)
		
		
		LOCAL ARRAY laPageRanges(1,2)
		LOCAL lnPageRangeCnt
		lnPageRangeCnt = 0
		DO CASE
		CASE lnPageMode = 1 && All pages
		    lnPageRangeCnt = 1
		    DIMENSION laPageRanges(1,2)
		    laPageRanges[1,1] = 1
		    laPageRanges[1,2] = This.fpdf_pagecount
		
		CASE lnPageMode = 2 && Odd pages
		    lnPageRangeCnt = INT(This.fpdf_pagecount / 2) + MOD(This.fpdf_pagecount, 2)
		    LOCAL lnRange
		    FOR lnRange = 1 TO lnPageRangeCnt
		        DIMENSION laPageRanges(lnRange,2)
		        laPageRanges[lnRange,1] = lnRange*2 - 1
		        laPageRanges[lnRange,2] = lnRange*2 - 1
		    ENDFOR
		
		CASE lnPageMode = 3 && Even pages
		    lnPageRangeCnt = INT(This.fpdf_pagecount / 2)
		    LOCAL lnRange
		    FOR lnRange = 1 TO lnPageRangeCnt
		        DIMENSION laPageRanges(lnRange,2)
		        laPageRanges[lnRange,1] = lnRange*2
		        laPageRanges[lnRange,2] = lnRange*2
		    ENDFOR
		
		CASE lnPageMode = 4
		    LOCAL ARRAY laPageList(1)
		    lnPageRangeCnt = ALINES(laPageList, lcPageList,1+4,",")
		    LOCAL lnRange
		    FOR lnRange = 1 TO lnPageRangeCnt
		        DIMENSION laPageRanges(lnRange,2)
		        laPageRanges[lnRange,1] = INT(VAL(STREXTRACT(laPageList[lnRange], "", "-",1,2)))
		        laPageRanges[lnRange,2] = EVL(INT(VAL(STREXTRACT(laPageList[lnRange], "-", "",1,2))), laPageRanges[lnRange,1])
		    ENDFOR
		ENDCASE
		*********************************************************************
		
		
		*********************************************************************
		LOCAL lnPrinterDPI
		lnPrinterDPI =  EVL(IIF(BITAND(lnPrnDevModeFlags, DM_YRESOLUTION)<>0, CTOBIN(SUBSTR(lcPrnDevMode,DM_OFFSET_YRESOLUTION,2),"2RS"), 0), 600)
		
		LOCAL llPrinterHasDuplex, lnPrinterDuplex
		llPrinterHasDuplex = This.PrintEnv.GetPrinterDuplex(This.PrintEnv.Printer)
		
		* Get default duplex setting of the printer
		lnPrinterDuplex = EVL(IIF(BITAND(lnPrnDevModeFlags, DM_DUPLEX)<>0, CTOBIN(SUBSTR(lcPrnDevMode,DM_OFFSET_DUPLEX,2),"2RS"), 0), DMDUP_SIMPLEX)
		
		DO CASE
		CASE llPrinterHasDuplex = .F. OR This.PrintEnv.Duplex  = .F.
		    lnPrinterDuplex = DMDUP_SIMPLEX
		OTHERWISE
		    lnPrinterDuplex = DMDUP_VERTICAL
		ENDCASE
		
		
		
		LOCAL loErr
		loErr = .F.
		
		TRY
		
		    LOCAL lcDocName
		    lcDocName = This.Class
		
		    LOCAL lhDocNameHeap, lhDocNameHeapPtr
		    lhDocNameHeap = WinApi_HeapCreate(0, LEN(lcDocName)+1, 0)
		    lhDocNameHeapPtr = 0
		    IF EMPTY(lhDocNameHeap) = .F.
		        lhDocNameHeapPtr = WinApi_HeapAlloc(lhDocNameHeap, 0, LEN(lcDocName)+1)
		        IF EMPTY(lhDocNameHeapPtr) = .F.
		            SYS(2600, lhDocNameHeapPtr, LEN(lcDocName)+1, lcDocName+CHR(0))
		        ENDIF
		    ENDIF
		    
		    LOCAL lhPrinterDC
		    lhPrinterDC = 0
		
		    LOCAL lcDocInfo
		    lcDocInfo = BINTOC(20, "4RS") + BINTOC(lhDocNameHeapPtr, "4RS") + BINTOC(0, "4RS") + BINTOC(0, "4RS") + BINTOC(0, "4RS")
		    
		
		    LOCAL llStartDoc
		    llStartDoc = .T.
		    
		    LOCAL lnDocPageNum
		    lnDocPageNum = 0
		    
		    LOCAL lnOrientation
		    lnOrientation = 0
		    
		    LOCAL lnPaperSize, lnPaperSizePrev
		    lnPaperSize = 0
		    lnPaperSizePrev = 0
		
		    LOCAL lnPageRange
		    lnPageRange = 1
		    FOR lnPageRange = 1 TO lnPageRangeCnt
		        
		        LOCAL lnPageFrom, lnPageTo
		        lnPageFrom = MAX(laPageRanges[lnPageRange,1], 1)
		        lnPageTo = MIN(laPageRanges[lnPageRange,2], This.fpdf_pagecount)
		        
		        LOCAL lnPageIndex
		        lnPageIndex = lnPageFrom
		
		        
		        FOR lnPageIndex = lnPageFrom TO lnPageTo
		
		            LOCAL lnPageWidth, lnPageHeight
		            lnPageWidth = This.GetPageSize(lnPageIndex,1)  / This.env.GetPDFDPI()
		            lnPageHeight = This.GetPageSize(lnPageIndex,2) / This.env.GetPDFDPI()
		
		
		            * Find paper size 
		            lnPaperSize = This.PrintEnv.PaperSize
		            
		            IF BETWEEN(lnPaperSize, 1, lnPrnFormCnt)
		               lnPaperSize = IIF(laPrnForm[lnPaperSize,9], lnPaperSize, -1) && check form is supported by printer
		            ELSE
		                lnPaperSize = -1 
		            ENDIF
		            
		            IF lnPaperSize = -1 && Find fittest paper form
		                LOCAL liPrnForm, lnFitFormWidth, lnFitFormHeight
		                liPrnForm = 1
		                STORE 0 TO lnFitFormWidth, lnFitFormHeight 
		                FOR liPrnForm = 1 TO lnPrnFormCnt
		                    DO CASE
		                    CASE BITAND(laPrnForm[liPrnForm,1], FORM_BUILTIN) = 0
		                    CASE laPrnForm[liPrnForm,9] = .F.
		                    CASE ROUND(laPrnForm[liPrnForm,3]/1000,0) < ROUND(IIF(lnPageWidth < lnPageHeight, lnPageWidth, lnPageHeight) * 25.4, 0)
		                    CASE ROUND(laPrnForm[liPrnForm,4]/1000,0) < ROUND(IIF(lnPageWidth < lnPageHeight, lnPageHeight, lnPageWidth) * 25.4, 0)
		                    CASE lnFitFormWidth > 0 AND lnFitFormWidth < laPrnForm[liPrnForm,3]
		                    CASE lnFitFormHeight > 0 AND lnFitFormHeight < laPrnForm[liPrnForm,4]
		                    OTHERWISE
		                        lnPaperSize = liPrnForm
		                        lnFitFormWidth = laPrnForm[liPrnForm,3]
		                        lnFitFormHeight = laPrnForm[liPrnForm,4]
		                    ENDCASE
		                ENDFOR
		                lnPaperSize = EVL(MAX(lnPaperSize,0), EVL(MAX(PRTINFO(2, This.PrintEnv.Printer), 0), DMPAPER_A4 ))
		            ENDIF
		            
		            *********************************************************
		            IF BETWEEN(lnPaperSize, 1, lnPrnFormCnt) = .F.
		                THROW TEXTMERGE("Not Found Paper Form For Page number <<lnPageIndex>>, page size <<ROUND(lnPageWidth * 25.4,0)>> mm, <<ROUND(lnPageHeight * 25.4,0)>> mm ")
		            ENDIF
		            *********************************************************
		
		            IF lnPaperSizePrev <> lnPaperSize
		                lnPaperSizePrev = lnPaperSize
		                llStartDoc = .T.
		            ENDIF
		
		            IF llStartDoc
		
		                IF EMPTY(lhPrinterDC) = .F.
		                    WinApi_EndDoc(lhPrinterDC)
		                    WinApi_DeleteDC(lhPrinterDC)
		                ENDIF
		
		                lnDocPageNum = 0
		                
		                lnOrientation = IIF(lnPageWidth > lnPageHeight, DMORIENT_LANDSCAPE, DMORIENT_PORTRAIT)
		                
		                * Set paper size
		                lcPrnDevMode = STUFF(lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(lnPrnDevModeFlags, DM_PAPERSIZE), "4RS"))
		                lcPrnDevMode = STUFF(lcPrnDevMode, DM_OFFSET_PAPERSIZE, 2, BINTOC(lnPaperSize, "2RS"))
		
		                * Set duplex
		                lcPrnDevMode = STUFF(lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(lnPrnDevModeFlags, DM_DUPLEX), "4RS"))
		                lcPrnDevMode = STUFF(lcPrnDevMode, DM_OFFSET_DUPLEX, 2, BINTOC(lnPrinterDuplex, "2RS"))
		                
		                * Set page orientation
		                lcPrnDevMode = STUFF(lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(lnPrnDevModeFlags, DM_ORIENTATION), "4RS"))
		                lcPrnDevMode = STUFF(lcPrnDevMode, DM_OFFSET_ORIENTATION, 2, BINTOC(lnOrientation, "2RS"))
		
		                * Set copies
		                lcPrnDevMode = STUFF(lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(lnPrnDevModeFlags, DM_COPIES), "4RS"))
		                lcPrnDevMode = STUFF(lcPrnDevMode, DM_OFFSET_COPIES, 2, BINTOC(EVL(This.PrintEnv.copies,1), "2RS"))
		                
		                lhPrinterDC = WinApi_CreateDC(NULL, This.printenv.Printer + CHR(0), NULL, @lcPrnDevMode)
		
		                IF EMPTY(lhPrinterDC)
		                    THROW TEXTMERGE("WinApi_CreateDC error on page <<lnPageIndex>>, printer <<This.PrintEnv.Printer>>")
		                ENDIF
		            
		                WinApi_StartDoc(lhPrinterDC, lcDocInfo)
		                
		                llStartDoc = .F.
		            ENDIF
		
		            lnDocPageNum = lnDocPageNum + 1
		
		
		            ***********************************
		            * Render page 
		            ***********************************
		            WinApi_StartPage(lhPrinterDC)
		            
		            LOCAL lnPrintX, lnPrintY, lnPrintWidth, lnPrintHeight
		            lnPrintX = IIF(lnOrientation = DMORIENT_LANDSCAPE, WinApi_GetDeviceCaps(lhPrinterDC, PHYSICALOFFSETY), WinApi_GetDeviceCaps(lhPrinterDC, PHYSICALOFFSETX))
		            lnPrintY = IIF(lnOrientation = DMORIENT_LANDSCAPE, WinApi_GetDeviceCaps(lhPrinterDC, PHYSICALOFFSETX), WinApi_GetDeviceCaps(lhPrinterDC, PHYSICALOFFSETY))
		            
		            lnPrintWidth = IIF(lnOrientation = DMORIENT_LANDSCAPE, laPrnForm[lnPaperSize,4], laPrnForm[lnPaperSize,3])
		            lnPrintHeight = IIF(lnOrientation = DMORIENT_LANDSCAPE, laPrnForm[lnPaperSize,3], laPrnForm[lnPaperSize,4])
		            lnPrintWidth = (lnPrintWidth / (25.4 * 1000)) * lnPrinterDPI
		            lnPrintHeight = (lnPrintHeight / (25.4 * 1000)) * lnPrinterDPI
		            
		            lnPrintWidth = lnPrintWidth - lnPrintX 
		            lnPrintHeight = lnPrintHeight - lnPrintY 
		            
		            LOCAL lnPrintRotate
		            lnPrintRotate = IIF(lnOrientation = DMORIENT_LANDSCAPE, IIF(lnPageWidth > lnPageHeight, 0, 1), IIF(lnPageWidth > lnPageHeight, 1, 0))
		            IF lnPrinterDuplex = DMDUP_VERTICAL AND MOD(lnDocPageNum,2) = 0
		                lnPrintRotate = IIF(lnOrientation = DMORIENT_LANDSCAPE, IIF(lnPageWidth > lnPageHeight, 2, 1), IIF(lnPageWidth > lnPageHeight, 3, 0)) 
		            ENDIF
		            
		            LOCAL lnFPDF_Page 
		            lnFPDF_Page = This.fpdf_pages[lnPageIndex]
		            
		            IF EMPTY(lnFPDF_Page) = .F.
		                
		                FPDF_RenderPage(lhPrinterDC, ;
		                    lnFPDF_Page, ;
		                    -lnPrintX * 0.5, ;
		                    -lnPrintY * 0.5, ;
		                    lnPrintWidth, ;
		                    lnPrintHeight, ;
		                    lnPrintRotate, ;
		                    FPDF_PRINTING)
		            ENDIF
		            
		            WinApi_EndPage(lhPrinterDC)
		            ***********************************
		            * / Render page 
		            ***********************************
		
		
		        ENDFOR
		
		    ENDFOR
		    
		    
		CATCH TO loErr
		    This.ErrMsg(loErr)
		FINALLY
		    IF EMPTY(lhPrinterDC) = .F.
		        IF llStartDoc = .F.
		            WinApi_EndDoc(lhPrinterDC)
		        ENDIF
		        WinApi_DeleteDC(lhPrinterDC)
		    ENDIF
		    
		    IF EMPTY(lhDocNameHeap) = .F.
		        WinApi_HeapDestroy(lhDocNameHeap)
		    ENDIF
		    
		ENDTRY
		
		
		
	ENDPROC

	HIDDEN PROCEDURE redraw
		LPARAMETERS tnWndDC
		
		LOCAL lnWndDC
		lnWndDC = EVL(m.tnWndDC, This.WndDC)
		
		IF EMPTY(lnWndDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDIB)
		    RETURN
		ENDIF
		
		IF VARTYPE(This.DrawBufGfx)<>"O"
		    RETURN
		ENDIF
		
		IF This.UIState.GetEffectivelyVisible() = .F.
		    RETURN
		ENDIF
		
		
		
		LOCAL lnWidth, lnHeight
		lnWidth = This.Width
		lnHeight = This.Height
		
		******************************************************************************
		LOCAL loGfx
		loGfx = This.DrawBufGfx
		loGfx.FillRectangle(This.BackColorBrush, 0,0, lnWidth, lnHeight)
		
		This.renderpages()
		
		loGfx.Flush()
		
		******************************************************************************
		#define FF_SRCCOPY 0x00CC0020
		
		WinApi_BitBlt(lnWndDC, 0,0, lnWidth, lnHeight, This.DrawBufDC, 0, 0, FF_SRCCOPY)
		
	ENDPROC

	HIDDEN PROCEDURE renderpagefromcache
		LPARAMETERS lnPageIndex, lnPageScale
		
		IF EMPTY(This.WndDC)
		    RETURN .F.
		ENDIF
		
		lnPageScale = EVL(lnPageScale,1)
		lnPageScale = MIN(lnPageScale, ALEN(This.fpdf_pages_render_cache,2))
		
		**********************************************************************
		IF VARTYPE(This.fpdf_pages_render_cache[lnPageIndex,lnPageScale]) = "O"
		    RETURN This.fpdf_pages_render_cache[lnPageIndex, lnPageScale]
		ENDIF
		**********************************************************************
		
		
		#DEFINE FF_RGBQUAD_SIZE     4
		#DEFINE FF_DIB_RGB_COLORS   0
		#DEFINE FF_BFHDR_SIZE      14
		#DEFINE FF_BHDR_SIZE       40
		#DEFINE FF_BI_RGB           0
		
		LOCAL lhPageDC
		lhPageDC = WinApi_CreateCompatibleDC(This.WndDC)
		
		IF EMPTY(lhPageDC)
		    RETURN .F.
		ENDIF
		
		
		LOCAL lnPageWidth, lnPageHeight
		lnPageWidth = lnPageScale * This.GetPageSize(lnPageIndex,3)
		lnPageHeight = lnPageScale * This.GetPageSize(lnPageIndex,4)
		
		
		LOCAL lnBitsPerPixel
		lnBitsPerPixel = 16
		
		LOCAL lcBMI
		lcBMI = BINTOC(FF_BHDR_SIZE ,"4RS") + BINTOC(lnPageWidth,"4RS") + BINTOC(lnPageHeight, "4RS") + ;
		        (CHR(MOD(1,256)) + CHR(INT(1/256))) + (CHR(MOD(lnBitsPerPixel,256))+ CHR(INT(lnBitsPerPixel/256))) +;
		        BINTOC(FF_BI_RGB, "4RS") + REPLICATE(0h00, 20)
		
		
		LOCAL lnDibDataPtr
		lnDibDataPtr = 0
		
		LOCAL lhPageDIB
		lhPageDIB = WinApi_CreateDIBSection(lhPageDC, lcBMI, FF_DIB_RGB_COLORS, @lnDibDataPtr, 0, 0)
		
		IF EMPTY(lhPageDIB)=.T.
		    WinApi_DeleteDC(lhPageDC)
		    RETURN .F.
		ENDIF
		
		WinApi_SelectObject(lhPageDC, lhPageDIB)
		
		LOCAL loGfx
		loGfx = This.env.System.Drawing.Graphics.FromHDC(lhPageDC)
		loGfx.FillRectangle(This.env.System.Drawing.Brushes.White, 0, 0, lnPageWidth, lnPageHeight)
		
		LOCAL lnFPDF_Page 
		lnFPDF_Page = This.fpdf_pages[lnPageIndex]
		
		FPDF_RenderPage(lhPageDC, lnFPDF_Page, 0, 0, lnPageWidth, lnPageHeight, 0, 0)
		
		LOCAL loBmp
		loBmp = This.env.System.Drawing.Bitmap.FromHbitmap(lhPageDIB)
		
		WinApi_DeleteObject(lhPageDIB)
		WinApi_DeleteDC(lhPageDC)
		
		**********************************************************************
		LOCAL loStream
		loStream = This.env.System.IO.MemoryStream.New()
		
		loBmp.Save(loStream, This.env.System.Drawing.Imaging.ImageFormat.Png)
		
		LOCAL loPng
		loPng = This.env.System.Drawing.Image.FromStream(loStream)
		
		This.fpdf_pages_render_cache[lnPageIndex, lnPageScale] = loPng
		
		RETURN loPng
		
		
	ENDPROC

	HIDDEN PROCEDURE renderpages
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.fpdf_page_first_visible)
		    RETURN
		ENDIF
		
		LOCAL lnPageWidthUnscaled, lnPageHeightUnscaled
		LOCAL lnPageX, lnPageY
		LOCAL lnPageWidth, lnPageHeight
		LOCAL lnPageRenderScale
		
		LOCAL lnPage
		FOR lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		    lnPageWidthUnscaled = This.GetPageSize(lnPage,3)
		    lnPageHeightUnscaled = This.GetPageSize(lnPage,4)
		
		    lnPageX = This.fpdf_pages_pos[lnPage,1] - This.ViewPortX
		    lnPageY = This.fpdf_pages_pos[lnPage,2] - This.ViewPortY
		    lnPageWidth = This.fpdf_pages_pos[lnPage,3]
		    lnPageHeight = This.fpdf_pages_pos[lnPage,4]
		
		
		    lnPageRenderScale = MAX(CEILING(lnPageWidth / EVL(lnPageWidthUnscaled,lnPageWidth)),1)
		    lnPageRenderScale = MIN(lnPageRenderScale, ALEN(This.fpdf_pages_render_cache,2))
		    
		    LOCAL loPng
		    loPng = This.RenderPageFromCache(lnPage, lnPageRenderScale)
		    
		    IF VARTYPE(loPng)="O"
		        This.DrawBufGfx.DrawImage(loPng, lnPageX, lnPageY, lnPageWidth, lnPageHeight)
		        This.RenderSearch(lnPage)
		        This.RenderSelection(lnPage)
		    ENDIF
		    
		ENDFOR
		
		
	ENDPROC

	HIDDEN PROCEDURE rendersearch
		LPARAMETERS lnPage
		
		IF lnPage <> This.SearchState_ResPage
		    RETURN
		ENDIF
		
		
		LOCAL loGfx
		loGfx = This.DrawBufGfx
		
		LOCAL lnRectCount
		lnRectCount = LEN(This.SearchState_ResRect)/32
		
		LOCAL lnRect, lcRect
		FOR lnRect = 1 TO lnRectCount
		    
		    lcRect = SUBSTR(This.SearchState_ResRect, 32*(lnRect-1) + 1, 32)
		    
		    LOCAL lnPageLeft,lnPageTop,lnPageRight,lnPageBottom
		    lnPageLeft = CTOBIN(SUBSTR(lcRect,1,8),"B")
		    lnPageTop = CTOBIN(SUBSTR(lcRect,9,8),"B")
		    lnPageRight = CTOBIN(SUBSTR(lcRect,17,8),"B")
		    lnPageBottom = CTOBIN(SUBSTR(lcRect,25,8),"B")
		    
		       
		    LOCAL lnLeft, lnTop, lnRight, lnBottom
		    STORE 0h00000000 TO lnLeft, lnTop, lnRight, lnBottom
		    
		    IF FPDF_PageToDevice(This.FPDF_PAGES[lnPage], This.fpdf_pages_pos[lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[lnPage,3], This.fpdf_pages_pos[lnPage,4], 0, lnPageLeft, lnPageTop, @lnLeft, @lnTop) = 0
		        LOOP
		    ENDIF
		    
		    IF FPDF_PageToDevice(This.FPDF_PAGES[lnPage], This.fpdf_pages_pos[lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[lnPage,3], This.fpdf_pages_pos[lnPage,4], 0, lnPageRight, lnPageBottom, @lnRight, @lnBottom) = 0
		        LOOP
		    ENDIF
		
		    lnLeft = CTOBIN(lnLeft, "4RS")
		    lnTop = CTOBIN(lnTop, "4RS")
		    lnRight = CTOBIN(lnRight, "4RS")
		    lnBottom = CTOBIN(lnBottom, "4RS")
		    
		    loGfx.FillRectangle(This.SearchBrush, lnLeft, lnTop, lnRight - lnLeft, lnBottom - lnTop)
		ENDFOR
		
	ENDPROC

	HIDDEN PROCEDURE renderselection
		LPARAMETERS lnPage
		
		LOCAL loGfx
		loGfx = This.DrawBufGfx
		
		LOCAL lnRectCount
		lnRectCount = LEN(This.fpdf_pages_selection[lnPage,1])/32
		
		LOCAL lnRect, lcRect
		FOR lnRect = 1 TO lnRectCount
		    
		    lcRect = SUBSTR(This.fpdf_pages_selection[lnPage,1], 32*(lnRect-1) + 1, 32)
		    
		    LOCAL lnPageLeft,lnPageTop,lnPageRight,lnPageBottom
		    lnPageLeft = CTOBIN(SUBSTR(lcRect,1,8),"B")
		    lnPageTop = CTOBIN(SUBSTR(lcRect,9,8),"B")
		    lnPageRight = CTOBIN(SUBSTR(lcRect,17,8),"B")
		    lnPageBottom = CTOBIN(SUBSTR(lcRect,25,8),"B")
		    
		    
		    LOCAL lnLeft, lnTop, lnRight, lnBottom
		    STORE 0h00000000 TO lnLeft, lnTop, lnRight, lnBottom
		    
		    IF FPDF_PageToDevice(This.FPDF_PAGES[lnPage], This.fpdf_pages_pos[lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[lnPage,3], This.fpdf_pages_pos[lnPage,4], 0, lnPageLeft, lnPageTop, @lnLeft, @lnTop) = 0
		        LOOP
		    ENDIF
		    
		    IF FPDF_PageToDevice(This.FPDF_PAGES[lnPage], This.fpdf_pages_pos[lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[lnPage,3], This.fpdf_pages_pos[lnPage,4], 0, lnPageRight, lnPageBottom, @lnRight, @lnBottom) = 0
		        LOOP
		    ENDIF
		    
		    lnLeft = CTOBIN(lnLeft, "4RS")
		    lnTop = CTOBIN(lnTop, "4RS")
		    lnRight = CTOBIN(lnRight, "4RS")
		    lnBottom = CTOBIN(lnBottom, "4RS")
		    
		    loGfx.FillRectangle(This.SelectionBrush, lnLeft, lnTop, lnRight - lnLeft, lnBottom - lnTop)
		ENDFOR
		
	ENDPROC

	HIDDEN PROCEDURE Resize
		This.WndResize()
		
	ENDPROC

	PROCEDURE savedocument		&& Save document to file
		LPARAMETERS tcFileName
		
		IF EMPTY(This.fpdf_doc)
		    RETURN
		ENDIF
		
		IF VARTYPE(m.tcFileName) <> "C"
		    RETURN
		ENDIF
		
		
		LOCAL lcFileName
		lcFileName = ALLTRIM(EVL(NVL(m.tcFileName,""), ""))
		
		IF EMPTY(lcFileName)
		    RETURN
		ENDIF
		
		LOCAL lcErrMsg
		lcErrMsg = SPACE(500)
		FPDF_SaveDocument(This.fpdf_doc, lcFileName, @lcErrMsg, LEN(lcErrMsg))
		
		IF EMPTY(lcErrMsg)=.F.
		    This.ErrMsg(ALLTRIM(lcErrMsg))
		ENDIF
		
		
	ENDPROC

	HIDDEN PROCEDURE scale_assign
		LPARAMETERS vNewVal
		
		
		This.Scale = MIN(MAX(EVL(NVL(m.vNewVal,0),0),0.2),4)
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE scrollbars_assign
		LPARAMETERS vNewVal
		
		This.ScrollBars = IIF(INLIST(m.vNewVal, 0,1,2,3), m.vNewVal, This.ScrollBars)
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE scrollhorz
		LPARAMETERS tnScroll, tlPage, tlRelative
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL lnScroll
		lnScroll = EVL(NVL(m.tnScroll,0),0)
		
		DO CASE
		CASE m.tlPage=.F. AND m.tlRelative = .T.
		    This.ViewPortX = This.ViewPortX + m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .T.
		    This.ViewPortX = This.ViewPortX + m.lnScroll * This.ViewPortSizeX
		    
		CASE m.tlPage=.F. AND m.tlRelative = .F.
		    This.ViewPortX = m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .F.
		    This.ViewPortX = (m.lnScroll - 1) * This.ViewPortSizeX
		
		ENDCASE
		
		This.ViewPortUpdate()
		
		This.WndRedraw()
		
	ENDPROC

	HIDDEN PROCEDURE scrollvert
		LPARAMETERS tnScroll, tlPage, tlRelative
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL lnScroll
		lnScroll = EVL(NVL(m.tnScroll,0),0)
		
		DO CASE
		CASE m.tlPage=.F. AND m.tlRelative = .T.
		    This.ViewPortY = This.ViewPortY + m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .T.
		    This.ViewPortY = This.ViewPortY + m.lnScroll * This.ViewPortSizeY
		    
		CASE  m.tlPage=.F. AND m.tlRelative = .F.
		    This.ViewPortY = m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .F.
		    This.ViewPortY = (m.lnScroll - 1) * This.ViewPortSizeY
		
		ENDCASE
		
		This.ViewPortUpdate()
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE searchclose		&& Stop search
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.SearchState_FindWhat = ""
		This.SearchState_Flags = 0
		This.SearchState_Dir = 0
		
		This.SearchState_ResPage = 0
		This.SearchState_ResIndex = 0
		This.SearchState_ResCount = 0
		This.SearchState_ResRect = ""
		
		LOCAL lnPage
		FOR lnPage = 1 TO This.fpdf_pagecount
		    IF EMPTY(This.fpdf_pages_search[lnPage]) = .F.
		        FPDFText_FindClose(This.fpdf_pages_search[lnPage])
		    ENDIF
		    
		    This.fpdf_pages_search[lnPage] = 0
		ENDFOR
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE searchtext		&& Text for searching. SearchClose must be called to stop search results rendering
		LPARAMETERS tcFindWhat, tnDirection, tlMatchCase, tlMatchWholeWorld
		
		* tcFindWhat - text to find
		* tnDirection - search direction: 1 - forward (default), 2 - backward
		* tlMatchCase - .T. - case sensitive, .F. - case insensitive (default)
		* tlMatchWholeWorld - .T. match whole word, .F. - not match whole word (default)
		
		* return value: -1 - error, 0 - not found, 1 - found, 2 - search ended
		
		#define SCH_ERROR -1
		#define SCH_NOT_FOUND 0
		#define SCH_FOUND 1
		#define SCH_ENDED 2
		
		#define SCH_FWD 1
		#define SCH_BCK 2
		
		
		IF This.fpdf_opened = .F.
		    RETURN SCH_ERROR
		ENDIF
		
		
		LOCAL lcFindWhat, lnDirection, llMatchCase, llMatchWholeWorld
		
		lcFindWhat = CHRTRAN(ALLTRIM(EVL(NVL(m.tcFindWhat,""),"")), CHR(10)+CHR(13)+CHR(9),"")
		lnDirection = EVL(NVL(m.tnDirection,0), SCH_FWD)
		llMatchCase = EMPTY(NVL(m.tlMatchCase,.F.))=.F.
		llMatchWholeWorld = EMPTY(NVL(m.tlMatchWholeWorld,.F.))=.F.
		
		
		* Flags used by FPDFText_FindStart function.
		*
		* If not set, it will not match case by default.
		#define FPDF_MATCHCASE 0x00000001
		* If not set, it will not match the whole word by default.
		#define FPDF_MATCHWHOLEWORD 0x00000002
		* If not set, it will skip past the current match to look for the next match.
		#define FPDF_CONSECUTIVE 0x00000004
		
		
		LOCAL lnSearchFlags
		lnSearchFlags = 0
		lnSearchFlags = lnSearchFlags + IIF(llMatchCase=.T., FPDF_MATCHCASE, 0)
		lnSearchFlags = lnSearchFlags + IIF(llMatchWholeWorld=.T., FPDF_MATCHWHOLEWORD, 0)
		
		LOCAL lnSearchStartIndex
		lnSearchStartIndex = IIF(lnDirection = SCH_BCK,-1,0)
		
		LOCAL llNewSearch
		llNewSearch = .F.
		DO CASE
		CASE lnDirection <> This.SearchState_Dir
		    llNewSearch = .T.
		CASE lnSearchFlags <> This.SearchState_Flags
		    llNewSearch = .T.
		CASE NOT lcFindWhat == This.SearchState_FindWhat
		    llNewSearch = .T.
		ENDCASE
		
		IF llNewSearch = .T.
		    LOCAL lnSearchState_ResPage
		    lnSearchState_ResPage = 0
		
		    IF lcFindWhat == This.SearchState_FindWhat AND BETWEEN(This.SearchState_ResPage, This.fpdf_page_first_visible, This.fpdf_page_last_visible)
		        lnSearchState_ResPage = This.SearchState_ResPage
		        lnSearchStartIndex = MAX(This.SearchState_ResIndex + IIF(lnDirection = SCH_BCK,-1,0),0)
		    ENDIF
		
		    This.SearchClose()
		    This.SearchState_ResPage = lnSearchState_ResPage
		ENDIF
		
		
		This.SearchState_FindWhat = lcFindWhat
		This.SearchState_Flags = lnSearchFlags
		This.SearchState_Dir = lnDirection
		
		
		
		IF EMPTY(lcFindWhat)
		    RETURN SCH_NOT_FOUND
		ENDIF
		
		
		
		LOCAL lnLocaleId
		lnLocaleId = This.i18n.GetLocaleID()
		
		LOCAL lcFindWhatUnicode
		lcFindWhatUnicode = ""
		
		LOCAL loErr
		loErr = .F.
		TRY
		    lcFindWhatUnicode = STRCONV(lcFindWhat, 5, lnLocaleId) + CHR(0)
		CATCH TO loErr
		    This.ErrMsg(loErr)
		ENDTRY
		
		IF LEN(lcFindWhatUnicode) = 0
		    RETURN SCH_ERROR
		ENDIF
		
		
		LOCAL lnPageIndex
		lnPageIndex = EVL(This.SearchState_ResPage, EVL(This.fpdf_page_first_visible,1))
		
		DO WHILE lnPageIndex > 0 AND lnPageIndex <= This.fpdf_pagecount
		
		    LOCAL lnFPDF_Text_Page
		    lnFPDF_Text_Page = This.fpdf_text_pages[lnPageIndex]
		    
		    LOCAL lnSearchHandle
		    lnSearchHandle = This.fpdf_pages_search[lnPageIndex]
		
		    IF EMPTY(lnSearchHandle)
		        lnSearchHandle = FPDFText_FindStart(lnFPDF_Text_Page, lcFindWhatUnicode, lnSearchFlags, lnSearchStartIndex)
		
		        IF EMPTY(lnSearchHandle)
		            RETURN SCH_ERROR
		        ENDIF
		
		        This.fpdf_pages_search[lnPageIndex] = lnSearchHandle
		    ENDIF
		
		
		    LOCAL lnFindRes
		    lnFindRes = 0
		    DO CASE
		    CASE lnDirection = SCH_FWD
		        lnFindRes = FPDFText_FindNext(lnSearchHandle)
		    CASE lnDirection = SCH_BCK
		        lnFindRes = FPDFText_FindPrev(lnSearchHandle)
		    ENDCASE
		
		
		    IF lnFindRes = 1
		        This.SearchState_ResPage = lnPageIndex
		        This.SearchState_ResIndex = MAX(FPDFText_GetSchResultIndex(lnSearchHandle),0)
		        This.SearchState_ResCount = MAX(FPDFText_GetSchCount(lnSearchHandle),0)
		
		
		        LOCAL lnRectCount
		        IF This.SearchState_ResCount > 0
		            lnRectCount = FPDFText_CountRects(lnFPDF_Text_Page, This.SearchState_ResIndex, This.SearchState_ResCount)
		        ELSE
		            lnRectCount = 0
		        ENDIF
		
		        This.SearchState_ResRect = ""
		        
		        LOCAL lnPageLeft as Double, lnPageRight as Double, lnPageBottom as Double, lnPageTop as Double
		        STORE 0 TO lnPageLeft, lnPageRight, lnPageBottom, lnPageTop
		
		        LOCAL lnRect
		        FOR lnRect=1 TO lnRectCount
		            IF FPDFText_GetRect(lnFPDF_Text_Page, lnRect-1, @lnPageLeft, @lnPageTop, @lnPageRight, @lnPageBottom) > 0
		                This.SearchState_ResRect = This.SearchState_ResRect + BINTOC(lnPageLeft,"8")+BINTOC(lnPageTop,"8")+BINTOC(lnPageRight,"8")+BINTOC(lnPageBottom,"8")
		                
		                IF lnRect = 1
		                    LOCAL lnLeft, lnTop
		                    STORE 0h00000000 TO lnLeft, lnTop
		                    
		                    IF FPDF_PageToDevice(This.FPDF_PAGES[lnPageIndex], 0, 0, This.fpdf_pages_pos[lnPageIndex,3], This.fpdf_pages_pos[lnPageIndex,4], 0, lnPageLeft, lnPageTop, @lnLeft, @lnTop) > 0
		                        lnLeft = CTOBIN(lnLeft, "4RS")
		                        lnTop = CTOBIN(lnTop, "4RS")
		                    
		                        LOCAL lnScrollVert
		                        lnScrollVert = This.fpdf_pages_pos[lnPageIndex,2] + lnTop
		                        lnScrollVert = lnScrollVert - This.ViewPortSizeY * 0.5
		                        This.ScrollVert(lnScrollVert)
		
		                        LOCAL lnScrollHorz
		                        lnScrollHorz = This.fpdf_pages_pos[lnPageIndex,1] + lnLeft
		                        lnScrollHorz = lnScrollHorz - This.ViewPortSizeX * 0.5
		                        This.ScrollHorz(lnScrollHorz)
		                    ENDIF
		                ENDIF
		            ENDIF
		        ENDFOR
		
		        This.WndRedraw()
		        RETURN SCH_FOUND
		    ENDIF
		
		
		    IF lnDirection = SCH_BCK
		        lnPageIndex = lnPageIndex - 1
		        lnSearchStartIndex = -1
		    ELSE
		        lnPageIndex = lnPageIndex + 1
		        lnSearchStartIndex = 0
		    ENDIF
		
		ENDDO
		
		
		IF EMPTY(This.SearchState_ResCount)=.F.
		    RETURN SCH_ENDED
		ELSE
		    RETURN SCH_NOT_FOUND
		ENDIF
		
	ENDPROC

	PROCEDURE selectioncopy		&& Copy selected text to clipboard
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		#define CF_TEXT       1
		#define CF_UNICODETEXT 13
		#DEFINE CF_LOCALE     16
		#define GMEM_MOVEABLE 0x0002
		#define GMEM_ZEROINIT 0x0040
		
		
		LOCAL lcCopyText
		lcCopyText = ""
		
		LOCAL lnPage, lnFPDF_TEXT_PAGE, lnSelStart, lnSelCount
		FOR lnPage = 1 TO This.fpdf_pagecount
		
		    lnFPDF_TEXT_PAGE = This.FPDF_TEXT_PAGES[lnPage]
		    lnSelStart = EVL(This.fpdf_pages_selection[lnPage,2],0)
		    lnSelCount = EVL(This.fpdf_pages_selection[lnPage,3],0)
		    
		    IF lnSelCount = 0
		        LOOP
		    ENDIF
		    
		    LOCAL lcBuffer, lnBufLen
		    lcBuffer = REPLICATE(CHR(0), lnSelCount * 2)
		    lnBufLen = FPDFText_GetText(lnFPDF_TEXT_PAGE, lnSelStart, lnSelCount, @lcBuffer)
		    
		    IF lnBufLen > 0
		        lcCopyText = lcCopyText + lcBuffer
		    ENDIF
		
		ENDFOR
		
		IF EMPTY(lcCopyText)=.F.
		    
		    LOCAL lnCopyTextLen
		    lnCopyTextLen = LEN(lcCopyText)
		
		    LOCAL lnDefaultLocaleID
		    lnDefaultLocaleID = EVL(WinApi_GetSystemDefaultLCID(), 1033) &&English LocaleID = 1033
		
		    IF WinApi_OpenClipboard(0) = 0
		        RETURN
		    ENDIF
		    
		    WinApi_EmptyClipboard()
		
		    LOCAL lnMemHandle
		    lnMemHandle = WinApi_GlobalAlloc(GMEM_MOVEABLE + GMEM_ZEROINIT, lnCopyTextLen+2)
		    
		    IF lnMemHandle <> 0
		        LOCAL lnMemPtr
		        lnMemPtr = WinApi_GlobalLock(lnMemHandle)
		        IF lnMemPtr <> 0
		            SYS(2600, lnMemPtr, lnCopyTextLen, lcCopyText)
		        ENDIF
		        WinApi_GlobalUnlock(lnMemHandle)
		        
		        WinApi_SetClipboardData(CF_UNICODETEXT, lnMemHandle)
		        
		        WinAPI_GlobalFree(lnMemHandle)
		    ENDIF
		
		
		    LOCAL lnMemHandle
		    lnMemHandle = WinApi_GlobalAlloc(GMEM_MOVEABLE + GMEM_ZEROINIT, 4)
		    IF lnMemHandle <> 0
		        LOCAL lnMemPtr
		        lnMemPtr = WinApi_GlobalLock(lnMemHandle)
		        IF lnMemPtr <> 0
		            SYS(2600, lnMemPtr, 4, BINTOC(lnDefaultLocaleID, "4RS"))
		        ENDIF
		        WinApi_GlobalUnlock(lnMemHandle)
		        
		        WinApi_SetClipboardData(CF_LOCALE, lnMemHandle)
		        
		        WinAPI_GlobalFree(lnMemHandle)
		    ENDIF
		
		    WinApi_CloseClipboard()
		
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE selecttext
		LPARAMETERS tnPage, tnStartIndex, tnCount
		
		* tnPage - page index, from 1 to This.fpdf_pagecount, 0 for all pages
		* tnStartIndex - Index for the start character (zero-based)
		* tnCount - Number of characters, or -1 for all remaining.
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL lnPage, lnStartIndex, lnCount
		lnPage = EVL(m.tnPage,0)
		lnStartIndex = EVL(m.tnStartIndex,0)
		lnCount = EVL(m.tnCount, 0)
		
		IF lnStartIndex < 0
		    RETURN
		ENDIF
		IF lnCount < -1
		    RETURN
		ENDIF
		
		
		LOCAL lnPageStart, lnPageEnd
		lnPageStart = EVL(lnPage,1)
		lnPageEnd = EVL(lnPage,This.fpdf_pagecount)
		
		FOR lnPage = lnPageStart TO lnPageEnd
		    LOCAL lnFPDF_Text_Page
		    lnFPDF_Text_Page = This.fpdf_text_pages[lnPage]
		
		    LOCAL lnCountChars
		    DO CASE
		    CASE lnCount = 0
		        lnCountChars = 0
		         
		    CASE lnCount = -1
		        lnCountChars = MAX(FPDFText_CountChars(lnFPDF_Text_Page) - lnStartIndex,0)
		
		    CASE FPDFText_CountChars(lnFPDF_Text_Page) >= lnStartIndex + lnCount
		        lnCountChars = lnCount
		
		    OTHERWISE
		        lnCountChars = 0
		
		    ENDCASE
		    
		    LOCAL lnRectCount
		    IF lnCountChars > 0
		        lnRectCount = FPDFText_CountRects(lnFPDF_Text_Page, lnStartIndex, lnCountChars)
		    ELSE
		        lnRectCount = 0
		    ENDIF
		
		    IF lnRectCount > 0 
		        This.fpdf_pages_selection[lnPage,1] = ""
		        This.fpdf_pages_selection[lnPage,2] = lnStartIndex
		        This.fpdf_pages_selection[lnPage,3] = lnCountChars
		
		        LOCAL lnPageLeft as Double, lnPageRight as Double, lnPageBottom as Double, lnPageTop as Double
		        STORE 0 TO lnPageLeft, lnPageRight, lnPageBottom, lnPageTop
		
		        LOCAL lnRect
		        FOR lnRect=1 TO lnRectCount
		            IF FPDFText_GetRect(lnFPDF_Text_Page, lnRect-1, @lnPageLeft, @lnPageTop, @lnPageRight, @lnPageBottom) > 0
		                This.fpdf_pages_selection[lnPage,1] = This.fpdf_pages_selection[lnPage,1] + BINTOC(lnPageLeft,"8")+BINTOC(lnPageTop,"8")+BINTOC(lnPageRight,"8")+BINTOC(lnPageBottom,"8")
		            ENDIF
		        ENDFOR
		    ELSE
		        This.fpdf_pages_selection[lnPage,1] = ""
		        This.fpdf_pages_selection[lnPage,2] = 0
		        This.fpdf_pages_selection[lnPage,3] = 0
		    ENDIF
		    
		ENDFOR
		
		This.Redraw()
		
	ENDPROC

	PROCEDURE selecttextall		&& Select all text in the document
		This.SelectText(0,0,-1)
		
	ENDPROC

	HIDDEN PROCEDURE viewportupdate
		LOCAL lnVewPortUpdateStep
		lnVewPortUpdateStep = 1
		
		FOR lnVewPortUpdateStep = 1 TO 2
		
		    This.fpdf_page_first_visible = 0
		    This.fpdf_page_last_visible = 0
		
		    *********************************************************************
		
		    This.ViewPortSizeX = MAX(This.Width - IIF(INLIST(This.ScrollBars,2,3), SYSMETRIC(5),0), 0)
		    This.ViewPortSizeY = MAX(This.Height - IIF(INLIST(This.ScrollBars,1,3), SYSMETRIC(8),0), 0)
		
		
		    *********************************************************************
		
		    IF This.ViewPortMaxX > This.ViewPortSizeX
		        This.ViewPortX = MIN(MAX(-0.5 * (This.ViewPortMaxX - This.ViewPortSizeX), This.ViewPortX), MAX(0.5 * (This.ViewPortMaxX - This.ViewPortSizeX),0))
		    ELSE
		        This.ViewPortX = 0
		    ENDIF    
		
		    This.ViewPortY = MIN(MAX(This.ViewPortY,0), MAX(This.ViewPortMaxY - This.Height,0))
		
		
		
		
		    LOCAL lnViewPortMaxXNew
		    lnViewPortMaxXNew = 0
		
		    *********************************************************************
		    LOCAL lnPageX, lnPageY
		    STORE 0 TO lnPageX, lnPageY
		
		    LOCAL lnPageWidthUnscaled, lnPageHeightUnscaled
		    LOCAL lnPageWidthUnscaledFirst
		    LOCAL lnPageWidth, lnPageHeight
		
		
		    LOCAL lnPageCount, lnPage
		    lnPageCount = This.FPDF_PageCount
		
		    FOR lnPage = 1 TO lnPageCount
		        
		        lnPageWidthUnscaled = This.GetPageSize(lnPage,3)
		        lnPageHeightUnscaled = This.GetPageSize(lnPage,4)
		        
		        IF lnPage = 1
		            lnPageWidthUnscaledFirst = lnPageWidthUnscaled
		        ENDIF
		
		        lnPageWidth = lnPageWidthUnscaled
		        lnPageHeight = lnPageHeightUnscaled
		
		        IF This.FitWidth
		            lnPageWidth = This.ViewPortSizeX * lnPageWidthUnscaled / EVL(lnPageWidthUnscaledFirst, lnPageWidthUnscaled)
		            lnPageHeight = INT(lnPageHeight * lnPageWidth / EVL(lnPageWidthUnscaled,1))
		        ENDIF
		        
		        lnPageWidth = lnPageWidth * This.scale
		        lnPageHeight = lnPageHeight * This.scale    
		        
		        lnPageX = (This.ViewPortSizeX - lnPageWidth) * 0.5
		        
		        IF lnPage > 1
		            lnPageY = lnPageY +  MIN(MAX(INT(lnPageWidth * 0.02),5),40) &&page separator
		        ENDIF
		        
		        This.fpdf_pages_pos[lnPage,1] = lnPageX
		        This.fpdf_pages_pos[lnPage,2] = lnPageY
		
		        This.fpdf_pages_pos[lnPage,3] = lnPageWidth
		        This.fpdf_pages_pos[lnPage,4] = lnPageHeight
		       
		        DO CASE
		        CASE This.Width < 30
		        CASE lnPageY + lnPageHeight < This.ViewPortY
		        CASE lnPageY > This.ViewPortY + This.ViewPortSizeY
		        OTHERWISE
		
		            IF This.fpdf_page_first_visible = 0
		                This.fpdf_page_first_visible = lnPage
		            ENDIF
		            
		            This.fpdf_page_last_visible = lnPage
		            
		        ENDCASE
		        
		      
		        lnPageY = lnPageY + lnPageHeight
		        
		        lnViewPortMaxXNew = MAX(lnViewPortMaxXNew, lnPageWidth)
		        
		    ENDFOR
		
		
		    *********************************************************************
		    IF This.ViewPortMaxX > 0 && Adjust ViewPortX after scaling
		        This.ViewPortX = INT(This.ViewPortX * lnViewPortMaxXNew * 10000 / This.ViewPortMaxX) / 10000
		    ENDIF
		
		    This.ViewPortMaxX = lnViewPortMaxXNew
		
		    *********************************************************************
		    LOCAL lnViewPortYPrev
		    lnViewPortYPrev = This.ViewPortY
		
		    LOCAL lnViewPortMaxYNew
		    lnViewPortMaxYNew = lnPageY
		    
		    IF This.ViewPortMaxY > 0 && Adjust ViewPortY after scaling
		        This.ViewPortY = INT(This.ViewPortY * lnViewPortMaxYNew * 10000 / This.ViewPortMaxY) / 10000
		    ENDIF
		    
		    This.ViewPortMaxY = lnViewPortMaxYNew
		    
		    
		    IF lnViewPortYPrev <> This.ViewPortY
		        * ViewPortY changed, need to recalculate page visibility
		        * Go to the second step
		        LOOP 
		    ENDIF
		    
		    EXIT 
		
		ENDFOR
		
		
		*********************************************************************
		* Scrollbars update
		*********************************************************************
		IF EMPTY(This.WndHandle)=.T.
		    RETURN
		ENDIF
		
		#define SIF_RANGE 0x0001
		#define SIF_PAGE 0x0002
		#define SIF_POS 0x0004
		#define SIF_DISABLENOSCROLL 0x0008
		
		*********************************************************************
		* Vertical scrollbar update
		
		LOCAL lnScrollMin, lnScrollMax, lnScrollPageSize, lnScrollPos
		IF INLIST(This.ScrollBars,2,3) AND This.ViewPortSizeY > 0
		    lnScrollMin = 0
		    lnScrollMax = This.ViewPortMaxY
		    lnScrollPageSize = This.ViewPortSizeY
		    lnScrollPos = This.ViewPortY
		ELSE
		    lnScrollMin = 0
		    lnScrollMax = 0
		    lnScrollPageSize = 0
		    lnScrollPos = 0
		ENDIF
		
		LOCAL lcScrollInfo
		lcScrollInfo = ;
		    BINTOC(28, "4RS")+;
		    BINTOC(SIF_RANGE+SIF_PAGE+SIF_POS, "4RS")+;
		    BINTOC(lnScrollMin, "4RS")+;
		    BINTOC(lnScrollMax, "4RS")+;
		    BINTOC(lnScrollPageSize, "4RS")+;
		    BINTOC(lnScrollPos, "4RS")+;
		    BINTOC(0, "4RS")
		
		WinApi_SetScrollInfo(This.WndHandle, 1, lcScrollInfo, 1)
		
		
		*********************************************************************
		* Horizontal scrollbar update
		
		LOCAL lnScrollMin, lnScrollMax, lnScrollPageSize, lnScrollPos
		IF INLIST(This.ScrollBars,1,3) AND This.ViewPortMaxX > This.ViewPortSizeX AND This.ViewPortSizeX > 0
		    lnScrollMin = -0.5 * (This.ViewPortMaxX - This.ViewPortSizeX)
		    lnScrollMax = 0.5 * (This.ViewPortMaxX - This.ViewPortSizeX)
		    lnScrollPageSize = This.ViewPortSizeX
		    lnScrollMax = lnScrollMax + lnScrollPageSize
		    lnScrollPos = MIN(MAX(lnScrollMin, This.ViewPortX), lnScrollMax)
		ELSE
		    lnScrollMin = 0
		    lnScrollMax = 0
		    lnScrollPageSize = 0
		    lnScrollPos = 0
		ENDIF
		
		LOCAL lcScrollInfo
		lcScrollInfo = ;
		    BINTOC(28, "4RS")+;
		    BINTOC(SIF_RANGE+SIF_PAGE+SIF_POS, "4RS")+;
		    BINTOC(lnScrollMin, "4RS")+;
		    BINTOC(lnScrollMax, "4RS")+;
		    BINTOC(lnScrollPageSize, "4RS")+;
		    BINTOC(lnScrollPos, "4RS")+;
		    BINTOC(0, "4RS")
		
		WinApi_SetScrollInfo(This.WndHandle, 0, lcScrollInfo, 1)
		
		
		*********************************************************************
		* Events triggering
		This.AfterViewportUpdate()
		*********************************************************************
		
		
	ENDPROC

	HIDDEN PROCEDURE wndcreate
		
		#DEFINE WNDCLASSEX_SIZE 48
		#DEFINE GW_CHILD 5
		#DEFINE GWL_WNDPROC -4
		#DEFINE GWL_HINSTANCE -6
		#DEFINE GWL_STYLE -16
		#define CS_OWNDC            0x0020
		#define CS_PARENTDC         0x0080
		#define WS_CHILD            0x40000000
		#define WS_DISABLED         0x08000000
		#define WS_VISIBLE          0x10000000
		#define WS_CLIPSIBLINGS     0x04000000
		#define WS_CLIPCHILDREN     0x02000000
		#define WS_VSCROLL          0x00200000
		#define WS_HSCROLL          0x00100000
		#define GMEM_FIXED 0x0
		#define GMEM_ZEROINIT 0x0040
		
		
		LOCAL lhWndParent
		lhWndParent = WinApi_GetWindow(Thisform.HWnd, GW_CHILD) && VFP window with ScrollBars != 0 or with ShowWindow = 2 - As Top-Level Form creates his own child window
		IF EMPTY(lhWndParent) = .F. AND Thisform.ShowWindow = 2 AND Thisform.ScrollBars <> 0
		    lhWndParent = EVL(WinApi_GetWindow(lhWndParent, GW_CHILD), lhWndParent)
		ENDIF
		IF EMPTY(lhWndParent)=.T. OR (Thisform.ScrollBars = 0 AND Thisform.ShowWindow <> 2)
		    lhWndParent = Thisform.HWnd
		ENDIF
		
		LOCAL lhInstance
		lhInstance = WinApi_GetModuleHandle(0)
		
		
		LOCAL lcWndClassEx
		lcWndClassEx = REPLICATE(CHR(0), WNDCLASSEX_SIZE)
		
		IF EMPTY( WinApi_GetClassInfoEx(lhInstance, This.WndClassName, @lcWndClassEx) )
		
		    LOCAL lnWndClassNamePtr
		    lnWndClassNamePtr = WinApi_GlobalAlloc(GMEM_FIXED + GMEM_ZEROINIT, LEN(This.WndClassName)+1)
		
		    SYS(2600, lnWndClassNamePtr, LEN(This.WndClassName), This.WndClassName)
		
		    lcWndClassEx = ;
		        BINTOC(WNDCLASSEX_SIZE, "4RS")+; &&cbSize
		        BINTOC(CS_PARENTDC,"4RS")+; &&style
		        BINTOC(WinApi_GetWindowLong(Application.HWnd, GWL_WNDPROC),"4RS")+; &&lpfnWndProc
		        BINTOC(0,"4RS")+; &&cbClsExtra
		        BINTOC(0,"4RS")+; &&cbWndExtra
		        BINTOC(lhInstance,"4RS")+; &&hInstance
		        BINTOC(0,"4RS")+; &&hIcon
		        BINTOC(0,"4RS")+; &&hCursor
		        BINTOC(0,"4RS")+; &&hbrBackground
		        BINTOC(0,"4RS")+; &&lpszMenuName
		        BINTOC(lnWndClassNamePtr,"4RS")+; &&lpszClassName
		        BINTOC(0,"4RS") &&hIconSm
		
		    WinApi_RegisterClassEx(lcWndClassEx)
		
		    WinApi_GlobalFree(lnWndClassNamePtr)
		    
		ENDIF
		
		
		This.WndHandle = WinApi_CreateWindowEx( ;
		    0, ;
		    This.WndClassName, ;
		    "", ;
		    WS_CHILD + WS_CLIPCHILDREN + WS_CLIPSIBLINGS + WS_HSCROLL + WS_VSCROLL, ;
		    0,0,1,1, ;
		    lhWndParent, ;
		    0, ;
		    lhInstance, ;
		    0)
		
		
		IF EMPTY(This.WndHandle)=.T.
		    This.errMsg("WinApi_CreateWindowEx returned 0")
		    RETURN
		ENDIF
		
		******************************************************
		This.WndDC = WinApi_GetDC(This.WndHandle)
		
		
		******************************************************
		#define WM_PAINT 0x000F
		BINDEVENT(This.WndHandle, WM_PAINT, This, "WndProc")
		
		#define WM_MOUSEACTIVATE 0x0021
		BINDEVENT(This.WndHandle, WM_MOUSEACTIVATE, This, "WndProc")
		
		#define WM_MOUSEMOVE 0x0200
		#define WM_LBUTTONDOWN 0x0201
		#define WM_RBUTTONUP 0x0205
		#define WM_MOUSEWHEEL 0x020A
		BINDEVENT(This.WndHandle, WM_MOUSEMOVE, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_LBUTTONDOWN, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_RBUTTONUP, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_MOUSEWHEEL, This, "WndProc")
		
		#define WM_VSCROLL 0x0115
		BINDEVENT(This.WndHandle, WM_VSCROLL, This, "WndProc")
		
		#define WM_HSCROLL 0x0114
		BINDEVENT(This.WndHandle, WM_HSCROLL, This, "WndProc")
		
		
		
	ENDPROC

	PROCEDURE wndproc		&& Events handler of PdfiumViewer internal window. Developer must not use or redefine this method
		LPARAMETERS thWnd, tnMsg, tnWParam, tnLParam
		
		#define GWL_WNDPROC -4
		#define WM_PAINT  0x000F
		#define WM_MOUSEACTIVATE 0x0021
		#define WM_VSCROLL 0x0115
		#define WM_HSCROLL 0x0114
		#define WM_MOUSEMOVE 0x0200
		#define WM_LBUTTONDOWN 0x0201
		#define WM_RBUTTONUP 0x0205
		#define WM_MOUSEWHEEL 0x020A
		#define MK_LBUTTON 0x0001
		#define MK_RBUTTON 0x0002
		#define MK_SHIFT 0x0004
		#define MK_CONTROL 0x0008
		
		
		#define SB_LINEUP           0
		#define SB_LINELEFT         0
		#define SB_LINEDOWN         1
		#define SB_LINERIGHT        1
		#define SB_PAGEUP           2
		#define SB_PAGELEFT         2
		#define SB_PAGEDOWN         3
		#define SB_PAGERIGHT        3
		#define SB_THUMBPOSITION    4
		#define SB_THUMBTRACK       5
		#define SB_TOP              6
		#define SB_LEFT             6
		#define SB_BOTTOM           7
		#define SB_RIGHT            7
		#define SB_ENDSCROLL        8
		#define SIF_TRACKPOS 0x0010
		#define SB_SCROLLINFO_TRACKPOS BINTOC(28, "4RS")+BINTOC(SIF_TRACKPOS, "4RS")+REPLICATE(CHR(0),20)
		
		
		LOCAL lnRetVal
		lnRetVal = 0
		
		DO CASE
		
		CASE This.UIState.GetEffectivelyVisible() = .F.
		 
		CASE m.tnMsg = WM_PAINT
		
		    LOCAL lcPaint
		    lcPaint = REPLICATE(CHR(0), 256)
		
		    LOCAL lnWndDC
		    lnWndDC = WinApi_BeginPaint(m.thWnd, @lcPaint)
		
		    This.Redraw(lnWndDC)
		
		    WinApi_EndPaint(m.thWnd, lcPaint)
		
		
		CASE This.UIState.GetEffectivelyEnabled() = .F.
		 
		
		CASE m.tnMsg = WM_MOUSEACTIVATE
		    IF This.IsFocused = .F.
		        LOCAL lSaveMousePointer
		        lSaveMousePointer = This.MousePointer
		        IF TYPE("Application.ActiveForm.HWnd") = "N"
		            IF Application.ActiveForm.WindowType <> 1 OR Application.ActiveForm.HWnd = Thisform.HWnd
		                This.SetFocus()
		            ENDIF
		        ENDIF
		        This.MousePointer = lSaveMousePointer
		    ENDIF
		    
		CASE INLIST(m.tnMsg, WM_MOUSEMOVE, WM_MOUSEWHEEL, WM_LBUTTONDOWN, WM_RBUTTONUP) 
		    LOCAL lnMBtn, lnMShift, lnMouseX, lnMouseY
		    lnMBtn = BITAND(m.tnWParam, MK_LBUTTON + MK_RBUTTON)
		    lnMShift = BITRSHIFT(BITAND(m.tnWParam, MK_SHIFT + MK_CONTROL),2)
		    lnMouseX = BITAND(m.tnLParam, 0xffff)
		    lnMouseY = BITAND(BITRSHIFT(m.tnLParam,16), 0xffff)
		    
		    DO CASE
		    
		    CASE INLIST(m.tnMsg, WM_MOUSEMOVE) AND This.IsFocused
		        This.MouseMove(lnMBtn, lnMShift, lnMouseX, lnMouseY)
		 
		    CASE INLIST(m.tnMsg, WM_MOUSEWHEEL)
		        LOCAL lnMWDir 
		        lnMWDir = BITAND(BITRSHIFT(m.tnWParam,16), 0xffff)
		        lnMWDir = IIF(BITTEST(lnMWDir,15), lnMWDir - 0xffff, lnMWDir)
		        
		        This.MouseWheel(lnMWDir, lnMShift, lnMouseX, lnMouseY)
		
		    CASE INLIST(m.tnMsg, WM_LBUTTONDOWN) AND This.IsFocused
		        This.MouseDown(1, lnMShift, lnMouseX, lnMouseY)
		        
		    CASE INLIST(m.tnMsg, WM_RBUTTONUP) AND This.IsFocused
		        This.MouseUp(2, lnMShift, lnMouseX, lnMouseY)
		
		    ENDCASE
		    
		    
		CASE m.tnMsg = WM_VSCROLL
		
		    LOCAL lnSbReq
		    lnSbReq = BITAND(m.tnWParam, 0xffff)
		     
		    DO CASE
		    CASE lnSbReq = SB_LINEUP
		       This.ScrollVert(-0.05 * This.Height, .F., .T.)
		
		    CASE lnSbReq = SB_LINEDOWN
		       This.ScrollVert(0.05 * This.Height, .F., .T.)
		
		    CASE lnSbReq = SB_PAGEUP
		       This.ScrollVert(-1, .T., .T.)
		
		    CASE lnSbReq = SB_PAGEDOWN
		       This.ScrollVert(1, .T., .T.)
		
		    CASE lnSbReq = SB_TOP
		       This.ScrollVert(0, .F., .F.)
		
		    CASE lnSbReq = SB_BOTTOM
		       This.ScrollVert(This.ViewPortMaxY, .F., .F.)
		
		    CASE lnSbReq = SB_THUMBTRACK
		       LOCAL lcScrollInfo
		       lcScrollInfo = SB_SCROLLINFO_TRACKPOS
		
		       IF WinApi_GetScrollInfo(m.thWnd, 1, @lcScrollInfo) = 1
		           LOCAL lnSbPos
		           lnSbPos = CTOBIN(SUBSTR(lcScrollInfo,25,4),"4RS")
		           This.ScrollVert(lnSbPos)
		       ENDIF
		    ENDCASE
		
		
		CASE m.tnMsg = WM_HSCROLL
		
		    LOCAL lnSbReq
		    lnSbReq = BITAND(m.tnWParam, 0xffff)
		     
		    DO CASE
		    CASE lnSbReq = SB_LINELEFT
		       This.ScrollHorz(-0.05 * This.Width, .F., .T.)
		
		    CASE lnSbReq = SB_LINERIGHT
		       This.ScrollHorz(0.05 * This.Width, .F., .T.)
		
		    CASE lnSbReq = SB_PAGELEFT
		       This.ScrollHorz(-1, .T., .T.)
		
		    CASE lnSbReq = SB_PAGERIGHT
		       This.ScrollHorz(1, .T., .T.)
		
		    CASE lnSbReq = SB_LEFT
		       This.ScrollHorz(-This.ViewPortMaxY, .F., .F.)
		
		    CASE lnSbReq = SB_RIGHT
		       This.ScrollHorz(This.ViewPortMaxY, .F., .F.)
		
		    CASE lnSbReq = SB_THUMBTRACK
		       LOCAL lcScrollInfo
		       lcScrollInfo = SB_SCROLLINFO_TRACKPOS
		
		       IF WinApi_GetScrollInfo(m.thWnd, 0, @lcScrollInfo) = 1
		           LOCAL lnSbPos
		           lnSbPos = CTOBIN(SUBSTR(lcScrollInfo,25,4),"4RS")
		           This.ScrollHorz(lnSbPos)
		       ENDIF
		    ENDCASE
		
		
		OTHERWISE
		    LOCAL lnWndProcDefault
		    lnWndProcDefault = WinApi_GetWindowLong(m.thWnd, GWL_WNDPROC)
		    lnRetVal = WinApi_CallWindowProc(lnWndProcDefault, m.thWnd, m.tnMsg, m.tnWParam, m.tnLParam)
		
		ENDCASE
		
		
		RETURN lnRetVal
		
	ENDPROC

	HIDDEN PROCEDURE wndredraw
		IF EMPTY(This.WndHandle)
		    RETURN
		ENDIF
		
		WinApi_InvalidateRect(This.WndHandle, 0, 1)
		
	ENDPROC

	HIDDEN PROCEDURE wndrelease
		IF EMPTY(This.WndDC) = .F.
		    WinApi_ReleaseDC(This.WndHandle, This.WndDC)
		    This.WndDC = 0
		ENDIF
		
		IF EMPTY(This.WndHandle) = .F.
		    UNBINDEVENTS(This.WndHandle)
		    WinApi_DestroyWindow(This.WndHandle)
		    This.WndHandle = 0
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE wndresize
		IF EMPTY(This.WndHandle)
		    RETURN
		ENDIF
		
		This.ViewPortUpdate()
		This.DrawBufCreate()
		
		WinApi_MoveWindow(This.WndHandle, This.UIState.ObjToClient(2), This.UIState.ObjToClient(1), This.Width, This.Height, 1)
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE wndshow		&& Show child window (for internal use, public for bindevent)
		
		#define SW_HIDE 0
		#define SW_SHOWNA 8
		IF EMPTY(This.WndHandle)=.F.
		    WinApi_ShowWindow(This.WndHandle, IIF(This.UIState.GetEffectivelyVisible(), SW_SHOWNA, SW_HIDE))
		ENDIF
		
	ENDPROC

	PROCEDURE UIState.onvisible
		This.Parent.WndShow()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumviewer_cmdfocus AS commandbutton 		&& PdfiumViewer input focus holder. Library consumer must not use this class directly
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: this_access
	*</DefinedPropArrayMethod>

	*<PropValue>
		Caption = ""
		Enabled = .T.
		Height = 27
		Name = "pdfiumviewer_cmdfocus"
		Style = 0
		Visible = .T.
		Width = 27
	*</PropValue>
	
	HIDDEN PROCEDURE this_access
		LPARAMETERS cMember
		
		RETURN This.Parent
		
	ENDPROC

ENDDEFINE
