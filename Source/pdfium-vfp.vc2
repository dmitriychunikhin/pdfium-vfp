*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="pdfium-vfp.vcx" CPID="1251" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS pdfium_api_fpdf AS custom 		&& Pdfium API wrapper
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="CONST" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: fpdftext_closepage
		*m: fpdftext_countchars
		*m: fpdftext_countrects
		*m: fpdftext_getcharindexatpos
		*m: fpdftext_getrect
		*m: fpdftext_gettext
		*m: fpdftext_getunicode
		*m: fpdftext_loadpage
		*m: fpdf_closedocument
		*m: fpdf_closepage
		*m: fpdf_destroylibrary
		*m: fpdf_devicetopage
		*m: fpdf_getlasterror
		*m: fpdf_getpagecount
		*m: fpdf_getpageheight
		*m: fpdf_getpagesizebyindex
		*m: fpdf_getpagewidth
		*m: fpdf_initlibrarywithconfig
		*m: fpdf_loaddocument
		*m: fpdf_loadmemdocument
		*m: fpdf_loadpage
		*m: fpdf_pagetodevice
		*m: fpdf_renderpage
		*m: vfpdf_getfontfilename		&& pdfium-vfp.dll function; Gets font face name and returns font filename and simulations
		*m: vfpdf_savedocument		&& pdfium-vfp.dll function; Save pdf to the file
		*p: pdfium_dll_path		&& Path to file pdfium.dll
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_fpdf"
		pdfium_dll_path = ("")
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="fpdf_initlibrarywithconfig" type="method" display="FPDF_InitLibraryWithConfig"/>
			<memberdata name="pdfium_dll_path" type="property" display="pdfium_dll_path"/>
			<memberdata name="fpdf_destroylibrary" type="method" display="FPDF_DestroyLibrary"/>
			<memberdata name="fpdf_loaddocument" type="method" display="FPDF_LoadDocument"/>
			<memberdata name="fpdf_loadmemdocument" type="method" display="FPDF_LoadMemDocument"/>
			<memberdata name="fpdf_closedocument" type="method" display="FPDF_CloseDocument"/>
			<memberdata name="fpdf_getlasterror" type="method" display="FPDF_GetLastError"/>
			<memberdata name="fpdf_getpagecount" type="method" display="FPDF_GetPageCount"/>
			<memberdata name="fpdf_loadpage" type="method" display="FPDF_LoadPage"/>
			<memberdata name="fpdf_closepage" type="method" display="FPDF_ClosePage"/>
			<memberdata name="fpdf_renderpage" type="method" display="FPDF_RenderPage"/>
			<memberdata name="fpdftext_loadpage" type="method" display="FPDFText_LoadPage"/>
			<memberdata name="fpdftext_closepage" type="method" display="FPDFText_ClosePage"/>
			<memberdata name="fpdf_getpagesizebyindex" type="method" display="FPDF_GetPageSizeByIndex"/>
			<memberdata name="fpdf_getpagewidth" type="method" display="FPDF_GetPageWidth"/>
			<memberdata name="fpdf_getpageheight" type="method" display="FPDF_GetPageHeight"/>
			<memberdata name="fpdftext_countchars" type="method" display="FPDFText_CountChars"/>
			<memberdata name="fpdftext_getcharindexatpos" type="method" display="FPDFText_GetCharIndexAtPos"/>
			<memberdata name="fpdftext_gettext" type="method" display="FPDFText_GetText"/>
			<memberdata name="fpdftext_getunicode" type="method" display="FPDFText_GetUnicode"/>
			<memberdata name="fpdftext_countrects" type="method" display="FPDFText_CountRects"/>
			<memberdata name="fpdftext_getrect" type="method" display="FPDFText_GetRect"/>
			<memberdata name="fpdf_devicetopage" type="method" display="FPDF_DeviceToPage"/>
			<memberdata name="fpdf_pagetodevice" type="method" display="FPDF_PageToDevice"/>
			<memberdata name="vfpdf_getfontfilename" type="method" display="VFPDF_GetFontFilename"/>
			<memberdata name="vfpdf_savedocument" type="method" display="VFPDF_SaveDocument"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'CONST' AS pdfium_api_fpdf_const WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "CONST", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE fpdftext_closepage
		LPARAMETERS text_page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_ClosePage(m.text_page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDFText_ClosePage IN (This.pdfium_dll_path) AS FPDFText_ClosePage LONG text_page
		    m.lvRes = FPDFText_ClosePage(m.text_page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_countchars
		LPARAMETERS text_page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_CountChars(m.text_page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFText_CountChars IN (This.pdfium_dll_path) AS FPDFText_CountChars LONG text_page
		    m.lvRes = FPDFText_CountChars(m.text_page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_countrects
		LPARAMETERS text_page as Long, start_index as Integer, count as Intege
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_CountRects(m.text_page, m.start_index, m.count)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFText_CountRects IN (This.pdfium_dll_path) AS FPDFText_CountRects LONG text_page, integer start_index, integer count
		    m.lvRes = FPDFText_CountRects(m.text_page, m.start_index, m.count)
		ENDTRY
		
		RETURN m.lvRes
		
		
	ENDPROC

	PROCEDURE fpdftext_getcharindexatpos
		LPARAMETERS text_page as Long, x as Double, y as Double, xTolerance as Double, yTolerance as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_GetCharIndexAtPos(m.text_page, m.x, m.y, m.xTolerance, m.yTolerance)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFText_GetCharIndexAtPos IN (This.pdfium_dll_path) AS FPDFText_GetCharIndexAtPos LONG text_page, double x, double y, double xTolerance, double yTolerance
		    m.lvRes = FPDFText_GetCharIndexAtPos(m.text_page, m.x, m.y, m.xTolerance, m.yTolerance)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_getrect
		LPARAMETERS text_page as Long, rect_index as Integer, left as Double, top as Double, right as Double, bottom as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_GetRect(m.text_page, m.rect_index, @m.left, @m.top, @m.right, @m.bottom)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFText_GetRect IN (This.pdfium_dll_path) AS FPDFText_GetRect LONG text_page, integer rect_index, double @left, double @top, double @right, double @bottom
		    m.lvRes = FPDFText_GetRect(m.text_page, m.rect_index, @m.left, @m.top, @m.right, @m.bottom)
		ENDTRY
		
		RETURN m.lvRes
		
		
	ENDPROC

	PROCEDURE fpdftext_gettext
		LPARAMETERS text_page as Long, start_index as Integer, count as Integer, result as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_GetText(m.text_page, m.start_index, m.count, @m.result)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFText_GetText IN (This.pdfium_dll_path) AS FPDFText_GetText LONG text_page, integer start_index, integer count, STRING @result
		    m.lvRes = FPDFText_GetText(m.text_page, m.start_index, m.count, @m.result)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_getunicode
		LPARAMETERS text_page as Long, index as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_GetUnicode(m.text_page, m.index)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFText_GetUnicode IN (This.pdfium_dll_path) AS FPDFText_GetUnicode LONG text_page, integer index
		    m.lvRes = FPDFText_GetUnicode(m.text_page, m.index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_loadpage
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_LoadPage(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFText_LoadPage IN (This.pdfium_dll_path) AS FPDFText_LoadPage LONG page
		    m.lvRes = FPDFText_LoadPage(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_closedocument
		LPARAMETERS document as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_CloseDocument(m.document)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDF_CloseDocument IN (This.pdfium_dll_path) AS FPDF_CloseDocument LONG document
		    m.lvRes = FPDF_CloseDocument(m.document)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_closepage
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_ClosePage(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDF_ClosePage IN (This.pdfium_dll_path) AS FPDF_ClosePage LONG page
		    m.lvRes = FPDF_ClosePage(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_destroylibrary
		
		DECLARE FPDF_DestroyLibrary IN (This.pdfium_dll_path) AS FPDF_DestroyLibrary
		
		IF PEMSTATUS(Application, "pdfium_instance_count", 5)=.T.
		
		    IF Application.pdfium_instance_count = 1
		        FPDF_DestroyLibrary()
		    ENDIF
		
		    Application.pdfium_instance_count = MAX(Application.pdfium_instance_count - 1, 0)
		
		ENDIF
		
	ENDPROC

	PROCEDURE fpdf_devicetopage
		LPARAMETERS page as Long, start_x as Integer, start_y as Integer, size_x as Integer, size_y as Integer, rotate as Integer, device_x as Integer, device_y as Integer, page_x as Double, page_y as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = m.FPDF_DeviceToPage(m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.device_x, m.device_y, @m.page_x, @m.page_y)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDF_DeviceToPage IN (This.pdfium_dll_path) AS FPDF_DeviceToPage LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer device_x, integer device_y, double @page_x, double @page_y
		    m.lvRes = m.FPDF_DeviceToPage(m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.device_x, m.device_y, @m.page_x, @m.page_y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getlasterror
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetLastError()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDF_GetLastError IN (This.pdfium_dll_path) AS FPDF_GetLastError
		    m.lvRes = FPDF_GetLastError()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getpagecount
		LPARAMETERS document as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetPageCount(m.document)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDF_GetPageCount IN (This.pdfium_dll_path) AS FPDF_GetPageCount LONG document
		    m.lvRes = FPDF_GetPageCount(m.document)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getpageheight
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetPageHeight(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE double FPDF_GetPageHeight IN (This.pdfium_dll_path) AS FPDF_GetPageHeight LONG page
		    m.lvRes = FPDF_GetPageHeight(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getpagesizebyindex
		LPARAMETERS document as Long, page_index as Integer, width as Double, height as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetPageSizeByIndex(m.document, m.page_index, @m.width, @m.height)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDF_GetPageSizeByIndex IN (This.pdfium_dll_path) AS FPDF_GetPageSizeByIndex LONG document, integer page_index, double @width, double @height
		    m.lvRes = FPDF_GetPageSizeByIndex(m.document, m.page_index, @m.width, @m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getpagewidth
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetPageWidth(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE double FPDF_GetPageWidth IN (This.pdfium_dll_path) AS FPDF_GetPageWidth LONG page
		    m.lvRes = FPDF_GetPageWidth(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_initlibrarywithconfig
		LPARAMETERS config as String
		
		DECLARE FPDF_InitLibraryWithConfig IN (This.pdfium_dll_path) AS FPDF_InitLibraryWithConfig STRING config
		
		LOCAL lcConfig
		m.lcConfig = EVL(NVL(m.config,""),"")
		IF EMPTY(m.lcConfig)
		    m.lcConfig = REPLICATE(CHR(0),24)
		    m.lcConfig = STUFF(m.lcConfig, 1,4, BINTOC(2, "4RS"))
		ELSE
		    m.lcConfig = PADR(m.lcConfig, 24, CHR(0))    
		ENDIF
		
		
		IF PEMSTATUS(Application, "pdfium_instance_count", 5)=.F.
		    ADDPROPERTY(Application, "pdfium_instance_count", 0)
		ENDIF
		
		IF Application.pdfium_instance_count = 0
		    FPDF_InitLibraryWithConfig(m.lcConfig)
		    This.FPDF_GetLastError() && Last error initialization, first call of FPDF_GetLastError() always returns 0 even if error has occured
		ENDIF
		
		Application.pdfium_instance_count = Application.pdfium_instance_count + 1
		
	ENDPROC

	PROCEDURE fpdf_loaddocument
		LPARAMETERS file_path as String, password as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_LoadDocument(m.file_path, m.password)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDF_LoadDocument IN (This.pdfium_dll_path) AS FPDF_LoadDocument STRING file_path, STRING password
		    m.lvRes = FPDF_LoadDocument(m.file_path, m.password)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_loadmemdocument
		LPARAMETERS data_buf as String, size as Integer, password as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_LoadMemDocument(m.data_buf, m.size, m.password)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDF_LoadMemDocument IN (This.pdfium_dll_path) AS FPDF_LoadMemDocument STRING data_buf, INTEGER size, STRING password
		    m.lvRes = FPDF_LoadMemDocument(m.data_buf, m.size, m.password)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_loadpage
		LPARAMETERS document as Long, page_index as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_LoadPage(m.document, m.page_index)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDF_LoadPage IN (This.pdfium_dll_path) AS FPDF_LoadPage LONG document, INTEGER page_index
		    m.lvRes = FPDF_LoadPage(m.document, m.page_index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_pagetodevice
		LPARAMETERS page as Long, start_x as Integer, start_y as Integer, size_x as Integer, size_y as Integer, rotate as Integer, page_x as Double, page_y as Double, device_x as Integer, device_y as Integer
		
		LOCAL lcDevX, lcDevY
		STORE 0h00000000 TO m.lcDevX, m.lcDevY
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_PageToDevice(m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.page_x, m.page_y, @m.lcDevX, @m.lcDevY)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDF_PageToDevice IN (This.pdfium_dll_path) AS FPDF_PageToDevice LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, double page_x, double page_y, string @device_x, string @device_y
		    m.lvRes = FPDF_PageToDevice(m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.page_x, m.page_y, @m.lcDevX, @m.lcDevY)
		ENDTRY
		
		m.device_x = CTOBIN(m.lcDevX, "4RS")
		m.device_y = CTOBIN(m.lcDevY, "4RS")
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_renderpage
		LPARAMETERS dc as Long, page as Long, start_x as Integer, start_y as Integer, size_x as Integer, size_y as Integer, rotate as Integer, flags as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_RenderPage(m.dc, m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.flags)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDF_RenderPage IN (This.pdfium_dll_path) AS FPDF_RenderPage LONG dc, LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer flags
		    m.lvRes = FPDF_RenderPage(m.dc, m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.flags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_getfontfilename		&& pdfium-vfp.dll function; Gets font face name and returns font filename and simulations
		LPARAMETERS family_name as String, is_bold as Long, is_italic as Long, nCharset as Long, buffer as String, buflen as Long, bBoldSimulation as Long, bItalicSimulation as Long, bSymbolFont as Long
		
		* Algorithmic emboldening is performed.
		#define DWRITE_FONT_SIMULATIONS_BOLD 0x0001
		* Algorithmic italicization is performed.
		#define DWRITE_FONT_SIMULATIONS_OBLIQUE 0x0002
		
		LOCAL m.lnFontSimulations, m.lnSymbolFont
		STORE 0 TO m.lnFontSimulations, m.lnSymbolFont
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_GetFontFileName(@m.family_name, m.is_bold, m.is_italic, m.nCharset, @m.buffer, m.buflen, @m.lnFontSimulations, @m.lnSymbolFont)
		CATCH
		    SET CONSOLE OFF    
		    
		    LOCAL m.lcPdfiumVfpDll
		    m.lcPdfiumVfpDll = ADDBS(JUSTPATH(This.pdfium_dll_path)) + IIF(ATC("x64", SYS(17))<>0, "pdfium-vfp64.dll", "pdfium-vfp.dll")
		    
		    DECLARE LONG FPDF_GetFontFileName IN (m.lcPdfiumVfpDll) AS VFPDF_GetFontFileName STRING @family_name, LONG is_bold, LONG is_italic, LONG nCharset, STRING @buffer, LONG buflen, LONG @nFontSimulations, LONG @bSymbolFont
		    m.lvRes = VFPDF_GetFontFileName(@m.family_name, m.is_bold, m.is_italic, m.nCharset, @m.buffer, m.buflen, @m.lnFontSimulations, @m.lnSymbolFont)
		ENDTRY
		
		IF m.lvRes <> 0
		    m.bBoldSimulation = IIF(BITAND(m.lnFontSimulations, DWRITE_FONT_SIMULATIONS_BOLD) <> 0, 1, 0)
		    m.bItalicSimulation = IIF(BITAND(m.lnFontSimulations, DWRITE_FONT_SIMULATIONS_OBLIQUE) <> 0, 1, 0)
		    m.bSymbolFont = m.lnSymbolFont
		ENDIF
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_savedocument		&& pdfium-vfp.dll function; Save pdf to the file
		LPARAMETERS document as Long, filepath as String, errMsg as String, errMsgSize as Long
		
		IF EMPTY(NVL(m.errMsg,""))
		    m.errMsg = ""
		    m.errMsgSize = 0
		ENDIF
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_SaveDocument(m.document, m.filepath, @m.errMsg, m.errMsgSize)
		CATCH
		    SET CONSOLE OFF
		    
		    LOCAL m.lcPdfiumVfpDll
		    m.lcPdfiumVfpDll = ADDBS(JUSTPATH(This.pdfium_dll_path)) + IIF(ATC("x64", SYS(17))<>0, "pdfium-vfp64.dll", "pdfium-vfp.dll")
		    
		    DECLARE LONG FPDF_SaveDocument IN (m.lcPdfiumVfpDll) AS VFPDF_SaveDocument LONG document, STRING filepath, STRING @errMsg, LONG errMsgSize &&errMsgSize: errMsg buffer size in chars, not in bytes
		    m.lvRes = VFPDF_SaveDocument(m.document, m.filepath, @m.errMsg, m.errMsgSize)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_fpdf_const AS custom 		&& Pdfium API constants
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: fpdf_err_password
		*m: fpdf_printing
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_fpdf_const"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="fpdf_err_password" type="method" display="FPDF_ERR_PASSWORD"/>
			<memberdata name="fpdf_printing" type="method" display="FPDF_PRINTING"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE fpdf_err_password
		RETURN 4
		
	ENDPROC

	PROCEDURE fpdf_printing
		RETURN 0x800
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_hpdf AS custom 		&& LibHARU API wrapper
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="CONST" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: hpdf_addpage
		*m: hpdf_createextgstate
		*m: hpdf_extgstate_setalphafill
		*m: hpdf_extgstate_setalphastroke
		*m: hpdf_free
		*m: hpdf_geterror
		*m: hpdf_getfont
		*m: hpdf_loadpngimagefromfile
		*m: hpdf_loadttfontfromfile
		*m: hpdf_new
		*m: hpdf_page_begintext
		*m: hpdf_page_closepath
		*m: hpdf_page_closepathstroke
		*m: hpdf_page_concat
		*m: hpdf_page_curveto
		*m: hpdf_page_drawimage
		*m: hpdf_page_ellipse
		*m: hpdf_page_endpath
		*m: hpdf_page_endtext
		*m: hpdf_page_executexobject
		*m: hpdf_page_fill
		*m: hpdf_page_fillstroke
		*m: hpdf_page_grestore
		*m: hpdf_page_gsave
		*m: hpdf_page_lineto
		*m: hpdf_page_moveto
		*m: hpdf_page_rectangle
		*m: hpdf_page_setdash
		*m: hpdf_page_setextgstate
		*m: hpdf_page_setfontandsize
		*m: hpdf_page_setheight
		*m: hpdf_page_setlinewidth
		*m: hpdf_page_setrgbfill
		*m: hpdf_page_setrgbstroke
		*m: hpdf_page_settextleading
		*m: hpdf_page_settextmatrix
		*m: hpdf_page_settextrenderingmode
		*m: hpdf_page_setwidth
		*m: hpdf_page_stroke
		*m: hpdf_page_textrect
		*m: hpdf_reseterror
		*m: hpdf_savetofile
		*m: hpdf_setcompressionmode
		*m: hpdf_setcurrentencoder
		*m: hpdf_setencryptionmode
		*m: hpdf_setinfoattr
		*m: hpdf_setpagemode
		*m: hpdf_setpassword
		*m: hpdf_setpermission
		*m: hpdf_useutfencodings
		*p: libhpdf_dll_path		&& Path to file libhpdf.dll
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		libhpdf_dll_path = ("")
		Name = "pdfium_api_hpdf"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="hpdf_new" type="method" display="HPDF_New"/>
			<memberdata name="libhpdf_dll_path" type="property" display="libhpdf_dll_path"/>
			<memberdata name="hpdf_free" type="method" display="HPDF_Free"/>
			<memberdata name="hpdf_savetofile" type="method" display="HPDF_SaveToFile"/>
			<memberdata name="hpdf_geterror" type="method" display="HPDF_GetError"/>
			<memberdata name="hpdf_reseterror" type="method" display="HPDF_ResetError"/>
			<memberdata name="hpdf_setpagemode" type="method" display="HPDF_SetPageMode"/>
			<memberdata name="hpdf_addpage" type="method" display="HPDF_AddPage"/>
			<memberdata name="hpdf_page_setwidth" type="method" display="HPDF_Page_SetWidth"/>
			<memberdata name="hpdf_page_setheight" type="method" display="HPDF_Page_SetHeight"/>
			<memberdata name="hpdf_getfont" type="method" display="HPDF_GetFont"/>
			<memberdata name="hpdf_loadttfontfromfile" type="method" display="HPDF_LoadTTFontFromFile"/>
			<memberdata name="hpdf_setcurrentencoder" type="method" display="HPDF_SetCurrentEncoder"/>
			<memberdata name="hpdf_useutfencodings" type="method" display="HPDF_UseUTFEncodings"/>
			<memberdata name="hpdf_loadpngimagefromfile" type="method" display="HPDF_LoadPngImageFromFile"/>
			<memberdata name="hpdf_setinfoattr" type="method" display="HPDF_SetInfoAttr"/>
			<memberdata name="hpdf_setpassword" type="method" display="HPDF_SetPassword"/>
			<memberdata name="hpdf_setpermission" type="method" display="HPDF_SetPermission"/>
			<memberdata name="hpdf_setencryptionmode" type="method" display="HPDF_SetEncryptionMode"/>
			<memberdata name="hpdf_setcompressionmode" type="method" display="HPDF_SetCompressionMode"/>
			<memberdata name="hpdf_page_setlinewidth" type="method" display="HPDF_Page_SetLineWidth"/>
			<memberdata name="hpdf_page_setdash" type="method" display="HPDF_Page_SetDash"/>
			<memberdata name="hpdf_page_moveto" type="method" display="HPDF_Page_MoveTo"/>
			<memberdata name="hpdf_page_lineto" type="method" display="HPDF_Page_LineTo"/>
			<memberdata name="hpdf_page_closepath" type="method" display="HPDF_Page_ClosePath"/>
			<memberdata name="hpdf_page_rectangle" type="method" display="HPDF_Page_Rectangle"/>
			<memberdata name="hpdf_page_concat" type="method" display="HPDF_Page_Concat"/>
			<memberdata name="hpdf_page_settextleading" type="method" display="HPDF_Page_SetTextLeading"/>
			<memberdata name="hpdf_page_stroke" type="method" display="HPDF_Page_Stroke"/>
			<memberdata name="hpdf_page_closepathstroke" type="method" display="HPDF_Page_ClosePathStroke"/>
			<memberdata name="hpdf_page_fill" type="method" display="HPDF_Page_Fill"/>
			<memberdata name="hpdf_page_fillstroke" type="method" display="HPDF_Page_FillStroke"/>
			<memberdata name="hpdf_page_endpath" type="method" display="HPDF_Page_EndPath"/>
			<memberdata name="hpdf_page_begintext" type="method" display="HPDF_Page_BeginText"/>
			<memberdata name="hpdf_page_endtext" type="method" display="HPDF_Page_EndText"/>
			<memberdata name="hpdf_page_setfontandsize" type="method" display="HPDF_Page_SetFontAndSize"/>
			<memberdata name="hpdf_page_settextrenderingmode" type="method" display="HPDF_Page_SetTextRenderingMode"/>
			<memberdata name="hpdf_page_setrgbfill" type="method" display="HPDF_Page_SetRGBFill"/>
			<memberdata name="hpdf_page_setrgbstroke" type="method" display="HPDF_Page_SetRGBStroke"/>
			<memberdata name="hpdf_page_ellipse" type="method" display="HPDF_Page_Ellipse"/>
			<memberdata name="hpdf_page_drawimage" type="method" display="HPDF_Page_DrawImage"/>
			<memberdata name="hpdf_page_textrect" type="method" display="HPDF_Page_TextRect"/>
			<memberdata name="hpdf_page_settextmatrix" type="method" display="HPDF_Page_SetTextMatrix"/>
			<memberdata name="hpdf_page_curveto" type="method" display="HPDF_Page_CurveTo"/>
			<memberdata name="hpdf_page_gsave" type="method" display="HPDF_Page_GSave"/>
			<memberdata name="hpdf_page_grestore" type="method" display="HPDF_Page_GRestore"/>
			<memberdata name="hpdf_page_executexobject" type="method" display="HPDF_Page_ExecuteXObject"/>
			<memberdata name="hpdf_createextgstate" type="method" display="HPDF_CreateExtGState"/>
			<memberdata name="hpdf_extgstate_setalphafill" type="method" display="HPDF_ExtGState_SetAlphaFill"/>
			<memberdata name="hpdf_extgstate_setalphastroke" type="method" display="HPDF_ExtGState_SetAlphaStroke"/>
			<memberdata name="hpdf_page_setextgstate" type="method" display="HPDF_Page_SetExtGState"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'CONST' AS pdfium_api_hpdf_const WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "CONST", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE hpdf_addpage
		LPARAMETERS pdf as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_AddPage(m.pdf)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_AddPage IN (This.libhpdf_dll_path) AS HPDF_AddPage INTEGER pdf
		    m.lvRes = HPDF_AddPage(m.pdf)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_createextgstate
		LPARAMETERS pdf as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_CreateExtGState(m.pdf) 
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_CreateExtGState IN (This.libhpdf_dll_path) AS HPDF_CreateExtGState INTEGER pdf
		    m.lvRes = HPDF_CreateExtGState(m.pdf) 
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_extgstate_setalphafill
		LPARAMETERS page as Integer, value as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_ExtGState_SetAlphaFill(m.page, m.value)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_ExtGState_SetAlphaFill IN (This.libhpdf_dll_path) AS HPDF_ExtGState_SetAlphaFill INTEGER page, SINGLE value
		    m.lvRes = HPDF_ExtGState_SetAlphaFill(m.page, m.value)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_extgstate_setalphastroke
		LPARAMETERS page as Integer, value as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_ExtGState_SetAlphaStroke(m.page, m.value)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_ExtGState_SetAlphaStroke IN (This.libhpdf_dll_path) AS HPDF_ExtGState_SetAlphaStroke INTEGER page, SINGLE value
		    m.lvRes = HPDF_ExtGState_SetAlphaStroke(m.page, m.value)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_free
		LPARAMETERS pdf as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Free(m.pdf)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Free IN (This.libhpdf_dll_path) AS HPDF_Free INTEGER pdf
		    m.lvRes = HPDF_Free(m.pdf)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_geterror
		LPARAMETERS pdf as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_GetError(m.pdf)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_GetError IN (This.libhpdf_dll_path) AS HPDF_GetError INTEGER pdf
		    m.lvRes = HPDF_GetError(m.pdf)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_getfont
		LPARAMETERS pdf as Integer, font_name as String, encoding_name as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_GetFont(m.pdf, m.font_name, m.encoding_name)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_GetFont IN (This.libhpdf_dll_path) AS HPDF_GetFont INTEGER pdf, STRING font_name, STRING encoding_name
		    m.lvRes = HPDF_GetFont(m.pdf, m.font_name, m.encoding_name)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_loadpngimagefromfile
		LPARAMETERS pdf as Integer, filename as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_LoadPngImageFromFile(m.pdf, m.filename)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_LoadPngImageFromFile IN (This.libhpdf_dll_path) AS HPDF_LoadPngImageFromFile INTEGER pdf, STRING filename
		    m.lvRes = HPDF_LoadPngImageFromFile(m.pdf, m.filename)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_loadttfontfromfile
		LPARAMETERS pdf as Integer, file_name as String, embedding as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_LoadTTFontFromFile(m.pdf, m.file_name, m.embedding)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE STRING HPDF_LoadTTFontFromFile IN (This.libhpdf_dll_path) AS HPDF_LoadTTFontFromFile INTEGER pdf, STRING file_name, INTEGER embedding
		    m.lvRes = HPDF_LoadTTFontFromFile(m.pdf, m.file_name, m.embedding)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_new
		LPARAMETERS user_error_fn as Integer, user_data as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_New(m.user_error_fn, m.user_data)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_New IN (This.libhpdf_dll_path) AS HPDF_New INTEGER user_error_fn, INTEGER user_data
		    m.lvRes = HPDF_New(m.user_error_fn, m.user_data)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_begintext
		LPARAMETERS page as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_BeginText(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_BeginText IN (This.libhpdf_dll_path) AS HPDF_Page_BeginText INTEGER page
		    m.lvRes = HPDF_Page_BeginText(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_closepath
		LPARAMETERS page as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_ClosePath(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_ClosePath IN (This.libhpdf_dll_path) AS HPDF_Page_ClosePath INTEGER page
		    m.lvRes = HPDF_Page_ClosePath(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_closepathstroke
		LPARAMETERS page as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_ClosePathStroke(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_ClosePathStroke IN (This.libhpdf_dll_path) AS HPDF_Page_ClosePathStroke INTEGER page
		    m.lvRes = HPDF_Page_ClosePathStroke(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_concat
		LPARAMETERS page as Integer, a as Single, b as Single, c as Single, d as Single, x as Single, y as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_Concat(m.page, m.a, m.b, m.c, m.d, m.x, m.y)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_Concat IN (This.libhpdf_dll_path) AS HPDF_Page_Concat INTEGER page, SINGLE a, SINGLE b, SINGLE c, SINGLE d, SINGLE x, SINGLE y
		    m.lvRes = HPDF_Page_Concat(m.page, m.a, m.b, m.c, m.d, m.x, m.y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_curveto
		LPARAMETERS page as Integer, x1 as Single, y1 as Single, x2 as Single, y2 as Single, x3 as Single, y3 as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_CurveTo(m.page, m.x1, m.y1, m.x2, m.y2, m.x3, m.y3)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_CurveTo IN (This.libhpdf_dll_path) AS HPDF_Page_CurveTo INTEGER page, SINGLE x1, SINGLE y1, SINGLE x2, SINGLE y2, SINGLE x3, SINGLE y3
		    m.lvRes = HPDF_Page_CurveTo(m.page, m.x1, m.y1, m.x2, m.y2, m.x3, m.y3)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_drawimage
		LPARAMETERS page as Integer, image as Integer, x as Single, y as Single, width as Single, height as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_DrawImage(m.page, m.image, m.x, m.y, m.width, m.height)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_DrawImage IN (This.libhpdf_dll_path) AS HPDF_Page_DrawImage INTEGER page, INTEGER image, SINGLE x, SINGLE y, SINGLE width, SINGLE height
		    m.lvRes = HPDF_Page_DrawImage(m.page, m.image, m.x, m.y, m.width, m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_ellipse
		LPARAMETERS page as Integer, x as Single, y as Single, xray as Single, yray as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_Ellipse(m.page, m.x, m.y, m.xray, m.yray)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_Ellipse IN (This.libhpdf_dll_path) AS HPDF_Page_Ellipse INTEGER page, SINGLE x, SINGLE y, SINGLE xray, SINGLE yray
		    m.lvRes = HPDF_Page_Ellipse(m.page, m.x, m.y, m.xray, m.yray)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_endpath
		LPARAMETERS page as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_EndPath(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_EndPath IN (This.libhpdf_dll_path) AS HPDF_Page_EndPath INTEGER page
		    m.lvRes = HPDF_Page_EndPath(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_endtext
		LPARAMETERS page as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_EndText(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_EndText IN (This.libhpdf_dll_path) AS HPDF_Page_EndText INTEGER page
		    m.lvRes = HPDF_Page_EndText(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_executexobject
		LPARAMETERS page as Integer, obj as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_ExecuteXObject(m.page, m.obj)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_ExecuteXObject IN (This.libhpdf_dll_path) AS HPDF_Page_ExecuteXObject INTEGER page, INTEGER obj
		    m.lvRes = HPDF_Page_ExecuteXObject(m.page, m.obj)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_fill
		LPARAMETERS page as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_Fill(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_Fill IN (This.libhpdf_dll_path) AS HPDF_Page_Fill INTEGER page
		    m.lvRes = HPDF_Page_Fill(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_fillstroke
		LPARAMETERS page as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_FillStroke(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_FillStroke IN (This.libhpdf_dll_path) AS HPDF_Page_FillStroke INTEGER page
		    m.lvRes = HPDF_Page_FillStroke(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_grestore
		LPARAMETERS page as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_GRestore(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_GRestore IN (This.libhpdf_dll_path) AS HPDF_Page_GRestore INTEGER page
		    m.lvRes = HPDF_Page_GRestore(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_gsave
		LPARAMETERS page as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_GSave(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_GSave IN (This.libhpdf_dll_path) AS HPDF_Page_GSave INTEGER page
		    m.lvRes = HPDF_Page_GSave(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_lineto
		LPARAMETERS page as Integer, x as Single, y as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_LineTo(m.page, m.x, m.y)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_LineTo IN (This.libhpdf_dll_path) AS HPDF_Page_LineTo INTEGER page, SINGLE x, SINGLE y
		    m.lvRes = HPDF_Page_LineTo(m.page, m.x, m.y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_moveto
		LPARAMETERS page as Integer, x as Single, y as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_MoveTo(m.page, m.x, m.y)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_MoveTo IN (This.libhpdf_dll_path) AS HPDF_Page_MoveTo INTEGER page, SINGLE x, SINGLE y
		    m.lvRes = HPDF_Page_MoveTo(m.page, m.x, m.y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_rectangle
		LPARAMETERS page as Integer, x as Single, y as Single, width as Single, height as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_Rectangle(m.page, m.x, m.y, m.width, m.height)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_Rectangle IN (This.libhpdf_dll_path) AS HPDF_Page_Rectangle INTEGER page, SINGLE x, SINGLE y, SINGLE width, SINGLE height
		    m.lvRes = HPDF_Page_Rectangle(m.page, m.x, m.y, m.width, m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_setdash
		LPARAMETERS page as Integer, dash_ptn as String, num_param as Integer, phase as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_SetDash(m.page, m.dash_ptn, m.num_param, m.phase)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_SetDash IN (This.libhpdf_dll_path) AS HPDF_Page_SetDash INTEGER page, STRING dash_ptn, INTEGER num_param, SINGLE phase
		    m.lvRes = HPDF_Page_SetDash(m.page, m.dash_ptn, m.num_param, m.phase)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_setextgstate
		LPARAMETERS page as Integer, ext_gstate as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_SetExtGState(m.page, m.ext_gstate)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_SetExtGState IN (This.libhpdf_dll_path) AS HPDF_Page_SetExtGState INTEGER page, INTEGER ext_gstate
		    m.lvRes = HPDF_Page_SetExtGState(m.page, m.ext_gstate)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_setfontandsize
		LPARAMETERS page as Integer, font as Integer, size as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_SetFontAndSize(m.page, m.font, m.size)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_SetFontAndSize IN (This.libhpdf_dll_path) AS HPDF_Page_SetFontAndSize INTEGER page, INTEGER font, SINGLE size
		    m.lvRes = HPDF_Page_SetFontAndSize(m.page, m.font, m.size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_setheight
		LPARAMETERS page as Integer, value as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_SetHeight(m.page, m.value)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_SetHeight IN (This.libhpdf_dll_path) AS HPDF_Page_SetHeight INTEGER page, SINGLE value
		    m.lvRes = HPDF_Page_SetHeight(m.page, m.value)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_setlinewidth
		LPARAMETERS page as Integer, line_width as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_SetLineWidth(m.page, m.line_width)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_SetLineWidth IN (This.libhpdf_dll_path) AS HPDF_Page_SetLineWidth INTEGER page, SINGLE line_width
		    m.lvRes = HPDF_Page_SetLineWidth(m.page, m.line_width)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_setrgbfill
		LPARAMETERS page as Integer, r as Single, g as Single, b as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_SetRGBFill(m.page, m.r, m.g, m.b)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_SetRGBFill IN (This.libhpdf_dll_path) AS HPDF_Page_SetRGBFill INTEGER page, SINGLE r, SINGLE g, SINGLE b
		    m.lvRes = HPDF_Page_SetRGBFill(m.page, m.r, m.g, m.b)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_setrgbstroke
		LPARAMETERS page as Integer, r as Single, g as Single, b as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_SetRGBStroke(m.page, m.r, m.g, m.b)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_SetRGBStroke IN (This.libhpdf_dll_path) AS HPDF_Page_SetRGBStroke INTEGER page, SINGLE r, SINGLE g, SINGLE b
		    m.lvRes = HPDF_Page_SetRGBStroke(m.page, m.r, m.g, m.b)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_settextleading
		LPARAMETERS page as Integer, value as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_SetTextLeading(m.page, m.value)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_SetTextLeading IN (This.libhpdf_dll_path) AS HPDF_Page_SetTextLeading INTEGER page, SINGLE value
		    m.lvRes = HPDF_Page_SetTextLeading(m.page, m.value)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_settextmatrix
		LPARAMETERS page as Integer, a as Single, b as Single, c as Single, d as Single, x as Single, y as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_SetTextMatrix(m.page, m.a, m.b, m.c, m.d, m.x, m.y)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_SetTextMatrix IN (This.libhpdf_dll_path) AS HPDF_Page_SetTextMatrix INTEGER page, SINGLE a, SINGLE b, SINGLE c, SINGLE d, SINGLE x, SINGLE y
		    m.lvRes = HPDF_Page_SetTextMatrix(m.page, m.a, m.b, m.c, m.d, m.x, m.y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_settextrenderingmode
		LPARAMETERS page as Integer, mode as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_SetTextRenderingMode(m.page, m.mode)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_SetTextRenderingMode IN (This.libhpdf_dll_path) AS HPDF_Page_SetTextRenderingMode INTEGER page, INTEGER mode
		    m.lvRes = HPDF_Page_SetTextRenderingMode(m.page, m.mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_setwidth
		LPARAMETERS page as Integer, value as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_SetWidth(m.page, m.value)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_SetWidth IN (This.libhpdf_dll_path) AS HPDF_Page_SetWidth INTEGER page, SINGLE value
		    m.lvRes = HPDF_Page_SetWidth(m.page, m.value)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_stroke
		LPARAMETERS page as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_Stroke(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_Stroke IN (This.libhpdf_dll_path) AS HPDF_Page_Stroke INTEGER page
		    m.lvRes = HPDF_Page_Stroke(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_page_textrect
		LPARAMETERS page as Integer, left as Single, top as Single, right as Single, bottom as Single, text as Single, align as Integer, len as Integer
		
		LOCAL lcLen
		m.lcLen = BINTOC(m.len, "4RS")
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_Page_TextRect(m.page, m.left, m.top, m.right, m.bottom, m.text, m.align, @m.lcLen)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_Page_TextRect IN (This.libhpdf_dll_path) AS HPDF_Page_TextRect INTEGER page, SINGLE left, SINGLE top, SINGLE right, SINGLE bottom, STRING text, INTEGER align, STRING @len
		    m.lvRes = HPDF_Page_TextRect(m.page, m.left, m.top, m.right, m.bottom, m.text, m.align, @m.lcLen)
		ENDTRY
		
		m.len = CTOBIN(m.lcLen, "4RS")
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_reseterror
		LPARAMETERS pdf as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_ResetError(m.pdf)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_ResetError IN (This.libhpdf_dll_path) AS HPDF_ResetError INTEGER pdf
		    m.lvRes = HPDF_ResetError(m.pdf)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_savetofile
		LPARAMETERS pdf as Integer, file_name as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_SaveToFile(m.pdf, m.file_name)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_SaveToFile IN (This.libhpdf_dll_path) AS HPDF_SaveToFile INTEGER pdf, STRING file_name
		    m.lvRes = HPDF_SaveToFile(m.pdf, m.file_name)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_setcompressionmode
		LPARAMETERS pdf as Integer, mode as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_SetCompressionMode(m.pdf, m.mode)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_SetCompressionMode IN (This.libhpdf_dll_path) AS HPDF_SetCompressionMode INTEGER pdf, INTEGER mode
		    m.lvRes = HPDF_SetCompressionMode(m.pdf, m.mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_setcurrentencoder
		LPARAMETERS pdf as Integer, encoding_name as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_SetCurrentEncoder(m.pdf, m.encoding_name)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_SetCurrentEncoder IN (This.libhpdf_dll_path) AS HPDF_SetCurrentEncoder INTEGER pdf, STRING encoding_name
		    m.lvRes = HPDF_SetCurrentEncoder(m.pdf, m.encoding_name)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_setencryptionmode
		LPARAMETERS pdf as Integer, mode as Integer, key_len as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_SetEncryptionMode(m.pdf, m.mode, m.key_len)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_SetEncryptionMode IN (This.libhpdf_dll_path) AS HPDF_SetEncryptionMode INTEGER pdf, INTEGER mode, INTEGER key_len
		    m.lvRes = HPDF_SetEncryptionMode(m.pdf, m.mode, m.key_len)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_setinfoattr
		LPARAMETERS pdf as Integer, type as Integer, value as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_SetInfoAttr(m.pdf, m.type, m.value)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_SetInfoAttr IN (This.libhpdf_dll_path) AS HPDF_SetInfoAttr INTEGER pdf, INTEGER type, STRING value
		    m.lvRes = HPDF_SetInfoAttr(m.pdf, m.type, m.value)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_setpagemode
		LPARAMETERS pdf as Integer, mode as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_SetPageMode(m.pdf, m.mode)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_SetPageMode IN (This.libhpdf_dll_path) AS HPDF_SetPageMode INTEGER pdf, INTEGER mode
		    m.lvRes = HPDF_SetPageMode(m.pdf, m.mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_setpassword
		LPARAMETERS pdf as Integer, owner_passwd as String, user_passwd as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_SetPassword(m.pdf, m.owner_passwd, m.user_passwd)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_SetPassword IN (This.libhpdf_dll_path) AS HPDF_SetPassword INTEGER pdf, STRING owner_passwd, STRING user_passwd
		    m.lvRes = HPDF_SetPassword(m.pdf, m.owner_passwd, m.user_passwd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_setpermission
		LPARAMETERS pdf as Integer, permission as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_SetPermission(m.pdf, m.permission)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_SetPermission IN (This.libhpdf_dll_path) AS HPDF_SetPermission INTEGER pdf, INTEGER permission
		    m.lvRes = HPDF_SetPermission(m.pdf, m.permission)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE hpdf_useutfencodings
		LPARAMETERS pdf as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = HPDF_UseUTFEncodings(m.pdf)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HPDF_UseUTFEncodings IN (This.libhpdf_dll_path) AS HPDF_UseUTFEncodings INTEGER pdf
		    m.lvRes = HPDF_UseUTFEncodings(m.pdf)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_hpdf_const AS custom 		&& LibHARU API constants
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: cp
		*m: hpdf_comp_all
		*m: hpdf_enable_copy
		*m: hpdf_enable_edit
		*m: hpdf_enable_edit_all
		*m: hpdf_enable_print
		*m: hpdf_enable_read
		*m: hpdf_encrypt_r2
		*m: hpdf_encrypt_r3
		*m: hpdf_fill
		*m: hpdf_fill_then_stroke
		*m: hpdf_info_author
		*m: hpdf_info_creation_date
		*m: hpdf_info_creator
		*m: hpdf_info_eof
		*m: hpdf_info_gts_pdfx
		*m: hpdf_info_keywords
		*m: hpdf_info_mod_date
		*m: hpdf_info_producer
		*m: hpdf_info_subject
		*m: hpdf_info_title
		*m: hpdf_info_trapped
		*m: hpdf_page_mode_use_none
		*m: hpdf_page_mode_use_outline
		*m: hpdf_stroke
		*m: hpdf_talign_center
		*m: hpdf_talign_justify
		*m: hpdf_talign_left
		*m: hpdf_talign_right
		*m: utf8
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_hpdf_const"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="hpdf_comp_all" type="method" display="HPDF_COMP_ALL"/>
			<memberdata name="hpdf_page_mode_use_none" type="method" display="HPDF_PAGE_MODE_USE_NONE"/>
			<memberdata name="hpdf_page_mode_use_outline" type="method" display="HPDF_PAGE_MODE_USE_OUTLINE"/>
			<memberdata name="utf8" type="method" display="UTF8"/>
			<memberdata name="cp" type="method" display="CP"/>
			<memberdata name="hpdf_encrypt_r2" type="method" display="HPDF_ENCRYPT_R2"/>
			<memberdata name="hpdf_encrypt_r3" type="method" display="HPDF_ENCRYPT_R3"/>
			<memberdata name="hpdf_info_author" type="method" display="HPDF_INFO_AUTHOR"/>
			<memberdata name="hpdf_info_creation_date" type="method" display="HPDF_INFO_CREATION_DATE"/>
			<memberdata name="hpdf_info_creator" type="method" display="HPDF_INFO_CREATOR"/>
			<memberdata name="hpdf_info_eof" type="method" display="HPDF_INFO_EOF"/>
			<memberdata name="hpdf_info_gts_pdfx" type="method" display="HPDF_INFO_GTS_PDFX"/>
			<memberdata name="hpdf_info_keywords" type="method" display="HPDF_INFO_KEYWORDS"/>
			<memberdata name="hpdf_info_mod_date" type="method" display="HPDF_INFO_MOD_DATE"/>
			<memberdata name="hpdf_info_producer" type="method" display="HPDF_INFO_PRODUCER"/>
			<memberdata name="hpdf_info_subject" type="method" display="HPDF_INFO_SUBJECT"/>
			<memberdata name="hpdf_info_title" type="method" display="HPDF_INFO_TITLE"/>
			<memberdata name="hpdf_info_trapped" type="method" display="HPDF_INFO_TRAPPED"/>
			<memberdata name="hpdf_enable_copy" type="method" display="HPDF_ENABLE_COPY"/>
			<memberdata name="hpdf_enable_edit" type="method" display="HPDF_ENABLE_EDIT"/>
			<memberdata name="hpdf_enable_edit_all" type="method" display="HPDF_ENABLE_EDIT_ALL"/>
			<memberdata name="hpdf_enable_print" type="method" display="HPDF_ENABLE_PRINT"/>
			<memberdata name="hpdf_enable_read" type="method" display="HPDF_ENABLE_READ"/>
			<memberdata name="hpdf_fill" type="method" display="HPDF_FILL"/>
			<memberdata name="hpdf_fill_then_stroke" type="method" display="HPDF_FILL_THEN_STROKE"/>
			<memberdata name="hpdf_stroke" type="method" display="HPDF_STROKE"/>
			<memberdata name="hpdf_talign_center" type="method" display="HPDF_TALIGN_CENTER"/>
			<memberdata name="hpdf_talign_justify" type="method" display="HPDF_TALIGN_JUSTIFY"/>
			<memberdata name="hpdf_talign_left" type="method" display="HPDF_TALIGN_LEFT"/>
			<memberdata name="hpdf_talign_right" type="method" display="HPDF_TALIGN_RIGHT"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE cp
		LPARAMETERS cCodePage as String
		
		IF INLIST(m.cCodePage, "1250", "1251", "1252", "1253", "1254", "1255", "1256", "1257", "1258")
		     RETURN "CP" + m.cCodePage
		ENDIF
		
		IF INLIST(LOWER(m.cCodePage), "utf8", "utf-8")
		    RETURN This.UTF8()
		ENDIF
		
		RETURN ""
		
	ENDPROC

	PROCEDURE hpdf_comp_all
		RETURN 5
		
	ENDPROC

	PROCEDURE hpdf_enable_copy
		RETURN 16
		
	ENDPROC

	PROCEDURE hpdf_enable_edit
		RETURN 32
		
	ENDPROC

	PROCEDURE hpdf_enable_edit_all
		RETURN 8
		
	ENDPROC

	PROCEDURE hpdf_enable_print
		RETURN 4
		
	ENDPROC

	PROCEDURE hpdf_enable_read
		RETURN 0
		
	ENDPROC

	PROCEDURE hpdf_encrypt_r2
		RETURN 2
		
	ENDPROC

	PROCEDURE hpdf_encrypt_r3
		RETURN 3
		
	ENDPROC

	PROCEDURE hpdf_fill
		RETURN 0
		
	ENDPROC

	PROCEDURE hpdf_fill_then_stroke
		RETURN 2
		
	ENDPROC

	PROCEDURE hpdf_info_author
		RETURN 2
		
	ENDPROC

	PROCEDURE hpdf_info_creation_date
		RETURN 0
		
	ENDPROC

	PROCEDURE hpdf_info_creator
		RETURN 3
		
	ENDPROC

	PROCEDURE hpdf_info_eof
		RETURN 10
		
	ENDPROC

	PROCEDURE hpdf_info_gts_pdfx
		RETURN 9
		
	ENDPROC

	PROCEDURE hpdf_info_keywords
		RETURN 7
		
	ENDPROC

	PROCEDURE hpdf_info_mod_date
		RETURN 1
		
	ENDPROC

	PROCEDURE hpdf_info_producer
		RETURN 4
		
	ENDPROC

	PROCEDURE hpdf_info_subject
		RETURN 6
		
	ENDPROC

	PROCEDURE hpdf_info_title
		RETURN 5
		
	ENDPROC

	PROCEDURE hpdf_info_trapped
		RETURN 8
		
	ENDPROC

	PROCEDURE hpdf_page_mode_use_none
		RETURN 0
		
	ENDPROC

	PROCEDURE hpdf_page_mode_use_outline
		RETURN 1
		
	ENDPROC

	PROCEDURE hpdf_stroke
		RETURN 1
		
	ENDPROC

	PROCEDURE hpdf_talign_center
		RETURN 2
		
	ENDPROC

	PROCEDURE hpdf_talign_justify
		RETURN 3
		
	ENDPROC

	PROCEDURE hpdf_talign_left
		RETURN 0
		
	ENDPROC

	PROCEDURE hpdf_talign_right
		RETURN 1
		
	ENDPROC

	PROCEDURE utf8
		RETURN "UTF-8"
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_win AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: beginpaint
		*m: bitblt
		*m: callwindowproc
		*m: closeclipboard
		*m: closeprinter
		*m: createcompatibledc
		*m: createdc
		*m: createdibsection
		*m: createwindowex
		*m: deletedc
		*m: deleteobject
		*m: destroywindow
		*m: devicecapabilities
		*m: documentproperties
		*m: emptyclipboard
		*m: enddoc
		*m: endpage
		*m: endpaint
		*m: enumforms
		*m: findnlsstring
		*m: gdipdrawstring
		*m: gdipmeasurestring
		*m: getclassinfoex
		*m: getclipboarddata
		*m: getdc
		*m: getdefaultprinter
		*m: getdevicecaps
		*m: getkeystate
		*m: getmodulehandle
		*m: getopenclipboardwindow
		*m: getscrollinfo
		*m: getsystemdefaultlcid
		*m: gettickcount
		*m: getwindow
		*m: getwindowlong
		*m: globalalloc
		*m: globalfree
		*m: globallock
		*m: globalunlock
		*m: heapalloc
		*m: heapcreate
		*m: heapdestroy
		*m: heapfree
		*m: invalidaterect
		*m: isclipboardformatavailable
		*m: movewindow
		*m: openclipboard
		*m: openprinter
		*m: registerclassex
		*m: releasedc
		*m: selectobject
		*m: setclipboarddata
		*m: setdefaultprinter
		*m: setscrollinfo
		*m: showwindow		&& Specifies the Form window to show the Form or Toolbar in at creation time.
		*m: startdoc
		*m: startpage
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_win"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="getmodulehandle" type="method" display="GetModuleHandle"/>
			<memberdata name="getwindowlong" type="method" display="GetWindowLong"/>
			<memberdata name="getclassinfoex" type="method" display="GetClassInfoEx"/>
			<memberdata name="registerclassex" type="method" display="RegisterClassEx"/>
			<memberdata name="createwindowex" type="method" display="CreateWindowEx"/>
			<memberdata name="movewindow" type="method" display="MoveWindow"/>
			<memberdata name="destroywindow" type="method" display="DestroyWindow"/>
			<memberdata name="getwindow" type="method" display="GetWindow"/>
			<memberdata name="bitblt" type="method" display="BitBlt"/>
			<memberdata name="createdibsection" type="method" display="CreateDIBSection"/>
			<memberdata name="selectobject" type="method" display="SelectObject"/>
			<memberdata name="deleteobject" type="method" display="DeleteObject"/>
			<memberdata name="createcompatibledc" type="method" display="CreateCompatibleDC"/>
			<memberdata name="getdc" type="method" display="GetDC"/>
			<memberdata name="releasedc" type="method" display="ReleaseDC"/>
			<memberdata name="deletedc" type="method" display="DeleteDC"/>
			<memberdata name="createdc" type="method" display="CreateDC"/>
			<memberdata name="findnlsstring" type="method" display="FindNLSString"/>
			<memberdata name="getsystemdefaultlcid" type="method" display="GetSystemDefaultLCID"/>
			<memberdata name="openprinter" type="method" display="OpenPrinter"/>
			<memberdata name="closeprinter" type="method" display="ClosePrinter"/>
			<memberdata name="documentproperties" type="method" display="DocumentProperties"/>
			<memberdata name="getdefaultprinter" type="method" display="GetDefaultPrinter"/>
			<memberdata name="setdefaultprinter" type="method" display="SetDefaultPrinter"/>
			<memberdata name="devicecapabilities" type="method" display="DeviceCapabilities"/>
			<memberdata name="getdevicecaps" type="method" display="GetDeviceCaps"/>
			<memberdata name="enumforms" type="method" display="EnumForms"/>
			<memberdata name="startpage" type="method" display="StartPage"/>
			<memberdata name="endpage" type="method" display="EndPage"/>
			<memberdata name="enddoc" type="method" display="EndDoc"/>
			<memberdata name="startdoc" type="method" display="StartDoc"/>
			<memberdata name="heapalloc" type="method" display="HeapAlloc"/>
			<memberdata name="heapcreate" type="method" display="HeapCreate"/>
			<memberdata name="heapdestroy" type="method" display="HeapDestroy"/>
			<memberdata name="heapfree" type="method" display="HeapFree"/>
			<memberdata name="globalalloc" type="method" display="GlobalAlloc"/>
			<memberdata name="globalfree" type="method" display="GlobalFree"/>
			<memberdata name="globallock" type="method" display="GlobalLock"/>
			<memberdata name="globalunlock" type="method" display="GlobalUnlock"/>
			<memberdata name="beginpaint" type="method" display="BeginPaint"/>
			<memberdata name="endpaint" type="method" display="EndPaint"/>
			<memberdata name="invalidaterect" type="method" display="InvalidateRect"/>
			<memberdata name="callwindowproc" type="method" display="CallWindowProc"/>
			<memberdata name="setscrollinfo" type="method" display="SetScrollInfo"/>
			<memberdata name="getscrollinfo" type="method" display="GetScrollInfo"/>
			<memberdata name="showwindow" type="method" display="ShowWindow"/>
			<memberdata name="getkeystate" type="method" display="GetKeyState"/>
			<memberdata name="closeclipboard" type="method" display="CloseClipboard"/>
			<memberdata name="emptyclipboard" type="method" display="EmptyClipboard"/>
			<memberdata name="getclipboarddata" type="method" display="GetClipboardData"/>
			<memberdata name="isclipboardformatavailable" type="method" display="IsClipboardFormatAvailable"/>
			<memberdata name="openclipboard" type="method" display="OpenClipboard"/>
			<memberdata name="setclipboarddata" type="method" display="SetClipboardData"/>
			<memberdata name="getopenclipboardwindow" type="method" display="GetOpenClipboardWindow"/>
			<memberdata name="gettickcount" type="method" display="GetTickCount"/>
			<memberdata name="gdipdrawstring" type="method" display="GdipDrawString"/>
			<memberdata name="gdipmeasurestring" type="method" display="GdipMeasureString"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE beginpaint
		LPARAMETERS hWnd as Long, lpPaint as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BeginPaint(m.hWnd, @m.lpPaint)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG BeginPaint IN user32 AS WinApi_BeginPaint LONG hWnd, STRING @lpPaint
		    m.lvRes = WinApi_BeginPaint(m.hWnd, @m.lpPaint)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bitblt
		LPARAMETERS hdc as Long, nXDest as Integer, nYDest as Integer, nWidth as Integer, nHeight as Integer, hdcSrc as Long, nXSrc as Integer, nYSrc as Integer, nRop as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BitBlt(m.hdc, m.nXDest, m.nYDest, m.nWidth, m.nHeight, m.hdcSrc, m.nXSrc, m.nYSrc, m.nRop)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER BitBlt IN Gdi32 AS WinApi_BitBlt LONG hdc, INTEGER nXDest, INTEGER nYDest, INTEGER nWidth, INTEGER nHeight, LONG hdcSrc, INTEGER nXSrc, INTEGER nYSrc, INTEGER nRop
		    m.lvRes = WinApi_BitBlt(m.hdc, m.nXDest, m.nYDest, m.nWidth, m.nHeight, m.hdcSrc, m.nXSrc, m.nYSrc, m.nRop)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE callwindowproc
		LPARAMETERS lpPrevWndFunc as Long, hWnd as Long, Msg as Long, wParam as Long, lParam as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CallWindowProc(m.lpPrevWndFunc, m.hWnd, m.Msg, m.wParam, m.lParam)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG CallWindowProc IN User32 AS WinApi_CallWindowProc LONG lpPrevWndFunc, LONG hWnd, LONG Msg, LONG wParam, LONG lParam
		    m.lvRes = WinApi_CallWindowProc(m.lpPrevWndFunc, m.hWnd, m.Msg, m.wParam, m.lParam)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE closeclipboard
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CloseClipboard()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER CloseClipboard IN user32 AS WinApi_CloseClipboard
		    m.lvRes = WinApi_CloseClipboard()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE closeprinter
		LPARAMETERS hPrinter as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_ClosePrinter(m.hPrinter)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER ClosePrinter IN winspool.drv AS WinApi_ClosePrinter INTEGER hPrinter
		    m.lvRes = WinApi_ClosePrinter(m.hPrinter)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE createcompatibledc
		LPARAMETERS hDC as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CreateCompatibleDC(m.hDC)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER CreateCompatibleDC IN Gdi32 AS WinApi_CreateCompatibleDC INTEGER hDC
		    m.lvRes = WinApi_CreateCompatibleDC(m.hDC)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE createdc
		LPARAMETERS pwszDriver as String, pwszDevice as String, pszPort as String, pdm as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CreateDC(m.pwszDriver, m.pwszDevice, m.pszPort, @m.pdm)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG CreateDC IN Gdi32 AS WinApi_CreateDC STRING pwszDriver, STRING pwszDevice, STRING pszPort, STRING @pdm
		    m.lvRes = WinApi_CreateDC(m.pwszDriver, m.pwszDevice, m.pszPort, @m.pdm)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE createdibsection
		LPARAMETERS hdc as Integer, pbmi as String, iUsage as Long, ppvBits as Integer, hSection as Integer, dwOffset as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CreateDIBSection(m.hdc, m.pbmi, m.iUsage, @m.ppvBits, m.hSection, m.dwOffset)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER CreateDIBSection IN Gdi32 AS WinApi_CreateDIBSection INTEGER hdc, STRING pbmi, LONG iUsage, INTEGER @ppvBits, INTEGER hSection, LONG dwOffset
		    m.lvRes = WinApi_CreateDIBSection(m.hdc, m.pbmi, m.iUsage, @m.ppvBits, m.hSection, m.dwOffset)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE createwindowex
		LPARAMETERS ;
		    dwExStyle as Long, ;
		    lpClassName as String,;
		    lpWindowName as String, ;
		    dwStyle as Long,;
		    x as Integer, ;
		    y as Integer, ;
		    nWidth as Integer, ;
		    nHeight as Integer,;
		    hWndParent as Long, ;
		    hMenu as Long, ;
		    hInstance as Long,;
		    lpParam as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CreateWindowEx(;
		        m.dwExStyle,;
		        m.lpClassName,;
		        m.lpWindowName,;
		        m.dwStyle,;
		        m.x,;
		        m.y,;
		        m.nWidth,;
		        m.nHeight,;
		        m.hWndParent,;
		        m.hMenu,;
		        m.hInstance,;
		        m.lpParam)
		
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG CreateWindowEx IN user32 AS WinApi_CreateWindowEx  ;
		        LONG dwExStyle, ;
		        STRING lpClassName,;
		        STRING lpWindowName, ;
		        LONG dwStyle,;
		        INTEGER x, ;
		        INTEGER y, ;
		        INTEGER nWidth, ;
		        INTEGER nHeight,;
		        LONG hWndParent, ;
		        LONG hMenu, ;
		        LONG hInstance,;
		        LONG lpParam  
		
		    m.lvRes = WinApi_CreateWindowEx(;
		        m.dwExStyle,;
		        m.lpClassName,;
		        m.lpWindowName,;
		        m.dwStyle,;
		        m.x,;
		        m.y,;
		        m.nWidth,;
		        m.nHeight,;
		        m.hWndParent,;
		        m.hMenu,;
		        m.hInstance,;
		        m.lpParam)
		
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE deletedc
		LPARAMETERS hdc as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DeleteDC(m.hdc)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE Long DeleteDC IN Gdi32 AS WinApi_DeleteDC Long hdc
		    m.lvRes = WinApi_DeleteDC(m.hdc)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE deleteobject
		LPARAMETERS hObject as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DeleteObject(m.hObject)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER DeleteObject IN Gdi32 AS WinApi_DeleteObject INTEGER hObject
		    m.lvRes = WinApi_DeleteObject(m.hObject)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE destroywindow
		LPARAMETERS hWnd as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DestroyWindow(m.hWnd)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG DestroyWindow IN user32 AS WinApi_DestroyWindow LONG hWnd
		    m.lvRes = WinApi_DestroyWindow(m.hWnd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE devicecapabilities
		LPARAMETERS pDevice as String, pPort as String, fwCapability as Integer, pOutput as String, pDevMode as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DeviceCapabilities(m.pDevice, m.pPort, m.fwCapability, @m.pOutput, @m.pDevMode)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER DeviceCapabilities IN winspool.drv AS WinApi_DeviceCapabilities STRING pDevice, STRING pPort, INTEGER fwCapability, STRING @pOutput, STRING @pDevMode
		    m.lvRes = WinApi_DeviceCapabilities(m.pDevice, m.pPort, m.fwCapability, @m.pOutput, @m.pDevMode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE documentproperties
		LPARAMETERS hWnd as Integer, hPrinter as Integer, pDeviceName as String, pDevModeOutput as String, pDevModeInput as String, fMode as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DocumentProperties(m.hWnd, m.hPrinter, m.pDeviceName, @m.pDevModeOutput, @m.pDevModeInput, m.fMode)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER DocumentProperties IN winspool.drv AS WinApi_DocumentProperties INTEGER hWnd, INTEGER hPrinter, STRING pDeviceName, STRING @pDevModeOutput, STRING @pDevModeInput, INTEGER fMode
		    m.lvRes = WinApi_DocumentProperties(m.hWnd, m.hPrinter, m.pDeviceName, @m.pDevModeOutput, @m.pDevModeInput, m.fMode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE emptyclipboard
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EmptyClipboard()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER EmptyClipboard IN user32 AS WinApi_EmptyClipboard
		    m.lvRes = WinApi_EmptyClipboard()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE enddoc
		LPARAMETERS hdc as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EndDoc(m.hdc)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER EndDoc IN GDI32 AS WinApi_EndDoc INTEGER hdc
		    m.lvRes = WinApi_EndDoc(m.hdc)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE endpage
		LPARAMETERS hdc as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EndPage(m.hdc)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER EndPage IN GDI32 AS WinApi_EndPage INTEGER hdc
		    m.lvRes = WinApi_EndPage(m.hdc)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE endpaint
		LPARAMETERS hWnd as Long, lpPaint as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EndPaint(m.hWnd, m.lpPaint)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER EndPaint IN user32 AS WinApi_EndPaint LONG hWnd, STRING lpPaint
		    m.lvRes = WinApi_EndPaint(m.hWnd, m.lpPaint)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE enumforms
		LPARAMETERS hPrinter as Long, Level as Long, pForm as Long, cbBuf as Long, pcbNeeded as Long, pcReturned as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EnumForms(m.hPrinter, m.Level, m.pForm, m.cbBuf, @m.pcbNeeded, @m.pcReturned)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG EnumForms IN winspool.drv AS WinApi_EnumForms LONG hPrinter, LONG Level, LONG pForm, LONG cbBuf, LONG @pcbNeeded, LONG @pcReturned
		    m.lvRes = WinApi_EnumForms(m.hPrinter, m.Level, m.pForm, m.cbBuf, @m.pcbNeeded, @m.pcReturned)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE findnlsstring
		LPARAMETERS ;
		    Locale as Integer, ;
		    dwFindNLSStringFlags as Integer, ;
		    lpStringSource as String, ;
		    cchSource as Integer, ;
		    lpStringValue as Integer, ;
		    cchValue as Integer, ;
		    pcchFound as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_FindNLSString(m.Locale, m.dwFindNLSStringFlags, m.lpStringSource, m.cchSource, m.lpStringValue, m.cchValue, @m.pcchFound)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FindNLSString IN Kernel32 AS WinApi_FindNLSString ;
		        INTEGER Locale, ;
		        INTEGER dwFindNLSStringFlags, ;
		        STRING lpStringSource, ;
		        INTEGER cchSource, ;
		        STRING lpStringValue, ;
		        INTEGER cchValue, ;
		        INTEGER @pcchFound
		
		    m.lvRes = WinApi_FindNLSString(m.Locale, m.dwFindNLSStringFlags, m.lpStringSource, m.cchSource, m.lpStringValue, m.cchValue, @m.pcchFound)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdrawstring
		LPARAMETERS graphics as Long, str as String, length as Long, thefont as Long, layoutRect as String, StringFormat as Long, brush as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDrawString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, m.brush)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE Long GdipDrawString IN GDIPLUS.DLL AS WinApi_GdipDrawString Long graphics, String str, Long length, Long thefont, String @layoutRect, Long StringFormat, Long brush
		    m.lvRes = WinApi_GdipDrawString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, m.brush)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipmeasurestring
		LPARAMETERS graphics as Long, str as String, length as Long, thefont as Long, layoutRect as String, StringFormat as Long, boundingBox as String, codepointsFitted as Long, linesFilled as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipMeasureString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, @m.boundingBox, @m.codepointsFitted, @m.linesFilled)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipMeasureString IN GDIPLUS.DLL AS WinApi_GdipMeasureString ;
		        Long graphics, String str, Long length, Long thefont, String @layoutRect, Long StringFormat, String @boundingBox, Long @codepointsFitted, Long @linesFilled
		
		    m.lvRes = WinApi_GdipMeasureString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, @m.boundingBox, @m.codepointsFitted, @m.linesFilled)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getclassinfoex
		LPARAMETERS hInstance as Long, lpClassName as String, lpWndClassEx as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetClassInfoEx(m.hInstance, m.lpClassName, @m.lpWndClassEx)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER GetClassInfoEx IN user32 AS WinApi_GetClassInfoEx LONG hInstance, STRING lpClassName, STRING @lpWndClassEx
		    m.lvRes = WinApi_GetClassInfoEx(m.hInstance, m.lpClassName, @m.lpWndClassEx)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getclipboarddata
		LPARAMETERS uFormat as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetClipboardData(m.uFormat)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER GetClipboardData IN user32 AS WinApi_GetClipboardData INTEGER uFormat
		    m.lvRes = WinApi_GetClipboardData(m.uFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getdc
		LPARAMETERS hWnd as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetDC(m.hWnd)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetDC IN User32 AS WinApi_GetDC LONG hWnd
		    m.lvRes = WinApi_GetDC(m.hWnd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getdefaultprinter
		LPARAMETERS pszBuffer as String, pcchBuffer as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetDefaultPrinter(@m.pszBuffer, @m.pcchBuffer)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER GetDefaultPrinter IN WINSPOOL.DRV  AS WinApi_GetDefaultPrinter STRING @pszBuffer, LONG @pcchBuffer
		    m.lvRes = WinApi_GetDefaultPrinter(@m.pszBuffer, @m.pcchBuffer)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getdevicecaps
		LPARAMETERS hdc as Long, nIndex as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetDeviceCaps(m.hdc, m.nIndex)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetDeviceCaps IN Gdi32 AS WinApi_GetDeviceCaps LONG hdc, LONG nIndex 
		    m.lvRes = WinApi_GetDeviceCaps(m.hdc, m.nIndex)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getkeystate
		LPARAMETERS vKey as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetKeyState(m.vKey)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE SHORT GetKeyState IN user32 AS WinApi_GetKeyState INTEGER vKey
		    m.lvRes = WinApi_GetKeyState(m.vKey)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getmodulehandle
		LPARAMETERS lpModuleName as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetModuleHandle(m.lpModuleName)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER GetModuleHandle IN kernel32 AS WinApi_GetModuleHandle STRING lpModuleName
		    m.lvRes = WinApi_GetModuleHandle(m.lpModuleName)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getopenclipboardwindow
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetOpenClipboardWindow()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER GetOpenClipboardWindow IN user32 AS WinApi_GetOpenClipboardWindow
		    m.lvRes = WinApi_GetOpenClipboardWindow()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getscrollinfo
		LPARAMETERS hwnd as Long, nBar as Integer, lpsi as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetScrollInfo(m.hwnd, m.nBar, @m.lpsi)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetScrollInfo IN User32 AS WinApi_GetScrollInfo LONG hwnd, INTEGER nBar, STRING @lpsi
		    m.lvRes = WinApi_GetScrollInfo(m.hwnd, m.nBar, @m.lpsi)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getsystemdefaultlcid
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetSystemDefaultLCID()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER GetSystemDefaultLCID IN Kernel32 AS WinApi_GetSystemDefaultLCID
		    m.lvRes = WinApi_GetSystemDefaultLCID()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gettickcount
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetTickCount()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetTickCount IN Kernel32 AS WinApi_GetTickCount
		    m.lvRes = WinApi_GetTickCount()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getwindow
		LPARAMETERS hWnd as Long, uCmd as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetWindow(m.hWnd, m.uCmd)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetWindow IN user32 AS WinApi_GetWindow LONG hWnd, LONG uCmd
		    m.lvRes = WinApi_GetWindow(m.hWnd, m.uCmd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getwindowlong
		LPARAMETERS hWnd as Long, nIndex as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetWindowLong(m.hWnd, m.nIndex)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetWindowLong IN user32 AS WinApi_GetWindowLong LONG hWnd, INTEGER nIndex
		    m.lvRes = WinApi_GetWindowLong(m.hWnd, m.nIndex)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globalalloc
		LPARAMETERS nFlags as Long, nSize as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalAlloc(m.nFlags, m.nSize)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE Long GlobalAlloc IN Kernel32 AS WinApi_GlobalAlloc Long nFlags, Long nSize
		    m.lvRes = WinApi_GlobalAlloc(m.nFlags, m.nSize)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globalfree
		LPARAMETERS nHandle as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalFree(m.nHandle)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE Long GlobalFree IN Kernel32 AS WinApi_GlobalFree Long nHandle
		    m.lvRes = WinApi_GlobalFree(m.nHandle)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globallock
		LPARAMETERS hMem as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalLock(m.hMem)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GlobalLock IN Kernel32 AS WinApi_GlobalLock LONG hMem
		    m.lvRes = WinApi_GlobalLock(m.hMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globalunlock
		LPARAMETERS hMem as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalUnlock(m.hMem)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GlobalUnlock IN Kernel32 AS WinApi_GlobalUnlock LONG hMem
		    m.lvRes = WinApi_GlobalUnlock(m.hMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE heapalloc
		LPARAMETERS hHeap as Integer, dwFlags as Integer, dwBytes as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_HeapAlloc(m.hHeap, m.dwFlags, m.dwBytes)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HeapAlloc IN Kernel32 AS WinApi_HeapAlloc INTEGER hHeap, INTEGER dwFlags, INTEGER dwBytes
		    m.lvRes = WinApi_HeapAlloc(m.hHeap, m.dwFlags, m.dwBytes)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE heapcreate
		LPARAMETERS dwOptions as Integer, dwInitialSize as Integer, dwMaxSize as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_HeapCreate(m.dwOptions, m.dwInitialSize, m.dwMaxSize)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HeapCreate IN Kernel32 AS WinApi_HeapCreate INTEGER dwOptions, INTEGER dwInitialSize, INTEGER dwMaxSize
		    m.lvRes = WinApi_HeapCreate(m.dwOptions, m.dwInitialSize, m.dwMaxSize)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE heapdestroy
		LPARAMETERS hHeap as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_HeapDestroy(m.hHeap)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HeapDestroy IN Kernel32 AS WinApi_HeapDestroy INTEGER hHeap
		    m.lvRes = WinApi_HeapDestroy(m.hHeap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE heapfree
		LPARAMETERS hHeap as Integer, dwFlags as Integer, pMem as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_HeapFree(m.hHeap, m.dwFlags, m.pMem)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HeapFree IN Kernel32 AS WinApi_HeapFree INTEGER hHeap, INTEGER dwFlags, INTEGER lpMem
		    m.lvRes = WinApi_HeapFree(m.hHeap, m.dwFlags, m.pMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE invalidaterect
		LPARAMETERS hWnd as Long, lpRect as String, bErase as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_InvalidateRect(m.hWnd, m.lpRect, m.bErase)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG InvalidateRect IN User32 AS WinApi_InvalidateRect LONG hWnd, STRING lpRect, LONG bErase
		    m.lvRes = WinApi_InvalidateRect(m.hWnd, m.lpRect, m.bErase)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE isclipboardformatavailable
		LPARAMETERS uFormat as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_IsClipboardFormatAvailable(m.uFormat)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER IsClipboardFormatAvailable IN user32 AS WinApi_IsClipboardFormatAvailable INTEGER uFormat
		    m.lvRes = WinApi_IsClipboardFormatAvailable(m.uFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE movewindow
		LPARAMETERS hWnd as Long, X as Integer, Y as Integer, nWidth as Integer, nHeight as Integer, bRepaint as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_MoveWindow(m.hWnd, m.X, m.Y, m.nWidth, m.nHeight, m.bRepaint)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG MoveWindow IN user32 AS WinApi_MoveWindow LONG hWnd, INTEGER X, INTEGER Y, INTEGER nWidth, INTEGER nHeight, INTEGER bRepaint
		    m.lvRes = WinApi_MoveWindow(m.hWnd, m.X, m.Y, m.nWidth, m.nHeight, m.bRepaint)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE openclipboard
		LPARAMETERS hWndNewOwner as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_OpenClipboard(m.hWndNewOwner)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER OpenClipboard IN user32 AS WinApi_OpenClipboard INTEGER hWndNewOwner
		    m.lvRes = WinApi_OpenClipboard(m.hWndNewOwner)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE openprinter
		LPARAMETERS pPrinterName as String, phPrinter as Integer, pDefault as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_OpenPrinter(m.pPrinterName, @m.phPrinter, m.pDefault)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER OpenPrinter IN winspool.drv AS WinApi_OpenPrinter STRING pPrinterName, INTEGER @phPrinter, INTEGER pDefault
		    m.lvRes = WinApi_OpenPrinter(m.pPrinterName, @m.phPrinter, m.pDefault)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE registerclassex
		LPARAMETERS lpWndClassEx as String 
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_RegisterClassEx(m.lpWndClassEx)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG RegisterClassEx IN user32 AS WinApi_RegisterClassEx STRING lpWndClassEx
		    m.lvRes = WinApi_RegisterClassEx(m.lpWndClassEx)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE releasedc
		LPARAMETERS hWnd as Long, hDC as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_ReleaseDC(m.hWnd, m.hDC)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE Long ReleaseDC IN User32 AS WinApi_ReleaseDC Long hWnd, Long hDC
		    m.lvRes = WinApi_ReleaseDC(m.hWnd, m.hDC)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE selectobject
		LPARAMETERS hdc as Integer, hgdiobj as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SelectObject(m.hdc, m.hgdiobj)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER SelectObject IN Gdi32 AS WinApi_SelectObject INTEGER hdc, INTEGER hgdiobj
		    m.lvRes = WinApi_SelectObject(m.hdc, m.hgdiobj)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE setclipboarddata
		LPARAMETERS uFormat as Integer, hMem as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SetClipboardData(m.uFormat, m.hMem)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER SetClipboardData IN user32 AS WinApi_SetClipboardData INTEGER uFormat, INTEGER hMem
		    m.lvRes = WinApi_SetClipboardData(m.uFormat, m.hMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE setdefaultprinter
		LPARAMETERS pszPrinter as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SetDefaultPrinter(m.pszPrinter)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER SetDefaultPrinter IN WINSPOOL.DRV  AS WinApi_SetDefaultPrinter STRING pszPrinter
		    m.lvRes = WinApi_SetDefaultPrinter(m.pszPrinter)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE setscrollinfo
		LPARAMETERS hwnd as Long, nBar as Integer, lpsi as String, redraw as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SetScrollInfo(m.hwnd, m.nBar, m.lpsi, m.redraw)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER SetScrollInfo IN User32 AS WinApi_SetScrollInfo LONG hwnd, INTEGER nBar, STRING lpsi, LONG redraw
		    m.lvRes = WinApi_SetScrollInfo(m.hwnd, m.nBar, m.lpsi, m.redraw)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE showwindow		&& Specifies the Form window to show the Form or Toolbar in at creation time.
		LPARAMETERS hWnd as Long, nCmdShow as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_ShowWindow(m.hWnd, m.nCmdShow)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG ShowWindow IN User32 AS WinApi_ShowWindow LONG hWnd, INTEGER nCmdShow
		    m.lvRes = WinApi_ShowWindow(m.hWnd, m.nCmdShow)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE startdoc
		LPARAMETERS hdc as Integer, lpdi as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_StartDoc(m.hdc, m.lpdi)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER StartDoc IN GDI32 AS WinApi_StartDoc INTEGER hdc, STRING lpdi
		    m.lvRes = WinApi_StartDoc(m.hdc, m.lpdi)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE startpage
		LPARAMETERS hdc as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_StartPage(m.hdc)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER StartPage IN GDI32 AS WinApi_StartPage INTEGER hdc
		    m.lvRes = WinApi_StartPage(m.hdc)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_env AS custom 		&& Pdfium Environment Configuration Object. Usage: create, setup and pass as first parameter of PdfiumViewer.Init, PdfiumReport.Init
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="API_FPDF" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="API_HPDF" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="API_WIN" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: errmsg
		*m: foxenv_restore		&& Restore VFP environment to the state before first call of This.FoxEnv_Set or first call after last This.FoxEnv_Restore call
		*m: foxenv_set		&& Sets VFP environment to fit pdfium-vfp requirements
		*m: getappname		&& Returns file name of application executable (app, exe) from the top of the call stack. Returns empty string if there is no application executable in stack
		*m: getpdfdpi		&& PDF standart resolution (72 DPI)
		*m: getscreendpix		&& Screen horizontal DPI (constant 96 DPI)
		*m: getscreendpiy		&& Screen vertical DPI (constant 96 DPI)
		*m: getuniquetempfilename		&& Returns uniquie not existent filename in %userprofile%\AppData\Local\Temp
		*m: ok		&& Return TRUE if enviroment setup ended up with success
		*m: setup		&& Setup environment (from external environment if neccessary)
		*m: setuprelease
		*p: foxenv_prev		&& VFP environment state saving by This.FoxEnv_Set and restoring by This.FoxEnv_Restore
		*p: libhpdf_dll_path		&& Path to file libhpdf.dll. Filename without path also accepted
		*p: pdfium_dll_path		&& Path to file pdfium.dll. Filename without path also accepted
		*p: privatefonts		&& Collection of non system (custom / private) fonts. Key must be the font face name, Value - path to the font file
		*p: setup_ok
		*p: system		&& GDIPlusX System object
		*p: system_app_path		&& Path to file GDIPlusX system.app Filename without path also accepted
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,Error,foxenv_prev,Height,HelpContextID,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,setup_ok,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		foxenv_prev = .F.
		Height = 27
		libhpdf_dll_path = (IIF(FILE(ADDBS(JUSTPATH(This.ClassLibrary))+"libhpdf.dll",1), ADDBS(JUSTPATH(This.ClassLibrary)), "") +  IIF(ATC("x64", SYS(17))<>0 , "libhpdf64.dll", "libhpdf.dll"))
		Name = "pdfium_env"
		pdfium_dll_path = (IIF(FILE(ADDBS(JUSTPATH(This.ClassLibrary))+"pdfium.dll",1), ADDBS(JUSTPATH(This.ClassLibrary)), "") + IIF(ATC("x64", SYS(17))<>0 , "pdfium64.dll", "pdfium.dll"))
		privatefonts = .F.
		setup_ok = .F.
		system = .F.
		system_app_path = (IIF(FILE(ADDBS(JUSTPATH(This.ClassLibrary))+"system.app",1), ADDBS(JUSTPATH(This.ClassLibrary)), "") + "system.app")
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="pdfium_dll_path" type="property" display="pdfium_dll_path"/>
			<memberdata name="system" type="property" display="System"/>
			<memberdata name="errmsg" type="method" display="ErrMsg"/>
			<memberdata name="ok" type="method" display="ok"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="setuprelease" type="method" display="SetupRelease"/>
			<memberdata name="getpdfdpi" type="method" display="GetPDFDPI"/>
			<memberdata name="getscreendpix" type="method" display="GetScreenDPIX"/>
			<memberdata name="getscreendpiy" type="method" display="GetScreenDPIY"/>
			<memberdata name="libhpdf_dll_path" type="property" display="libhpdf_dll_path"/>
			<memberdata name="getuniquetempfilename" type="method" display="GetUniqueTempFileName"/>
			<memberdata name="system_app_path" type="property" display="system_app_path"/>
			<memberdata name="privatefonts" type="property" display="PrivateFonts"/>
			<memberdata name="getappname" type="method" display="GetAppName"/>
			<memberdata name="foxenv_prev" type="property" display="FoxEnv_Prev"/>
			<memberdata name="foxenv_restore" type="method" display="FoxEnv_Restore"/>
			<memberdata name="foxenv_set" type="method" display="FoxEnv_Set"/>
			<memberdata name="setup_ok" type="property" display="Setup_Ok"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'API_FPDF' AS pdfium_api_fpdf WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_FPDF", ;
		Top = 0, ;
		Width = 0, ;
		CONST.Name = "CONST"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'API_HPDF' AS pdfium_api_hpdf WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_HPDF", ;
		Top = 0, ;
		Width = 0, ;
		CONST.Name = "CONST"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'API_WIN' AS pdfium_api_win WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_WIN", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE Destroy
		This.PrivateFonts = .F.
		This.System = .F.
		This.SetupRelease()
		
		This.FoxEnv_Prev = .F.
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		m.lcMsg = ""
		
		DO CASE
		CASE VARTYPE(m.tvMsg)="O"
		    m.lcMsg = ;
		        m.tvMsg.Message + ;
		        RTRIM(" " + NVL(m.tvMsg.Details,"")) + ;
		        RTRIM(" " + NVL(m.tvMsg.UserValue,"")) + ;
		        CHR(13) + "Procedure: " + m.tvMsg.Procedure + ;
		        CHR(13) + "LineContents: " + m.tvMsg.LineContents
		
		CASE VARTYPE(m.tvMsg)="C"
		    m.lcMsg = ALLTRIM(m.tvMsg)
		
		ENDCASE
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		MESSAGEBOX(This.Class + " ("+This.ClassLibrary+"): " + m.lcMsg, 0+48, This.Class + " ("+This.ClassLibrary+")")
		
	ENDPROC

	PROCEDURE foxenv_restore		&& Restore VFP environment to the state before first call of This.FoxEnv_Set or first call after last This.FoxEnv_Restore call
		IF VARTYPE(This.FoxEnv_Prev) <> "O"
		    RETURN
		ENDIF
		
		LOCAL loFoxEnv
		m.loFoxEnv = This.FoxEnv_Prev
		This.FoxEnv_Prev = .F.
		
		LOCAL lcVal
		
		m.lcVal = m.loFoxEnv.SET_COMPATIBLE
		IF m.lcVal <> SET("Compatible")
		    SET COMPATIBLE &lcVal
		ENDIF
		
		m.lcVal = m.loFoxEnv.SET_CONSOLE
		SET CONSOLE &lcVal
		
	ENDPROC

	PROCEDURE foxenv_set		&& Sets VFP environment to fit pdfium-vfp requirements
		IF VARTYPE(This.FoxEnv_Prev) <> "O"
		    This.FoxEnv_Prev = NEWOBJECT("Empty")
		    ADDPROPERTY(This.FoxEnv_Prev, "SET_COMPATIBLE", SET("Compatible"))
		    ADDPROPERTY(This.FoxEnv_Prev, "SET_CONSOLE", SET("Console"))
		ENDIF
		
		IF UPPER(SET("Compatible")) <> "OFF"
		    SET COMPATIBLE OFF
		ENDIF
		
		SET CONSOLE OFF
		
	ENDPROC

	PROCEDURE getappname		&& Returns file name of application executable (app, exe) from the top of the call stack. Returns empty string if there is no application executable in stack
		LOCAL ARRAY laStack(1)
		LOCAL lnStack, liStack
		m.lnStack = ASTACKINFO(laStack)
		
		FOR m.liStack = m.lnStack TO 1 STEP -1
		
		    IF INLIST(LOWER(JUSTEXT(m.laStack[m.liStack,2])), "app", "exe") = .F.
		        LOOP
		    ENDIF
		    
		    RETURN m.laStack[m.liStack,2]
		
		ENDFOR
		
		RETURN ""
		
	ENDPROC

	PROCEDURE getpdfdpi		&& PDF standart resolution (72 DPI)
		RETURN 72
		
	ENDPROC

	PROCEDURE getscreendpix		&& Screen horizontal DPI (constant 96 DPI)
		RETURN 96
		
	ENDPROC

	PROCEDURE getscreendpiy		&& Screen vertical DPI (constant 96 DPI)
		RETURN 96
		
	ENDPROC

	PROCEDURE getuniquetempfilename		&& Returns uniquie not existent filename in %userprofile%\AppData\Local\Temp
		LPARAMETERS tcFileExt
		
		LOCAL lcFileExt
		m.lcFileExt = ALLTRIM(EVL(NVL(m.tcFileExt,""),""), 1, " ", ".")
		
		LOCAL lcPath
		m.lcPath = ADDBS(SYS(2023))
		
		LOCAL lcFilename
		m.lcFilename = ""
		
		LOCAL i
		FOR m.i = 1 TO 500
		    m.lcFilename = m.lcPath + "pdfium_vfp" + SYS(2015) + IIF(EMPTY(m.lcFileExt), "", "." + m.lcFileExt)
		    
		    IF FILE(m.lcFilename,1) OR DIRECTORY(m.lcFilename,1)
		        m.lcFilename = ""
		        LOOP
		    ENDIF
		
		    EXIT
		ENDFOR
		
		RETURN m.lcFilename
		
		
	ENDPROC

	PROCEDURE Init
		This.PrivateFonts = NEWOBJECT("Collection")
		
	ENDPROC

	PROCEDURE ok		&& Return TRUE if enviroment setup ended up with success
		RETURN This.setup_ok
		
	ENDPROC

	PROCEDURE setup		&& Setup environment (from external environment if neccessary)
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.SetupRelease()
		
		IF VARTYPE(m.toEnv)="O"
		    This.System = IIF(VARTYPE(m.toEnv.System)="O", m.toEnv.System, This.System)
		    This.pdfium_dll_path = EVL(NVL(m.toEnv.pdfium_dll_path,""), This.pdfium_dll_path)
		    This.libhpdf_dll_path = EVL(NVL(m.toEnv.libhpdf_dll_path,""), "")
		    This.system_app_path = EVL(NVL(m.toEnv.system_app_path,""), This.system_app_path)  
		
		    This.PrivateFonts = IIF(VARTYPE(m.toEnv.PrivateFonts)="O", m.toEnv.PrivateFonts, This.PrivateFonts)
		ENDIF
		
		*****************************************************************
		* System.app binding
		*****************************************************************
		IF VARTYPE(This.System)<>"O" AND FILE(This.system_app_path,1)
		    LOCAL loTemp
		    m.loTemp = NEWOBJECT("Empty")
		    DO (This.system_app_path) WITH m.loTemp
		    This.System = m.loTemp.System
		    m.loTemp = .F.
		ENDIF
		
		IF VARTYPE(This.System)<>"O" AND TYPE("_SCREEN.System")="O"
		    This.System = _SCREEN.System
		ENDIF
		
		IF VARTYPE(This.System)<>"O"
		    This.errMsg(TEXTMERGE("<<This.Class>>.System: GDIPlusX System object wasn't found. It must be passed through <<This.Class>>.Init toConf parameter or as _SCREEN.System"))
		    RETURN .F.
		ENDIF
		
		
		*****************************************************************
		* Pdfium.dll binding
		*****************************************************************
		This.pdfium_dll_path = FULLPATH(ALLTRIM(EVL(NVL(This.pdfium_dll_path,""),"")))
		
		IF FILE(This.pdfium_dll_path,1)=.F.
		    This.errMsg(TEXTMERGE("<<This.Class>>.pdfium_dll_path: File <<This.pdfium_dll_path>> does not exist"))
		    RETURN .F.
		ENDIF
		
		This.API_FPDF.pdfium_dll_path = This.pdfium_dll_path
		
		
		*****************************************************************
		* Libhpdf.dll binding
		*****************************************************************
		IF EMPTY(This.libhpdf_dll_path)=.F.
		    This.libhpdf_dll_path = FULLPATH(ALLTRIM(EVL(NVL(This.libhpdf_dll_path,""),"")))
		
		    IF FILE(This.libhpdf_dll_path,1)=.F.
		        This.errMsg(TEXTMERGE("<<This.Class>>.libhpdf_dll_path: File <<This.libhpdf_dll_path>> does not exist"))
		        RETURN .F.
		    ENDIF
		
		    This.API_HPDF.libhpdf_dll_path = This.libhpdf_dll_path
		ENDIF
		
		
		
		*****************************************************************
		* Pdfium library initialization
		*****************************************************************
		This.setup_ok = .F.
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    This.API_FPDF.FPDF_InitLibraryWithConfig()
		    
		    This.setup_ok = .T.
		
		CATCH TO m.loErr
		    This.errMsg(m.loErr)
		ENDTRY
		
		IF This.setup_ok = .F.
		    RETURN .F.
		ENDIF
		
		
		*****************************************************************
		* Private fonts installation
		*****************************************************************
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    LOCAL lcFontPath
		    m.lcFontPath = ""
		    FOR EACH m.lcFontPath IN This.PrivateFonts FOXOBJECT
		        IF FILE(ALLTRIM(m.lcFontPath),1)
		            This.System.Drawing.Text.PrivateFontCollection.AddFontFile(ALLTRIM(m.lcFontPath) + CHR(0))
		        ENDIF
		    ENDFOR
		
		CATCH TO m.loErr
		    This.errMsg(m.loErr)
		ENDTRY
		
		
	ENDPROC

	HIDDEN PROCEDURE setuprelease
		
		IF This.setup_ok = .F.
		    RETURN
		ENDIF
		
		This.setup_ok = .F.
		
		This.API_FPDF.FPDF_DestroyLibrary()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_i18n AS custom 		&& PdfiumViewer Internationalization Helper. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="API_WIN" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: getlocaleid		&& Returns system locale id
		*m: text		&& Returns all of the text in a text-entry area of a control.
		*m: text_cn
		*m: text_de
		*m: text_en
		*m: text_es
		*m: text_fr
		*m: text_ru
		*p: localeid
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,Error,Height,HelpContextID,localeid,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		localeid = 1033
		Name = "pdfium_i18n"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="localeid" type="property" display="LocaleID"/>
			<memberdata name="getlocaleid" type="method" display="GetLocaleID"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'API_WIN' AS pdfium_api_win WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_WIN", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE getlocaleid		&& Returns system locale id
		RETURN This.LocaleID
		
	ENDPROC

	PROCEDURE Init
		This.LocaleID = This.API_WIN.GetSystemDefaultLCID()
		
	ENDPROC

	PROCEDURE text		&& Returns all of the text in a text-entry area of a control.
		* This code is generated by BUILD\BUILD_I18N.prg
		
		LPARAMETERS tcTxtID
		
		LOCAL lcTxtID
		m.lcTxtID = UPPER(ALLTRIM(EVL(NVL(m.tcTxtID,""),"")))
		
		IF EMPTY(m.lcTxtID)
		RETURN ""
		ENDIF
		
		
		DO CASE 
		
		CASE This.LocaleID = 2052
		RETURN This.text_cn(m.lcTxtID)
		
		CASE This.LocaleID = 1031
		RETURN This.text_de(m.lcTxtID)
		
		CASE This.LocaleID = 1033
		RETURN This.text_en(m.lcTxtID)
		
		CASE This.LocaleID = 1034
		RETURN This.text_es(m.lcTxtID)
		
		CASE This.LocaleID = 1036
		RETURN This.text_fr(m.lcTxtID)
		
		CASE This.LocaleID = 1049
		RETURN This.text_ru(m.lcTxtID)
		
		OTHERWISE
		RETURN This.text_en(m.lcTxtID)
		
		ENDCASE
		
	ENDPROC

	HIDDEN PROCEDURE text_cn
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_CN.XML for LocaleID = 2052
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(184) + CHR(180) + CHR(214) + CHR(198)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(200) + CHR(171) + CHR(209) + CHR(161)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(188) + CHR(244) + CHR(199) + CHR(208)
		
		
		CASE m.tcTxtID == "MNU_PASTE"
		RETURN CHR(213) + CHR(179) + CHR(204) + CHR(249)
		
		
		CASE m.tcTxtID == "MNU_CLEAR"
		RETURN CHR(199) + CHR(229) + CHR(192) + CHR(237)
		
		
		CASE m.tcTxtID == "REPORTVIEWER_TITLE"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161) + CHR(212) + CHR(164) + CHR(192) + CHR(192)
		
		
		CASE m.tcTxtID == "SEARCH_NOT_FOUND"
		RETURN CHR(195) + CHR(187) + CHR(211) + CHR(208) + CHR(183) + CHR(162) + CHR(207) + CHR(214)
		
		
		CASE m.tcTxtID == "SEARCH_ENDED"
		RETURN CHR(203) + CHR(209) + CHR(203) + CHR(247) + CHR(205) + CHR(234) + CHR(177) + CHR(207)
		
		
		CASE m.tcTxtID == "BTN_PRINT"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161)
		
		
		CASE m.tcTxtID == "PRINTENV_TITLE"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161) + CHR(201) + CHR(232) + CHR(214) + CHR(195)
		
		
		CASE m.tcTxtID == "PRINTENV_OK"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161)
		
		
		CASE m.tcTxtID == "PRINTENV_CANCEL"
		RETURN CHR(200) + CHR(161) + CHR(207) + CHR(251)
		
		
		CASE m.tcTxtID == "PRINTENV_PRINTER"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161) + CHR(187) + CHR(250)
		
		
		CASE m.tcTxtID == "PRINTENV_COPIES"
		RETURN CHR(183) + CHR(221) + CHR(202) + CHR(253)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE"
		RETURN CHR(210) + CHR(179) + CHR(195) + CHR(230)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ALL"
		RETURN CHR(203) + CHR(249) + CHR(211) + CHR(208)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ODD"
		RETURN CHR(189) + CHR(246) + CHR(198) + CHR(230) + CHR(202) + CHR(253) + CHR(210) + CHR(179)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_EVEN"
		RETURN CHR(189) + CHR(246) + CHR(197) + CHR(188) + CHR(202) + CHR(253) + CHR(210) + CHR(179)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_PAGELIST"
		RETURN CHR(192) + CHR(253) + CHR(200) + CHR(231) + CHR(58) + CHR(32) + CHR(49) + CHR(45) + CHR(51) + CHR(44) + CHR(32) + CHR(53) + CHR(45) + CHR(56) + CHR(44) + CHR(32) + CHR(57)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_DUPLEX"
		RETURN CHR(203) + CHR(171) + CHR(195) + CHR(230) + CHR(180) + CHR(242) + CHR(211) + CHR(161)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE"
		RETURN CHR(214) + CHR(189) + CHR(213) + CHR(197) + CHR(185) + CHR(230) + CHR(184) + CHR(241)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE_AUTO"
		RETURN CHR(215) + CHR(212) + CHR(182) + CHR(175) + CHR(209) + CHR(161) + CHR(212) + CHR(241)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_TITLE"
		RETURN CHR(202) + CHR(228) + CHR(200) + CHR(235) + CHR(195) + CHR(220) + CHR(194) + CHR(235)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_PROMPT"
		RETURN CHR(80) + CHR(68) + CHR(70) + CHR(32) + CHR(206) + CHR(196) + CHR(188) + CHR(254) + CHR(202) + CHR(220) + CHR(195) + CHR(220) + CHR(194) + CHR(235) + CHR(177) + CHR(163) + CHR(187) + CHR(164) + CHR(161) + CHR(163) + CHR(202) + CHR(228) + CHR(200) + CHR(235) + CHR(195) + CHR(220) + CHR(194) + CHR(235) + CHR(188) + CHR(180) + CHR(191) + CHR(201) + CHR(180) + CHR(242) + CHR(191) + CHR(170) + CHR(206) + CHR(196) + CHR(188) + CHR(254) + CHR(161) + CHR(163)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_INCORRECTPASSWORD"
		RETURN CHR(195) + CHR(220) + CHR(194) + CHR(235) + CHR(180) + CHR(237) + CHR(206) + CHR(243)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_OK"
		RETURN CHR(180) + CHR(242) + CHR(191) + CHR(170) + CHR(206) + CHR(196) + CHR(181) + CHR(181)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_CANCEL"
		RETURN CHR(200) + CHR(161) + CHR(207) + CHR(251)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_TITLE"
		RETURN CHR(209) + CHR(161) + CHR(212) + CHR(241) + CHR(180) + CHR(242) + CHR(211) + CHR(161) + CHR(187) + CHR(250)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_OK"
		RETURN CHR(211) + CHR(166) + CHR(211) + CHR(195)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_CANCEL"
		RETURN CHR(200) + CHR(161) + CHR(207) + CHR(251)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_de
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_DE.XML for LocaleID = 1031
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(75) + CHR(111) + CHR(112) + CHR(105) + CHR(101) + CHR(114) + CHR(101) + CHR(110)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(65) + CHR(108) + CHR(108) + CHR(101) + CHR(115) + CHR(32) + CHR(109) + CHR(97) + CHR(114) + CHR(107) + CHR(105) + CHR(101) + CHR(114) + CHR(101) + CHR(110)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_en
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_EN.XML for LocaleID = 1033
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(121)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(83) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(116) + CHR(32) + CHR(97) + CHR(108) + CHR(108)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(67) + CHR(117) + CHR(116)
		
		
		CASE m.tcTxtID == "MNU_PASTE"
		RETURN CHR(80) + CHR(97) + CHR(115) + CHR(116) + CHR(101)
		
		
		CASE m.tcTxtID == "MNU_CLEAR"
		RETURN CHR(67) + CHR(108) + CHR(101) + CHR(97) + CHR(114)
		
		
		CASE m.tcTxtID == "REPORTVIEWER_TITLE"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(32) + CHR(112) + CHR(114) + CHR(101) + CHR(118) + CHR(105) + CHR(101) + CHR(119)
		
		
		CASE m.tcTxtID == "SEARCH_NOT_FOUND"
		RETURN CHR(78) + CHR(111) + CHR(116) + CHR(32) + CHR(102) + CHR(111) + CHR(117) + CHR(110) + CHR(100)
		
		
		CASE m.tcTxtID == "SEARCH_ENDED"
		RETURN CHR(83) + CHR(101) + CHR(97) + CHR(114) + CHR(99) + CHR(104) + CHR(32) + CHR(101) + CHR(110) + CHR(100) + CHR(101) + CHR(100)
		
		
		CASE m.tcTxtID == "BTN_PRINT"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PRINTENV_TITLE"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(32) + CHR(115) + CHR(101) + CHR(116) + CHR(116) + CHR(105) + CHR(110) + CHR(103)
		
		
		CASE m.tcTxtID == "PRINTENV_OK"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PRINTENV_CANCEL"
		RETURN CHR(67) + CHR(97) + CHR(110) + CHR(99) + CHR(101) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTENV_PRINTER"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(101) + CHR(114)
		
		
		CASE m.tcTxtID == "PRINTENV_COPIES"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(105) + CHR(101) + CHR(115)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE"
		RETURN CHR(80) + CHR(97) + CHR(103) + CHR(101) + CHR(115)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ALL"
		RETURN CHR(65) + CHR(108) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ODD"
		RETURN CHR(79) + CHR(100) + CHR(100) + CHR(32) + CHR(112) + CHR(97) + CHR(103) + CHR(101) + CHR(115) + CHR(32) + CHR(111) + CHR(110) + CHR(108) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_EVEN"
		RETURN CHR(69) + CHR(118) + CHR(101) + CHR(110) + CHR(32) + CHR(112) + CHR(97) + CHR(103) + CHR(101) + CHR(115) + CHR(32) + CHR(111) + CHR(110) + CHR(108) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_PAGELIST"
		RETURN CHR(69) + CHR(120) + CHR(97) + CHR(109) + CHR(112) + CHR(108) + CHR(101) + CHR(58) + CHR(32) + CHR(49) + CHR(45) + CHR(51) + CHR(44) + CHR(32) + CHR(53) + CHR(45) + CHR(56) + CHR(44) + CHR(32) + CHR(57)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_DUPLEX"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(32) + CHR(111) + CHR(110) + CHR(32) + CHR(98) + CHR(111) + CHR(116) + CHR(104) + CHR(32) + CHR(115) + CHR(105) + CHR(100) + CHR(101) + CHR(115)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE"
		RETURN CHR(80) + CHR(97) + CHR(112) + CHR(101) + CHR(114) + CHR(32) + CHR(115) + CHR(105) + CHR(122) + CHR(101)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE_AUTO"
		RETURN CHR(65) + CHR(117) + CHR(116) + CHR(111) + CHR(109) + CHR(97) + CHR(116) + CHR(105) + CHR(99) + CHR(32) + CHR(99) + CHR(104) + CHR(111) + CHR(105) + CHR(99) + CHR(101)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_TITLE"
		RETURN CHR(73) + CHR(110) + CHR(112) + CHR(117) + CHR(116) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_PROMPT"
		RETURN CHR(80) + CHR(68) + CHR(70) + CHR(32) + CHR(102) + CHR(105) + CHR(108) + CHR(101) + CHR(32) + CHR(105) + CHR(115) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100) + CHR(32) + CHR(112) + CHR(114) + CHR(111) + CHR(116) + CHR(101) + CHR(99) + CHR(116) + CHR(101) + CHR(100) + CHR(46) + CHR(32) + CHR(73) + CHR(110) + CHR(112) + CHR(117) + CHR(116) + CHR(32) + CHR(97) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100) + CHR(32) + CHR(116) + CHR(111) + CHR(32) + CHR(111) + CHR(112) + CHR(101) + CHR(110) + CHR(32) + CHR(116) + CHR(104) + CHR(101) + CHR(32) + CHR(102) + CHR(105) + CHR(108) + CHR(101) + CHR(46)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_INCORRECTPASSWORD"
		RETURN CHR(73) + CHR(110) + CHR(99) + CHR(111) + CHR(114) + CHR(114) + CHR(101) + CHR(99) + CHR(116) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_OK"
		RETURN CHR(79) + CHR(112) + CHR(101) + CHR(110) + CHR(32) + CHR(100) + CHR(111) + CHR(99) + CHR(117) + CHR(109) + CHR(101) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_CANCEL"
		RETURN CHR(67) + CHR(97) + CHR(110) + CHR(99) + CHR(101) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_TITLE"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(101) + CHR(114) + CHR(32) + CHR(115) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(116) + CHR(105) + CHR(111) + CHR(110)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_OK"
		RETURN CHR(65) + CHR(112) + CHR(112) + CHR(108) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_CANCEL"
		RETURN CHR(67) + CHR(97) + CHR(110) + CHR(99) + CHR(101) + CHR(108)
		
		OTHERWISE
		RETURN m.tcTxtID
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_es
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_ES.XML for LocaleID = 1034
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(105) + CHR(97) + CHR(114)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(83) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(99) + CHR(105) + CHR(111) + CHR(110) + CHR(97) + CHR(114) + CHR(32) + CHR(116) + CHR(111) + CHR(100) + CHR(111)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_fr
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_FR.XML for LocaleID = 1036
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(105) + CHR(101) + CHR(114)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(83) + CHR(233) + CHR(108) + CHR(101) + CHR(99) + CHR(116) + CHR(105) + CHR(111) + CHR(110) + CHR(110) + CHR(101) + CHR(114) + CHR(32) + CHR(116) + CHR(111) + CHR(117) + CHR(116)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_ru
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_RU.XML for LocaleID = 1049
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(202) + CHR(238) + CHR(239) + CHR(232) + CHR(240) + CHR(238) + CHR(226) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(194) + CHR(251) + CHR(225) + CHR(240) + CHR(224) + CHR(242) + CHR(252) + CHR(32) + CHR(226) + CHR(241) + CHR(229)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(194) + CHR(251) + CHR(240) + CHR(229) + CHR(231) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "MNU_PASTE"
		RETURN CHR(194) + CHR(241) + CHR(242) + CHR(224) + CHR(226) + CHR(232) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "MNU_CLEAR"
		RETURN CHR(211) + CHR(228) + CHR(224) + CHR(235) + CHR(232) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "REPORTVIEWER_TITLE"
		RETURN CHR(207) + CHR(240) + CHR(238) + CHR(241) + CHR(236) + CHR(238) + CHR(242) + CHR(240) + CHR(32) + CHR(239) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(232)
		
		
		CASE m.tcTxtID == "SEARCH_NOT_FOUND"
		RETURN CHR(205) + CHR(229) + CHR(32) + CHR(237) + CHR(224) + CHR(233) + CHR(228) + CHR(229) + CHR(237) + CHR(238)
		
		
		CASE m.tcTxtID == "SEARCH_ENDED"
		RETURN CHR(207) + CHR(238) + CHR(232) + CHR(241) + CHR(234) + CHR(32) + CHR(231) + CHR(224) + CHR(226) + CHR(229) + CHR(240) + CHR(248) + CHR(229) + CHR(237)
		
		
		CASE m.tcTxtID == "BTN_PRINT"
		RETURN CHR(207) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTENV_TITLE"
		RETURN CHR(207) + CHR(224) + CHR(240) + CHR(224) + CHR(236) + CHR(229) + CHR(242) + CHR(240) + CHR(251) + CHR(32) + CHR(239) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(232)
		
		
		CASE m.tcTxtID == "PRINTENV_OK"
		RETURN CHR(207) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTENV_CANCEL"
		RETURN CHR(206) + CHR(242) + CHR(236) + CHR(229) + CHR(237) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTENV_PRINTER"
		RETURN CHR(207) + CHR(240) + CHR(232) + CHR(237) + CHR(242) + CHR(229) + CHR(240)
		
		
		CASE m.tcTxtID == "PRINTENV_COPIES"
		RETURN CHR(202) + CHR(238) + CHR(239) + CHR(232) + CHR(232)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE"
		RETURN CHR(209) + CHR(242) + CHR(240) + CHR(224) + CHR(237) + CHR(232) + CHR(246) + CHR(251)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ALL"
		RETURN CHR(194) + CHR(241) + CHR(229)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ODD"
		RETURN CHR(210) + CHR(238) + CHR(235) + CHR(252) + CHR(234) + CHR(238) + CHR(32) + CHR(237) + CHR(229) + CHR(247) + CHR(229) + CHR(242) + CHR(237) + CHR(251) + CHR(229)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_EVEN"
		RETURN CHR(210) + CHR(238) + CHR(235) + CHR(252) + CHR(234) + CHR(238) + CHR(32) + CHR(247) + CHR(229) + CHR(242) + CHR(237) + CHR(251) + CHR(229)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_PAGELIST"
		RETURN CHR(205) + CHR(224) + CHR(239) + CHR(240) + CHR(232) + CHR(236) + CHR(229) + CHR(240) + CHR(58) + CHR(32) + CHR(49) + CHR(45) + CHR(51) + CHR(44) + CHR(32) + CHR(53) + CHR(45) + CHR(56) + CHR(44) + CHR(32) + CHR(57)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_DUPLEX"
		RETURN CHR(196) + CHR(226) + CHR(243) + CHR(241) + CHR(242) + CHR(238) + CHR(240) + CHR(238) + CHR(237) + CHR(237) + CHR(255) + CHR(255) + CHR(32) + CHR(239) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE"
		RETURN CHR(208) + CHR(224) + CHR(231) + CHR(236) + CHR(229) + CHR(240) + CHR(32) + CHR(225) + CHR(243) + CHR(236) + CHR(224) + CHR(227) + CHR(232)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE_AUTO"
		RETURN CHR(192) + CHR(226) + CHR(242) + CHR(238) + CHR(226) + CHR(251) + CHR(225) + CHR(238) + CHR(240)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_TITLE"
		RETURN CHR(194) + CHR(226) + CHR(229) + CHR(228) + CHR(232) + CHR(242) + CHR(229) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(252)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_PROMPT"
		RETURN CHR(80) + CHR(68) + CHR(70) + CHR(32) + CHR(244) + CHR(224) + CHR(233) + CHR(235) + CHR(32) + CHR(231) + CHR(224) + CHR(249) + CHR(232) + CHR(249) + CHR(229) + CHR(237) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(229) + CHR(236) + CHR(46) + CHR(32) + CHR(194) + CHR(226) + CHR(229) + CHR(228) + CHR(232) + CHR(242) + CHR(229) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(252) + CHR(32) + CHR(228) + CHR(235) + CHR(255) + CHR(32) + CHR(238) + CHR(242) + CHR(234) + CHR(240) + CHR(251) + CHR(242) + CHR(232) + CHR(255) + CHR(32) + CHR(244) + CHR(224) + CHR(233) + CHR(235) + CHR(224) + CHR(46)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_INCORRECTPASSWORD"
		RETURN CHR(205) + CHR(229) + CHR(239) + CHR(240) + CHR(224) + CHR(226) + CHR(232) + CHR(235) + CHR(252) + CHR(237) + CHR(251) + CHR(233) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(252)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_OK"
		RETURN CHR(206) + CHR(242) + CHR(234) + CHR(240) + CHR(251) + CHR(242) + CHR(252) + CHR(32) + CHR(228) + CHR(238) + CHR(234) + CHR(243) + CHR(236) + CHR(229) + CHR(237) + CHR(242)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_CANCEL"
		RETURN CHR(206) + CHR(242) + CHR(236) + CHR(229) + CHR(237) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_TITLE"
		RETURN CHR(194) + CHR(251) + CHR(225) + CHR(238) + CHR(240) + CHR(32) + CHR(239) + CHR(240) + CHR(232) + CHR(237) + CHR(242) + CHR(229) + CHR(240) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_OK"
		RETURN CHR(209) + CHR(238) + CHR(245) + CHR(240) + CHR(224) + CHR(237) + CHR(232) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_CANCEL"
		RETURN CHR(206) + CHR(242) + CHR(236) + CHR(229) + CHR(237) + CHR(224)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_password_input AS form 		&& Password input form
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtPassword" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOk" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTitle" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFocusHolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPrompt" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblIncorrect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgPasswordShow" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgPasswordHide" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: in_incorrect		&& Incorrect password flag
		*p: out_ok		&& .T. - User pressed ok button, .F. - user pressed cancel
		*p: out_password		&& Inputted password
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BindControls = .F.
		BorderStyle = 2
		Caption = ""
		DoCreate = .T.
		Height = 187
		Icon = (NVL(EVL(JUSTPATH(This.ClassLibrary),NULL)+"\images\wwrite.ico",""))
		in_incorrect = .F.
		KeyPreview = .T.
		MaxButton = .F.
		MinButton = .F.
		Name = "pdfium_password_input"
		out_ok = .F.
		out_password = ("")
		ShowWindow = 1
		TitleBar = 0
		Visible = .T.
		Width = 331
		WindowType = 1
		_memberdata = <VFPData>
			<memberdata name="in_incorrect" type="property" display="In_Incorrect"/>
			<memberdata name="out_ok" type="property" display="Out_Ok"/>
			<memberdata name="out_password" type="property" display="Out_Password"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Cancel", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 192, ;
		Name = "cmdCancel", ;
		TabIndex = 3, ;
		Top = 144, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFocusHolder' AS commandbutton WITH ;
		Caption = "", ;
		Height = 27, ;
		Left = 444, ;
		Name = "cmdFocusHolder", ;
		Style = 1, ;
		TabIndex = 4, ;
		Top = 276, ;
		Width = 36
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOk' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Ok", ;
		Default = .T., ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 12, ;
		Name = "cmdOk", ;
		TabIndex = 2, ;
		Top = 144, ;
		Width = 160
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 300, ;
		Name = "i18n", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'imgPasswordHide' AS image WITH ;
		Height = 24, ;
		Left = 291, ;
		MousePointer = 15, ;
		Name = "imgPasswordHide", ;
		PictureVal = , ;
		Top = 73, ;
		Visible = .F., ;
		Width = 24
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'imgPasswordShow' AS image WITH ;
		Height = 24, ;
		Left = 291, ;
		MousePointer = 15, ;
		Name = "imgPasswordShow", ;
		PictureVal = , ;
		Top = 73, ;
		Visible = .F., ;
		Width = 24
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'lblIncorrect' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Incorrect password", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		ForeColor = 255,0,0, ;
		Height = 19, ;
		Left = 12, ;
		Name = "lblIncorrect", ;
		TabIndex = 5, ;
		Top = 106, ;
		Width = 300
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPrompt' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "This file is protected by password. Input password to open the file", ;
		FontBold = .F., ;
		FontName = "Segoe UI", ;
		FontSize = 9, ;
		Height = 33, ;
		Left = 12, ;
		Name = "lblPrompt", ;
		TabIndex = 5, ;
		Top = 36, ;
		Width = 300, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblTitle' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Input password", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 12, ;
		Name = "lblTitle", ;
		TabIndex = 5, ;
		Top = 12, ;
		Width = 300
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'txtPassword' AS pdfium_textbox WITH ;
		ControlSource = "Thisform.out_password", ;
		Format = "KF", ;
		Height = 27, ;
		InputMask = "", ;
		Left = 12, ;
		MaxLength = 255, ;
		Name = "txtPassword", ;
		PasswordChar = "", ;
		TabIndex = 1, ;
		Top = 72, ;
		Width = 276
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />
	
	PROCEDURE Init
		This.BindControls = .T.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 27 AND EMPTY(m.nShiftAltCtrl)
		    This.out_ok = .F.
		    This.Hide()
		ENDIF
		
		
	ENDPROC

	PROCEDURE Load
		CLEAR TYPEAHEAD 
		
		
		
		
	ENDPROC

	PROCEDURE Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_TITLE")
		
		This.txtPassword.Value = This.Out_Password
		This.lblIncorrect.Visible = This.in_incorrect
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.out_ok = .F.
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdCancel.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_CANCEL")
		
	ENDPROC

	PROCEDURE cmdOk.Click
		
		Thisform.Out_Ok = .T.
		
		Thisform.Hide()
		
		
	ENDPROC

	PROCEDURE cmdOk.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_OK")
		
	ENDPROC

	PROCEDURE imgPasswordHide.Click
		This.Visible = .F.
		This.Parent.txtPassword.ResetToDefault("PasswordChar")
		This.Parent.txtPassword.InteractiveChange()
		This.Parent.txtPassword.SelStart = LEN(This.Parent.txtPassword.Text)
		
	ENDPROC

	PROCEDURE imgPasswordHide.Init
		This.PictureVal = STRCONV("iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAASnSURBVEhL7ZR7aFt1FMd/v/u+N69C3dwUpkWx7fLqc0xcZTIEFVe"+"FgmBfaZO1Da7+4R/6h8Ol9TFRhCKFdq3UPuI/boNVNhi+YFERtiZp0qKydi1tpfXFZpv0Jmnuy3PT24zVig78R/ADyb055/zON79zzu+H/udOwM3e9keN938NbDxRs6+j02y29IqJ5JujwwOvGeYcDQ0NVlIQdhGIEQiSoC"+"Q5LVoYZqWvr2/dCPlL8gJNXn85RZFnBMH0YCK51h0cGujS7SD8Ek3RJ+C1kCQphGGFoihIVuQVsH2LNfzx/Ox346FQSNbjt0MaTzQ1Gf7Z7ai4oGjqIwLP1ztcbhSLhkNlrspVROCDkPSaosgXpawUUzVlBWnaPo7jq1mOf"+"85kLXjW6apYmopFZo10efI72KKxtaPfYjb5NXCJ6+vdweHNnQDY42kv1jScHBsbWA4EAsT80koNJogXBV6o0yAgJYpvB4cHX90M3yS/A52mlrb3rVbrcQhckhUpYbZYavc7nDg+Gbnc1HS8ENPogmAxvessq3j+xs3EXHBk8"+"AvwnXE43ROqig5ZbdanS0oc1ngs8pmR8pYA/HOfzWZ7K53JLGqSclgjlTOKrD3D8/zR/Q43Co72XzpQVf6JpGh3IQ1XsDzrc7pc0dhkZAY+s/ZS1zko3RNmi7W2uLj0l6l4NKznzZWo3vvCfSyFpwmC5KTUxiEowVXd3uA5d"+"pBh2C8ZhhEyqVQ3TFeuXB5Px/0kS0/LsvRbyibYz/X0pHV7s8/nYmjT14qqYDktOYLBwSVCd9Ca/IoZZjSbTr+xlVyHEehfobm0JEmI5bmAx9eRExgdHViQlex5WFJkWU0V5YKBsaGhqWw2dUrPRdDEy7otJ6ARhKJp0CYSi"+"/rvPBmVg7GkVFVBugjDcoEWrz+guwiFPJFKp8KapppysQYwBKyeCpD0r00BUn0PJibBslxXo9fr0G06NK0twIpZmqaRCl2UQYRm2S5Pa0fXyEj/j1Jq7Ygo0D8Y4XCWvA/D6J4UxWQCq7hHt+WaPBWJrDnc5TdNJlOdKmtH7"+"BXu8eloNBGJRCRXZfUCgXE9RVG5AwZ/B7EcexjOCQ6ODn/6/cREFoy45Zi/hqKYs9Azazaz4R8dPv2VnvvWQYtFIqWlzkKbreApJSvVudxV1+Kx8PWpaHjG4SyfgFI5VA0VQklIEFI4nn/M7ihD8clwCJZjd1nVRzBB9sTqW"+"ieM7webWXc4aM1efzfPcyd1VzqTOksSxOD8zO7LoVC33NDWthdKRhIqsYciqHGW4+5Ni2JuujztnSWqLFcHPzwdNFLl+JOATnNr25OYpN6BaXCqiorSKfEGNO6KhtESCOh12geX0uOCIHBQMSSmxfzdtZ3bTvIW8Vj0+kMPF"+"A1hgrwqyTIBd9E90INKhmaqoOEHYOKKIfGMlM1+DpdeAUxlbandtVWu29hxB9tpbGw00bTlbpWUrHA6kKSi35fndi3rZWtpaasgaPoiL5j2JpPJ120m+lRvb++GsfSfCfwdDSACu7vE8dzu9WSyBi68bwzXziW6U6Zj0Z/sL"+"vcVRVZii3N7zi8uhlTD9Z8HoT8A5bAHNfkKxCkAAAAASUVORK5CYII=",14)
		
	ENDPROC

	PROCEDURE imgPasswordShow.Click
		This.Visible = .F.
		This.Parent.txtPassword.PasswordChar = ""
		This.Parent.txtPassword.InteractiveChange()
		This.Parent.txtPassword.SelStart = LEN(This.Parent.txtPassword.Text)
		
	ENDPROC

	PROCEDURE imgPasswordShow.Init
		This.PictureVal = STRCONV("iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAPxSURBV"+"EhL7ZRfaBxFHMdn9u/s7l1DHjQ2TTHFUqsBa1SKiKKSVqGGRi2o1Oz9SS53xT5IEGPBlxxtkWIffGmSW7zLXa4BEarWaC1UK6WgiE1JBNGWEmvQ+iAid7e7t//Hmbu9lJKYV33o52Fn9"+"7u/+f125vedBbf5z4HhuC6jo6PSn1V7E8dAiWEZzvXqRlQQbkxMTOhhyL+yboFk6mA/hoFKbh8jebtYjm1M8H0feL53A2J4ETL4g4I2+UljwhqsWeDV+PBTvCAeUxRlJ01WN83fMMCLJ"+"HwJBIAnSTtJ2KOSpNxJixq6fsnz8Fsni1PnmxluwoTjCmoyfUhRIl8jEe2s1fRTdUPfVcpPbZ7J5/p54B7lIHu4lM8NdHfdtdGyzD69VjstSdIjCAlfxZMH3gjTrHDLCgYT6SPt7e1vG"+"6bxR+D5mWJ+co7qaiI1wPLCMY5l74UQku3xf/Qcb6xczJ2h7xPDmT0MyxUkWe6oVqrZ8nRunOqUlQJqfESNtrXNWLa1bOvmM7OzhStUjw2N7JXkyGnPdYHrunMAQp8Uep7jeODY5t5iX"+"mt+hJraxknCWUWObKlVKqnSdC5P9UaB/UOv3Y04uMgwLGs71tPlgnaJ6vF4HGEWLQqi2O3V7f5iMXeO6olEZjeHhLOO4ywhDu/QNM1sxqce5iX5fBD42K27D5TL2nKjBzwMxpRIpM2yr"+"COt5BSflbYiSdpmW/aZVnIKvXccew4haavhwu5QBqXS+/O2bbyjRKJtDM+8SbWwyYGLMSarx17zuQmPcUD1tSC6SF6TGOCGUgOMGUguAEPg0OdGAQ8Gxw1Dr4iiNK6qQ71Uo/A8vm5b1"+"i8iEp+Lx9N9oQzU1I"+"FnRRHtsm3752hUWA5lsJ9sEUJoXNf1v33GP061lSbHkukkaXLBMutLlmHuaTVZTab6id/niHOA77mfknUGPMeRJnPAIn0pFSY/p3GvxFI9CkJfCEjcrFdr+8"+"pF7SOqs/RCWVyYX9h+Xw9UohtewBC/vKP3oasLl+ev/LBw+er9PQ9+DxnYy/PC48RB28nh+6nuWMlyIddInhhOv0iMcEpWlI3VSuXoyaJ2opGUsOokx4Yyr5Pg96gN66bxMdlF7fq1O7"+"68cCHrxWKZTTRmZib3Ox2J/3eTFR2UZWXA9Vxg29YYMcm79F2LVQUoanLkSYbjD0dk+QnaY9PQ/yLjd6Rxy6SBPgm5h65IlpQO8vMDpm5843jBodni1MVmhpusWaAFPaEQsi8Rx/SRf0"+"4Xy3LEacQUngeI168BzHwLOPDh9NSJz8Ipq1i3QIvBwUGF56MdAetuAEAgFnRrWzo7f81ms7fY+jb/RwD4B+vrrUXeOtApAAAAAElFTkSuQmCC",14)
	ENDPROC

	PROCEDURE lblIncorrect.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_INCORRECTPASSWORD")
	ENDPROC

	PROCEDURE lblPrompt.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_PROMPT")
	ENDPROC

	PROCEDURE lblTitle.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_TITLE")
	ENDPROC

	PROCEDURE txtPassword.InteractiveChange
		DO CASE
		CASE EMPTY(NVL(This.Value,""))
		    This.Parent.imgPasswordShow.Visible = .F.
		    This.Parent.imgPasswordHide.Visible = .F.
		
		CASE EMPTY(This.PasswordChar) = .T.
		    This.Parent.imgPasswordShow.Visible = .F.
		    This.Parent.imgPasswordHide.Visible = .T.
		
		OTHERWISE
		    This.Parent.imgPasswordShow.Visible = .T.
		    This.Parent.imgPasswordHide.Visible = .F.
		    
		ENDCASE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_pdfmeta AS custom 		&& PDF metadata (author,creator etc) + encryption (by password) + permission (read, edit, print etc)
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: author		&& The name of the person who created the document
		*p: creator		&& The the name of the application that created the document
		*p: keywords		&& The keywords associated with the document
		*p: ownerpassword		&& The password for the owner of the document. Owner password protects permissions of the document (Permit_* properties) . The same value as user password are not allowed. Mandatory if user password is set
		*p: permit_copy		&& Reader can copy the text and the graphics of the document; Owner password must be set to apply permission to the output doc
		*p: permit_edit		&& Reader can add or modify the annotations and form fields of the document. Owner password must be set to apply permission to the output doc
		*p: permit_edit_all		&& Reader can edit the contents of the document other than annotations, form fields. Owner password must be set to apply permission to the output doc
		*p: permit_print		&& Reader can print the document; Owner password must be set to apply permission to the output doc
		*p: producer		&& The name of the application that produced the document
		*p: subject		&& The subject of the document
		*p: title		&& The title of the document
		*p: userpassword		&& The password for the reader of the document. Document is encrypted if user password is set. Owner password is mandatory if User password is not empty
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,Error,Height,HelpContextID,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		author = ("")
		creator = ("")
		Height = 27
		keywords = ("")
		Name = "pdfium_pdfmeta"
		ownerpassword = ("")
		permit_copy = .T.
		permit_edit = .T.
		permit_edit_all = .T.
		permit_print = .T.
		producer = ("pdfium-vfp")
		subject = ("")
		title = ("")
		userpassword = ("")
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="author" type="property" display="Author"/>
			<memberdata name="creator" type="property" display="Creator"/>
			<memberdata name="keywords" type="property" display="Keywords"/>
			<memberdata name="ownerpassword" type="property" display="OwnerPassword"/>
			<memberdata name="producer" type="property" display="Producer"/>
			<memberdata name="subject" type="property" display="Subject"/>
			<memberdata name="title" type="property" display="Title"/>
			<memberdata name="userpassword" type="property" display="UserPassword"/>
		</VFPData>
	*</PropValue>

ENDDEFINE

DEFINE CLASS pdfium_print_env AS custom 		&& Print configuration state for PdfiumViewer and PdfiumReport.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="API_WIN" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: foxdefaultprinter_get		&& Returns VFP default printer (SET("Printer", 3))
		*m: foxdefaultprinter_restore		&& Restore VFP default printer to the value before first FoxDefaultPrinter_Set call or before first FoxDefaultPrinter_Set after previous FoxDefaultPrinter_Restore call
		*m: foxdefaultprinter_set		&& Set VFP default printer. If input parameter is empty default printer is set to This.Printer
		*m: getprinterdevmode		&& Return output structure DEVMODE from DocumentProperties win32api function
		*m: getprinterduplex		&& Returns printer duplex support: .T. - duplex is supported, .F. - duplex is not supported.
		*m: getprinterforms		&& Return full list of paper forms with the flag indicating that  form is supported by printer
		*m: getprintertitle
		*m: pagelist_parse		&& Parse page list input (string), returns valid string of page list
		*m: setup		&& Copy print configuration from external pdfium_print_env object
		*m: setupdefault		&& Set default values (as they are on Init)
		*m: statelen		&& Return length of the state stack
		*m: statepop		&& Restores object's state from stack saved by This.StatePush call
		*m: statepush		&& Stores object's state in the stack
		*m: sysdefaultprinter_get		&& Returns system default printer
		*m: sysdefaultprinter_restore		&& Restore system default printer to the value before first SysDefaultPrinter_Set call or before first SysDefaultPrinter_Set after previous SysDefaultPrinter_Restore call
		*m: sysdefaultprinter_set		&& Set system default printer. If input parameter is empty default printer is set to This.Printer
		*p: allowprintsetupui		&& Allows print setup dialog to be shown to a user. This is instructions to application using this object not to show any print settings dialogs. Values .T. (Default) | .F. | NULL
		*p: allowsetdefaultprinter		&& Allows set default printer. This is instructions to application using this object not to change default vfp printer. Values .T. (default) | .F. | NULL
		*p: copies		&& Number of  copies; Default value = 1
		*p: duplex		&& Duplex mode .T. | .F. (Default) | NULL
		*p: foxdefaultprinter_prev		&& VFP default printer before FoxDefaultPrinter_Set call
		*p: pagelist		&& List of pages to print (comma separated), supports intervals: 1,2-5,10; Default value = empty string
		*p: pagemode		&& 1 (default) - all, 2 - only odd, 3 - only even, 4 - PageList
		*p: papersize		&& Paper size index (like PRTINFO(2) returns); -1 - auto choice the fittest to the document; 0 (default) - unknown paper size
		*p: printer		&& Printer name; Default value = VFP default printer (sys("printer",3))
		*p: statestacksize		&& Size of StateStack
		*p: sysdefaultprinter_prev		&& System default printer before SysDefaultPrinter_Set call
		*a: statestack[1,0]		&& State store for This.StatePush and This.StatePop
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,Error,foxdefaultprinter_prev,Height,HelpContextID,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,statestacksize,statestack,sysdefaultprinter_prev,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		allowprintsetupui = .T.
		allowsetdefaultprinter = .T.
		copies = 1
		duplex = .F.
		foxdefaultprinter_prev = ("")
		Height = 27
		Name = "pdfium_print_env"
		pagelist = ("")
		pagemode = 1
		papersize = 0
		printer = ("")
		statestacksize = 0
		sysdefaultprinter_prev = ("")
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="duplex" type="property" display="Duplex"/>
			<memberdata name="printer" type="property" display="Printer"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="sysdefaultprinter_restore" type="method" display="SysDefaultPrinter_Restore"/>
			<memberdata name="sysdefaultprinter_set" type="method" display="SysDefaultPrinter_Set"/>
			<memberdata name="sysdefaultprinter_prev" type="property" display="SysDefaultPrinter_Prev"/>
			<memberdata name="copies" type="property" display="Copies"/>
			<memberdata name="pagelist" type="property" display="PageList"/>
			<memberdata name="pagemode" type="property" display="PageMode"/>
			<memberdata name="pagelist_parse" type="method" display="PageList_Parse"/>
			<memberdata name="getprinterforms" type="method" display="GetPrinterForms"/>
			<memberdata name="getprinterdevmode" type="method" display="GetPrinterDevMode"/>
			<memberdata name="papersize" type="property" display="PaperSize"/>
			<memberdata name="getprinterduplex" type="method" display="GetPrinterDuplex"/>
			<memberdata name="allowprintsetupui" type="property" display="AllowPrintSetupUI"/>
			<memberdata name="allowsetdefaultprinter" type="property" display="AllowSetDefaultPrinter"/>
			<memberdata name="foxdefaultprinter_prev" type="property" display="FoxDefaultPrinter_Prev"/>
			<memberdata name="foxdefaultprinter_restore" type="method" display="FoxDefaultPrinter_Restore"/>
			<memberdata name="foxdefaultprinter_set" type="method" display="FoxDefaultPrinter_Set"/>
			<memberdata name="getprintertitle" type="method" display="GetPrinterTitle"/>
			<memberdata name="statepop" type="method" display="StatePop"/>
			<memberdata name="statepush" type="method" display="StatePush"/>
			<memberdata name="statestack" type="property" display="StateStack"/>
			<memberdata name="statestacksize" type="property" display="StateStackSize"/>
			<memberdata name="setupdefault" type="method" display="SetupDefault"/>
			<memberdata name="foxdefaultprinter_get" type="method" display="FoxDefaultPrinter_Get"/>
			<memberdata name="sysdefaultprinter_get" type="method" display="SysDefaultPrinter_Get"/>
			<memberdata name="statelen" type="method" display="StateLen"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'API_WIN' AS pdfium_api_win WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_WIN", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE foxdefaultprinter_get		&& Returns VFP default printer (SET("Printer", 3))
		RETURN EVL(SET("Printer",3),"")
		
	ENDPROC

	PROCEDURE foxdefaultprinter_restore		&& Restore VFP default printer to the value before first FoxDefaultPrinter_Set call or before first FoxDefaultPrinter_Set after previous FoxDefaultPrinter_Restore call
		
		IF EMPTY(NVL(This.FoxDefaultPrinter_Prev,"")) = .T.
		    RETURN .F.
		ENDIF
		
		SET PRINTER TO NAME (This.FoxDefaultPrinter_Prev)
		
		This.FoxDefaultPrinter_Prev = ""
		
		
	ENDPROC

	PROCEDURE foxdefaultprinter_set		&& Set VFP default printer. If input parameter is empty default printer is set to This.Printer
		LPARAMETERS tcPrinter
		
		LOCAL lcPrinter
		m.lcPrinter = EVL(NVL(m.tcPrinter,""), EVL(NVL(This.Printer,""),""))
		
		IF EMPTY(m.lcPrinter) = .T.
		    RETURN .F.
		ENDIF
		
		IF EMPTY(This.FoxDefaultPrinter_Prev)
		    This.FoxDefaultPrinter_Prev = This.FoxDefaultPrinter_Get()
		ENDIF
		
		SET PRINTER TO NAME (m.lcPrinter)
		
		
	ENDPROC

	PROCEDURE getprinterdevmode		&& Return output structure DEVMODE from DocumentProperties win32api function
		LPARAMETERS lcPrinter
		
		* lcPrinter - printer name
		* Return: DEVMODE structure (as STRING)
		
		IF EMPTY(NVL(m.lcPrinter,""))
		    RETURN ""
		ENDIF
		
		
		#define DM_OUT_BUFFER 2
		#define DM_IN_BUFFER  8
		#define DM_IN_PROMPT  4
		
		LOCAL lcPrnDevMode
		m.lcPrnDevMode = ""
		
		LOCAL lhPrinter
		m.lhPrinter = 0
		
		This.API_WIN.OpenPrinter(m.lcPrinter, @m.lhPrinter, 0)
		
		IF m.lhPrinter = 0 
		    RETURN ""
		ENDIF
		
		LOCAL lnBufSize
		m.lnBufsize = This.API_WIN.DocumentProperties(Application.HWnd, m.lhPrinter, m.lcPrinter, NULL, NULL, 0)
		
		IF m.lnBufSize > 0
		    m.lcPrnDevMode = REPLICATE(CHR(0), m.lnBufsize)
		    This.API_WIN.DocumentProperties(Application.HWnd, m.lhPrinter, m.lcPrinter, @m.lcPrnDevMode, NULL, DM_OUT_BUFFER)
		ENDIF
		
		IF LEN(CHRTRAN(m.lcPrnDevMode, CHR(0), "")) = 0
		    m.lcPrnDevMode = ""
		ENDIF
		
		This.API_WIN.ClosePrinter(m.lhPrinter)
		
		RETURN m.lcPrnDevMode
		
	ENDPROC

	PROCEDURE getprinterduplex		&& Returns printer duplex support: .T. - duplex is supported, .F. - duplex is not supported.
		LPARAMETERS lcPrinter
		
		IF EMPTY(NVL(m.lcPrinter,""))
		    RETURN 0
		ENDIF
		
		#define DC_DUPLEX 7
		
		RETURN EMPTY(This.API_WIN.DeviceCapabilities(m.lcPrinter, NULL, DC_DUPLEX, NULL, NULL)) = .F.
		
	ENDPROC

	PROCEDURE getprinterforms		&& Return full list of paper forms with the flag indicating that  form is supported by printer
		LPARAMETERS laPrnForm, lcPrinter
		
		* laPrnForm - output array (form-info-1 of EnumForms + additional columns)
		* lcPrinter - printer name
		* Return: number of forms of printer 
		
		* laPrnForm[,1] - Flags
		* laPrnForm[,2] - pName
		* laPrnForm[,3] - Size width
		* laPrnForm[,4] - Size height
		* laPrnForm[,5] - ImageableArea Left
		* laPrnForm[,6] - ImageableArea Top
		* laPrnForm[,7] - ImageableArea Width
		* laPrnForm[,8] - ImageableArea Height
		* laPrnForm[,9] - Form is supported by the printer .T. | .F.
		
		IF EMPTY(NVL(m.lcPrinter,""))
		    RETURN 0
		ENDIF
		
		#define DC_PAPERS 2
		
		
		LOCAL lhPrinter
		m.lhPrinter = 0
		
		This.API_WIN.OpenPrinter(m.lcPrinter, @m.lhPrinter, 0)
		
		IF m.lhPrinter = 0 
		    RETURN 0
		ENDIF
		
		LOCAL lnPrnFormCnt
		m.lnPrnFormCnt = 0
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    LOCAL lnBufSize, lnFormHeap, lnFormHeapPtr
		    STORE 0 TO m.lnBufSize, m.lnFormHeap, m.lnFormHeapPtr
		
		    This.API_WIN.EnumForms(m.lhPrinter, 1,  0, 0, @m.lnBufSize, 0)
		    IF m.lnBufSize = 0
		        EXIT
		    ENDIF
		    m.lnFormHeap = This.API_WIN.HeapCreate(0, m.lnBufSize, 0)
		    IF EMPTY(m.lnFormHeap)
		        EXIT
		    ENDIF
		    m.lnFormHeapPtr = This.API_WIN.HeapAlloc(m.lnFormHeap, 0, m.lnBufSize)
		    IF EMPTY(m.lnFormHeapPtr)
		        EXIT
		    ENDIF
		    This.API_WIN.EnumForms(m.lhPrinter, 1, m.lnFormHeapPtr, m.lnBufSize, @m.lnBufSize, @m.lnPrnFormCnt)
		    IF EMPTY(m.lnPrnFormCnt)
		        EXIT
		    ENDIF
		    
		    DIMENSION m.laPrnForm(m.lnPrnFormCnt, 9)
		    
		    LOCAL liForm, lnFormOffs
		    m.liForm = 1
		    m.lnFormOffs = m.lnFormHeapPtr
		    FOR m.liForm = 1 TO m.lnPrnFormCnt
		        m.laPrnForm[m.liForm,1] = CTOBIN(SYS(2600, m.lnFormOffs, 4),"4RS") && Flags
		        m.laPrnForm[m.liForm,2] = SYS(2600, CTOBIN(SYS(2600, m.lnFormOffs+4, 4),"4RS"), 31) &&pName
		        m.laPrnForm[m.liForm,3] = CTOBIN(SYS(2600, m.lnFormOffs+8, 4),"4RS") &&Size width
		        m.laPrnForm[m.liForm,4] = CTOBIN(SYS(2600, m.lnFormOffs+12, 4),"4RS") &&Size height
		        m.laPrnForm[m.liForm,5] = CTOBIN(SYS(2600, m.lnFormOffs+16, 4),"4RS") && ImageableArea Left
		        m.laPrnForm[m.liForm,6] = CTOBIN(SYS(2600, m.lnFormOffs+20, 4),"4RS") && ImageableArea Top
		        m.laPrnForm[m.liForm,7] = CTOBIN(SYS(2600, m.lnFormOffs+24, 4),"4RS") && ImageableArea Width
		        m.laPrnForm[m.liForm,8] = CTOBIN(SYS(2600, m.lnFormOffs+28, 4),"4RS") && ImageableArea Height
		        m.laPrnForm[m.liForm,9] = .F.
		        m.lnFormOffs = m.lnFormOffs + 32        
		    ENDFOR
		
		CATCH TO m.loErr
		    
		FINALLY
		    IF EMPTY(m.lnFormHeap) = .F.
		        This.API_WIN.HeapDestroy(m.lnFormHeap)
		    ENDIF
		
		    This.API_WIN.ClosePrinter(m.lhPrinter)
		ENDTRY
		
		IF VARTYPE(m.loErr) = "O"
		    RETURN 0
		ENDIF
		
		LOCAL lcPapers, lnPaperCnt, liPaper, lnFormID
		m.lnPaperCnt = This.API_WIN.DeviceCapabilities(m.lcPrinter, NULL, DC_PAPERS, NULL, NULL)
		
		IF m.lnPaperCnt <> 0
		    m.lcPapers = REPLICATE(CHR(0), m.lnPaperCnt * 2)
		    m.lnPaperCnt = This.API_WIN.DeviceCapabilities(m.lcPrinter, NULL, DC_PAPERS, @m.lcPapers, NULL)
		    m.liPaper = 1
		    FOR m.liPaper = 1 TO m.lnPaperCnt
		        m.lnFormID = CTOBIN(SUBSTR(m.lcPapers, (m.liPaper-1)*2 + 1, 2), "2RS")
		        IF BETWEEN(m.lnFormID, 1, m.lnPrnFormCnt)
		            m.laPrnForm[m.lnFormID,9] = .T.
		        ENDIF
		    ENDFOR
		ENDIF
		
		
		RETURN m.lnPrnFormCnt
		
	ENDPROC

	PROCEDURE getprintertitle
		LPARAMETERS lcPrinter
		
		m.lcPrinter = EVL(NVL(m.lcPrinter,""), NVL(This.Printer,""))
		
		IF EMPTY(m.lcPrinter) = .T.
		    RETURN ""
		ENDIF
		
		LOCAL ARRAY laPrinters(1)
		LOCAL lnPrinters, liPrinter
		m.lnPrinters = APRINTERS(laPrinters,1)
		m.liPrinter = ASCAN(m.laPrinters, m.lcPrinter, 1, m.lnPrinters, 1, 15)
		IF m.liPrinter > 0
		    RETURN m.laPrinters[m.liPrinter,1]
		ENDIF
		
		RETURN ""
		
	ENDPROC

	PROCEDURE Init
		This.Printer = This.FoxDefaultPrinter_Get()
		
	ENDPROC

	PROCEDURE pagelist_parse		&& Parse page list input (string), returns valid string of page list
		LPARAMETERS m.tcPageList
		
		LOCAL lcPageList
		m.lcPageList = m.tcPageList
		
		IF INLIST(VARTYPE(m.lcPageList), "C", "N") = .F.
		    m.lcPageList = ""
		ENDIF
		
		m.lcPageList = LEFT(ALLTRIM(EVL(NVL(m.lcPageList,""),"")),200)
		m.lcPageList = CHRTRAN(m.lcPageList, ";.Ee", ",")
		
		
		LOCAL ARRAY laGroups(1)
		LOCAL lnGroups
		m.lnGroups = ALINES(laGroups, m.lcPageList, 1+4, ",")
		
		IF m.lnGroups = 0
		    RETURN ""
		ENDIF
		
		LOCAL ARRAY laGroups2(lnGroups * 2)
		LOCAL lnGroups2
		m.lnGroups2 = 0
		
		LOCAL i, lcGroup, lnLVal, lnRVal, lnEVal
		m.i = 1
		FOR m.i = 1 TO m.lnGroups
		    m.lcGroup = m.laGroups[m.i]
		    
		    m.lnLVal = MAX(INT(VAL(LEFT(STREXTRACT(m.lcGroup, "", "-",1,2),10))), 0)
		    m.lnRVal = MAX(INT(VAL(LEFT(STREXTRACT(m.lcGroup, "-", "",1,2),10))), 0)
		
		    m.lnEVal = m.lnLVal
		    m.lnLVal = EVL(MIN(m.lnEVal, m.lnRVal), m.lnEVal)
		    m.lnRVal = MAX(m.lnEVal, m.lnRVal)
		
		    IF EMPTY(m.lnLVal)
		        LOOP
		    ENDIF
		    
		    m.lnGroups2 = m.lnGroups2 + 1 
		    m.laGroups2[m.lnGroups2] = m.lnLVal
		    
		    m.lnGroups2 = m.lnGroups2 + 1 
		    m.laGroups2[m.lnGroups2] = m.lnRVal
		    
		ENDFOR
		
		
		
		LOCAL i, lnLInd, lnLVal, lnRVal
		
		DO WHILE .T.
		    m.i = 1
		    m.lnLInd = 1
		    m.lnLVal = 0
		    m.lnRVal = 0
		    DO WHILE m.i < m.lnGroups2 
		        
		        DO CASE
		        CASE m.laGroups2[m.lnLInd] > m.laGroups2[m.i]
		            m.lnLVal = m.laGroups2[m.lnLInd]
		            m.laGroups2[m.lnLInd] = m.laGroups2[m.i]
		            m.laGroups2[m.lnLInd+1] = m.laGroups2[m.i+1]
		               
		            m.laGroups2[m.i] = m.lnLVal
		            m.laGroups2[m.i+1] = m.lnRVal
		            m.lnLInd = m.i
		
		        CASE m.lnRVal < m.laGroups2[m.i]
		            m.lnLInd = m.i
		            m.lnRVal = m.laGroups2[m.i+1]
		
		        
		        CASE m.lnRVal = m.laGroups2[m.i]
		            m.lnRVal = m.laGroups2[m.i+1]
		
		        CASE m.lnRVal < m.laGroups2[m.i+1]
		            m.laGroups2[m.i] = m.lnRVal
		            m.lnRVal = m.laGroups2[m.i+1]
		
		        OTHERWISE
		            m.laGroups2[m.i] = m.lnRVal
		            m.laGroups2[m.i+1] = m.lnRVal
		        ENDCASE
		        
		        m.i = m.i + 2
		        
		    ENDDO
		
		    IF m.lnLVal = 0
		        EXIT
		    ENDIF
		ENDDO
		
		
		
		m.lcPageList = ""
		
		LOCAL i, lnLVal, lnRVal
		m.i = 1
		m.lnLVal = 0
		m.lnRVal = 0
		DO WHILE m.i < m.lnGroups2
		    
		    IF m.lnRVal = m.laGroups2[m.i+1]
		        m.i = m.i + 2
		        LOOP
		    ENDIF
		    
		    IF m.lnRVal = m.laGroups2[m.i]
		        m.lnLVal = m.laGroups2[m.i]
		        m.lnRVal = m.laGroups2[m.i+1]
		        m.i = m.i + 2
		        LOOP
		    ENDIF
		    
		    m.lcPageList = m.lcPageList + ;
		        IIF(m.lnLVal = m.lnRVal, "", "-" + TRANSFORM(m.lnRVal)) + ;
		        IIF(EMPTY(m.lcPageList), "", ", ") + ;
		        TRANSFORM(m.laGroups2[m.i])
		   
		    m.lnLVal = m.laGroups2[m.i]
		    m.lnRVal = m.laGroups2[m.i+1]
		    m.i = m.i + 2
		ENDDO
		
		m.lcPageList = m.lcPageList + IIF(m.lnLVal = m.lnRVal, "", "-" + TRANSFORM(m.lnRVal))
		
		
		RETURN m.lcPageList
		
		
	ENDPROC

	PROCEDURE setup		&& Copy print configuration from external pdfium_print_env object
		LPARAMETERS toPrintEnvSrc as pdfium_print_env of pdfium-vfp, tlCopyAsIs, tcFields, tcFieldsExcept
		
		* toPrintEnvSrc: if Object passed then copies state from it, if NULL is passed then set state to undefined
		* tcFields: restore fields those matching this list (format: string of comma separated field names)
		* tcFieldsExcept: restore fields except those matching this list (format: string of comma separated field names).
		
		LOCAL lcFields, lcFieldsExcept
		m.lcFields = ALLTRIM(CHRTRAN(EVL(NVL(m.tcFields,""),""), " ", ""), 1, ",")
		m.lcFieldsExcept = ALLTRIM(CHRTRAN(EVL(NVL(m.lcFieldsExcept,""),""), " ",""), 1, ",")
		
		**************************************************************
		* Store props according to tcFieldsExcept and tcFields
		**************************************************************
		
		LOCAL ARRAY laPropState(1,2) 
		LOCAL lnPropStateCnt
		m.lnPropStateCnt = 0
		
		IF EMPTY(m.lcFields)=.F. OR EMPTY(m.lcFieldsExcept) = .F.
		    LOCAL ARRAY laProps(1)
		    LOCAL lnProps, liProp
		    m.lnProps = AMEMBERS(laProps, This, 0, "U+G")
		
		    FOR m.liProp = 1 TO m.lnProps
		
		        LOCAL lcPropName
		        m.lcPropName = ALLTRIM(m.laProps[m.liProp])
		
		        IF EMPTY(m.lcFields)=.F. AND ATC(","+m.lcPropName+",", ","+m.lcFields+",") = 0
		            LOOP
		        ENDIF
		
		        IF EMPTY(m.lcFieldsExcept)=.F. AND ATC(","+m.lcPropName+",", ","+m.lcFieldsExcept+",") <> 0
		            LOOP
		        ENDIF
		
		        m.lnPropStateCnt = m.lnPropStateCnt + 1
		        DIMENSION m.laPropState(m.lnPropStateCnt, 2)
		
		        m.laPropState[m.lnPropStateCnt, 1] = m.lcPropName
		        m.laPropState[m.lnPropStateCnt, 2] = This.&lcPropName
		
		    ENDFOR
		ENDIF
		**************************************************************
		
		DO CASE
		CASE VARTYPE(m.toPrintEnvSrc)="O" AND m.tlCopyAsIs
		    This.Printer = m.toPrintEnvSrc.Printer
		    This.Copies = m.toPrintEnvSrc.Copies
		    This.PageMode = m.toPrintEnvSrc.PageMode
		    This.PageList = m.toPrintEnvSrc.PageList
		    This.Duplex = m.toPrintEnvSrc.Duplex
		    This.PaperSize = m.toPrintEnvSrc.PaperSize
		    This.AllowPrintSetupUI = m.toPrintEnvSrc.AllowPrintSetupUI
		    This.AllowSetDefaultPrinter = m.toPrintEnvSrc.AllowSetDefaultPrinter
		
		CASE VARTYPE(m.toPrintEnvSrc)="O"
		    IF NOT ALLTRIM(LOWER(EVL(NVL(m.toPrintEnvSrc.Printer,""), This.Printer))) == ALLTRIM(LOWER(This.Printer))
		        This.PaperSize = 0
		    ENDIF
		
		    This.Printer = EVL(NVL(m.toPrintEnvSrc.Printer,""), This.Printer)
		    This.Copies = EVL(NVL(m.toPrintEnvSrc.Copies, 0), This.Copies)
		    This.PageMode = EVL(NVL(m.toPrintEnvSrc.PageMode, 0), This.PageMode)
		    This.PageList = EVL(NVL(m.toPrintEnvSrc.PageList, ""), This.PageList)
		    This.Duplex = NVL(m.toPrintEnvSrc.Duplex, This.Duplex)
		    This.PaperSize = EVL(EVL(NVL(m.toPrintEnvSrc.PaperSize, 0), NVL(This.PaperSize,0)), EVL(MAX(PRTINFO(2, NVL(This.Printer,"")),0), -1))
		    This.AllowPrintSetupUI = NVL(m.toPrintEnvSrc.AllowPrintSetupUI, This.AllowPrintSetupUI)
		    This.AllowSetDefaultPrinter = NVL(m.toPrintEnvSrc.AllowSetDefaultPrinter, This.AllowSetDefaultPrinter)
		
		
		CASE ISNULL(m.toPrintEnvSrc)
		    This.Printer = ""
		    This.Copies = 0
		    This.PageMode = 0
		    This.PageList = ""
		    This.Duplex = NULL
		    This.PaperSize = 0
		    This.AllowPrintSetupUI = NULL
		    This.AllowSetDefaultPrinter = NULL
		
		ENDCASE
		
		
		**************************************************************
		* Restore props according to tcFieldsExcept and tcFields
		**************************************************************
		LOCAL liProp
		FOR m.liProp = 1 TO m.lnPropStateCnt
		
		    LOCAL lcPropName
		    m.lcPropName = ALLTRIM(m.laPropState[m.liProp, 1])
		
		    This.&lcPropName = m.laPropState[m.liProp, 2]
		
		ENDFOR
		**************************************************************
		
	ENDPROC

	PROCEDURE setupdefault		&& Set default values (as they are on Init)
		LPARAMETERS tlCopyAsIs, tcFields, tcFieldsExcept
		
		* tcFields: restore fields those matching this list (format: string of comma separated field names)
		* tcFieldsExcept: restore fields except those matching this list (format: string of comma separated field names).
		
		LOCAL loPrintEnv
		m.loPrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		
		This.Setup(m.loPrintEnv, m.tlCopyAsIs, m.tcFieldsExcept, m.tcFields)
		
	ENDPROC

	PROCEDURE statelen		&& Return length of the state stack
		RETURN This.StateStackSize
		
	ENDPROC

	PROCEDURE statepop		&& Restores object's state from stack saved by This.StatePush call
		LPARAMETERS tcFields, tcFieldsExcept
		
		* tcFields: restore fields those matching this list (format: string of comma separated field names)
		* tcFieldsExcept: restore fields except those matching this list (format: string of comma separated field names).
		
		
		IF EMPTY(This.StateStackSize)
		    RETURN 0
		ENDIF
		
		LOCAL lSavePrintEnv
		m.lSavePrintEnv = This.StateStack[This.StateStackSize]
		
		This.Setup(m.lSavePrintEnv, .T., m.tcFieldsExcept, m.tcFields)
		
		This.StateStack[This.StateStackSize] = .F.
		This.StateStackSize = This.StateStackSize - 1
		
		IF EMPTY(This.StateStackSize) = .F.
		    DIMENSION This.StateStack(This.StateStackSize)
		ENDIF    
		
		RETURN This.StateStackSize
		
	ENDPROC

	PROCEDURE statepush		&& Stores object's state in the stack
		This.StateStackSize = This.StateStackSize + 1
		DIMENSION This.StateStack(This.StateStackSize)
		
		LOCAL lSavePrintEnv
		m.lSavePrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		
		m.lSavePrintEnv.Setup(This, .T.)
		
		This.StateStack[This.StateStackSize] = m.lSavePrintEnv
		
		RETURN This.StateStackSize
		
	ENDPROC

	PROCEDURE sysdefaultprinter_get		&& Returns system default printer
		
		LOCAL lcBuf, lnBufLen
		m.lcBuf = REPLICATE(CHR(0),2000)
		m.lnBufLen = LEN(m.lcBuf)
		
		LOCAL lcPrinter
		m.lcPrinter = ""
		
		IF This.API_WIN.GetDefaultPrinter(@m.lcBuf, @m.lnBufLen) <> 0
		    IF m.lnBufLen > 0
		        m.lcPrinter = SUBSTR(m.lcBuf, 1, m.lnBufLen)
		    ENDIF
		ENDIF    
		
		RETURN m.lcPrinter
		
	ENDPROC

	PROCEDURE sysdefaultprinter_restore		&& Restore system default printer to the value before first SysDefaultPrinter_Set call or before first SysDefaultPrinter_Set after previous SysDefaultPrinter_Restore call
		IF EMPTY(NVL(This.SysDefaultPrinter_Prev,""))
		    RETURN .F.
		ENDIF
		
		IF This.API_WIN.SetDefaultPrinter(This.SysDefaultPrinter_Prev) = 0
		    RETURN .F.
		ENDIF
		
		This.SysDefaultPrinter_Prev = ""
		
	ENDPROC

	PROCEDURE sysdefaultprinter_set		&& Set system default printer. If input parameter is empty default printer is set to This.Printer
		LPARAMETERS tcPrinter
		
		LOCAL lcPrinter
		m.lcPrinter = EVL(NVL(m.tcPrinter,""), EVL(NVL(This.Printer,""),""))
		
		IF EMPTY(m.lcPrinter) = .T.
		    RETURN .F.
		ENDIF
		
		IF EMPTY(This.SysDefaultPrinter_Prev)
		    This.SysDefaultPrinter_Prev = This.SysDefaultPrinter_Get()
		ENDIF    
		
		IF This.API_WIN.SetDefaultPrinter(This.Printer) = 0
		    RETURN .F.
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_print_settings AS form 		&& Print settings dialog.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmbPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDuplex" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOk" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="PrintEnv" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCopies" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCopies" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ogrPageMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPageMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtPageList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPageList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFocusHolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmbPaperSize" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPaperSize" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: cancel		&& Specifies if a CommandButton is the Cancel button.
		*m: papersizerequery
		*m: setup
		*p: out_ok		&& .T. - User pressed ok button, .F. - user pressed cancel
		*p: printenvin
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN printenvin
	*<PropValue>
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BindControls = .F.
		BorderStyle = 2
		Caption = "Print setup"
		DoCreate = .T.
		Height = 297
		Icon = (NVL(EVL(JUSTPATH(This.ClassLibrary),NULL)+"\images\wwrite.ico",""))
		KeyPreview = .T.
		MaxButton = .F.
		MinButton = .F.
		Name = "pdfium_print_settings"
		out_ok = .F.
		printenvin = .F.
		ShowWindow = 1
		Visible = .T.
		Width = 435
		WindowType = 1
		_memberdata = <VFPData>
			<memberdata name="out_ok" type="property" display="Out_Ok"/>
			<memberdata name="papersizerequery" type="method" display="PaperSizeRequery"/>
			<memberdata name="cancel" type="method" display="Cancel"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="printenvin" type="property" display="PrintEnvIn"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'chkDuplex' AS checkbox WITH ;
		Alignment = 4, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Duplex printing", ;
		ControlSource = "Thisform.PrintEnv.duplex", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 20, ;
		Left = 12, ;
		Name = "chkDuplex", ;
		TabIndex = 4, ;
		Top = 125, ;
		Width = 177, ;
		WordWrap = .F.
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmbPaperSize' AS combobox WITH ;
		BoundColumn = 2, ;
		BoundTo = .T., ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "160,0", ;
		ControlSource = "", ;
		DisplayCount = 21, ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 28, ;
		Left = 12, ;
		Name = "cmbPaperSize", ;
		Style = 2, ;
		TabIndex = 5, ;
		Top = 180, ;
		Width = 180
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmbPrinters' AS combobox WITH ;
		BoundColumn = 1, ;
		BoundTo = .T., ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "370,200", ;
		ControlSource = "Thisform.PrintEnv.printer", ;
		DisplayCount = 30, ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 28, ;
		Left = 12, ;
		Name = "cmbPrinters", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 28, ;
		Width = 408
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Cancel", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 237, ;
		Name = "cmdCancel", ;
		TabIndex = 10, ;
		Top = 252, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFocusHolder' AS commandbutton WITH ;
		Caption = "", ;
		Height = 27, ;
		Left = 444, ;
		Name = "cmdFocusHolder", ;
		Style = 1, ;
		TabIndex = 1, ;
		Top = 276, ;
		Width = 36
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOk' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Ok", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 74, ;
		Name = "cmdOk", ;
		TabIndex = 9, ;
		Top = 252, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 336, ;
		Name = "i18n", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'lblCopies' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Copies", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblCopies", ;
		TabIndex = 12, ;
		Top = 69, ;
		Width = 117
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPageList' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "For example: 1,2, 4 -5", ;
		Enabled = .T., ;
		FontBold = .F., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 248, ;
		Name = "lblPageList", ;
		TabIndex = 11, ;
		Top = 183, ;
		Width = 143
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPageMode' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Pages", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 227, ;
		Name = "lblPageMode", ;
		TabIndex = 15, ;
		Top = 69, ;
		Width = 171
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPaperSize' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Paper size", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblPaperSize", ;
		TabIndex = 14, ;
		Top = 158, ;
		Width = 173
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPrinters' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Printer", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblPrinters", ;
		TabIndex = 13, ;
		Top = 4, ;
		Width = 173
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'ogrPageMode' AS optiongroup WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		ButtonCount = 4, ;
		ControlSource = "Thisform.PrintEnv.PageMode", ;
		Height = 121, ;
		Left = 221, ;
		Name = "ogrPageMode", ;
		TabIndex = 7, ;
		Top = 90, ;
		Value = 1, ;
		Width = 208, ;
		Option1.AutoSize = .F., ;
		Option1.Caption = "All", ;
		Option1.FontName = "Segoe UI", ;
		Option1.FontSize = 10, ;
		Option1.Height = 19, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 5, ;
		Option1.Value = 1, ;
		Option1.Width = 193, ;
		Option2.AutoSize = .F., ;
		Option2.Caption = "Odd pages only", ;
		Option2.FontName = "Segoe UI", ;
		Option2.FontSize = 10, ;
		Option2.Height = 19, ;
		Option2.Left = 5, ;
		Option2.Name = "Option2", ;
		Option2.Top = 34, ;
		Option2.Width = 193, ;
		Option3.AutoSize = .F., ;
		Option3.Caption = "Even pages only", ;
		Option3.FontName = "Segoe UI", ;
		Option3.FontSize = 10, ;
		Option3.Height = 19, ;
		Option3.Left = 5, ;
		Option3.Name = "Option3", ;
		Option3.PictureMargin = 0, ;
		Option3.PictureSpacing = 0, ;
		Option3.Top = 63, ;
		Option3.Width = 193, ;
		Option4.AutoSize = .F., ;
		Option4.Caption = "", ;
		Option4.FontName = "Segoe UI", ;
		Option4.FontSize = 10, ;
		Option4.Height = 19, ;
		Option4.Left = 5, ;
		Option4.Name = "Option4", ;
		Option4.Top = 94, ;
		Option4.Width = 19
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'PrintEnv' AS pdfium_print_env WITH ;
		Left = 288, ;
		Name = "PrintEnv", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'txtCopies' AS pdfium_textbox WITH ;
		ControlSource = "Thisform.PrintEnv.copies", ;
		Height = 27, ;
		InputMask = "9999", ;
		Left = 12, ;
		Name = "txtCopies", ;
		TabIndex = 3, ;
		Top = 90, ;
		Width = 113
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtPageList' AS pdfium_textbox WITH ;
		ControlSource = "Thisform.PrintEnv.PageList", ;
		Height = 27, ;
		InputMask = "", ;
		Left = 242, ;
		Name = "txtPageList", ;
		TabIndex = 8, ;
		TabStop = .F., ;
		Top = 180, ;
		Width = 173
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />
	
	PROCEDURE cancel		&& Specifies if a CommandButton is the Cancel button.
		Thisform.out_ok = .F.
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE Destroy
		This.PrintEnvIn = .F.
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toPrintEnvIn as pdfium_print_env of pdfium-vfp.vcx
		
		This.PrintEnvIn = m.toPrintEnvIn
		This.PrintEnv.Setup(This.PrintEnvIn)
		
		This.BindControls = .T.
		
		LOCAL ARRAY laPrinters(1)
		LOCAL lnPrinters
		m.lnPrinters = APRINTERS(laPrinters,1)
		
		LOCAL i, llHasComments
		m.llHasComments = .F.
		FOR m.i = 1 TO m.lnPrinters
		    LOCAL lcPrinter, lcComment
		    m.lcPrinter = RTRIM(EVL(NVL(m.laPrinters[m.i,1], ""),""))
		    m.lcComment = RTRIM(EVL(NVL(m.laPrinters[m.i,4],""),""))
		
		    IF EMPTY(m.lcPrinter)
		        LOOP
		    ENDIF
		    
		    IF EMPTY(m.lcComment)=.F.
		        m.llHasComments = .T.
		    ENDIF
		
		    This.cmbPrinters.AddItem(m.lcPrinter)
		    This.cmbPrinters.AddListItem(m.lcComment, m.i, 2)
		    
		    IF RTRIM(LOWER(This.PrintEnv.Printer)) == RTRIM(LOWER(m.lcPrinter))
		        This.PrintEnv.Printer = m.lcPrinter &&Fix uppercase printer name of set(printer,3) result
		    ENDIF
		ENDFOR
		
		IF m.llHasComments = .F.
		    This.cmbPrinters.ColumnWidths = STREXTRACT(This.cmbPrinters.ColumnWidths, "", ",",1,2) + ",0"
		ENDIF
		
		This.PaperSizeRequery()
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 27 AND EMPTY(m.nShiftAltCtrl)
		    This.Cancel()
		ENDIF
		
		
	ENDPROC

	PROCEDURE Load
		CLEAR TYPEAHEAD 
		
	ENDPROC

	PROCEDURE papersizerequery
		
		#define FORM_BUILTIN 0x00000001
		#define FORM_PRINTER 0x00000002
		
		This.cmbPaperSize.Clear()
		
		LOCAL lnPrnFormCnt
		LOCAL ARRAY laPrnForm(1,9)
		m.lnPrnFormCnt = This.PrintEnv.GetPrinterForms(@m.laPrnForm, This.PrintEnv.Printer)
		IF EMPTY(m.lnPrnFormCnt)
		    RETURN
		ENDIF
		
		This.cmbPaperSize.AddItem(Thisform.i18n.text("PRINTENV_PAPERSIZE_AUTO"))
		This.cmbPaperSize.AddListItem("-1", 1, 2)
		
		LOCAL liPrnForm, lcPrnForm, llPrnFormFound
		m.liPrnForm = 1
		m.llPrnFormFound = .F.
		FOR m.liPrnForm = 1 TO m.lnPrnFormCnt
		    m.lcPrnForm = RTRIM(TRANSFORM(EVL(NVL(m.laPrnForm[m.liPrnForm,2], ""),"")))
		
		    IF EMPTY(m.lcPrnForm)
		        LOOP
		    ENDIF
		    
		    IF m.laPrnForm[m.liPrnForm,9] = .F.
		        LOOP
		    ENDIF
		    
		    IF BITAND(m.laPrnForm[m.liPrnForm,1], FORM_BUILTIN) = 0
		        LOOP
		    ENDIF
		    
		    This.cmbPaperSize.AddItem(m.lcPrnForm)
		    This.cmbPaperSize.AddListItem(TRANSFORM(m.liPrnForm), This.cmbPaperSize.ListCount, 2)
		
		    IF m.liPrnForm = This.PrintEnv.PaperSize
		        m.llPrnFormFound = .T.
		    ENDIF
		ENDFOR
		
		IF m.llPrnFormFound = .F. AND This.PrintEnv.PaperSize <> -1
		    This.PrintEnv.PaperSize = EVL(MAX(PRTINFO(2, This.PrintEnv.Printer),0), -1)
		ENDIF
		
		This.cmbPaperSize.Value = TRANSFORM(This.Printenv.PaperSize)
		
	ENDPROC

	PROCEDURE Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_TITLE")
		
	ENDPROC

	PROCEDURE setup
		IF NVL(This.PrintEnv.AllowSetDefaultPrinter, .F.) = .T.
		    This.PrintEnv.FoxDefaultPrinter_Set()
		ENDIF
		
		IF VARTYPE(This.PrintEnvIn) = "O"
		    This.PrintEnvIn.Setup(This.PrintEnv)
		ENDIF
		
		Thisform.Out_Ok = .T.
		
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE chkDuplex.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_DUPLEX")
		
		
	ENDPROC

	PROCEDURE cmbPaperSize.InteractiveChange
		Thisform.PrintEnv.PaperSize = INT(VAL(This.Value))
	ENDPROC

	PROCEDURE cmbPrinters.InteractiveChange
		Thisform.PrintEnv.Printer = This.Value
		Thisform.PaperSizeRequery()
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.Cancel()
		
	ENDPROC

	PROCEDURE cmdCancel.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_CANCEL")
		
	ENDPROC

	PROCEDURE cmdOk.Click
		Thisform.Setup()
	ENDPROC

	PROCEDURE cmdOk.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_OK")
		
	ENDPROC

	PROCEDURE lblCopies.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_COPIES")
	ENDPROC

	PROCEDURE lblPageList.Init
		DODEFAULT()
		
		This.ForeColor = This.DisabledForeColor
		
		
	ENDPROC

	PROCEDURE lblPageList.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.Parent.txtPageList.SetFocus()
		
	ENDPROC

	PROCEDURE lblPageList.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_PAGELIST")
		
		This.Visible = EMPTY(This.Parent.txtPageList.Value)
		
		
	ENDPROC

	PROCEDURE lblPageMode.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE")
		
		
	ENDPROC

	PROCEDURE lblPaperSize.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAPERSIZE")
		
	ENDPROC

	PROCEDURE lblPrinters.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PRINTER")
		
	ENDPROC

	PROCEDURE ogrPageMode.InteractiveChange
		Thisform.txtPageList.TabStop = (This.Value = 4)
		
	ENDPROC

	PROCEDURE ogrPageMode.Option1.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_ALL")
	ENDPROC

	PROCEDURE ogrPageMode.Option2.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_ODD")
	ENDPROC

	PROCEDURE ogrPageMode.Option3.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_EVEN")
		
	ENDPROC

	PROCEDURE ogrPageMode.ProgrammaticChange
		Thisform.txtPageList.TabStop = (This.Value = 4)
		
	ENDPROC

	PROCEDURE txtPageList.GotFocus
		DODEFAULT()
		
		This.Parent.lblPageList.Visible = .F.
		This.Parent.ogrPageMode.Value = 4
		
	ENDPROC

	PROCEDURE txtPageList.LostFocus
		DODEFAULT()
		
		Thisform.Refresh()
		This.Parent.ogrPageMode.Value = IIF(EMPTY(This.Value), 1, 4)
		
		This.Value = Thisform.PrintEnv.PageList_Parse(This.Value)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_printer_selection AS form 		&& Printer selection dialog.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmbPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDuplex" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOk" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="PrintEnv" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFocusHolder" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: cancel		&& Specifies if a CommandButton is the Cancel button.
		*m: setup
		*p: out_ok		&& .T. - User pressed ok button, .F. - user pressed cancel
		*p: printenvin
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN printenvin
	*<PropValue>
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BindControls = .F.
		BorderStyle = 2
		Caption = "Print setup"
		DoCreate = .T.
		Height = 163
		Icon = (NVL(EVL(JUSTPATH(This.ClassLibrary),NULL)+"\images\wwrite.ico",""))
		KeyPreview = .T.
		MaxButton = .F.
		MinButton = .F.
		Name = "pdfium_printer_selection"
		out_ok = .F.
		printenvin = .F.
		ShowWindow = 1
		Visible = .T.
		Width = 435
		WindowType = 1
		_memberdata = <VFPData>
			<memberdata name="out_ok" type="property" display="Out_Ok"/>
			<memberdata name="cancel" type="method" display="Cancel"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="printenvin" type="property" display="PrintEnvIn"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'chkDuplex' AS checkbox WITH ;
		Alignment = 4, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Duplex printing", ;
		ControlSource = "Thisform.PrintEnv.duplex", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 20, ;
		Left = 12, ;
		Name = "chkDuplex", ;
		TabIndex = 4, ;
		Top = 72, ;
		Width = 177, ;
		WordWrap = .F.
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmbPrinters' AS combobox WITH ;
		BoundColumn = 1, ;
		BoundTo = .T., ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "370,200", ;
		ControlSource = "Thisform.PrintEnv.printer", ;
		DisplayCount = 30, ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 28, ;
		Left = 12, ;
		Name = "cmbPrinters", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 28, ;
		Width = 408
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Cancel", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 235, ;
		Name = "cmdCancel", ;
		TabIndex = 10, ;
		Top = 108, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFocusHolder' AS commandbutton WITH ;
		Caption = "", ;
		Height = 27, ;
		Left = 444, ;
		Name = "cmdFocusHolder", ;
		Style = 1, ;
		TabIndex = 1, ;
		Top = 276, ;
		Width = 36
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOk' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Ok", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 72, ;
		Name = "cmdOk", ;
		TabIndex = 9, ;
		Top = 108, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 336, ;
		Name = "i18n", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'lblPrinters' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Printer", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblPrinters", ;
		TabIndex = 13, ;
		Top = 4, ;
		Width = 173
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'PrintEnv' AS pdfium_print_env WITH ;
		Left = 288, ;
		Name = "PrintEnv", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE cancel		&& Specifies if a CommandButton is the Cancel button.
		Thisform.out_ok = .F.
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE Destroy
		This.PrintEnvIn = .F.
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toPrintEnvIn as pdfium_print_env of pdfium-vfp.vcx
		
		This.PrintEnvIn = m.toPrintEnvIn
		This.PrintEnv.Setup(This.PrintEnvIn)
		
		This.BindControls = .T.
		
		LOCAL ARRAY laPrinters(1)
		LOCAL lnPrinters
		m.lnPrinters = APRINTERS(laPrinters,1)
		
		LOCAL i, llHasComments
		m.llHasComments = .F.
		FOR m.i = 1 TO m.lnPrinters
		    LOCAL lcPrinter, lcComment
		    m.lcPrinter = RTRIM(EVL(NVL(m.laPrinters[m.i,1], ""),""))
		    m.lcComment = RTRIM(EVL(NVL(m.laPrinters[m.i,4],""),""))
		
		    IF EMPTY(m.lcPrinter)
		        LOOP
		    ENDIF
		    
		    IF EMPTY(m.lcComment)=.F.
		        m.llHasComments = .T.
		    ENDIF
		
		    This.cmbPrinters.AddItem(m.lcPrinter)
		    This.cmbPrinters.AddListItem(m.lcComment, m.i, 2)
		    
		    IF RTRIM(LOWER(This.PrintEnv.Printer)) == RTRIM(LOWER(m.lcPrinter))
		        This.PrintEnv.Printer = m.lcPrinter &&Fix uppercase printer name of set(printer,3) result
		    ENDIF
		ENDFOR
		
		IF m.llHasComments = .F.
		    This.cmbPrinters.ColumnWidths = STREXTRACT(This.cmbPrinters.ColumnWidths, "", ",",1,2) + ",0"
		ENDIF
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 27 AND EMPTY(m.nShiftAltCtrl)
		    This.Cancel()
		ENDIF
		
	ENDPROC

	PROCEDURE Load
		CLEAR TYPEAHEAD 
		
	ENDPROC

	PROCEDURE Refresh
		This.Caption = Thisform.i18n.text("PRINTER_SELECTION_TITLE")
		
	ENDPROC

	PROCEDURE setup
		IF NVL(This.PrintEnv.AllowSetDefaultPrinter, .F.) = .T.
		    This.PrintEnv.FoxDefaultPrinter_Set()
		ENDIF
		
		IF VARTYPE(This.PrintEnvIn) = "O"
		    This.PrintEnvIn.Setup(This.PrintEnv)
		ENDIF
		
		Thisform.Out_Ok = .T.
		
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE chkDuplex.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_DUPLEX")
		
		
	ENDPROC

	PROCEDURE cmbPrinters.InteractiveChange
		Thisform.PrintEnv.Printer = This.Value
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.Cancel()
		
	ENDPROC

	PROCEDURE cmdCancel.Refresh
		This.Caption = Thisform.i18n.text("PRINTER_SELECTION_CANCEL")
		
	ENDPROC

	PROCEDURE cmdOk.Click
		Thisform.Setup()
		
		
	ENDPROC

	PROCEDURE cmdOk.Refresh
		This.Caption = Thisform.i18n.text("PRINTER_SELECTION_OK")
		
	ENDPROC

	PROCEDURE lblPrinters.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PRINTER")
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_textbox AS textbox 		&& Pdfium-vfp Textbox. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: contextmenu
		*m: selectall
		*p: allow_lost_focus
		*p: changed		&& .T. on InteractiveChange
		*p: mousefocused		&& Focused by Click
		*p: prevvalue		&& Value on GotFocus event
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN allow_lost_focus
	PROTECTED changed,mousefocused,prevvalue
	*<PropValue>
		Alignment = 0
		allow_lost_focus = .T.
		changed = .F.
		EnableHyperlinks = .F.
		FontName = "Segoe UI"
		FontSize = 10
		Format = "K"
		Height = 27
		mousefocused = 0
		Name = "pdfium_textbox"
		prevvalue = 
		SelectOnEntry = .T.
		Width = 173
		_memberdata = <VFPData>
			<memberdata name="changed" type="property" display="Changed"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="mousefocused" type="property" display="MouseFocused"/>
			<memberdata name="prevvalue" type="property" display="PrevValue"/>
			<memberdata name="selectall" type="method" display="SelectAll"/>
			<memberdata name="allow_lost_focus" type="property" display="allow_lost_focus"/>
		</VFPData>
	*</PropValue>
	
	PROTECTED PROCEDURE contextmenu
		LOCAL lcMenuName
		m.lcMenuName = "_context_menu"
		
		DEFINE POPUP (m.lcMenuName) FROM MROW(), MCOL() MARGIN RELATIVE SHORTCUT FONT 'Segoe UI', 10
		
		LOCAL lcSelect, lcClipboard
		m.lcSelect = IIF(EMPTY(This.SelLength)=.T., "SKIP FOR .T.", "")
		m.lcClipboard = IIF(EMPTY(_CLIPTEXT)=.T., "SKIP FOR .T.", "")
		
		LOCAL i
		m.i=9000
		
		m.i=m.i+1
		DEFINE BAR (m.i) OF _context_menu PROMPT (Thisform.i18n.text("MNU_CUT")) PICTRES _MED_CUT  &lcSelect
		ON SELECTION BAR (m.i) OF _context_menu poThis.KeyPress(24,2)
		
		m.i=m.i+1
		DEFINE BAR (m.i) OF _context_menu PROMPT (Thisform.i18n.text("MNU_COPY")) PICTRES _MED_COPY &lcSelect
		ON SELECTION BAR (m.i) OF _context_menu poThis.KeyPress(3,2)
		
		DEFINE BAR _med_paste OF _context_menu PROMPT (Thisform.i18n.text("MNU_PASTE")) PICTRES _MED_PASTE &lcClipboard
		DEFINE BAR _med_slcta OF _context_menu PROMPT (Thisform.i18n.text("MNU_SLCTA"))
		DEFINE BAR _med_clear OF _context_menu PROMPT (Thisform.i18n.text("MNU_CLEAR")) &lcSelect
		
		RETURN m.lcMenuName
		
	ENDPROC

	PROCEDURE GotFocus
		DODEFAULT()
		
		This.PrevValue = This.Value
		
		IF This.SelectOnEntry
		    This.MouseFocused = MDOWN()
		    This.SelectAll()
		ENDIF
		
		
		This.allow_lost_focus = .T.
		
	ENDPROC

	PROCEDURE InteractiveChange
		This.Changed = .T.
		
		This.allow_lost_focus = .F.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode=44 AND VARTYPE(This.Value) = 'N'
		    KEYBOARD '.' PLAIN CLEAR
		ENDIF
		
		IF m.nKeyCode=3 AND m.nShiftAltCtrl=2
		    IF INLIST(VARTYPE(This.SelText),'C')
		        _cliptext = ALLTRIM(NVL(This.SelText,''))
		        NODEFAULT
		    ENDIF
		ENDIF
		
		IF m.nKeyCode=24 AND m.nShiftAltCtrl=2
		    IF INLIST(VARTYPE(This.SelText),'C')
		        _cliptext = ALLTRIM(NVL(This.SelText,''))
		        This.SelText = ''
		        NODEFAULT
		    ENDIF
		ENDIF
		
		
		IF INLIST(m.nKeyCode, 13, 27, 9)
		    This.allow_lost_focus = .T.
		ENDIF
		
	ENDPROC

	PROCEDURE LostFocus
		IF VARTYPE(This.Value)="C"
		    IF NOT (This.Value == ALLTRIM(This.Value,1,CHR(13),CHR(10)))
		        This.Value = ALLTRIM(This.Value,1,CHR(13),CHR(10))
		    ENDIF
		ENDIF
		
		*******************************************************
		LOCAL lcInvalidChars
		m.lcInvalidChars = ""
		LOCAL i
		FOR m.i=0x1 TO 0x1F
		    m.lcInvalidChars = m.lcInvalidChars + CHR(m.i)
		ENDFOR
		FOR m.i=0x7F TO 0x84
		    m.lcInvalidChars = m.lcInvalidChars + CHR(m.i)
		ENDFOR
		FOR m.i=0x86 TO 0x9F
		    m.lcInvalidChars = m.lcInvalidChars + CHR(m.i)
		ENDFOR
		
		IF VARTYPE(This.Value) = 'C'
		    IF NOT (This.Value == CHRTRAN(This.Value, m.lcInvalidChars, ''))
		        This.Value = CHRTRAN(This.Value, m.lcInvalidChars, '')
		    ENDIF    
		ENDIF
		*******************************************************
		
		#define VK_LBUTTON 0x01
		#define VK_RBUTTON 0x02
		IF This.allow_lost_focus = .F. AND This.SelStart+1 >= LEN(This.Text) AND NOT EMPTY(This.Value) AND NOT MDOWN() 
		    IF This.env.API_WIN.GetKeyState(VK_LBUTTON)>=0 AND This.env.API_WIN.GetKeyState(VK_RBUTTON)>=0 
		        This.SelStart = LEN(This.Text)
		        NODEFAULT
		        RETURN
		    ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.SelectOnEntry
		    IF This.SelLength <> 0 AND This.MouseFocused
		        NODEFAULT
		    ENDIF
		ENDIF
		This.MouseFocused = .F.
		
	ENDPROC

	PROCEDURE RightClick
		LOCAL lcMenuName
		m.lcMenuName = This.ContextMenu()
		
		PRIVATE poThis
		m.poThis = This
		IF CNTBAR(m.lcMenuName)<>0
		    ACTIVATE POPUP &lcMenuName
		ENDIF
		m.poThis = NULL
		
		
	ENDPROC

	PROCEDURE selectall
		This.SelStart = 0
		This.SelLength = 255
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_uistate AS custom 		&& UI states handling (visible, enable) respecting PageFrames. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: geteffectivelyenabled
		*m: geteffectivelyvisible
		*m: getispageframe
		*m: objtoclient
		*m: onenabled
		*m: onvisible
		*m: setstate
		*m: _onactivate
		*m: _ondeactivate
		*m: _onenabled
		*m: _onvisible
		*p: effectivelyenabled
		*p: effectivelyvisible
		*p: ispageframe
		*p: _ispagedeactivated
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,effectivelyenabled,effectivelyvisible,Error,Height,HelpContextID,ispageframe,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod,_ispagedeactivated
	*<PropValue>
		effectivelyenabled = .F.
		effectivelyvisible = .F.
		Height = 24
		ispageframe = .F.
		Name = "pdfium_uistate"
		Tag = ""
		Width = 37
		_ispagedeactivated = .F.
		_memberdata = <VFPData>
			<memberdata name="objtoclient" display="ObjToClient"/>
			<memberdata name="addobject" display="AddObject"/>
			<memberdata name="writemethod" display="WriteMethod"/>
			<memberdata name="writeexpression" display="WriteExpression"/>
			<memberdata name="whatsthishelpid" display="WhatsThisHelpID"/>
			<memberdata name="tag" display="Tag"/>
			<memberdata name="showwhatsthis" display="ShowWhatsThis"/>
			<memberdata name="saveasclass" display="SaveAsClass"/>
			<memberdata name="resettodefault" display="ResetToDefault"/>
			<memberdata name="removeobject" display="RemoveObject"/>
			<memberdata name="readmethod" display="ReadMethod"/>
			<memberdata name="readexpression" display="ReadExpression"/>
			<memberdata name="picture" display="Picture"/>
			<memberdata name="parentclass" display="ParentClass"/>
			<memberdata name="parent" display="Parent"/>
			<memberdata name="objects" display="Objects"/>
			<memberdata name="newobject" display="Newobject"/>
			<memberdata name="helpcontextid" display="HelpContextID"/>
			<memberdata name="error" display="Error"/>
			<memberdata name="controls" display="Controls"/>
			<memberdata name="classlibrary" display="ClassLibrary"/>
			<memberdata name="addproperty" display="AddProperty"/>
			<memberdata name="setstate" display="SetState"/>
			<memberdata name="effectivelyenabled" display="EffectivelyEnabled"/>
			<memberdata name="effectivelyvisible" display="EffectivelyVisible"/>
			<memberdata name="geteffectivelyenabled" display="GetEffectivelyEnabled"/>
			<memberdata name="geteffectivelyvisible" display="GetEffectivelyVisible"/>
			<memberdata name="ispageframe" display="IsPageFrame"/>
			<memberdata name="getispageframe" display="GetIsPageFrame"/>
			<memberdata name="onenabled" display="OnEnabled"/>
			<memberdata name="onvisible" display="OnVisible"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE Destroy
		UNBINDEVENTS(This)
		
	ENDPROC

	PROCEDURE geteffectivelyenabled
		RETURN This.EffectivelyEnabled
		
	ENDPROC

	PROCEDURE geteffectivelyvisible
		RETURN This.EffectivelyVisible
		
	ENDPROC

	PROCEDURE getispageframe
		RETURN This.IsPageFrame
		
	ENDPROC

	PROCEDURE Init
		LOCAL loControl
		m.loControl = This.Parent
		
		This.IsPageFrame = .F.
		
		BINDEVENT(m.loControl, "Visible", This, "_OnVisible",1)
		BINDEVENT(m.loControl, "Enabled", This, "_OnEnabled",1)
		
		DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		    IF UPPER(m.loControl.BASECLASS) == [PAGE] THEN
		        This.IsPageFrame = .T.
		
		        BINDEVENT(m.loControl, "Activate", This, "_OnActivate",1)
		        BINDEVENT(m.loControl, "Deactivate", This, "_OnDeactivate",1)
		        BINDEVENT(m.loControl, "Enabled", This, "_OnEnabled",1)
		        BINDEVENT(m.loControl.Parent, "Visible", This, "_OnVisible",1)
		        BINDEVENT(m.loControl.Parent, "Enabled", This, "_OnEnabled",1)
		    ENDIF
		    m.loControl = m.loControl.PARENT
		ENDDO
		
		This.SetState()
		
	ENDPROC

	PROCEDURE objtoclient
		*********************************************************************
		** opied from GDPIPlusX xfcBitmap.ObjToClientEx
		**
		** This replaces OBJTOCLIENT that has bugs with pageframes and SP2
		*********************************************************************
		PARAMETERS tnType && 1 = Top  2 = Left
		
		IF This.GetIsPageframe() = .F.
		    RETURN OBJTOCLIENT(This.Parent, m.tnType)
		ENDIF
		
		LOCAL loControl
		m.loControl = This.Parent
		
		
		*!* TabOrientation parameters
		#DEFINE CON_TABOR_TOP    0
		#DEFINE CON_TABOR_BOTTOM 1
		#DEFINE CON_TABOR_LEFT   2
		#DEFINE CON_TABOR_RIGHT  3
		
		LOCAL lnPosition AS INTEGER
		m.lnPosition = 0
		
		DO CASE
		
		CASE m.tnType = 1 && Top
		    DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		        IF PEMSTATUS(m.loControl, [Top],5) THEN && Defined Property
		            m.lnPosition = m.lnPosition + m.loControl.TOP
		        ENDIF
		        IF UPPER(m.loControl.BASECLASS) == [PAGE] THEN
		            IF m.loControl.PARENT.TABORIENTATION = CON_TABOR_TOP THEN    && Top
		                m.lnPosition = m.lnPosition + ;
		                    m.loControl.PARENT.HEIGHT - ;
		                    m.loControl.PARENT.PAGEHEIGHT - ;
		                    m.loControl.PARENT.BORDERWIDTH * 2
		            ELSE
		                m.lnPosition = m.lnPosition + 1
		            ENDIF
		        ENDIF
		        m.loControl = m.loControl.PARENT
		    ENDDO
		
		CASE m.tnType = 2 && Left
		    DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		        IF PEMSTATUS(m.loControl, [Left], 5) THEN && Defined Property
		            m.lnPosition = m.lnPosition + m.loControl.LEFT
		        ENDIF
		        IF UPPER(m.loControl.BASECLASS) == [PAGE]
		            IF m.loControl.PARENT.TABORIENTATION = CON_TABOR_LEFT THEN    && Left
		                m.lnPosition = m.lnPosition + ;
		                    m.loControl.PARENT.WIDTH - ;
		                    m.loControl.PARENT.PAGEWIDTH - ;
		                    m.loControl.PARENT.BORDERWIDTH * 2
		            ELSE
		                m.lnPosition = m.lnPosition + 1
		            ENDIF
		        ENDIF
		        m.loControl = m.loControl.PARENT
		    ENDDO
		
		ENDCASE
		
		RETURN m.lnPosition
		
	ENDPROC

	PROCEDURE onenabled
	ENDPROC

	PROCEDURE onvisible
	ENDPROC

	HIDDEN PROCEDURE setstate
		LOCAL loControl
		m.loControl = This.Parent
		
		
		LOCAL llPrevVisible, llPrevEnabled
		m.llPrevVisible = This.EffectivelyVisible
		m.llPrevEnabled = This.EffectivelyEnabled
		
		This.EffectivelyVisible = m.loControl.Visible
		This.EffectivelyEnabled = m.loControl.Enabled
		
		
		IF This._IsPageDeactivated
		    This.EffectivelyVisible = .F.
		ENDIF
		
		DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		    IF UPPER(m.loControl.BASECLASS) == [PAGE] THEN
		        IF m.loControl.Enabled = .F.
		            This.EffectivelyEnabled = .F.
		        ENDIF
		       IF m.loControl.Parent.Enabled = .F.
		            This.EffectivelyEnabled = .F.
		        ENDIF
		
		        IF m.loControl.Parent.Visible = .F.
		            This.EffectivelyVisible = .F.
		        ENDIF
		        
		        IF BETWEEN(m.loControl.Parent.ActivePage, 1, m.loControl.Parent.PageCount)
		            IF m.loControl.Parent.Pages(m.loControl.Parent.ActivePage) != m.loControl
		                This.EffectivelyVisible = .F.
		            ENDIF
		        ENDIF
		    ENDIF
		    m.loControl = m.loControl.PARENT
		ENDDO
		
		DO CASE
		CASE m.llPrevVisible <> This.EffectivelyVisible
		    This.OnVisible()
		CASE m.llPrevEnabled <> This.EffectivelyEnabled
		    This.OnEnabled()
		ENDCASE
		
	ENDPROC

	PROCEDURE _onactivate
		This.SetState()
		
	ENDPROC

	PROCEDURE _ondeactivate
		This._IsPageDeactivated = .T.
		This.SetState()
		This._IsPageDeactivated = .F.
		
		
	ENDPROC

	PROCEDURE _onenabled
		LPARAMETERS tlEnabled
		This.SetState()
		
	ENDPROC

	PROCEDURE _onvisible
		LPARAMETERS tlVisible
		This.SetState()
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_utils AS custom 		&& Utility class; Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: extractfile		&& Extract file contents from application executable (exe,app), return empty string if file wast not found. Pdfium-vfp.vcx must be included in the application executable or this method will  alwaysreturn empty string
		*m: filetostr		&& FileToStr wrapper for ExtractFile mehtod
		*m: strtofile
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		Name = "pdfium_utils"
		_memberdata = <VFPData>
			<memberdata name="extractfile" type="method" display="ExtractFile"/>
			<memberdata name="filetostr" type="method" display="FileToStr"/>
			<memberdata name="strtofile" type="method" display="StrToFile"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE extractfile		&& Extract file contents from application executable (exe,app), return empty string if file wast not found. Pdfium-vfp.vcx must be included in the application executable or this method will  alwaysreturn empty string
		LPARAMETERS tcFileName
		
		IF EMPTY(NVL(m.tcFileName,""))
		    RETURN ""
		ENDIF
		
		IF FILE(m.tcFileName)
		    RETURN This.FileToStr(m.tcFileName)
		ENDIF
		
		RETURN ""
		
	ENDPROC

	PROCEDURE filetostr		&& FileToStr wrapper for ExtractFile mehtod
		LPARAMETERS tcFileName
		
		RETURN FILETOSTR(m.tcFileName)
		
	ENDPROC

	PROCEDURE strtofile
		LPARAMETERS tcStr, tcFileName
		
		LOCAL lSaveSafety
		m.lSaveSafety = SET("Safety")
		SET SAFETY OFF
		
		LOCAL lnBytesWritten
		m.lnBytesWritten = STRTOFILE(m.tcStr, m.tcFileName)
		
		SET SAFETY &lSaveSafety
		
		RETURN m.lnBytesWritten
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport AS reportlistener 		&& Report listener with integrated report preview based on PdfiumViewer control
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: batchbegin
		*m: batchend
		*m: closepdf
		*m: createpdf
		*m: errlogshow
		*m: errmsg
		*m: finalize
		*m: getfontgdi
		*m: getfontpdf
		*m: measurestring
		*m: printenvdefault_access
		*m: printenvdefault_assign
		*m: printenv_access
		*m: printenv_assign
		*m: render_frxdynamics
		*m: render_frxfield
		*m: render_frxheader
		*m: render_frxlabel
		*m: render_frxline
		*m: render_frxpicture
		*m: render_frxrectangle
		*m: render_text
		*m: render_textasimage		&& Fallback rendering text as images (case of symbolic and non ttf fonts)
		*m: saveas_pdfmeta_access
		*m: saveas_pdfmeta_assign
		*p: batchmode
		*p: batchmodeauto		&& .T. if report was created by  _REPORTOUTPUT (= PdfiumReport.app)  and NOPAGEEJECT was set
		*p: env		&& pdfium_env object
		*p: errlog
		*p: frx_offsetx
		*p: frx_offsety
		*p: frx_pagecount
		*p: frx_wholepage
		*p: gdi_fonts
		*p: hpdf_doc
		*p: hpdf_fonts		&& Font collection for caching purporses
		*p: hpdf_pagecount
		*p: ogfx
		*p: printenv		&& Print configuration state (pdfium_print_env object). ; Read-only; Overrides default print settings when report is printed from preview window or by TO PRINTER clause with This.ToPrinterNative=.T.
		*p: printenvdefault
		*p: saveas_filename		&& Filename suggestion for "save as" dialog
		*p: saveas_pdfmeta		&& Pdfium_pdfmeta object; Output PDF metadata + encryption (password) and reader permissions
		*p: toprinternative		&& TO PRINTER clause handing mode:: .T. - report is printed by VFP (PdfiumReport does nothing) ; .F. (default) - report is printed by PdfiumReport (renders report to PDF and prints PDF)
		*p: utils		&& pdfium_utils object
		*a: hpdf_pages[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _printenv		&& Print configuration state (pdfium_print_env object)
		*p: _printenvdefault
		*p: _saveas_pdfmeta
	*</DefinedPropArrayMethod>

	HIDDEN batchmodeauto,batchmode,env,errlog,frx_offsetx,frx_offsety,frx_pagecount,frx_wholepage,gdi_fonts,hpdf_doc,hpdf_fonts,hpdf_pagecount,hpdf_pages,ogfx,utils,_printenvdefault,_printenv,_saveas_pdfmeta
	*<PropValue>
		AllowModalMessages = .T.
		batchmode = .F.
		batchmodeauto = .F.
		DynamicLineHeight = .T.
		env = .F.
		errlog = ("")
		FRXDataSession = 0
		frx_offsetx = 0
		frx_offsety = 0
		frx_pagecount = 0
		frx_wholepage = .F.
		gdi_fonts = .F.
		Height = 23
		hpdf_doc = 0
		hpdf_fonts = .F.
		hpdf_pagecount = 0
		ListenerType = -1
		Name = "pdfiumreport"
		ogfx = .F.
		printenv = .F.
		printenvdefault = .F.
		QuietMode = .F.
		saveas_filename = ("")
		saveas_pdfmeta = .F.
		SendGDIPlusImage = 1
		toprinternative = .F.
		TwoPassProcess = .T.
		utils = .F.
		Width = 23
		_memberdata = <VFPData>
			<memberdata name="hpdf_pages" type="property" display="hpdf_pages"/>
			<memberdata name="measurestring" type="method" display="MeasureString"/>
			<memberdata name="frx_pagecount" type="property" display="frx_pagecount"/>
			<memberdata name="getfontgdi" type="method" display="GetFontGDI"/>
			<memberdata name="getfontpdf" type="method" display="GetFontPDF"/>
			<memberdata name="hpdf_doc" type="property" display="hpdf_doc"/>
			<memberdata name="hpdf_pagecount" type="property" display="hpdf_pagecount"/>
			<memberdata name="ogfx" type="property" display="oGfx"/>
			<memberdata name="render_frxfield" type="method" display="Render_FrxField"/>
			<memberdata name="render_frxlabel" type="method" display="Render_FrxLabel"/>
			<memberdata name="render_frxline" type="method" display="Render_FrxLine"/>
			<memberdata name="render_frxpicture" type="method" display="Render_FrxPicture"/>
			<memberdata name="render_frxrectangle" type="method" display="Render_FrxRectangle"/>
			<memberdata name="render_text" type="method" display="Render_Text"/>
			<memberdata name="env" type="property" display="env"/>
			<memberdata name="errlog" type="property" display="ErrLog"/>
			<memberdata name="errlogshow" type="method" display="ErrLogShow"/>
			<memberdata name="errmsg" type="method" display="ErrMsg"/>
			<memberdata name="finalize" type="method" display="Finalize"/>
			<memberdata name="batchbegin" type="method" display="BatchBegin"/>
			<memberdata name="batchend" type="method" display="BatchEnd"/>
			<memberdata name="batchmode" type="property" display="BatchMode"/>
			<memberdata name="closepdf" type="method" display="ClosePDF"/>
			<memberdata name="createpdf" type="method" display="CreatePDF"/>
			<memberdata name="hpdf_fonts" type="property" display="hpdf_Fonts"/>
			<memberdata name="render_textasimage" type="method" display="Render_TextAsImage"/>
			<memberdata name="gdi_fonts" type="property" display="gdi_fonts"/>
			<memberdata name="batchmodeauto" type="property" display="BatchModeAuto"/>
			<memberdata name="saveas_filename" type="property" display="SaveAs_Filename"/>
			<memberdata name="render_frxdynamics" type="method" display="Render_FrxDynamics"/>
			<memberdata name="utils" type="property" display="utils"/>
			<memberdata name="printenv" type="property" display="PrintEnv"/>
			<memberdata name="printenv_access" type="method" display="PrintEnv_Access"/>
			<memberdata name="printenv_assign" type="method" display="PrintEnv_Assign"/>
			<memberdata name="_printenv" type="property" display="_PrintEnv"/>
			<memberdata name="printenvdefault" type="property" display="PrintEnvDefault"/>
			<memberdata name="printenvdefault_access" type="method" display="PrintEnvDefault_Access"/>
			<memberdata name="printenvdefault_assign" type="method" display="PrintEnvDefault_Assign"/>
			<memberdata name="_printenvdefault" type="property" display="_PrintEnvDefault"/>
			<memberdata name="toprinternative" type="property" display="ToPrinterNative"/>
			<memberdata name="saveas_pdfmeta" type="property" display="SaveAs_PDFMeta"/>
			<memberdata name="saveas_pdfmeta_access" type="method" display="SaveAs_PDFMeta_Access"/>
			<memberdata name="saveas_pdfmeta_assign" type="method" display="SaveAs_PDFMeta_Assign"/>
			<memberdata name="_saveas_pdfmeta" type="property" display="_SaveAs_PDFMeta"/>
			<memberdata name="frx_offsetx" type="property" display="frx_offsetx"/>
			<memberdata name="frx_offsety" type="property" display="frx_offsety"/>
			<memberdata name="frx_wholepage" type="property" display="frx_wholepage"/>
			<memberdata name="render_frxheader" type="method" display="Render_FrxHeader"/>
		</VFPData>
		_printenv = .F.
		_printenvdefault = .F.
		_saveas_pdfmeta = .F.
	*</PropValue>
	
	PROCEDURE batchbegin
		This.BatchMode = .T.
		
		
	ENDPROC

	PROCEDURE batchend
		IF This.BatchMode = .F.
		    RETURN
		ENDIF
		
		This.Finalize()
		
		This.BatchMode = .F.
		
	ENDPROC

	HIDDEN PROCEDURE closepdf
		IF EMPTY(This.hpdf_doc)
		    RETURN
		ENDIF
		
		**************************************************
		* Release resources
		**************************************************
		This.env.API_HPDF.HPDF_Free(This.hpdf_doc)
		
		DIMENSION This.hpdf_pages(1)
		This.hpdf_pages[1] = 0
		
		This.hpdf_pagecount = 0
		This.hpdf_doc = 0
		This.hpdf_fonts = .F.
		This.gdi_fonts = .F.
		
	ENDPROC

	HIDDEN PROCEDURE createpdf
		
		This.ClosePDF()
		
		LOCAL loHPDF, loHPDFC
		m.loHPDF = This.env.API_HPDF
		m.loHPDFC = m.loHPDF.CONST
		
		
		This.hpdf_doc = m.loHPDF.HPDF_New(0,0)
		
		This.hpdf_fonts = NEWOBJECT("Collection")
		This.ErrLog = ""
		
		
		IF EMPTY(This.hpdf_doc) = .F.
		    m.loHPDF.HPDF_SetCompressionMode(This.hpdf_doc, m.loHPDFC.HPDF_COMP_ALL())
		    m.loHPDF.HPDF_SetPageMode(This.hpdf_doc, m.loHPDFC.HPDF_PAGE_MODE_USE_NONE())
		
		    m.loHPDF.HPDF_UseUTFEncodings(This.hpdf_doc)
		    m.loHPDF.HPDF_SetCurrentEncoder(This.hpdf_doc, m.loHPDFC.UTF8())
		ENDIF
		
		This.gdi_fonts = NEWOBJECT("Collection")
		
	ENDPROC

	PROCEDURE Destroy
		
		This.ClosePDF()
		
		This.env = .F.
		This._PrintEnv = .F.
		This._PrintEnvDefault = .F.
		This.utils = .F.
		This.oGfx = .F.
		
		This._SaveAs_PDFMeta = .F.
		
		This.PreviewContainer = NULL
		
	ENDPROC

	HIDDEN PROCEDURE errlogshow
		IF EMPTY(This.errLog)
		    RETURN
		ENDIF
		
		IF This.QuietMode
		    RETURN
		ENDIF
		
		IF This.AllowModalMessages
		    This.DoMessage(LEFT(This.errLog, 500), 0+48, This.Class + " ("+This.ClassLibrary+")")
		ELSE
		    This.DoStatus(LEFT(This.errLog, 250))
		ENDIF
		
		This.errLog = ""
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		m.lcMsg = ""
		
		DO CASE
		CASE VARTYPE(m.tvMsg)="O"
		    m.lcMsg = ;
		        m.tvMsg.Message + ;
		        RTRIM(" " + NVL(m.tvMsg.Details,"")) + ;
		        RTRIM(" " + NVL(m.tvMsg.UserValue,"")) + ;
		        CHR(13) + "Procedure: " + m.tvMsg.Procedure + ;
		        CHR(13) + "LineContents: " + m.tvMsg.LineContents
		
		CASE VARTYPE(m.tvMsg)="C"
		    m.lcMsg = ALLTRIM(m.tvMsg)
		
		ENDCASE
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		This.errLog = LEFT(IIF(EMPTY(This.errLog), "", This.errLog + CHR(13) + CHR(13)) + m.lcMsg, 10000)
		
		
	ENDPROC

	HIDDEN PROCEDURE finalize
		
		IF EMPTY(This.hpdf_doc)
		    RETURN
		ENDIF
		
		
		This.errLogShow()
		
		LOCAL loHPDF, loHPDFC
		m.loHPDF = This.env.API_HPDF
		m.loHPDFC = m.loHPDF.CONST
		
		
		LOCAL lcTempFileName
		m.lcTempFileName = This.env.GetUniqueTempFileName("pdf")
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    IF This.CommandClauses.OUTPUTTO = 1 AND This.ToPrinterNative = .T. && VFP native output to the printer, do nothing
		        EXIT
		    ENDIF
		
		    IF This.CommandClauses.PREVIEW = .F. AND INLIST(This.CommandClauses.OUTPUTTO,1,2)=.F. && not preview or output to the printer or to the file
		        EXIT
		    ENDIF
		
		
		    m.loHPDF.HPDF_ResetError(This.hpdf_doc)
		
		    *******************************************************
		    IF EMPTY(NVL(This.SaveAs_PDFMeta.Author,"")) = .F.
		        m.loHPDF.HPDF_SetInfoAttr(This.hpdf_doc, m.loHPDFC.HPDF_INFO_AUTHOR(), This.SaveAs_PDFMeta.Author)
		        m.loHPDF.HPDF_ResetError(This.hpdf_doc)
		    ENDIF
		    
		    IF EMPTY(NVL(This.SaveAs_PDFMeta.Creator,"")) = .F.
		        m.loHPDF.HPDF_SetInfoAttr(This.hpdf_doc, m.loHPDFC.HPDF_INFO_CREATOR(), This.SaveAs_PDFMeta.Creator)
		        m.loHPDF.HPDF_ResetError(This.hpdf_doc)
		    ENDIF
		    
		    IF EMPTY(NVL(This.SaveAs_PDFMeta.Producer,"")) = .F.
		        m.loHPDF.HPDF_SetInfoAttr(This.hpdf_doc, m.loHPDFC.HPDF_INFO_PRODUCER(), This.SaveAs_PDFMeta.Producer)
		        m.loHPDF.HPDF_ResetError(This.hpdf_doc)
		    ENDIF
		
		    IF EMPTY(NVL(This.SaveAs_PDFMeta.Title,"")) = .F.
		        m.loHPDF.HPDF_SetInfoAttr(This.hpdf_doc, m.loHPDFC.HPDF_INFO_TITLE(), This.SaveAs_PDFMeta.Title)
		        m.loHPDF.HPDF_ResetError(This.hpdf_doc)
		    ENDIF
		
		    IF EMPTY(NVL(This.SaveAs_PDFMeta.Subject,"")) = .F.
		        m.loHPDF.HPDF_SetInfoAttr(This.hpdf_doc, m.loHPDFC.HPDF_INFO_SUBJECT(), This.SaveAs_PDFMeta.Subject)
		        m.loHPDF.HPDF_ResetError(This.hpdf_doc)
		    ENDIF
		
		    IF EMPTY(NVL(This.SaveAs_PDFMeta.Keywords,"")) = .F.
		        m.loHPDF.HPDF_SetInfoAttr(This.hpdf_doc, m.loHPDFC.HPDF_INFO_KEYWORDS(), This.SaveAs_PDFMeta.Keywords)
		        m.loHPDF.HPDF_ResetError(This.hpdf_doc)
		    ENDIF
		    *******************************************************
		    
		
		    *******************************************************
		    This.SaveAs_PDFMeta.OwnerPassword = NVL(This.SaveAs_PDFMeta.OwnerPassword,"")
		    This.SaveAs_PDFMeta.UserPassword = NVL(This.SaveAs_PDFMeta.UserPassword,"")
		    DO CASE
		    CASE LEN(This.SaveAs_PDFMeta.OwnerPassword) = 0 AND LEN(This.SaveAs_PDFMeta.UserPassword) = 0
		    
		    CASE LEN(This.SaveAs_PDFMeta.OwnerPassword) = 0 AND LEN(This.SaveAs_PDFMeta.UserPassword) > 0
		        ERROR "Owner Password cannot be empty when User Password is not empty"
		    
		    CASE This.SaveAs_PDFMeta.OwnerPassword == This.SaveAs_PDFMeta.UserPassword
		        ERROR "Owner Password cannot be equal to User Password"
		    
		    OTHERWISE
		
		        IF m.loHPDF.HPDF_SetPassword(This.hpdf_doc, This.SaveAs_PDFMeta.OwnerPassword, This.SaveAs_PDFMeta.UserPassword) = 0
		            LOCAL lnErrCode
		            m.lnErrCode = m.loHPDF.HPDF_SetEncryptionMode(This.hpdf_doc, m.loHPDFC.HPDF_ENCRYPT_R3(), 16) 
		            IF m.lnErrCode <> 0
		                ERROR "HPDF_SetEncryptionMode returned error code " + TRANSFORM(m.lnErrCode)
		            ENDIF
		        ENDIF
		        
		        
		        LOCAL lnPermit
		        m.lnPermit = ;
		            IIF(This.SaveAs_PDFMeta.Permit_Print, m.loHPDFC.HPDF_ENABLE_PRINT(), 0) + ;
		            IIF(This.SaveAs_PDFMeta.Permit_Edit_All, m.loHPDFC.HPDF_ENABLE_EDIT_ALL(), 0) + ;
		            IIF(This.SaveAs_PDFMeta.Permit_Copy, m.loHPDFC.HPDF_ENABLE_COPY(), 0) + ;
		            IIF(This.SaveAs_PDFMeta.Permit_Edit, m.loHPDFC.HPDF_ENABLE_EDIT(), 0) 
		        
		        IF m.lnPermit <> 0
		            m.loHPDF.HPDF_SetPermission(This.hpdf_doc, m.lnPermit)
		        ENDIF
		        
		        m.loHPDF.HPDF_ResetError(This.hpdf_doc)
		    ENDCASE
		    *******************************************************
		    
		
		    *******************************************************
		    m.loHPDF.HPDF_ResetError(This.hpdf_doc)    
		    
		    IF m.loHPDF.HPDF_SaveToFile(This.hpdf_doc, m.lcTempFileName) <> 0
		        EXIT
		    ENDIF
		    
		    This.ClosePDF()
		    
		        
		    DO CASE
		    CASE This.CommandClauses.OUTPUTTO = 2 && output to the file
		        IF EMPTY(This.CommandClauses.TOFILE) = .F.
		            COPY FILE (m.lcTempFileName) TO (This.CommandClauses.TOFILE)
		        ENDIF
		
		    CASE This.CommandClauses.OUTPUTTO = 1 && output to the printer
		        This.PreviewContainer = NEWOBJECT("PdfiumReportViewer", This.ClassLibrary, "", This.env, This.PrintEnv)
		        This.PreviewContainer.SetReport(This)
		        This.PreviewContainer.OpenPDF(m.lcTempFileName, This.SaveAs_PDFMeta.UserPassword)
		
		        IF This.CommandClauses.PROMPT
		            This.PreviewContainer.Show()
		        ENDIF
		        
		        This.PreviewContainer.PrintReport()
		    
		    
		    CASE This.CommandClauses.PREVIEW
		        This.PreviewContainer = NEWOBJECT("PdfiumReportViewer", This.ClassLibrary, "", This.env, This.PrintEnv)
		        This.PreviewContainer.SetReport(This)
		        This.PreviewContainer.OpenPDF(m.lcTempFileName, This.SaveAs_PDFMeta.UserPassword)
		        This.PreviewContainer.SaveAs_Filename = EVL(NVL(This.SaveAs_Filename,""),"")
		        This.PreviewContainer.Show(1)
		    
		    ENDCASE
		
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		    This.errLogShow()
		
		FINALLY
		
		    This.PreviewContainer = NULL
		    
		    This.ClosePDF()
		
		    This._PrintEnv = .F.
		    
		    TRY
		        IF FILE(m.lcTempFileName,1)
		            DELETE FILE (m.lcTempFileName)
		        ENDIF
		    CATCH
		    ENDTRY
		
		ENDTRY
		
		
	ENDPROC

	HIDDEN PROCEDURE getfontgdi
		LPARAMETERS loRepObj
		
		LOCAL lcFontID
		m.lcFontID = ALLTRIM(m.loRepObj.FontFace)
		m.lcFontID = m.lcFontID + "<"+TRANSFORM(m.loRepObj.FontSize)+">"
		IF m.loRepObj.FontBold
		    m.lcFontID = m.lcFontID + "<B>"
		ENDIF
		IF m.loRepObj.FontItalic
		    m.lcFontID = m.lcFontID + "<I>"
		ENDIF
		IF m.loRepObj.FontUnderline
		    m.lcFontID = m.lcFontID + "<U>"
		ENDIF
		m.lcFontID = m.lcFontID + "<"+TRANSFORM(m.loRepObj.FontCharset)+">"
		
		
		***********************************************************
		* Font has been found
		***********************************************************
		LOCAL lnFontIndex
		m.lnFontIndex = This.gdi_fonts.GetKey(m.lcFontID)
		IF m.lnFontIndex > 0
		    RETURN This.gdi_fonts[m.lnFontIndex]
		ENDIF
		***********************************************************
		
		
		***********************************************************
		* Font hasn't been found, create it
		***********************************************************
		LOCAL loGDIFont, loGDIFontFamily, liFont, lcFontFace
		STORE .F. TO m.loGDIFont, m.loGDIFontFamily
		m.liFont = 1
		FOR m.liFont = 1 TO 3
		
		    m.lcFontFace = ICASE(m.liFont=1, m.loRepObj.FontFace, m.liFont=2, "Helvetica", "Arial") && If report font is not found, take fallback font
		
		    m.loGDIFont = This.env.System.Drawing.Font.New( ;
		        m.lcFontFace, ;
		        m.loRepObj.FontSize, ;
		        ( ;
		            IIF(m.loRepObj.FontBold, This.env.System.Drawing.FontStyle.Bold, 0) + ;
		            IIF(m.loRepObj.FontItalic, This.env.System.Drawing.FontStyle.Italic, 0) + ; 
		            IIF(m.loRepObj.FontUnderline, This.env.System.Drawing.FontStyle.Underline, 0) ;
		        ),;
		        This.env.System.Drawing.GraphicsUnit.Point, ;
		        m.loRepObj.FontCharset, ;
		        .F.)
		
		
		    IF EMPTY(m.loGDIFont.GetHandle()) = .F.
		        m.loGDIFontFamily = m.loGDIFont.FontFamily
		        EXIT
		    ENDIF
		    
		    LOOP
		
		
		    IF EMPTY(This.env.System.Drawing.Text.PrivateFontCollection.Families.GetKey(m.lcFontFace)) = .F. && Try to get font from private font collection
		        
		        m.loGDIFontFamily = This.env.System.Drawing.Text.PrivateFontCollection.Families.Item(m.lcFontFace)
		        
		        m.loGDIFont = This.env.System.Drawing.Font.New( ;
		            m.loGDIFontFamily, ;
		            m.loRepObj.FontSize, ;
		            ( ;
		                IIF(m.loRepObj.FontBold, This.env.System.Drawing.FontStyle.Bold, 0) + ;
		                IIF(m.loRepObj.FontItalic, This.env.System.Drawing.FontStyle.Italic, 0) + ; 
		                IIF(m.loRepObj.FontUnderline, This.env.System.Drawing.FontStyle.Underline, 0) ;
		            ),;
		            This.env.System.Drawing.GraphicsUnit.Point, ;
		            m.loRepObj.FontCharset, ;
		            .F.)
		
		    ENDIF    
		
		    IF EMPTY(m.loGDIFont.GetHandle()) = .F.
		        EXIT
		    ENDIF
		    
		    m.loGDIFont = .F.
		    m.loGDIFontFamily = .F.
		
		ENDFOR
		
		
		LOCAL loFont
		m.loFont = NEWOBJECT("Empty")
		ADDPROPERTY(m.loFont, "GDIFont", m.loGDIFont)
		ADDPROPERTY(m.loFont, "Handle", m.loGDIFont.GetHandle())
		ADDPROPERTY(m.loFont, "Height", EVL(MAX(m.loGDIFont.GetHeight(), 0), 15.7))
		ADDPROPERTY(m.loFont, "HeightCeil", EVL(MAX(m.loGDIFont.Height, 0), 16))
		
		
		TRY
		    ADDPROPERTY(m.loFont, "CellDescent", m.loGDIFontFamily.GetCellDescent())
		    ADDPROPERTY(m.loFont, "CellAscent", m.loGDIFontFamily.GetCellAscent())
		    ADDPROPERTY(m.loFont, "EmHeight", m.loGDIFontFamily.GetEmHeight())
		CATCH
		    ADDPROPERTY(m.loFont, "CellDescent", 434)
		    ADDPROPERTY(m.loFont, "CellAscent", 1854)
		    ADDPROPERTY(m.loFont, "EmHeight", 2048)
		ENDTRY
		
		
		This.gdi_fonts.Add(m.loFont, m.lcFontID)
		
		RETURN m.loFont
		
		
	ENDPROC

	HIDDEN PROCEDURE getfontpdf
		LPARAMETERS loRepObj
		
		IF EMPTY(This.hpdf_doc)
		    RETURN 0
		ENDIF
		
		LOCAL loHPDF, loHPDFC
		m.loHPDF = This.env.API_HPDF
		m.loHPDFC = m.loHPDF.CONST
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		
		LOCAL lcFontID
		m.lcFontID = ALLTRIM(m.loRepObj.FontFace)
		IF m.loRepObj.FontBold
		    m.lcFontID = m.lcFontID + "<B>"
		ENDIF
		IF m.loRepObj.FontItalic
		    m.lcFontID = m.lcFontID + "<I>"
		ENDIF
		
		
		***********************************************************
		* Font has been found
		***********************************************************
		LOCAL lnFontIndex
		m.lnFontIndex = This.hpdf_fonts.GetKey(m.lcFontID)
		IF m.lnFontIndex > 0
		    RETURN This.hpdf_fonts[m.lnFontIndex]
		ENDIF
		***********************************************************
		
		
		***********************************************************
		* Font hasn't been found, load it from file
		***********************************************************
		LOCAL lnHPDF_Font
		m.lnHPDF_Font = 0
		
		LOCAL lnBoldSimulation, lnItalicSimulation
		STORE 0 TO m.lnBoldSimulation, m.lnItalicSimulation
		
		LOCAL lnIsSymbolFont
		m.lnIsSymbolFont = 0
		
		LOCAL lcFontFileName
		m.lcFontFileName = ""
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    
		    m.lcFontFileName = REPLICATE(CHR(0),255*2)
		
		    LOCAL lnGetFont
		    m.lnGetFont = m.loFPDF.VFPDF_GetFontFileName( ;
		                    STRCONV(ALLTRIM(m.loRepObj.FontFace),5)+CHR(0), ;
		                    IIF(m.loRepObj.FontBold,1,0), ;
		                    IIF(m.loRepObj.FontItalic,1,0), ;
		                    m.loRepObj.FontCharset, ;
		                    @m.lcFontFileName, ;
		                    LEN(m.lcFontFileName), ;
		                    @m.lnBoldSimulation, ;
		                    @m.lnItalicSimulation, ;
		                    @m.lnIsSymbolFont)
		                    
		    IF m.lnGetFont = 1
		        m.lcFontFileName = STRCONV(m.lcFontFileName,6)
		        m.lcFontFileName = ALLTRIM(m.lcFontFileName, 1, CHR(0), " ")
		
		    ELSE    
		        * Font is not found
		        
		        * Private font collection searching
		        LOCAL lnPrivateFontKey
		        m.lnPrivateFontKey = This.env.PrivateFonts.GetKey(ALLTRIM(m.loRepObj.FontFace)) 
		        IF EMPTY(m.lnPrivateFontKey)
		            EXIT
		        ENDIF
		        
		        m.lcFontFileName = ALLTRIM(This.env.PrivateFonts.Item(m.lnPrivateFontKey))
		        
		        m.lnIsSymbolFont = 0
		        m.lnBoldSimulation = 0
		        m.lnItalicSimulation = 0
		        
		        IF EMPTY(This.env.System.Drawing.Text.PrivateFontCollection.Families.GetKey(ALLTRIM(m.loRepObj.FontFace))) = .F.
		            LOCAL loGDIFontFamily
		            m.loGDIFontFamily = This.env.System.Drawing.Text.PrivateFontCollection.Families.Item(ALLTRIM(m.loRepObj.FontFace))
		
		            m.lnBoldSimulation = IIF(m.loGDIFontFamily.IsStyleAvailable(This.env.System.Drawing.FontStyle.Bold), 0, 1)
		            m.lnItalicSimulation = IIF(m.loGDIFontFamily.IsStyleAvailable(This.env.System.Drawing.FontStyle.Italic), 0, 1)
		            
		            m.loGDIFontFamily = .F.
		        ENDIF
		
		    ENDIF
		
		    IF EMPTY(m.lnIsSymbolFont)=.F.
		        * LibHARU fails on HPDF_LoadTTFontFromFile with Symbol fonts (Windings*...)    
		        EXIT
		    ENDIF
		
		
		    IF FILE(m.lcFontFileName,1) = .F.
		        EXIT && Font file doesn't exist OR FILENAME HAS UNICODE SYMBOLS
		    ENDIF
		      
		    IF NOT LOWER(ALLTRIM(JUSTEXT(m.lcFontFileName))) == "ttf"
		        EXIT && Only TTF files supported
		    ENDIF
		
		
		    * Check if font file has been loaded earlier
		    LOCAL loFont
		    FOR EACH m.loFont IN This.hpdf_fonts FOXOBJECT
		        IF ALLTRIM(m.loFont.FontFileName) == ALLTRIM(m.lcFontFileName)
		            m.lnHPDF_Font = m.loFont.FontHandle
		            EXIT
		        ENDIF
		    ENDFOR
		
		    * Load font from file if file hasn't been loaded yet
		    IF EMPTY(m.lnHPDF_Font)
		        LOCAL lcHPDF_FontName
		        m.lcHPDF_FontName = m.loHPDF.HPDF_LoadTTFontFromFile(This.hpdf_doc, m.lcFontFileName, 1)
		
		        IF EMPTY(m.lcHPDF_FontName)=.F.
		            m.lnHPDF_Font = m.loHPDF.HPDF_GetFont(This.hpdf_doc, m.lcHPDF_FontName, m.loHPDFC.UTF8())
		        ENDIF
		    ENDIF
		
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		
		FINALLY
		
		    IF EMPTY(m.lnHPDF_Font)=.T. AND EMPTY(m.lnIsSymbolFont)=.T. && Get Fallback Font
		        m.lnBoldSimulation = 0
		        m.lnItalicSimulation = 0
		        m.lcFontFileName = ""
		
		        m.lnHPDF_Font = m.loHPDF.HPDF_GetFont( ;
		            This.hpdf_doc, ;
		            ICASE( ;
		                m.loRepObj.FontBold and m.loRepObj.FontItalic, "Helvetica-BoldOblique", ;
		                m.loRepObj.FontBold, "Helvetica-Bold", ;
		                m.loRepObj.FontItalic, "Helvetica-Oblique", ;
		                "Helvetica"), ;
		            ICASE(;
		                m.loRepObj.FontCharset=161, m.loHPDFC.CP("1253"),;
		                m.loRepObj.FontCharset=162, m.loHPDFC.CP("1254"),;
		                m.loRepObj.FontCharset=163, m.loHPDFC.CP("1258"),;
		                m.loRepObj.FontCharset=177, m.loHPDFC.CP("1255"),;
		                m.loRepObj.FontCharset=178, m.loHPDFC.CP("1256"),;
		                m.loRepObj.FontCharset=186, m.loHPDFC.CP("1257"),;
		                m.loRepObj.FontCharset=204, m.loHPDFC.CP("1251"),;
		                m.loRepObj.FontCharset=238, m.loHPDFC.CP("1250"),;
		                m.loHPDFC.CP("1252")))
		    ENDIF
		
		ENDTRY
		
		
		* Create and store font object
		IF EMPTY(m.lnHPDF_Font)=.F.
		    LOCAL loPDFFont
		    m.loPDFFont = NEWOBJECT("Empty")
		    
		    ADDPROPERTY(m.loPDFFont, "FontFileName", m.lcFontFileName)
		    ADDPROPERTY(m.loPDFFont, "FontHandle", m.lnHPDF_Font)
		    ADDPROPERTY(m.loPDFFont, "FontFace", m.loRepObj.FontFace)
		    ADDPROPERTY(m.loPDFFont, "FontBold", (m.loRepObj.FontBold and m.lnBoldSimulation = 0))
		    ADDPROPERTY(m.loPDFFont, "FontItalic", (m.loRepObj.FontItalic and m.lnItalicSimulation = 0))
		
		    This.hpdf_fonts.Add(m.loPDFFont, m.lcFontID)
		ENDIF
		
		
		LOCAL lnFontIndex
		m.lnFontIndex = This.hpdf_fonts.GetKey(m.lcFontID)
		IF m.lnFontIndex > 0
		    RETURN This.hpdf_fonts[m.lnFontIndex]
		ENDIF
		
		RETURN .F.
		
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.env = NEWOBJECT("pdfium_env", This.ClassLibrary)
		This.env.Setup(m.toEnv)
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.utils = NEWOBJECT("pdfium_utils", This.ClassLibrary)
		
		This.oGfx = This.env.System.Drawing.Graphics.FromHWND(_SCREEN.HWnd)
		
	ENDPROC

	PROCEDURE LoadReport
		This.env.FoxEnv_Set()
		
		This.frx_pagecount = 0
		
		This.ListenerType = -1
		
		********************************************************
		LOCAL loPrintEnv
		m.loPrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		m.loPrintEnv.Setup(This.PrintEnv)
		This.PrintEnv.Setup(m.loPrintEnv, .T.)
		m.loPrintEnv = .F.
		
		IF This.CommandClauses.OUTPUTTO = 1
		    This.PrintEnv.AllowPrintSetupUI = This.CommandClauses.PROMPT
		ENDIF
		
		********************************************************
		
		********************************************************
		DO CASE
		CASE This.CommandClauses.ISDESIGNERLOADED
		    This.CommandClauses.PREVIEW = .T.
		 
		CASE This.CommandClauses.OUTPUTTO = 1 AND This.ToPrinterNative = .T. && VFP native output to the printer, do nothing
		    This.ListenerType = 0
		    RETURN
		ENDCASE
		********************************************************
		
		IF EMPTY(This.hpdf_doc)
		    This.CreatePDF()
		ENDIF
		
		This.BatchModeAuto = This.CommandClauses.NOPAGEEJECT
		This.CommandClauses.NOPAGEEJECT = .F.
		
	ENDPROC

	HIDDEN PROCEDURE measurestring
		LPARAMETERS tcTextUnicode, toFont, toLayoutRectF, toObjRectF, tnCharsFitted, tnLinesFitted
		
		STORE 0 TO m.tnCharsFitted, m.tnLinesFitted
		
		m.toObjRectF = This.env.system.Drawing.RectangleF.New(0,0,0,0)
		
		LOCAL lcObjBBox
		m.lcObjBBox = m.toObjRectF.ToVarBinary()
		
		* Plain Api call because GDIPluxX Graphics.MeasureString performs STRCONV(...,5) on input text while loRepObj.Text is in Unicode
		This.env.API_WIN.GdipMeasureString (;
		    This.oGfx.GetHandle(), ;
		    m.tcTextUnicode + CHR(0), ;
		    LEN(m.tcTextUnicode) / 2, ;
		    m.toFont.Handle, ;
		    m.toLayoutRectF.ToVarBinary(), ;
		    This.env.system.Drawing.StringFormat.GenericTypographic.GetHandle(), ;
		    @m.lcObjBBox, ;
		    @m.tnCharsFitted, ;
		    @m.tnLinesFitted)
		
		
		m.toObjRectF = m.toObjRectF.New(m.lcObjBBox)
		
		
	ENDPROC

	PROCEDURE OnPreviewClose
		LPARAMETERS lPrint
		
		This.PreviewContainer = NULL
		
	ENDPROC

	PROCEDURE printenvdefault_access
		
		IF VARTYPE(This._PrintEnvDefault) <> "O"
		    This._PrintEnvDefault = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		    This._PrintEnvDefault.Setup(NULL)
		ENDIF
		
		RETURN This._PrintEnvDefault
		
	ENDPROC

	PROCEDURE printenvdefault_assign
		LPARAMETERS vNewVal
		
		ERROR 1740, TEXTMERGE("<<This.Class>>.PrintEnvDefault")
		
	ENDPROC

	PROCEDURE printenv_access
		
		IF VARTYPE(This._PrintEnv) <> "O"
		    This._PrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		    This._PrintEnv.Setup(This.PrintEnvDefault, .T.)
		ENDIF
		
		RETURN This._PrintEnv
		
	ENDPROC

	PROCEDURE printenv_assign
		LPARAMETERS vNewVal
		
		ERROR 1740, TEXTMERGE("<<This.Class>>.PrintEnv")
		
	ENDPROC

	PROCEDURE Render
		LPARAMETERS nFRXRecno, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage
		
		IF This.TwoPassProcess AND This.CurrentPass = 0
		    RETURN DODEFAULT(m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
		ENDIF
		
		IF This.ListenerType = 0 AND This.ToPrinterNative = .T. && VFP native output to the printer, do nothing
		    RETURN DODEFAULT(m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
		ENDIF
		
		
		IF This.PageNo < This.CommandClauses.RANGEFROM
		    RETURN 
		ENDIF
		    
		IF This.PageNo > This.CommandClauses.RANGETO AND This.CommandClauses.RANGETO > 0
		    RETURN
		ENDIF
		
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		IF EMPTY(This.hpdf_doc)
		    RETURN
		ENDIF
		
		
		LOCAL loHPDF
		m.loHPDF = This.env.API_HPDF
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL lnPageWidth, lnPageHeight
		m.lnPageWidth = This.GetPageWidth() / 10
		m.lnPageHeight = This.GetPageHeight() / 10
		
		
		m.loHPDF.HPDF_ResetError(This.hpdf_doc)
		
		
		*************************************************
		* Create new page
		*************************************************
		IF This.PageNo > This.frx_pagecount
		
		    This.frx_pagecount = This.frx_pagecount + 1
		    This.hpdf_pagecount = This.hpdf_pagecount + 1 &&It may be greater than frx_pagecount if PDF comprise output of many reports when This.BatchMode=.T.
		
		    DIMENSION This.hpdf_pages(This.hpdf_pagecount)
		
		    LOCAL lnHPDF_Page
		    m.lnHPDF_Page = m.loHPDF.HPDF_AddPage(This.hpdf_doc)
		
		    IF EMPTY(m.lnHPDF_Page)=.F.
		        m.loHPDF.HPDF_Page_SetWidth(m.lnHPDF_Page,  m.lnPageWidth * m.lnDpiCoef)
		        m.loHPDF.HPDF_Page_SetHeight(m.lnHPDF_Page, m.lnPageHeight * m.lnDpiCoef)
		    ENDIF
		    
		    This.hpdf_pages[This.hpdf_pagecount] = m.lnHPDF_Page
		    
		    IF This.frx_pagecount = 1
		        This.Render_FrxHeader()
		    ENDIF
		ENDIF
		
		IF EMPTY(This.hpdf_pages[This.hpdf_pagecount])
		    RETURN
		ENDIF
		
		
		
		*************************************************
		#define FRX_OBJ_COMMENT     0
		#define FRX_OBJ_LABEL       5
		#define FRX_OBJ_LINE        6
		#define FRX_OBJ_RECTANGLE   7
		#define FRX_OBJ_FIELD       8
		#define FRX_OBJ_PICTURE     17
		#define FRX_OBJ_VARIABLE    18
		
		
		*************************************************
		IF (This.FRXDatasession > -1) AND (This.FRXDatasession <> SET("DATASESSION"))
		    SET DATASESSION TO (This.FRXDatasession)
		ENDIF
		
		GO m.nFRXRecNo IN FRX
		
		LOCAL loFrx
		SCATTER NAME m.loFrx MEMO
		
		SET DATASESSION TO (This.CurrentDataSession)
		*************************************************
		
		
		*************************************************
		LOCAL loRepObj
		
		m.loRepObj = NEWOBJECT("Empty")
		
		
		ADDPROPERTY(m.loRepObj, "ObjType", m.loFrx.ObjType)
		
		ADDPROPERTY(m.loRepObj, "Text", "")
		ADDPROPERTY(m.loRepObj, "FileName", "")
		
		IF INLIST(m.loFrx.ObjType, FRX_OBJ_FIELD, FRX_OBJ_LABEL)
		    m.loRepObj.Text = m.cContentsToBeRendered
		ENDIF
		
		IF INLIST(m.loFrx.ObjType, FRX_OBJ_PICTURE)
		    m.loRepObj.FileName = m.cContentsToBeRendered
		ENDIF
		
		
		ADDPROPERTY(m.loRepObj, "Left", m.nLeft / 10)
		ADDPROPERTY(m.loRepObj, "Top", m.nTop / 10)
		ADDPROPERTY(m.loRepObj, "TopRev", m.lnPageHeight - m.nTop / 10)
		ADDPROPERTY(m.loRepObj, "Width", m.nWidth / 10)
		ADDPROPERTY(m.loRepObj, "Height", m.nHeight / 10)
		
		m.loRepObj.Left = m.loRepObj.Left - This.frx_offsetx * 96
		m.loRepObj.Top = m.loRepObj.Top - This.frx_offsety * 96
		
		ADDPROPERTY(m.loRepObj, "FontFace", LTRIM(ALLTRIM(m.loFrx.FontFace), "@"))
		ADDPROPERTY(m.loRepObj, "FontSize", m.loFrx.FontSize)
		ADDPROPERTY(m.loRepObj, "FontBold", BITTEST(m.loFrx.FontStyle,0))
		ADDPROPERTY(m.loRepObj, "FontItalic", BITTEST(m.loFrx.FontStyle,1))
		ADDPROPERTY(m.loRepObj, "FontUnderline", BITTEST(m.loFrx.FontStyle,2))
		ADDPROPERTY(m.loRepObj, "FontStrikeout", BITTEST(m.loFrx.FontStyle,7))
		ADDPROPERTY(m.loRepObj, "FontCharset", m.loFrx.ResOID)
		
		
		* (-1,-1,-1) - default color
		ADDPROPERTY(m.loRepObj, "FillRed", IIF(m.loFrx.FillRed=-1, 255, m.loFrx.FillRed))
		ADDPROPERTY(m.loRepObj, "FillGreen", IIF(m.loFrx.FillGreen=-1, 255, m.loFrx.FillGreen))
		ADDPROPERTY(m.loRepObj, "FillBlue", IIF(m.loFrx.FillBlue=-1, 255, m.loFrx.FillBlue))
		ADDPROPERTY(m.loRepObj, "FillAlpha", 255)
		
		* (-1,-1,-1) - default color
		ADDPROPERTY(m.loRepObj, "PenRed", IIF(m.loFrx.PenRed=-1, 0, m.loFrx.PenRed))
		ADDPROPERTY(m.loRepObj, "PenGreen", IIF(m.loFrx.PenGreen=-1, 0, m.loFrx.PenGreen))
		ADDPROPERTY(m.loRepObj, "PenBlue", IIF(m.loFrx.PenBlue=-1, 0, m.loFrx.PenBlue))
		ADDPROPERTY(m.loRepObj, "PenAlpha", 255)
		
		ADDPROPERTY(m.loRepObj, "PenPat", m.loFrx.PenPat)
		ADDPROPERTY(m.loRepObj, "PenSize", m.loFrx.PenSize)
		
		ADDPROPERTY(m.loRepObj, "FillPat", m.loFrx.FillPat)
		ADDPROPERTY(m.loRepObj, "Mode", m.loFrx.Mode) &&Transparency: 0 - Opaque, 1 - Transparent
		ADDPROPERTY(m.loRepObj, "Offset", m.loFrx.Offset) &&Alignment: 0 - left, 1 - right, 2 - center
		ADDPROPERTY(m.loRepObj, "ContinuationType", m.nObjectContinuationType)
		ADDPROPERTY(m.loRepObj, "GDIPlusImage", m.GDIPlusImage)
		ADDPROPERTY(m.loRepObj, "General", m.loFrx.General)
		ADDPROPERTY(m.loRepObj, "Style", m.loFrx.Style)
		ADDPROPERTY(m.loRepObj, "Rotate", 0)
		
		This.Render_FrxDynamics(m.loRepObj)
		
		
		*************************************************
		DO CASE
		CASE m.loFrx.ObjType = FRX_OBJ_FIELD
		    This.Render_FrxField(m.loRepObj)
		   
		CASE m.loFrx.ObjType = FRX_OBJ_LABEL
		    This.Render_FrxLabel(m.loRepObj)
		
		CASE m.loFrx.ObjType = FRX_OBJ_LINE
		    This.Render_FrxLine(m.loRepObj)
		
		CASE m.loFrx.ObjType = FRX_OBJ_RECTANGLE
		    This.Render_FrxRectangle(m.loRepObj)
		
		CASE m.loFrx.ObjType = FRX_OBJ_PICTURE
		    This.Render_FrxPicture(m.loRepObj)
		
		ENDCASE
		*************************************************
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxdynamics
		LPARAMETERS loRepObj
		
		IF EMPTY(NVL(m.loRepObj.Style,""))
		    RETURN
		ENDIF
		
		#define FRX_OBJ_RECTANGLE   7
		#define FRX_OBJ_FIELD       8
		#define FRX_OBJ_PICTURE     17
		
		
		LOCAL lSaveArea
		m.lSaveArea = SELECT()
		
		LOCAL lSetNull
		m.lSetNull = SET("Null")
		
		SET NULL OFF
		
		LOCAL lcAliasCursor, llRes
		m.lcAliasCursor = "curTempFrxDynamics"+SYS(2015)
		
		CREATE CURSOR &lcAliasCursor (Name c(100), Execute c(10), ExecWhen M, Script M, FName c(100), FSize c(10), FStyle c(10), Width c(10), Height c(10), penrgb c(10), pena c(5), fillrgb c(10), filla c(5))
		
		SET NULL &lSetNull
		
		m.llRes = .T.
		TRY
		    XMLTOCURSOR(m.loRepObj.Style, m.lcAliasCursor,1024+8192)
		CATCH
		    m.llRes = .F.
		FINALLY    
		    IF m.llRes = .F.
		        USE IN (m.lcAliasCursor)
		        SELECT (m.lSaveArea)
		        RETURN
		    ENDIF
		ENDTRY
		
		
		SELECT (m.lcAliasCursor)
		GO TOP
		SCAN
		    SELECT (m.lcAliasCursor)
		
		    LOCAL loDS
		    SCATTER NAME m.loDS MEMO
		    
		    SELECT (m.lSaveArea)
		
		    DO CASE
		    CASE ALLTRIM(m.loDS.Name) == "Microsoft.VFP.Reporting.Builder.Rotate"
		        m.loRepObj.Rotate = CAST(m.loDS.Execute AS I)
		        
		    CASE EMPTY(m.loDS.ExecWhen)
		
		    CASE EVALUATE(m.loDS.ExecWhen) = .F.
		    
		    
		    CASE m.loRepObj.ObjType = FRX_OBJ_FIELD
		        IF EMPTY(m.loDS.Script) = .F.
		            IF INLIST(m.loRepObj.FontCharset,0,1)=.F.
		                m.loRepObj.Text = STRCONV(RTRIM(EVALUATE(m.loDS.Script)),5,m.loRepObj.FontCharset,2)
		            ELSE
		                m.loRepObj.Text = STRCONV(RTRIM(EVALUATE(m.loDS.Script)),5)
		            ENDIF
		        ENDIF
		        
		        IF EMPTY(m.loDS.FName) = .F.
		            m.loRepObj.FontFace = LTRIM(ALLTRIM(m.loDS.FName), "@")
		        ENDIF
		
		        IF EMPTY(CAST(m.loDS.FSize as I)) = .F.
		            m.loRepObj.FontSize = CAST(m.loDS.FSize as I)
		        ENDIF
		        
		        IF EMPTY(CAST(m.loDS.FStyle as I)) = .F.
		            m.loRepObj.FontBold = BITTEST(CAST(m.loDS.FStyle as I),0)
		            m.loRepObj.FontItalic = BITTEST(CAST(m.loDS.FStyle as I),1)
		            m.loRepObj.FontUnderline = BITTEST(CAST(m.loDS.FStyle as I),2)
		            m.loRepObj.FontStrikeout = BITTEST(CAST(m.loDS.FStyle as I),7)                                    
		        ENDIF
		        
		        IF CAST(m.loDS.FillRgb as I) >= 0 AND EMPTY(m.loDS.FillRgb)=.F.
		            m.loRepObj.FillRed = BITRSHIFT(BITAND(CAST(m.loDS.FillRgb as I), 0x0000FF),0)
		            m.loRepObj.FillGreen = BITRSHIFT(BITAND(CAST(m.loDS.FillRgb as I), 0x00FF00),8)
		            m.loRepObj.FillBlue = BITRSHIFT(BITAND(CAST(m.loDS.FillRgb as I), 0xFF0000),16)
		        ENDIF
		        
		        IF CAST(m.loDS.PenA as I) >= 0 AND EMPTY(m.loDS.PenA)=.F.
		            m.loRepObj.PenAlpha = BITAND(CAST(m.loDS.PenA as I), 0xFF)
		        ENDIF
		
		        IF CAST(m.loDS.PenRgb as I) >= 0 AND EMPTY(m.loDS.PenRgb)=.F.
		            m.loRepObj.PenRed = BITRSHIFT(BITAND(CAST(m.loDS.PenRgb as I), 0x0000FF),0)
		            m.loRepObj.PenGreen = BITRSHIFT(BITAND(CAST(m.loDS.PenRgb as I), 0x00FF00),8)
		            m.loRepObj.PenBlue = BITRSHIFT(BITAND(CAST(m.loDS.PenRgb as I), 0xFF0000),16)
		        ENDIF
		
		        IF CAST(m.loDS.FillA as I) >= 0 AND EMPTY(m.loDS.FillA)=.F.
		            m.loRepObj.FillAlpha = BITAND(CAST(m.loDS.FillA as I), 0xFF)
		            m.loRepObj.Mode = IIF(m.loRepObj.FillAlpha = 0, 1, 0)
		        ENDIF
		
		    
		    CASE INLIST(m.loRepObj.ObjType, FRX_OBJ_RECTANGLE, FRX_OBJ_PICTURE)
		        m.loRepObj.Width = IIF(CAST(m.loDS.Width AS I) >= 0, CAST(m.loDS.Width AS I) / 10, m.loRepObj.Width)
		        m.loRepObj.Height = IIF(CAST(m.loDS.Height AS I) >= 0, CAST(m.loDS.Height AS I) / 10, m.loRepObj.Height)
		    
		    ENDCASE
		    
		ENDSCAN
		GO TOP
		
		USE IN (m.lcAliasCursor)
		SELECT (m.lSaveArea)
		
	ENDPROC

	HIDDEN PROCEDURE render_frxfield
		LPARAMETERS loRepObj
		
		This.render_text(m.loRepObj)
		
	ENDPROC

	HIDDEN PROCEDURE render_frxheader
		This.frx_wholepage = .F.
		This.frx_offsetx = 0
		This.frx_offsety = 0
		
		*************************************************
		IF (This.FRXDatasession > -1) AND (This.FRXDatasession <> SET("DATASESSION"))
		    SET DATASESSION TO (This.FRXDatasession)
		ENDIF
		
		LOCAL lnFRXRecNo
		m.lnFRXRecNo = RECNO("FRX")
		
		GO TOP IN FRX && Header record
		
		IF FRX.Top = .T.
		    This.frx_wholepage = .T.
		ENDIF
		
		LOCAL lcPrinter
		m.lcPrinter = ALLTRIM(STREXTRACT(STREXTRACT(CHRTRAN(Frx.Expr,CHR(13),CHR(10)), "DEVICE",CHR(10),1,1)+CHR(10), "=", CHR(10),1,1), 1, " ", CHR(10))
		
		IF BETWEEN(m.lnFRXRecNo, 1, RECCOUNT("FRX"))
		    GO (m.lnFRXRecNo) IN FRX
		ENDIF
		
		SET DATASESSION TO (This.CurrentDataSession)
		*************************************************
		
		IF EMPTY(m.lcPrinter)=.F.
		    IF EMPTY(This.PrintEnv.GetPrinterTitle(m.lcPrinter))
		        m.lcPrinter = ""
		    ENDIF
		ENDIF
		
		IF EMPTY(m.lcPrinter)=.T.
		    m.lcPrinter = This.PrintEnv.SysDefaultPrinter_Get()
		ENDIF
		
		
		IF EMPTY(m.lcPrinter) = .F. AND This.frx_wholepage = .F. 
		
		    #define PHYSICALOFFSETX 112
		    #define PHYSICALOFFSETY 113
		
		    LOCAL lnPrinterDPI
		    m.lnPrinterDPI = EVL(MAX(PRTINFO(11, m.lcPrinter),0), 600)
		
		    LOCAL lhPrinterDC
		    m.lhPrinterDC = This.env.API_WIN.CreateDC(NULL, m.lcPrinter + CHR(0), NULL, NULL)
		
		    IF EMPTY(m.lhPrinterDC) = .F.
		        TRY
		            This.frx_offsetx = This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETX) / m.lnPrinterDPI
		            This.frx_offsety = This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETY) / m.lnPrinterDPI
		        FINALLY
		            This.env.API_WIN.DeleteDC(m.lhPrinterDC)
		        ENDTRY
		    ENDIF
		ENDIF
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxlabel
		LPARAMETERS loRepObj
		
		This.render_text(m.loRepObj)
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxline
		LPARAMETERS loRepObj
		
		LOCAL loHPDF, loHPDFC
		m.loHPDF = This.env.API_HPDF
		m.loHPDFC = m.loHPDF.CONST
		
		
		LOCAL lnHPDF_Page
		m.lnHPDF_Page = This.hpdf_pages[This.hpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		m.loHPDF.HPDF_Page_GSave(m.lnHPDF_Page)
		
		
		LOCAL lnLineWidth
		IF m.loRepObj.PenPat >= 1
		    m.lnLineWidth = MAX(m.loRepObj.PenSize, 0.5) * m.lnDpiCoef
		ELSE
		    m.lnLineWidth = 0
		ENDIF
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = m.loRepObj.Left + IIF(m.loRepObj.OffSet = 1, 0, m.loRepObj.PenSize * 0.5)
		m.lnTop = m.loRepObj.TopRev + IIF(m.loRepObj.OffSet = 1, -m.loRepObj.PenSize * 0.5, 0)
		m.lnWidth = m.loRepObj.Width + IIF(m.loRepObj.OffSet = 1, 0, 0)
		m.lnHeight = m.loRepObj.Height + IIF(m.loRepObj.OffSet = 1, 0, 0)
		
		IF EMPTY(m.loRepObj.Rotate) = .F.
		    LOCAL lnRad
		    m.lnRad = -m.loRepObj.Rotate * PI() / 180
		
		    m.loHPDF.HPDF_Page_Concat(;
		        m.lnHPDF_Page, ;
		        COS(m.lnRad), ;
		        SIN(m.lnRad), ;
		        -SIN(m.lnRad), ;
		        COS(m.lnRad), ;
		        m.lnDpiCoef * m.lnLeft, ;
		        m.lnDpiCoef * m.lnTop)
		
		    m.lnLeft = 0
		    m.lnTop = 0
		ENDIF
		
		m.loHPDF.HPDF_Page_SetRGBStroke(m.lnHPDF_Page, m.loRepObj.PenRed / 255, m.loRepObj.PenGreen / 255, m.loRepObj.PenBlue / 255)
		
		m.loHPDF.HPDF_Page_SetLineWidth(m.lnHPDF_Page,  m.lnLineWidth)
		
		
		LOCAL lcDash
		
		DO CASE
		CASE m.loRepObj.PenPat = 8 && Normal
		    m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, NULL, 0, 0)
		
		CASE m.loRepObj.PenPat = 1 && Dot
		    m.lcDash = BINTOC(1, "F")
		    m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, @m.lcDash, 1, 1)
		    
		CASE m.loRepObj.PenPat = 2 && Dash
		    m.lcDash = BINTOC(6, "F") + BINTOC(6, "F")
		    m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, @m.lcDash, 2, 2)
		    
		CASE m.loRepObj.PenPat = 3 && Dash-dot
		    m.lcDash = BINTOC(6, "F") + BINTOC(6, "F") + BINTOC(1, "F") + BINTOC(6, "F")
		    m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, @m.lcDash, 4, 0)
		    
		CASE m.loRepObj.PenPat = 4 && Dash-dot-dot
		    m.lcDash = BINTOC(6, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F")
		    m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, @m.lcDash, 6, 0)
		
		OTHERWISE && Normal
		    m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, NULL, 0, 0)
		
		ENDCASE
		
		
		IF m.loRepObj.OffSet = 1
		    * Horizontal line
		    m.loHPDF.HPDF_Page_MoveTo(m.lnHPDF_Page, ;
		        m.lnDpiCoef * m.lnLeft, ;
		        m.lnDpiCoef * m.lnTop)
		        
		    m.loHPDF.HPDF_Page_LineTo(m.lnHPDF_Page, ;
		        m.lnDpiCoef * (m.lnLeft + m.lnWidth), ;
		        m.lnDpiCoef * m.lnTop)
		
		        
		ELSE
		    * Vertical line
		    m.loHPDF.HPDF_Page_MoveTo(m.lnHPDF_Page, ;
		        m.lnDpiCoef * m.lnLeft, ;
		        m.lnDpiCoef * (m.lnTop - m.lnHeight)) 
		        
		    m.loHPDF.HPDF_Page_LineTo(m.lnHPDF_Page, ;
		        m.lnDpiCoef * m.lnLeft, ;
		        m.lnDpiCoef * m.lnTop)
		ENDIF
		
		
		m.loHPDF.HPDF_Page_Stroke(m.lnHPDF_Page)
		    
		m.loHPDF.HPDF_Page_GRestore(m.lnHPDF_Page)
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxpicture
		LPARAMETERS loRepObj
		
		LOCAL loHPDF, loHPDFC
		m.loHPDF = This.env.API_HPDF
		m.loHPDFC = m.loHPDF.CONST
		
		
		LOCAL lnHPDF_Page
		m.lnHPDF_Page = This.hpdf_pages[This.hpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL lcTempFileName
		m.lcTempFileName = This.env.GetUniqueTempFileName("png")
		
		LOCAL lcTempFileName2
		m.lcTempFileName2 = This.env.GetUniqueTempFileName("png")
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    LOCAL loImage
		    m.loImage = .F.
		
		    DO CASE
		    CASE EMPTY(m.loRepObj.GDIPlusImage)=.F.
		        
		        m.loImage = This.env.System.Drawing.Bitmap.FromHbitmap(m.loRepObj.GDIPlusImage)
		       
		    CASE EMPTY(m.loRepObj.FileName) = .F.
		    
		        LOCAL lcFileData
		        m.lcFileData = This.utils.ExtractFile(m.loRepObj.FileName)
		        
		        IF EMPTY(m.lcFileData)
		            ERROR 1, m.loRepObj.FileName
		        ENDIF
		
		        * GDIPlusX xfcMemoryStream has the error in xfcMemoryStream.capacity_assign ("MemoryStream is not expandable")
		        * Error occurs when xfcMemoryStream.Handle is accessed
		        * That's why stream was changed to file 
		*!*            loImage = This.env.System.Drawing.Bitmap.FromVarBinary(lcFileData)
		                
		        This.utils.StrToFile(m.lcFileData, m.lcTempFileName2)
		        m.loImage = This.env.System.Drawing.Bitmap.FromFile(m.lcTempFileName2)
		                
		        m.lcFileData = ""
		
		    ENDCASE
		       
		    IF VARTYPE(m.loImage) <> "O"
		        EXIT
		    ENDIF
		
		
		    **************************************************
		    * Image scaling
		    **************************************************
		    LOCAL lnImgWidth, lnImgHeight
		    STORE 0 TO m.lnImgWidth, m.lnImgHeight
		
		    DO CASE
		    CASE m.loRepObj.General = 0 && Crop
		        m.lnImgWidth = MIN(m.loImage.Width, m.loRepObj.Width)
		        m.lnImgHeight = MIN(m.loImage.Height, m.loRepObj.Height)
		        
		    CASE m.loRepObj.General = 1 && Scale Keep shape
		        LOCAL lnScale
		        m.lnScale = MIN(m.loRepObj.Width / EVL(m.loImage.Width,1), m.loRepObj.Height / EVL(m.loImage.Height,1))
		
		        m.lnImgWidth = m.loImage.Width * m.lnScale
		        m.lnImgHeight = m.loImage.Height * m.lnScale
		
		    OTHERWISE && Scale Stretch
		        m.lnImgWidth = m.loRepObj.Width
		        m.lnImgHeight = m.loRepObj.Height
		
		    ENDCASE
		
		
		    **************************************************
		    * Image compression
		    **************************************************
		    LOCAL loImageScaled, loGfxScaled
		    m.loImageScaled = This.env.System.Drawing.Bitmap.New(m.lnImgWidth, m.lnImgHeight, m.loImage.PixelFormat)
		
		    m.loGfxScaled = This.env.System.Drawing.Graphics.New()
		    m.loGfxScaled = m.loGfxScaled.FromImage(m.loImageScaled)
		
		    DO CASE
		    CASE m.loRepObj.General = 0 && Crop
		        m.loGfxScaled.DrawImageUnscaled(m.loImage, 0, 0, m.lnImgWidth, m.lnImgHeight)
		        m.loImage = m.loImageScaled
		        
		    CASE m.loImage.Width * m.loImage.Height > m.lnImgWidth * m.lnImgHeight && Scale and compress
		        m.loGfxScaled.DrawImage(m.loImage, 0, 0, m.lnImgWidth, m.lnImgHeight)
		        m.loImage = m.loImageScaled
		        
		    ENDCASE
		
		    m.loGfxScaled = .F.
		    m.loImageScaled = .F.
		
		
		    m.loImage.Save(m.lcTempFileName, This.env.System.Drawing.Imaging.ImageFormat.Png)
		    m.loImage = .F.
		
		
		    **************************************************
		    * Draw image
		    **************************************************
		    LOCAL lnHPDF_Image
		    m.lnHPDF_Image = 0
		    
		    IF FILE(m.lcTempFileName, 1)
		        m.lnHPDF_Image = m.loHPDF.HPDF_LoadPngImageFromFile(This.hpdf_doc, m.lcTempFileName)
		    ENDIF
		
		    IF EMPTY(m.lnHPDF_Image)
		        EXIT
		    ENDIF
		    
		
		    m.loHPDF.HPDF_Page_GSave(m.lnHPDF_Page)
		    
		    LOCAL lnRad
		    m.lnRad = -m.loRepObj.Rotate * PI() / 180
		    
		    m.loHPDF.HPDF_Page_Concat(;
		        m.lnHPDF_Page, ;
		        m.lnDpiCoef * MAX(m.lnImgWidth,1) * COS(m.lnRad), ;
		        m.lnDpiCoef * MAX(m.lnImgWidth,1) * SIN(m.lnRad), ;
		        m.lnDpiCoef * MAX(m.lnImgHeight,1) * -SIN(m.lnRad), ;
		        m.lnDpiCoef * MAX(m.lnImgHeight,1) * COS(m.lnRad), ;
		        m.lnDpiCoef * (m.loRepObj.Left + SIN(m.lnRad) * m.lnImgHeight), ;
		        m.lnDpiCoef * (m.loRepObj.TopRev - COS(m.lnRad) * m.lnImgHeight))
		
		    m.loHPDF.HPDF_Page_ExecuteXObject(m.lnHPDF_Page, m.lnHPDF_Image)
		    
		    m.loHPDF.HPDF_Page_GRestore(m.lnHPDF_Page)
		    
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		FINALLY
		
		    IF FILE(m.lcTempFileName,1)
		        DELETE FILE (m.lcTempFileName)
		    ENDIF
		
		    IF FILE(m.lcTempFileName2,1)
		        DELETE FILE (m.lcTempFileName2)
		    ENDIF
		    
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE render_frxrectangle
		LPARAMETERS loRepObj
		
		LOCAL loHPDF, loHPDFC
		m.loHPDF = This.env.API_HPDF
		m.loHPDFC = m.loHPDF.CONST
		
		
		LOCAL lnHPDF_Page
		m.lnHPDF_Page = This.hpdf_pages[This.hpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		m.loHPDF.HPDF_Page_GSave(m.lnHPDF_Page)
		
		LOCAL lnLineWidth
		IF m.loRepObj.PenPat >= 1
		    m.lnLineWidth = MAX(m.loRepObj.PenSize, 0.5) * m.lnDpiCoef
		ELSE
		    m.lnLineWidth = 0
		ENDIF
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = m.loRepObj.Left + m.loRepObj.PenSize * 0.5
		m.lnTop = m.loRepObj.TopRev - m.loRepObj.PenSize * 0.5
		m.lnWidth = m.loRepObj.Width - m.loRepObj.PenSize
		m.lnHeight = m.loRepObj.Height - m.loRepObj.PenSize
		
		IF EMPTY(m.loRepObj.Rotate) = .F.
		    LOCAL lnRad
		    m.lnRad = -m.loRepObj.Rotate * PI() / 180
		
		    m.loHPDF.HPDF_Page_Concat(;
		        m.lnHPDF_Page, ;
		        COS(m.lnRad), ;
		        SIN(m.lnRad), ;
		        -SIN(m.lnRad), ;
		        COS(m.lnRad), ;
		        m.lnDpiCoef * m.lnLeft, ;
		        m.lnDpiCoef * m.lnTop)
		        
		    m.lnLeft = 0
		    m.lnTop = 0
		ENDIF
		
		
		m.loHPDF.HPDF_Page_SetRGBFill(m.lnHPDF_Page, m.loRepObj.FillRed / 255, m.loRepObj.FillGreen / 255, m.loRepObj.FillBlue / 255)
		m.loHPDF.HPDF_Page_SetRGBStroke(m.lnHPDF_Page, m.loRepObj.PenRed / 255, m.loRepObj.PenGreen / 255, m.loRepObj.PenBlue / 255)
		
		m.loHPDF.HPDF_Page_SetLineWidth(m.lnHPDF_Page,  m.lnLineWidth)
		
		*******************************************************
		LOCAL lcDash
		DO CASE
		CASE m.loRepObj.PenPat = 8 && Normal
		    m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, NULL, 0, 0)
		
		CASE m.loRepObj.PenPat = 1 && Dot
		    m.lcDash = BINTOC(1, "F")
		    m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, @m.lcDash, 1, 1)
		    
		CASE m.loRepObj.PenPat = 2 && Dash
		    m.lcDash = BINTOC(6, "F") + BINTOC(6, "F")
		    m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, @m.lcDash, 2, 2)
		    
		CASE m.loRepObj.PenPat = 3 && Dash-dot
		    m.lcDash = BINTOC(6, "F") + BINTOC(6, "F") + BINTOC(1, "F") + BINTOC(6, "F")
		    m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, @m.lcDash, 4, 0)
		    
		CASE m.loRepObj.PenPat = 4 && Dash-dot-dot
		    m.lcDash = BINTOC(6, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F")
		    m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, @m.lcDash, 6, 0)
		
		OTHERWISE && Normal
		    m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, NULL, 0, 0)
		
		ENDCASE
		*******************************************************
		
		
		
		DO CASE
		CASE m.loRepObj.OffSet = 0 && Normal rectangle
		
		    m.loHPDF.HPDF_Page_Rectangle(m.lnHPDF_Page, ;
		        m.lnDpiCoef * (m.lnLeft), ;
		        m.lnDpiCoef * (m.lnTop - m.lnHeight), ;
		        m.lnDpiCoef * (m.lnWidth), ;
		        m.lnDpiCoef * (m.lnHeight))
		    
		
		CASE BETWEEN(m.loRepObj.OffSet, 1, 98) AND m.loRepObj.OffSet <= MAX(m.lnWidth, m.lnHeight)/2  && Rounded rectangle
		    LOCAL lnRay
		    m.lnRay = ROUND(IIF(m.lnWidth > m.lnHeight, MIN(m.loRepObj.OffSet, INT(m.lnHeight / 2)), MIN(m.loRepObj.OffSet, INT(m.lnWidth / 2))), 0)
		    
		    LOCAL lnRight, lnBottom
		    IF EMPTY(m.loRepObj.Rotate) = .F.
		        m.lnRight = m.lnDpiCoef * m.lnWidth
		        m.lnBottom = m.lnDpiCoef * -m.lnHeight
		        m.lnLeft = m.lnDpiCoef * m.lnLeft
		        m.lnTop = m.lnDpiCoef * m.lnTop
		    ELSE
		        m.lnRight = m.lnDpiCoef * (m.lnLeft + m.lnWidth)
		        m.lnBottom = m.lnDpiCoef * (m.lnTop - m.lnHeight)
		        m.lnLeft = m.lnDpiCoef * m.lnLeft
		        m.lnTop = m.lnDpiCoef * m.lnTop
		    ENDIF
		
		    
		    m.loHPDF.HPDF_Page_MoveTo(m.lnHPDF_Page, m.lnLeft + m.lnRay, m.lnBottom)
		    m.loHPDF.HPDF_Page_LineTo(m.lnHPDF_Page, m.lnRight - m.lnRay, m.lnBottom)
		    m.loHPDF.HPDF_Page_CurveTo(m.lnHPDF_Page, m.lnRight, m.lnBottom, m.lnRight, m.lnBottom, m.lnRight, m.lnBottom + m.lnRay) 
		    m.loHPDF.HPDF_Page_LineTo(m.lnHPDF_Page, m.lnRight, m.lnTop - m.lnRay)
		    m.loHPDF.HPDF_Page_CurveTo(m.lnHPDF_Page, m.lnRight, m.lnTop, m.lnRight, m.lnTop, m.lnRight - m.lnRay, m.lnTop)
		    m.loHPDF.HPDF_Page_LineTo(m.lnHPDF_Page, m.lnLeft + m.lnRay, m.lnTop)
		    m.loHPDF.HPDF_Page_CurveTo(m.lnHPDF_Page, m.lnLeft, m.lnTop, m.lnLeft, m.lnTop, m.lnLeft, m.lnTop - m.lnRay)
		    m.loHPDF.HPDF_Page_LineTo(m.lnHPDF_Page, m.lnLeft , m.lnBottom + m.lnRay)
		    m.loHPDF.HPDF_Page_CurveTo(m.lnHPDF_Page, m.lnLeft, m.lnBottom, m.lnLeft, m.lnBottom, m.lnLeft + m.lnRay, m.lnBottom)
		
		OTHERWISE && Ellipsis
		
		    m.loHPDF.HPDF_Page_Ellipse(m.lnHPDF_Page, ;
		        m.lnDpiCoef * (m.lnLeft + m.lnWidth / 2), ;
		        m.lnDpiCoef * (m.lnTop - m.lnHeight / 2), ;
		        m.lnDpiCoef * (m.lnWidth / 2), ;
		        m.lnDpiCoef * (m.lnHeight / 2))
		
		ENDCASE
		
		DO CASE
		CASE m.loRepObj.Mode = 0 AND m.loRepObj.FillPat > 0 AND m.loRepObj.PenPat = 0
		    m.loHPDF.HPDF_Page_Fill(m.lnHPDF_Page)
		CASE m.loRepObj.Mode = 0 AND m.loRepObj.FillPat > 0
		    m.loHPDF.HPDF_Page_FillStroke(m.lnHPDF_Page)
		
		OTHERWISE 
		    m.loHPDF.HPDF_Page_Stroke(m.lnHPDF_Page)
		
		ENDCASE
		
		m.loHPDF.HPDF_Page_GRestore(m.lnHPDF_Page)
		
	ENDPROC

	HIDDEN PROCEDURE render_text
		LPARAMETERS loRepObj
		
		#define FRX_OBJ_LABEL       5
		
		LOCAL loHPDF, loHPDFC
		m.loHPDF = This.env.API_HPDF
		m.loHPDFC = m.loHPDF.CONST
		
		
		LOCAL lnHPDF_Page
		m.lnHPDF_Page = This.hpdf_pages[This.hpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		LOCAL loGDIFont
		m.loGDIFont = This.GetFontGDI(m.loRepObj)
		
		LOCAL loPDFFont
		m.loPDFFont = This.GetFontPDF(m.loRepObj)
		
		IF VARTYPE(m.loPDFFont) <> "O"
		    This.Render_TextAsImage(m.loRepObj)
		    RETURN
		ENDIF
		
		IF EMPTY(m.loRepObj.Rotate)=.F.
		    This.Render_TextAsImage(m.loRepObj)
		    RETURN
		ENDIF
		
		*******************************************************
		* Background mode 0 - Opaque, 1 - Transparent
		IF m.loRepObj.Mode = 0 
		    m.loHPDF.HPDF_Page_GSave(m.lnHPDF_Page)
		
		    IF m.loRepObj.FillAlpha <> 255
		        LOCAL lnExtGState
		        m.lnExtGState = m.loHPDF.HPDF_CreateExtGState(This.hpdf_doc)
		        IF m.lnExtGState <> 0
		            m.loHPDF.HPDF_ExtGState_SetAlphaFill(m.lnExtGState, m.loRepObj.FillAlpha / 255)
		            m.loHPDF.HPDF_Page_SetExtGState(m.lnHPDF_Page, m.lnExtGState)
		        ENDIF
		    ENDIF
		    
		    m.loHPDF.HPDF_Page_SetRGBFill(m.lnHPDF_Page, m.loRepObj.FillRed / 255, m.loRepObj.FillGreen / 255, m.loRepObj.FillBlue / 255)
		
		    m.loHPDF.HPDF_Page_Rectangle(m.lnHPDF_Page, ;
		        m.lnDpiCoef * m.loRepObj.Left, ;
		        m.lnDpiCoef * (m.loRepObj.TopRev - m.loRepObj.Height), ;
		        m.lnDpiCoef * m.loRepObj.Width, ;
		        m.lnDpiCoef * m.loRepObj.Height)
		        
		    m.loHPDF.HPDF_Page_Fill(m.lnHPDF_Page)
		
		    m.loHPDF.HPDF_Page_GRestore(m.lnHPDF_Page)
		ENDIF
		*******************************************************
		
		
		m.loHPDF.HPDF_Page_GSave(m.lnHPDF_Page)
		
		IF m.loRepObj.PenAlpha <> 255
		    LOCAL lnExtGState
		    m.lnExtGState = m.loHPDF.HPDF_CreateExtGState(This.hpdf_doc)
		    IF m.lnExtGState <> 0
		        m.loHPDF.HPDF_ExtGState_SetAlphaFill(m.lnExtGState, m.loRepObj.PenAlpha / 255)
		        m.loHPDF.HPDF_ExtGState_SetAlphaStroke(m.lnExtGState, m.loRepObj.PenAlpha / 255)
		        m.loHPDF.HPDF_Page_SetExtGState(m.lnHPDF_Page, m.lnExtGState)
		    ENDIF
		ENDIF
		
		
		m.loHPDF.HPDF_Page_SetFontAndSize(m.lnHPDF_Page, m.loPDFFont.FontHandle, m.loRepObj.FontSize)
		m.loHPDF.HPDF_Page_SetRGBFill(m.lnHPDF_Page, m.loRepObj.PenRed / 255, m.loRepObj.PenGreen / 255, m.loRepObj.PenBlue / 255)
		m.loHPDF.HPDF_Page_SetRGBStroke(m.lnHPDF_Page, m.loRepObj.PenRed / 255, m.loRepObj.PenGreen / 255, m.loRepObj.PenBlue / 255)
		m.loHPDF.HPDF_Page_SetLineWidth(m.lnHPDF_Page, 0.5)
		m.loHPDF.HPDF_Page_SetDash(m.lnHPDF_Page, NULL, 0, 0)
		
		
		IF m.loRepObj.ObjType = FRX_OBJ_LABEL
		    m.loRepObj.Width = m.loRepObj.Width + m.loGDIFont.HeightCeil * 2
		ENDIF
		
		*******************************************************
		LOCAL loLineRect
		m.loLineRect = This.env.system.Drawing.RectangleF.New(0, 0, m.loRepObj.Width, m.loGDIFont.HeightCeil)
		
		LOCAL lnLineHeight
		m.lnLineHeight = m.loGDIFont.Height
		
		LOCAL lnFontDescent
		m.lnFontDescent = m.lnLineHeight * m.loGDIFont.CellDescent / m.loGDIFont.EmHeight
		
		LOCAL lnFontAscent
		m.lnFontAscent = m.lnLineHeight * m.loGDIFont.CellAscent / m.loGDIFont.EmHeight
		
		LOCAL lnAlign
		m.lnAlign = ICASE(m.loRepObj.Offset = 0, m.loHPDFC.HPDF_TALIGN_LEFT(), m.loRepObj.Offset = 1, m.loHPDFC.HPDF_TALIGN_RIGHT(), m.loRepObj.Offset = 2, m.loHPDFC.HPDF_TALIGN_CENTER(), m.loHPDFC.HPDF_TALIGN_LEFT())
		
		LOCAL lnPadX, lnPadY
		m.lnPadX = ICASE(m.lnAlign = m.loHPDFC.HPDF_TALIGN_RIGHT(), -1, m.lnAlign = m.loHPDFC.HPDF_TALIGN_LEFT(), 1, 0) * 2
		m.lnPadY = 2
		
		*******************************************************
		
		
		LOCAL lnLine, lnCharIndex, lnLineCharsFitted, lcLineText, lcLineTextUTF
		m.lnLine = 0
		m.lnCharIndex = 1
		DO WHILE .T.
		
		    m.lnLine = m.lnLine + 1
		    
		    IF m.lnLine * m.lnLineHeight > m.loRepObj.Height
		        EXIT
		    ENDIF
		
		    
		    m.lcLineText = SUBSTR(m.loRepObj.Text, m.lnCharIndex * 2 - 1)
		
		    m.lnLineCharsFitted = 0
		
		    LOCAL loLineTextRect
		    This.MeasureString(m.lcLineText, m.loGDIFont, m.loLineRect, @m.loLineTextRect, @m.lnLineCharsFitted)
		    
		    m.lcLineText = SUBSTR(m.lcLineText, 1, m.lnLineCharsFitted * 2)
		    m.lcLineTextUTF = STRCONV(m.lcLineText, 10)
		    
		    m.lnCharIndex = m.lnCharIndex + m.lnLineCharsFitted
		    
		    
		    m.loHPDF.HPDF_Page_BeginText(m.lnHPDF_Page)
		
		        m.loHPDF.HPDF_Page_SetTextRenderingMode(m.lnHPDF_Page, m.loHPDFC.HPDF_FILL())
		        m.loHPDF.HPDF_Page_SetTextMatrix(m.lnHPDF_Page, 1, 0, 0, 1, 0, 0)
		
		
		        IF m.loRepObj.FontBold AND m.loPDFFont.FontBold = .F.
		            m.loHPDF.HPDF_Page_SetTextRenderingMode(m.lnHPDF_Page, m.loHPDFC.HPDF_FILL_THEN_STROKE()) && Bold imitation
		        ENDIF
		
		        LOCAL llFakeItalic
		        m.llFakeItalic = m.loRepObj.FontItalic AND m.loPDFFont.FontItalic = .F.
		        IF m.llFakeItalic
		            m.loHPDF.HPDF_Page_SetTextMatrix(m.lnHPDF_Page, 1, 0, 0.3333, 1, 0, 0) && Italic imitation
		        ENDIF
		
		        m.loHPDF.HPDF_Page_SetTextLeading(m.lnHPDF_Page, 0) && reset line spacing
		        
		        m.loHPDF.HPDF_Page_TextRect(m.lnHPDF_Page, ;
		            m.lnDpiCoef * (m.loRepObj.Left + m.lnPadX) + IIF(m.llFakeItalic, m.loRepObj.FontSize * 0.5, 0), ;
		            m.lnDpiCoef * (m.loRepObj.TopRev - (m.lnLine-1) * m.lnLineHeight + m.lnFontDescent - m.lnPadY), ;
		            m.lnDpiCoef * (m.loRepObj.Left + m.loRepObj.Width + m.lnPadX) + IIF(m.llFakeItalic, m.loRepObj.FontSize * 0.5, 0), ;
		            m.lnDpiCoef * (m.loRepObj.TopRev - m.lnLine * m.lnLineHeight - m.lnPadY), ;
		            m.lcLineTextUTF + CHR(0), ;
		            m.lnAlign, ;
		            0)
		    
		    m.loHPDF.HPDF_Page_EndText(m.lnHPDF_Page)
		
		    
		    LOCAL lnStrokeLeft
		    m.lnStrokeLeft = ICASE(m.lnAlign=m.loHPDFC.HPDF_TALIGN_RIGHT(), m.loRepObj.Width - m.loLineTextRect.Width, m.lnAlign=m.loHPDFC.HPDF_TALIGN_CENTER(), 0.5 * (m.loRepObj.Width - m.loLineTextRect.Width), 0)
		    
		    IF m.loRepObj.FontUnderline
		        m.loHPDF.HPDF_Page_MoveTo(m.lnHPDF_Page, ;
		            m.lnDpiCoef * (m.loRepObj.Left + m.lnStrokeLeft + m.lnPadX), ;
		            m.lnDpiCoef * (m.loRepObj.TopRev - m.lnLine * m.lnLineHeight + m.lnFontDescent - m.lnPadY))
		        
		        m.loHPDF.HPDF_Page_LineTo(m.lnHPDF_Page, ;
		            m.lnDpiCoef * (m.loRepObj.Left + m.lnStrokeLeft + m.loLineTextRect.Width + m.lnPadX), ;
		            m.lnDpiCoef * (m.loRepObj.TopRev - m.lnLine * m.lnLineHeight + m.lnFontDescent - m.lnPadY))
		        
		        m.loHPDF.HPDF_Page_Stroke(m.lnHPDF_Page)
		    ENDIF
		
		    IF m.loRepObj.FontStrikeout
		        m.loHPDF.HPDF_Page_MoveTo(m.lnHPDF_Page, ;
		            m.lnDpiCoef * (m.loRepObj.Left + m.lnStrokeLeft + m.lnPadX), ;
		            m.lnDpiCoef * (m.loRepObj.TopRev - m.lnLine * m.lnLineHeight + (m.lnFontDescent + m.lnFontAscent) * 0.5 -  m.lnPadY))
		        
		        m.loHPDF.HPDF_Page_LineTo(m.lnHPDF_Page, ;
		            m.lnDpiCoef * (m.loRepObj.Left + m.lnStrokeLeft + m.loLineTextRect.Width + m.lnPadX), ;
		            m.lnDpiCoef * (m.loRepObj.TopRev - m.lnLine * m.lnLineHeight + (m.lnFontDescent + m.lnFontAscent) * 0.5 -  m.lnPadY))
		        
		        m.loHPDF.HPDF_Page_Stroke(m.lnHPDF_Page)
		    ENDIF
		    
		ENDDO
		
		m.loHPDF.HPDF_Page_GRestore(m.lnHPDF_Page)
		
	ENDPROC

	HIDDEN PROCEDURE render_textasimage		&& Fallback rendering text as images (case of symbolic and non ttf fonts)
		LPARAMETERS loRepObj
		
		#define FRX_OBJ_LABEL       5
		
		LOCAL loHPDF, loHPDFC
		m.loHPDF = This.env.API_HPDF
		m.loHPDFC = m.loHPDF.CONST
		
		
		LOCAL lnHPDF_Page
		m.lnHPDF_Page = This.hpdf_pages[This.hpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL loGDIFont
		m.loGDIFont = This.GetFontGDI(m.loRepObj)
		
		
		LOCAL lcTempFileName
		m.lcTempFileName = This.env.GetUniqueTempFileName("png")
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    IF m.loRepObj.ObjType = FRX_OBJ_LABEL
		        m.loRepObj.Width = m.loRepObj.Width + m.loGDIFont.HeightCeil
		    ENDIF
		
		    LOCAL loImage, loGfx, loColor, loBrush
		    m.loImage = This.env.System.Drawing.Bitmap.New(m.loRepObj.Width, m.loRepObj.Height, This.env.System.Drawing.Imaging.PixelFormat.Format32bppARGB)
		    m.loGfx = This.env.System.Drawing.Graphics.New()
		    m.loGfx = m.loGfx.FromImage(m.loImage)
		    m.loGfx.CompositingMode = 0
		    m.loGfx.CompositingQuality = 2
		    m.loGfx.PixelOffsetMode = 2
		    m.loGfx.TextRenderingHint = 4
		    m.loGfx.TextContrast = 0    
		    
		    
		    *******************************************************
		    * Background mode 0 - Opaque, 1 - Transparent
		    IF m.loRepObj.Mode = 0
		        m.loColor = This.env.System.Drawing.Color.FromARGB(m.loRepObj.FillAlpha, m.loRepObj.FillRed, m.loRepObj.FillGreen, m.loRepObj.FillBlue)
		        m.loBrush = This.env.System.Drawing.SolidBrush.New(m.loColor)
		        m.loGfx.FillRectangle(m.loBrush, 0, 0, m.loRepObj.Width, m.loRepObj.Height)
		    ENDIF
		    *******************************************************
		    
		    m.loColor = This.env.System.Drawing.Color.FromARGB(m.loRepObj.PenAlpha, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue)
		    m.loBrush = This.env.System.Drawing.SolidBrush.New(m.loColor)
		
		    LOCAL lqLayoutRect
		    m.lqLayoutRect = BINTOC(0,"F")+BINTOC(0,"F")+BINTOC(0,"F")+BINTOC(0,"F")
		    
		    * Plain Api call because GDIPluxX Graphics.DrawString performs STRCONV(...,5) on input text while loRepObj.Text is in Unicode
		    This.env.API_WIN.GdipDrawString(;
		        m.loGfx.Handle, ;
		        m.loRepObj.Text + CHR(0), ;
		        LEN(m.loRepObj.Text) / 2, ;
		        m.loGDIFont.GDIFont.Handle, ;
		        @m.lqLayoutRect, ;
		        This.env.System.Drawing.StringFormat.GenericDefault.Handle, ;
		        m.loBrush.Handle)
		    
		
		    m.loImage.Save(m.lcTempFileName, This.env.System.Drawing.Imaging.ImageFormat.Png)
		    m.loImage = .F.
		
		    LOCAL lnHPDF_Image
		    m.lnHPDF_Image = 0
		
		    IF FILE(m.lcTempFileName, 1)
		        m.lnHPDF_Image = m.loHPDF.HPDF_LoadPngImageFromFile(This.hpdf_doc, m.lcTempFileName)
		    ENDIF
		
		    IF EMPTY(m.lnHPDF_Image)
		        EXIT
		    ENDIF
		
		
		    m.loHPDF.HPDF_Page_GSave(m.lnHPDF_Page)
		    
		    LOCAL lnRad
		    m.lnRad = -m.loRepObj.Rotate * PI() / 180
		    
		    m.loHPDF.HPDF_Page_Concat(;
		        m.lnHPDF_Page, ;
		        m.lnDpiCoef * MAX(m.loRepObj.Width,1) * COS(m.lnRad), ;
		        m.lnDpiCoef * MAX(m.loRepObj.Width,1) * SIN(m.lnRad), ;
		        m.lnDpiCoef * MAX(m.loRepObj.Height,1) * -SIN(m.lnRad), ;
		        m.lnDpiCoef * MAX(m.loRepObj.Height,1) * COS(m.lnRad), ;
		        m.lnDpiCoef * (m.loRepObj.Left + SIN(m.lnRad) * m.loRepObj.Height), ;
		        m.lnDpiCoef * (m.loRepObj.TopRev - COS(m.lnRad) * m.loRepObj.Height))
		
		    m.loHPDF.HPDF_Page_ExecuteXObject(m.lnHPDF_Page, m.lnHPDF_Image)
		    
		    m.loHPDF.HPDF_Page_GRestore(m.lnHPDF_Page)
		    
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		FINALLY
		    IF FILE(m.lcTempFileName,1)
		        DELETE FILE (m.lcTempFileName)
		    ENDIF
		ENDTRY
		
		
	ENDPROC

	PROCEDURE saveas_pdfmeta_access
		
		IF VARTYPE(This._SaveAs_PDFMeta) <> "O"
		    This._SaveAs_PDFMeta = NEWOBJECT("pdfium_pdfmeta", This.ClassLibrary)
		ENDIF
		
		RETURN This._SaveAs_PDFMeta
		
	ENDPROC

	PROCEDURE saveas_pdfmeta_assign
		LPARAMETERS vNewVal
		
		ERROR 1740, TEXTMERGE("<<This.Class>>.SaveAs_PDFMeta")
		
	ENDPROC

	PROCEDURE UnloadReport
		
		IF This.BatchModeAuto = .F. AND This.BatchMode = .F.
		    This.Finalize()
		ENDIF
		
		This.env.FoxEnv_Restore()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreportviewer AS form 		&& Report preview for PdfiumReport. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="PdfiumViewer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSaveAs" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFitWidth" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFitPage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmbScale" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPageInfo" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: close		&& Close preview window
		*m: openpdf		&& Open pdf file
		*m: printreport		&& Print report
		*m: scalechanged		&& Scale change handling
		*m: setreport		&& ReportPreviewer interface requirement (reead docs on ReportPreviewer, ReportListener)
		*p: listenerref
		*p: saveas_filename		&& Filename suggestion for "save as" dialog
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN listenerref
	*<PropValue>
		Caption = "Pdfium report preview"
		Desktop = .F.
		DoCreate = .T.
		Height = 741
		Icon = ("images\wwrite.ico")
		KeyPreview = .T.
		Left = 0
		listenerref = .F.
		MaxButton = .T.
		MinButton = .F.
		Name = "pdfiumreportviewer"
		saveas_filename = ("")
		ScrollBars = 0
		ShowWindow = 1
		Top = 0
		Visible = .T.
		Width = 747
		WindowState = 0
		WindowType = 0
		_memberdata = <VFPData>
			<memberdata name="openpdf" type="method" display="OpenPDF"/>
			<memberdata name="setreport" type="method" display="SetReport"/>
			<memberdata name="listenerref" type="property" display="ListenerRef"/>
			<memberdata name="printreport" type="method" display="PrintReport"/>
			<memberdata name="close" type="method" display="Close"/>
			<memberdata name="scalechanged" type="method" display="ScaleChanged"/>
			<memberdata name="saveas_filename" type="property" display="SaveAs_Filename"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cmbScale' AS combobox WITH ;
		BoundColumn = 1, ;
		BoundTo = .F., ;
		ColumnCount = 1, ;
		ColumnLines = .F., ;
		ColumnWidths = "80,0", ;
		ControlSource = "", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 27, ;
		Left = 534, ;
		Name = "cmbScale", ;
		Style = 2, ;
		TabIndex = 8, ;
		TabStop = .F., ;
		Top = 11, ;
		Width = 65
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdClose' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 685, ;
		Name = "cmdClose", ;
		Picture = (NVL(EVL(JUSTPATH(Thisform.ClassLibrary),NULL)+"\images\close.bmp","")), ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 9, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFitPage' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 483, ;
		Name = "cmdFitPage", ;
		Picture = (NVL(EVL(JUSTPATH(Thisform.ClassLibrary),NULL)+"\images\fitpage.bmp","")), ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 7, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFitWidth' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 437, ;
		Name = "cmdFitWidth", ;
		Picture = (NVL(EVL(JUSTPATH(Thisform.ClassLibrary),NULL)+"\images\fitwidth.bmp","")), ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 6, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrint' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "  Print", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 237, ;
		Name = "cmdPrint", ;
		Picture = (NVL(EVL(JUSTPATH(Thisform.ClassLibrary),NULL)+"\images\print.bmp","")), ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 4, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 135
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSaveAs' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 384, ;
		Name = "cmdSaveAs", ;
		Picture = (NVL(EVL(JUSTPATH(Thisform.ClassLibrary),NULL)+"\images\saveas.bmp","")), ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 5, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSearch' AS commandbutton WITH ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 189, ;
		Name = "cmdSearch", ;
		Picture = (NVL(EVL(JUSTPATH(Thisform.ClassLibrary),NULL)+"\images\search.bmp","")), ;
		PictureMargin = 0, ;
		PicturePosition = 14, ;
		PictureSpacing = 0, ;
		TabIndex = 3, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 192, ;
		Name = "i18n", ;
		Top = 72, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'lblPageInfo' AS label WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "1234 / 1234", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 603, ;
		Name = "lblPageInfo", ;
		Top = 15, ;
		Width = 76
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'PdfiumViewer' AS pdfiumviewer WITH ;
		Anchor = 15, ;
		Enabled = .T., ;
		Height = 681, ;
		Left = 12, ;
		Name = "PdfiumViewer", ;
		scrollbars = 3, ;
		TabIndex = 1, ;
		TabStop = .T., ;
		Top = 48, ;
		Visible = .T., ;
		Width = 723, ;
		cmdFocus.Name = "cmdFocus", ;
		env.API_FPDF.CONST.Name = "CONST", ;
		env.API_FPDF.Name = "API_FPDF", ;
		env.API_HPDF.CONST.Name = "CONST", ;
		env.API_HPDF.Name = "API_HPDF", ;
		env.API_WIN.Name = "API_WIN", ;
		env.Name = "env", ;
		i18n.API_WIN.Name = "API_WIN", ;
		i18n.Name = "i18n", ;
		UIState.Name = "UIState"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="control" />

	ADD OBJECT 'txtSearch' AS pdfium_textbox WITH ;
		Anchor = 0, ;
		InputMask = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", ;
		Left = 12, ;
		Name = "txtSearch", ;
		TabIndex = 2, ;
		TabStop = .F., ;
		Top = 11
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />
	
	PROCEDURE close		&& Close preview window
		IF VARTYPE(This.ListenerRef)="O"
		    This.ListenerRef.OnPreviewClose()
		    This.ListenerRef = .F.
		ENDIF
		
		This.Hide()
		
	ENDPROC

	PROCEDURE Destroy
		This.Pdfiumviewer.Destroy()
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp, toPrintEnv as Pdfium_print_env of pdfium-vfp.vcx
		
		This.Pdfiumviewer.Init(m.toEnv)
		
		This.Pdfiumviewer.PrintEnv.Setup(m.toPrintEnv)
		
		
		BINDEVENT(This.PdfiumViewer, "scale", This, "scalechanged", 1)
		
		This.Caption = This.i18n.text("REPORTVIEWER_TITLE")
		
		This.MinWidth = This.Width
		This.MinHeight = 300
		
		
		LOCAL loTopLevelForm
		IF TYPE("Application.ActiveForm") = "O"
		    m.loTopLevelForm = Application.ActiveForm
		ELSE
		    m.loTopLevelForm = _SCREEN    
		ENDIF
		
		IF m.loTopLevelForm.ShowWindow <> 2
		    m.loTopLevelForm = _SCREEN
		ENDIF
		
		
		IF m.loTopLevelForm = _SCREEN
		    LOCAL lnTop, lnBottom
		    m.lnTop = 0
		    m.lnBottom = m.loTopLevelForm.Height
		
		
		    LOCAL i, loForm
		    FOR m.i = 1 TO m.loTopLevelForm.FormCount
		        m.loForm = m.loTopLevelForm.Forms[m.i]
		        
		        IF m.loForm = Thisform
		            LOOP
		        ENDIF
		
		        IF m.loForm.DockPosition = 0
		            m.lnTop = MAX(m.lnTop, m.loForm.Top + m.loForm.Height)
		        ENDIF
		
		        IF m.loForm.DockPosition = 3
		            m.lnBottom = MIN(m.lnBottom, m.loForm.Height - laDockState[m.i,6].Top)
		        ENDIF
		        
		    ENDFOR
		
		    This.Width = MAX(MIN(m.loTopLevelForm.Height, m.loTopLevelForm.Width) - SYSMETRIC(3) , This.MinWidth) 
		    This.Height = MAX(MAX(m.lnBottom - m.lnTop, This.Height) - SYSMETRIC(4), This.MinHeight)
		
		ENDIF
		
		This.WindowState = 2
		This.TitleBar = 0
		This.BorderStyle = 0
		
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		DO CASE
		CASE m.nKeyCode = 6 AND m.nShiftAltCtrl = 2 && Ctrl + F
		    NODEFAULT
		    This.txtSearch.SetFocus()
		
		CASE m.nKeyCode = -2 AND m.nShiftAltCtrl = 0 && F3
		    NODEFAULT
		    Thisform.cmdSearch.Click()
		
		ENDCASE
		
	ENDPROC

	PROCEDURE openpdf		&& Open pdf file
		LPARAMETERS tcFilename, tcPassword
		
		RETURN This.pdfiumviewer.OpenPDF(m.tcFilename, m.tcPassword)
		
	ENDPROC

	PROCEDURE printreport		&& Print report
		This.PdfiumViewer.PrintDocument()
		
	ENDPROC

	PROCEDURE QueryUnload
		
		This.Close()
		
		
	ENDPROC

	PROCEDURE Resize
		IF This.ScrollBars > 0 AND Thisform.WindowState = 2
		    This.Cls()
		ENDIF
		This.Refresh()
		
	ENDPROC

	PROCEDURE scalechanged		&& Scale change handling
		LOCAL lnScale, lcScale
		m.lnScale = This.PdfiumViewer.Scale
		m.lcScale = TRANSFORM(INT(m.lnScale*100)) + "%"
		
		IF INLIST(m.lnScale,1,2,3,4)=.F.
		    This.cmbScale.List[1] = m.lcScale
		ELSE
		    This.cmbScale.List[1] = ""
		ENDIF
		
		This.cmbScale.Value = m.lcScale
		
	ENDPROC

	PROCEDURE setreport		&& ReportPreviewer interface requirement (reead docs on ReportPreviewer, ReportListener)
		LPARAMETERS toListenerRef 
		
		This.ListenerRef = m.toListenerRef 
		
	ENDPROC

	PROCEDURE cmbScale.Init
		This.AddItem("")
		This.AddItem("100%")
		This.AddItem("200%")
		This.AddItem("300%")
		This.AddItem("400%")
		
	ENDPROC

	PROCEDURE cmbScale.InteractiveChange
		Thisform.pdfiumviewer.Scale = MIN(MAX(INT(VAL(EVL(This.Value,"100")))/100,0.25),4)
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdClose.Click
		Thisform.Close()
		
		
	ENDPROC

	PROCEDURE cmdFitPage.Click
		Thisform.pdfiumviewer.FitWidth = .F.
		Thisform.pdfiumviewer.Scale = 1
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdFitPage.Refresh
		IF Thisform.pdfiumviewer.FitWidth = .T. and This.Enabled = .F.
		    This.Enabled = .T.
		ENDIF
		
		IF Thisform.pdfiumviewer.FitWidth = .F. and This.Enabled = .T.
		    This.Enabled = .F.
		ENDIF
		
		
	ENDPROC

	PROCEDURE cmdFitWidth.Click
		Thisform.pdfiumviewer.FitWidth = .T.
		Thisform.pdfiumviewer.Scale = 1
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdFitWidth.Refresh
		IF Thisform.pdfiumviewer.FitWidth = .T. and This.Enabled = .T.
		    This.Enabled = .F.
		ENDIF
		
		IF Thisform.pdfiumviewer.FitWidth = .F. and This.Enabled = .F.
		    This.Enabled = .T.
		ENDIF
		
		
	ENDPROC

	PROCEDURE cmdPrint.Click
		Thisform.PrintReport()
		
	ENDPROC

	PROCEDURE cmdPrint.Refresh
		This.Caption = SPACE(2) + Thisform.i18n.text("BTN_PRINT")
		
	ENDPROC

	PROCEDURE cmdSaveAs.Click
		LOCAL lcFilename
		m.lcFilename = PUTFILE("", Thisform.SaveAs_Filename, "pdf")
		
		IF EMPTY(m.lcFilename)
		    RETURN
		ENDIF
		
		Thisform.pdfiumviewer.SaveDocument(m.lcFileName)
		
	ENDPROC

	PROCEDURE cmdSearch.Click
		CLEAR TYPEAHEAD 
		
		IF EMPTY(Thisform.txtSearch.Value)
		    Thisform.pdfiumviewer.SearchClose()
		ELSE
		    LOCAL lnRes
		    m.lnRes = Thisform.Pdfiumviewer.SearchText(Thisform.txtSearch.Value)
		    DO CASE
		    CASE m.lnRes = 0
		        WAIT WINDOW Thisform.i18n.text("SEARCH_NOT_FOUND") NOWAIT
		    CASE m.lnRes = 2
		        WAIT WINDOW Thisform.i18n.text("SEARCH_ENDED") NOWAIT
		    ENDCASE
		    
		ENDIF
		
	ENDPROC

	PROCEDURE lblPageInfo.Refresh
		This.Caption = TRANSFORM(Thisform.PdfiumViewer.GetCurrentPage()) + " / " + TRANSFORM(Thisform.PdfiumViewer.GetPageCount())
		
	ENDPROC

	PROCEDURE PdfiumViewer.afterviewportupdate
		Thisform.lblPageInfo.Refresh()
		
	ENDPROC

	PROCEDURE txtSearch.GotFocus
		Thisform.pdfiumviewer.SearchClose()
		
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE txtSearch.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 13 AND EMPTY(m.nShiftAltCtrl) AND EMPTY(This.Value)=.F.
		    NODEFAULT
		    Thisform.cmdSearch.Click()
		ENDIF    
		
		DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumviewer AS control 		&& PDF viewer control.
 	*< CLASSDATA: Baseclass="control" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdFocus" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="env" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="UIState" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: afterviewportupdate		&& Event. Triggered after ViewPortUpdate call
		*m: backcolor_assign
		*m: closepdf		&& Close pdf file, previously opened by PdfiumViewer.openpdf
		*m: contextmenu
		*m: drawbufcreate
		*m: drawbufrelease
		*m: errmsg
		*m: fitwidth_assign
		*m: getcurrentpage		&& Current page number. First page has number = 1
		*m: getpagecount		&& Returns page count
		*m: getpagesize		&& Returns page dimensions (see comment in source code)
		*m: keypress		&& Occurs when the user presses and releases a key.
		*m: openpdf		&& Open pdf file. Returns: .T. on success, .F. if file was not loaded
		*m: pagepick
		*m: printdocument		&& Send document to printer with preceding setup dialog
		*m: printenv_access
		*m: printenv_assign
		*m: redraw
		*m: renderpagefromcache
		*m: renderpages
		*m: rendersearch
		*m: renderselection
		*m: savedocument		&& Save document to file
		*m: scale_assign
		*m: scrollbars_assign
		*m: scrollhorz
		*m: scrollvert
		*m: searchclose		&& Stop search
		*m: searchtext		&& Text for searching. SearchClose must be called to stop search results rendering
		*m: selectioncopy		&& Copy selected text to clipboard
		*m: selecttext
		*m: selecttextall		&& Select all text in the document
		*m: viewportupdate
		*m: wndcreate
		*m: wndproc		&& Events handler of PdfiumViewer internal window. Developer must not use or redefine this method
		*m: wndredraw
		*m: wndrelease
		*m: wndresize
		*m: wndshow		&& Show child window (for internal use, public for bindevent)
		*p: backcolorbrush
		*p: dblclickbegin
		*p: drawbufdc
		*p: drawbufdib
		*p: drawbufgfx
		*p: fitwidth
		*p: fpdf_doc
		*p: fpdf_opened
		*p: fpdf_pagecount
		*p: fpdf_page_first_visible		&& Index of the page that appears first after rendering
		*p: fpdf_page_last_visible
		*p: isfocused		&& .T. if control has input focus
		*p: printenv		&& Print configuration state (pdfium_print_env object); Read-Only
		*p: scale
		*p: scrollbars		&& Specifies the type of scroll bars that an EditBox control, Form object, or Grid control has. 0 - None (Default); 1 - Horizontal; 2 - Vertical; 3 - Both vertical and horizontal
		*p: searchbrush
		*p: searchstate_dir
		*p: searchstate_findwhat
		*p: searchstate_rescount
		*p: searchstate_resindex
		*p: searchstate_respage
		*p: searchstate_resrect
		*p: selectionbrush
		*p: selectioncharindexprev
		*p: selectioncharindexstart
		*p: tplclickbegin
		*p: viewportmaxx
		*p: viewportmaxy
		*p: viewportsizex
		*p: viewportsizey
		*p: viewportx
		*p: viewporty
		*p: wndclassname
		*p: wnddc
		*p: wndhandle		&& Specifies the Window handle of the Window.
		*a: fpdf_pages[1,0]
		*a: fpdf_pages_pos[1,4]
		*a: fpdf_pages_render_cache[1,4]
		*a: fpdf_pages_selection[1,3]
		*a: fpdf_pages_size[1,4]
		*a: fpdf_text_pages[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _printenv
	*</DefinedPropArrayMethod>

	HIDDEN ActiveControl,AddProperty,backcolorbrush,BackStyle,BorderColor,BorderWidth,Click,CloneObject,ColorSource,ControlCount,Controls,dblclickbegin,DblClick,DragDrop,DragIcon,DragMode,DragOver,Drag,drawbufdc,drawbufdib,drawbufgfx,Draw,Error,ForeColor,fpdf_doc,fpdf_opened,fpdf_pagecount,fpdf_pages,fpdf_pages_pos,fpdf_pages_render_cache,fpdf_pages_selection,fpdf_pages_size,fpdf_page_first_visible,fpdf_page_last_visible,fpdf_text_pages,GotFocus,HelpContextID,isfocused,LostFocus,MiddleClick,MouseDown,MouseEnter,MouseIcon,MouseLeave,MouseMove,MousePointer,MouseUp,MouseWheel,Moved,Objects,OLECompleteDrag,OLEDragDrop,OLEDragMode,OLEDragOver,OLEDragPicture,OLEDrag,OLEDropEffects,OLEDropHasData,OLEDropMode,OLEGiveFeedback,OLESetData,OLEStartDrag,ParentClass,Picture,ReadExpression,ReadMethod,Refresh,ResetToDefault,Resize,RightClick,SaveAsClass,searchbrush,searchstate_dir,searchstate_findwhat,searchstate_rescount,searchstate_resindex,searchstate_respage,searchstate_resrect,selectionbrush,selectioncharindexprev,selectioncharindexstart,ShowWhatsThis,SpecialEffect,Style,Tag,tplclickbegin,UIEnable,viewportmaxx,viewportmaxy,viewportsizex,viewportsizey,viewportx,viewporty,WhatsThisHelpID,wndclassname,wnddc,wndhandle,WriteExpression,WriteMethod,ZOrder,_printenv
	*<PropValue>
		backcolorbrush = .F.
		BackStyle = 1
		dblclickbegin = 0
		drawbufdc = 0
		drawbufdib = 0
		drawbufgfx = 0
		fitwidth = .F.
		fpdf_doc = 0
		fpdf_opened = .F.
		fpdf_pagecount = 0
		fpdf_page_first_visible = 0
		fpdf_page_last_visible = 0
		Height = 622
		isfocused = .F.
		Name = "pdfiumviewer"
		printenv = .F.
		scale = 1
		scrollbars = 0
		searchbrush = .F.
		searchstate_dir = 0
		searchstate_findwhat = ("")
		searchstate_rescount = 0
		searchstate_resindex = 0
		searchstate_respage = 0
		searchstate_resrect = ("")
		selectionbrush = .F.
		selectioncharindexprev = -1
		selectioncharindexstart = 0
		tplclickbegin = 0
		viewportmaxx = 0
		viewportmaxy = 0
		viewportsizex = 0
		viewportsizey = 0
		viewportx = 0
		viewporty = 0
		Visible = .T.
		Width = 445
		wndclassname = ("PDFIUM-VFP-VIEWER")
		wnddc = 0
		wndhandle = 0
		_memberdata = <VFPData>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="drawbufgfx" type="property" display="DrawBufGFX"/>
			<memberdata name="drawbufrelease" type="method" display="DrawBufRelease"/>
			<memberdata name="errmsg" type="method" display="ErrMsg"/>
			<memberdata name="fpdf_doc" type="property" display="fpdf_doc"/>
			<memberdata name="fpdf_opened" type="property" display="fpdf_opened"/>
			<memberdata name="fpdf_pagecount" type="property" display="fpdf_pagecount"/>
			<memberdata name="fpdf_pages" type="property" display="fpdf_pages"/>
			<memberdata name="fpdf_pages_pos" type="property" display="fpdf_pages_pos"/>
			<memberdata name="fpdf_pages_render_cache" type="property" display="fpdf_pages_render_cache"/>
			<memberdata name="fpdf_pages_selection" type="property" display="fpdf_pages_selection"/>
			<memberdata name="fpdf_pages_size" type="property" display="fpdf_pages_size"/>
			<memberdata name="fpdf_page_first_visible" type="property" display="fpdf_page_first_visible"/>
			<memberdata name="fpdf_page_last_visible" type="property" display="fpdf_page_last_visible"/>
			<memberdata name="fpdf_text_pages" type="property" display="fpdf_text_pages"/>
			<memberdata name="getcurrentpage" type="method" display="GetCurrentPage"/>
			<memberdata name="getpagecount" type="method" display="GetPageCount"/>
			<memberdata name="getpagesize" type="method" display="GetPageSize"/>
			<memberdata name="keypress" type="method" display="KeyPress"/>
			<memberdata name="openpdf" type="method" display="OpenPDF" favorites="True"/>
			<memberdata name="pagepick" type="method" display="PagePick"/>
			<memberdata name="redraw" type="method" display="Redraw"/>
			<memberdata name="renderpages" type="method" display="RenderPages"/>
			<memberdata name="renderpagefromcache" type="method" display="RenderPageFromCache"/>
			<memberdata name="renderselection" type="method" display="RenderSelection"/>
			<memberdata name="scale" type="property" display="Scale"/>
			<memberdata name="scale_assign" type="method" display="Scale_Assign"/>
			<memberdata name="scrollbars" type="property" display="ScrollBars"/>
			<memberdata name="scrollbars_assign" type="method" display="ScrollBars_Assign"/>
			<memberdata name="scrollhorz" type="method" display="ScrollHorz"/>
			<memberdata name="scrollvert" type="method" display="ScrollVert"/>
			<memberdata name="selectionbrush" type="property" display="SelectionBrush"/>
			<memberdata name="selectioncharindexprev" type="property" display="SelectionCharIndexPrev"/>
			<memberdata name="selectioncharindexstart" type="property" display="SelectionCharIndexStart"/>
			<memberdata name="selectioncopy" type="method" display="SelectionCopy"/>
			<memberdata name="selecttext" type="method" display="SelectText"/>
			<memberdata name="viewportmaxx" type="property" display="ViewPortMaxX"/>
			<memberdata name="viewportmaxy" type="property" display="ViewPortMaxY"/>
			<memberdata name="viewportsizex" type="property" display="ViewPortSizeX"/>
			<memberdata name="viewportsizey" type="property" display="ViewPortSizeY"/>
			<memberdata name="viewportupdate" type="method" display="ViewPortUpdate"/>
			<memberdata name="viewportx" type="property" display="ViewPortX"/>
			<memberdata name="viewporty" type="property" display="ViewPortY"/>
			<memberdata name="wndclassname" type="property" display="WndClassName"/>
			<memberdata name="wndcreate" type="method" display="WndCreate"/>
			<memberdata name="wnddc" type="property" display="WndDC"/>
			<memberdata name="wndhandle" type="property" display="WndHandle"/>
			<memberdata name="wndproc" type="method" display="WndProc"/>
			<memberdata name="wndredraw" type="method" display="WndRedraw"/>
			<memberdata name="wndrelease" type="method" display="WndRelease"/>
			<memberdata name="wndresize" type="method" display="WndResize"/>
			<memberdata name="wndshow" type="method" display="WndShow"/>
			<memberdata name="selecttextall" type="method" display="SelectTextAll"/>
			<memberdata name="dblclickbegin" type="property" display="DblClickBegin"/>
			<memberdata name="tplclickbegin" type="property" display="TplClickBegin"/>
			<memberdata name="rendersearch" type="method" display="RenderSearch"/>
			<memberdata name="searchbrush" type="property" display="SearchBrush"/>
			<memberdata name="searchclose" type="method" display="SearchClose"/>
			<memberdata name="searchstate_findwhat" type="property" display="SearchState_FindWhat"/>
			<memberdata name="searchstate_rescount" type="property" display="SearchState_ResCount"/>
			<memberdata name="searchstate_resindex" type="property" display="SearchState_ResIndex"/>
			<memberdata name="searchstate_respage" type="property" display="SearchState_ResPage"/>
			<memberdata name="searchstate_resrect" type="property" display="SearchState_ResRect"/>
			<memberdata name="searchtext" type="method" display="SearchText"/>
			<memberdata name="searchstate_dir" type="property" display="SearchState_Dir"/>
			<memberdata name="savedocument" type="method" display="SaveDocument"/>
			<memberdata name="fitwidth" type="property" display="FitWidth"/>
			<memberdata name="fitwidth_assign" type="method" display="FitWidth_Assign"/>
			<memberdata name="isfocused" type="property" display="IsFocused"/>
			<memberdata name="printdocument" type="method" display="PrintDocument"/>
			<memberdata name="afterviewportupdate" type="method" display="AfterViewportUpdate"/>
			<memberdata name="printenv" type="property" display="PrintEnv"/>
			<memberdata name="printenv_assign" type="method" display="PrintEnv_Assign"/>
			<memberdata name="printenv_access" type="method" display="PrintEnv_Access"/>
			<memberdata name="_printenv" type="property" display="_PrintEnv"/>
		</VFPData>
		_printenv = .F.
	*</PropValue>

	ADD OBJECT 'cmdFocus' AS pdfiumviewer_cmdfocus WITH ;
		Left = -100, ;
		Name = "cmdFocus", ;
		Top = -100
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'env' AS pdfium_env WITH ;
		Left = 69, ;
		libhpdf_dll_path = (""), ;
		Name = "env", ;
		Top = 24, ;
		API_FPDF.CONST.Name = "CONST", ;
		API_FPDF.Name = "API_FPDF", ;
		API_HPDF.CONST.Name = "CONST", ;
		API_HPDF.Name = "API_HPDF", ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 108, ;
		Name = "i18n", ;
		Top = 24, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'UIState' AS pdfium_uistate WITH ;
		Left = 24, ;
		Name = "UIState", ;
		Top = 24
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE afterviewportupdate		&& Event. Triggered after ViewPortUpdate call
	ENDPROC

	HIDDEN PROCEDURE backcolor_assign
		LPARAMETERS vNewVal
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.BackColor = m.vNewVal
		
		LOCAL loBackColor
		m.loBackColor = This.env.System.Drawing.Color.FromRgb(This.BackColor)
		This.BackColorBrush.Color = m.loBackColor
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE closepdf		&& Close pdf file, previously opened by PdfiumViewer.openpdf
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		
		IF This.fpdf_opened
		    This._PrintEnv = .F.
		ENDIF
		
		This.fpdf_opened = .F.
		
		This.SearchClose()
		
		LOCAL lnPage, lnPageCount
		m.lnPageCount = This.fpdf_pagecount
		
		This.fpdf_pagecount = 0
		
		This.fpdf_page_first_visible = 0
		This.fpdf_page_last_visible = 0
		
		This.ViewPortX = 0
		This.ViewPortY = 0
		This.ViewPortSizeX = 0
		This.ViewPortSizeY = 0
		This.ViewPortMaxX = 0
		This.ViewPortMaxY = 0
		
		This.scale = 1
		
		LOCAL lnPage
		FOR m.lnPage = 1 TO m.lnPageCount
		    m.loFPDF.FPDFText_ClosePage(This.fpdf_text_pages[m.lnPage])
		    m.loFPDF.FPDF_ClosePage(This.fpdf_pages[m.lnPage])
		    
		    This.fpdf_pages[m.lnPage] = 0
		    This.fpdf_text_pages[m.lnPage] = 0
		    This.fpdf_pages_selection[m.lnPage,1] = ""
		    This.fpdf_pages_selection[m.lnPage,2] = 0
		    This.fpdf_pages_selection[m.lnPage,3] = 0
		    
		    LOCAL j
		    FOR m.j = 1 TO ALEN(This.fpdf_pages_render_cache,2)
		        This.fpdf_pages_render_cache[m.lnPage,m.j] = .F.
		    ENDFOR
		ENDFOR
		
		DIMENSION This.fpdf_pages(1)
		DIMENSION This.fpdf_text_pages(1)
		DIMENSION This.fpdf_pages_selection(1,3)
		DIMENSION This.fpdf_pages_pos(1,4)
		DIMENSION This.fpdf_pages_size(1,2)
		DIMENSION This.fpdf_pages_render_cache(1, ALEN(This.fpdf_pages_render_cache,2))
		
		STORE 0 TO This.fpdf_pages_pos, This.fpdf_pages_size
		
		IF EMPTY(This.fpdf_doc)=.F.
		    m.loFPDF.FPDF_CloseDocument(This.fpdf_doc)
		    This.fpdf_doc = 0
		ENDIF
		
		This.ViewPortUpdate()
		This.WndRedraw()
		
	ENDPROC

	HIDDEN PROCEDURE contextmenu
		
		LOCAL lcMenuName
		m.lcMenuName = "_context_menu"
		
		DEFINE POPUP (m.lcMenuName) FROM MROW(), MCOL() MARGIN RELATIVE SHORTCUT FONT 'Segoe UI', 10
		
		LOCAL lcSelectCopy, lcSelectAll
		m.lcSelectCopy = "SKIP FOR .T."
		m.lcSelectAll = ""
		
		IF This.fpdf_opened = .T.
		    LOCAL lnPage
		    FOR m.lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		        IF This.fpdf_pages_selection[m.lnPage,3] > 0
		            m.lcSelectCopy = ""
		            EXIT
		        ENDIF
		    ENDFOR
		ELSE
		    m.lcSelectAll = "SKIP FOR .T."
		ENDIF
		
		
		LOCAL i
		m.i=0
		
		m.i=m.i+1
		DEFINE BAR (m.i) OF (m.lcMenuName) PROMPT (This.i18n.text("MNU_COPY")) PICTRES _MED_COPY &lcSelectCopy
		ON SELECTION BAR (m.i) OF (m.lcMenuName) m.poThis.SelectionCopy()
		
		m.i=m.i+1
		DEFINE BAR (m.i) OF (m.lcMenuName) PROMPT (This.i18n.text("MNU_SLCTA")) &lcSelectAll
		ON SELECTION BAR (m.i) OF (m.lcMenuName) m.poThis.SelectTextAll()
		
		
		PRIVATE poThis
		m.poThis = This
		IF CNTBAR(m.lcMenuName)<>0
		    ACTIVATE POPUP &lcMenuName
		ENDIF
		m.poThis = .F.
		
		
	ENDPROC

	PROCEDURE Destroy
		
		This.ClosePDF()
		
		This.DrawBufRelease()
		
		This.WndRelease()
		
		This._PrintEnv = .F.
		
	ENDPROC

	HIDDEN PROCEDURE drawbufcreate
		
		#DEFINE FF_RGBQUAD_SIZE     4
		#DEFINE FF_DIB_RGB_COLORS   0
		#DEFINE FF_BFHDR_SIZE      14
		#DEFINE FF_BHDR_SIZE       40
		#DEFINE FF_BI_RGB           0
		
		IF EMPTY(This.WndDC)
		    RETURN
		ENDIF
		
		IF VARTYPE(This.env.System)<>"O"
		    RETURN
		ENDIF
		
		
		This.DrawBufRelease()
		
		
		***********************************************************************************
		IF EMPTY(This.DrawBufDC)
		    This.DrawBufDC = This.env.API_WIN.CreateCompatibleDC(This.WndDC)
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		LOCAL lnWidth, lnHeight, lnBitsPerPixel
		m.lnWidth = This.Width
		m.lnHeight = This.Height
		m.lnBitsPerPixel = 16
		
		LOCAL lcBMI
		m.lcBMI = BINTOC(FF_BHDR_SIZE ,"4RS") + BINTOC(m.lnWidth,"4RS") + BINTOC(m.lnHeight, "4RS") + ;
		        (CHR(MOD(1,256)) + CHR(INT(1/256))) + (CHR(MOD(m.lnBitsPerPixel,256))+ CHR(INT(m.lnBitsPerPixel/256))) +;
		        BINTOC(FF_BI_RGB, "4RS") + REPLICATE(0h00, 20)
		
		
		LOCAL lnDibDataPtr
		m.lnDibDataPtr = 0
		
		This.DrawBufDIB = This.env.API_WIN.CreateDIBSection(This.DrawBufDC, m.lcBMI, FF_DIB_RGB_COLORS, @m.lnDibDataPtr, 0, 0)
		This.env.API_WIN.SelectObject(This.DrawBufDC, This.DrawBufDIB)
		
		This.DrawBufGfx = This.env.System.Drawing.Graphics.FromHDC(This.DrawBufDC)
		
		
	ENDPROC

	HIDDEN PROCEDURE drawbufrelease
		This.DrawBufGfx = .F.
		
		IF EMPTY(This.DrawBufDC) = .F.
		    This.env.API_WIN.DeleteDC(This.DrawBufDC)
		    This.DrawBufDC = 0
		ENDIF
		
		IF EMPTY(This.DrawBufDIB) = .F.
		    This.env.API_WIN.DeleteObject(This.DrawBufDIB)
		    This.DrawBufDIB = 0
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		m.lcMsg = ""
		
		DO CASE
		 CASE VARTYPE(m.tvMsg)="O"
		    m.lcMsg = ;
		        m.tvMsg.Message + ;
		        RTRIM(" " + NVL(m.tvMsg.Details,"")) + ;
		        RTRIM(" " + NVL(m.tvMsg.UserValue,"")) + ;
		        CHR(13) + "Procedure: " + m.tvMsg.Procedure + ;
		        CHR(13) + "LineContents: " + m.tvMsg.LineContents
		
		 CASE VARTYPE(m.tvMsg)="C"
		    m.lcMsg = ALLTRIM(m.tvMsg)
		
		ENDCASE
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		MESSAGEBOX(m.lcMsg, 0+48, This.Class + " ("+This.ClassLibrary+")")
		
		
	ENDPROC

	HIDDEN PROCEDURE fitwidth_assign
		LPARAMETERS vNewVal
		
		This.FitWidth = m.vNewVal
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
		
	ENDPROC

	PROCEDURE getcurrentpage		&& Current page number. First page has number = 1
		RETURN This.fpdf_page_first_visible
	ENDPROC

	PROCEDURE getpagecount		&& Returns page count
		RETURN This.fpdf_pagecount
		
	ENDPROC

	PROCEDURE getpagesize		&& Returns page dimensions (see comment in source code)
		LPARAMETERS tnPageIndex, tnPosition
		
		*tnPageIndex: page number from 1 to This.fpdf_pagecount
		*tnPosition: 1 - width in pdf units  (1/72 on inch)
		*tnPosition: 2 - height in pdf units  (1/72 on inch)
		*tnPosition: 3 - width in pixels
		*tnPosition: 4 - height in pixels
		*tnPosition: 5 - width / height relation
		
		IF BETWEEN(m.tnPageIndex, 1, This.fpdf_pagecount)=.F.
		    RETURN 0
		ENDIF
		
		LOCAL lnPdfPageWidth, lnPdfPageHeight
		m.lnPdfPageWidth = This.fpdf_pages_size[m.tnPageIndex,1]
		m.lnPdfPageHeight = This.fpdf_pages_size[m.tnPageIndex,2]
		
		LOCAL lnPageWidth, lnPageHeight
		m.lnPageWidth = INT(m.lnPdfPageWidth * This.env.GetScreenDPIX() / This.env.GetPDFDPI())
		m.lnPageHeight = INT(m.lnPdfPageHeight * This.env.GetScreenDPIY() / This.env.GetPDFDPI())
		
		DO CASE
		
		CASE m.tnPosition = 1
		    RETURN m.lnPdfPageWidth
		
		CASE m.tnPosition = 2
		    RETURN m.lnPdfPageHeight
		
		CASE m.tnPosition = 3
		    RETURN m.lnPageWidth
		    
		CASE m.tnPosition = 4
		    RETURN m.lnPageHeight
		
		CASE m.tnPosition = 5
		    RETURN m.lnPdfPageWidth / EVL(m.lnPdfPageHeight,1)
		
		ENDCASE
		
		RETURN 0
		
	ENDPROC

	HIDDEN PROCEDURE GotFocus
		This.IsFocused = .T.
		
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.env.Setup(m.toEnv)
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		*********************************************************
		This.BorderWidth = 0
		
		
		*********************************************************
		IF This.WndCreate() = .F.
		    RETURN
		ENDIF
		
		LOCAL loBackColor
		m.loBackColor = This.env.System.Drawing.Color.FromRgb(This.BackColor)
		This.BackColorBrush = This.env.System.Drawing.SolidBrush.New(m.loBackColor)
		
		LOCAL loSelectionColor
		m.loSelectionColor = This.env.System.Drawing.Color.New(This.env.System.Drawing.Color.SteelBlue.ToArgb())
		m.loSelectionColor.A = 72
		This.SelectionBrush = This.env.System.Drawing.SolidBrush.New(m.loSelectionColor)
		
		LOCAL loSearchColor
		m.loSearchColor = This.env.System.Drawing.Color.New(This.env.System.Drawing.Color.Yellow.ToArgb())
		m.loSearchColor.A = 96
		This.SearchBrush = This.env.System.Drawing.SolidBrush.New(m.loSearchColor)
		
		
		
		
		*********************************************************
		This.Resize()
		This.WndShow()
		
	ENDPROC

	PROCEDURE keypress		&& Occurs when the user presses and releases a key.
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		#define KEY_LEFT_ARROW 19
		#define KEY_RIGHT_ARROW 4
		#define KEY_UP_ARROW 5
		#define KEY_DOWN_ARROW 24
		#define KEY_PAGE_UP 18
		#define KEY_PAGE_DOWN 3
		#define KEY_HOME 1
		#define KEY_END 6
		
		DO CASE
		
		CASE This.fpdf_opened = .F.
		 
		CASE This.UIState.GetEffectivelyVisible() = .F.
		
		CASE This.UIState.GetEffectivelyEnabled() = .F. 
		 
		CASE m.nKeyCode = KEY_LEFT_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollHorz(-0.05 * This.Width, .F., .T.)
		
		CASE m.nKeyCode = KEY_RIGHT_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollHorz(0.05 * This.Width, .F., .T.)
		
		CASE m.nKeyCode = KEY_UP_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(-0.05 * This.Height, .F., .T.)
		
		CASE m.nKeyCode = KEY_DOWN_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(0.05 * This.Height, .F., .T.)
		
		CASE m.nKeyCode = KEY_PAGE_UP AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(-1, .T., .T.)
		
		CASE m.nKeyCode = KEY_PAGE_DOWN AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(1, .T., .T.)
		
		CASE m.nKeyCode = KEY_HOME AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(1, .T., .F.)
		
		CASE m.nKeyCode = KEY_END AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(This.ViewPortMaxY, .T., .F.)
		
		CASE m.nKeyCode = 3 AND m.nShiftAltCtrl = 2
		    NODEFAULT
		    This.SelectionCopy()
		    
		ENDCASE
		
		
	ENDPROC

	HIDDEN PROCEDURE LostFocus
		This.IsFocused = .F.
		
		
		
	ENDPROC

	HIDDEN PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		This.SelectionCharIndexStart = 0
		
		IF m.nButton <> 1
		    RETURN 
		ENDIF
		
		
		LOCAL lnMouseX, lnMouseY
		m.lnMouseX = m.nXCoord
		m.lnMouseY = m.nYCoord
		
		LOCAL llDblClick, llTplClick
		m.llDblClick = .F.
		m.llTplClick = .F.
		
		********************************************************************
		LOCAL lnTick
		m.lnTick = This.env.API_WIN.GetTickCount()
		m.lnTick = IIF(m.lnTick < 0, 0x80000000 + BITCLEAR(m.lnTick,31), m.lnTick)
		
		DO CASE 
		
		CASE This.DblClickBegin = 0 AND This.TplClickBegin = 0
		    This.DblClickBegin = -m.lnTick
		    This.TplClickBegin = -m.lnTick
		
		CASE This.DblClickBegin < 0
		    This.DblClickBegin = -This.DblClickBegin
		    
		    IF ABS(m.lnTick - This.DblClickBegin)/1000 <= _DBLCLICK
		        m.llDblClick = .T.
		        This.DblClickBegin = 0
		    ELSE
		        This.DblClickBegin = -m.lnTick
		        This.TplClickBegin = -m.lnTick
		    ENDIF
		
		CASE This.TplClickBegin < 0
		    This.TplClickBegin = -This.TplClickBegin
		    IF ABS(m.lnTick - This.TplClickBegin)/1000 <= _DBLCLICK 
		        m.llTplClick = .T.
		        This.DblClickBegin = 0
		        This.TplClickBegin = 0
		    ELSE
		        This.DblClickBegin = -m.lnTick
		        This.TplClickBegin = -m.lnTick
		    ENDIF
		
		ENDCASE
		
		
		********************************************************************
		LOCAL lnPage, lnFPDF_Page, lnFPDF_Text_Page
		m.lnPage = This.PagePick(m.lnMouseX, m.lnMouseY)
		
		IF EMPTY(m.lnPage) = .T.
		    RETURN
		ENDIF
		
		m.lnFPDF_Page = This.fpdf_pages[m.lnPage]
		m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPage]
		
		LOCAL lnPageX as Double, lnPageY as Double
		STORE 0 TO m.lnPageX, m.lnPageY
		
		IF m.loFPDF.FPDF_DeviceToPage(m.lnFPDF_Page, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnMouseX, m.lnMouseY, @m.lnPageX, @m.lnPageY) <> 1
		    RETURN
		ENDIF
		
		
		********************************************************************
		LOCAL lnCharIndexStart
		m.lnCharIndexStart = m.loFPDF.FPDFText_GetCharIndexAtPos(m.lnFPDF_Text_Page, m.lnPageX, m.lnPageY, 10, 0)
		
		IF m.lnCharIndexStart > 0
		    This.SelectionCharIndexStart = m.lnCharIndexStart
		ENDIF
		
		IF m.lnCharIndexStart < 0
		    * TEXT MISCLICK
		    This.SelectText()
		    RETURN
		ENDIF
		
		
		IF m.llDblClick = .F. AND m.llTplClick = .F.
		    * TEXT SINGLE CLICK
		    This.SelectText()
		    RETURN
		ENDIF
		
		
		********************************************************************
		* TEXT DOUBLE CLICK, TRIPLE CLICK
		********************************************************************
		
		LOCAL lnCharCountMax
		m.lnCharCountMax = m.loFPDF.FPDFText_CountChars(m.lnFPDF_Text_Page)
		IF m.lnCharCountMax < 0
		    RETURN
		ENDIF
		
		LOCAL lnCharCount
		m.lnCharCount = 1
		
		LOCAL lnCharIndexLeft
		m.lnCharIndexLeft = m.lnCharIndexStart
		
		DO WHILE m.lnCharIndexLeft > 0
		    LOCAL lcChar
		    m.lcChar = LEFT(STRCONV(STRCONV(BINTOC(m.loFPDF.FPDFText_GetUnicode(m.lnFPDF_Text_Page, m.lnCharIndexLeft-1), "4RS"),6),2),1)
		    
		    IF INLIST(m.lcChar, CHR(10),CHR(13))
		        EXIT
		    ENDIF
		    
		    IF EMPTY(m.lcChar) AND m.llTplClick = .F.
		        EXIT
		    ENDIF
		    
		    m.lnCharIndexLeft = m.lnCharIndexLeft - 1
		    m.lnCharCount = m.lnCharCount + 1
		ENDDO
		
		
		DO WHILE m.lnCharIndexLeft + m.lnCharCount < m.lnCharCountMax
		    LOCAL lcChar
		    m.lcChar = LEFT(STRCONV(STRCONV(BINTOC(m.loFPDF.FPDFText_GetUnicode(m.lnFPDF_Text_Page, m.lnCharIndexLeft + m.lnCharCount), "4RS"),6),2),1)
		
		    IF INLIST(m.lcChar, CHR(10),CHR(13))
		        EXIT
		    ENDIF
		
		    IF EMPTY(m.lcChar) AND m.llTplClick = .F.
		        EXIT
		    ENDIF
		
		    m.lnCharCount = m.lnCharCount + 1
		ENDDO
		
		
		This.SelectText(m.lnPage, m.lnCharIndexLeft, m.lnCharCount)
		
		
	ENDPROC

	HIDDEN PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL lnMouseX, lnMouseY
		m.lnMouseX = m.nXCoord
		m.lnMouseY = m.nYCoord
		
		LOCAL lnPage, lnFPDF_Page, lnFPDF_Text_Page
		m.lnPage = This.PagePick(m.lnMouseX, m.lnMouseY)
		IF EMPTY(m.lnPage)
		    RETURN
		ENDIF
		
		m.lnFPDF_Page = This.fpdf_pages[m.lnPage]
		m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPage]
		
		LOCAL lnPageX as Double, lnPageY as Double
		STORE 0 TO m.lnPageX, m.lnPageY
		
		IF m.loFPDF.FPDF_DeviceToPage(m.lnFPDF_Page, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnMouseX, m.lnMouseY, @m.lnPageX, @m.lnPageY) <> 1
		    RETURN
		ENDIF
		
		LOCAL lnCharIndex
		m.lnCharIndex = m.loFPDF.FPDFText_GetCharIndexAtPos(m.lnFPDF_Text_Page, m.lnPageX, m.lnPageY, 10, 0)
		
		DO CASE
		CASE m.lnCharIndex >= 0
		    This.MousePointer = 3
		    
		    IF m.nButton = 1 AND m.lnCharIndex <> This.SelectionCharindexPrev
		        This.selecttext(m.lnPage, MIN(This.SelectionCharIndexStart,m.lnCharIndex), ABS(m.lnCharIndex-This.SelectionCharIndexStart)+1)
		    ENDIF
		    
		OTHERWISE
		    This.MousePointer = 0
		ENDCASE
		
		This.SelectionCharindexPrev = m.lnCharIndex
		
	ENDPROC

	HIDDEN PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		IF m.nButton = 2
		    This.contextmenu()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE MouseWheel
		LPARAMETERS nDirection, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		DO CASE
		CASE EVL(m.nShift,0)=2
		     This.scale = This.scale + (SIGN(m.nDirection) * 0.1)
		 
		CASE EVL(m.nShift,0)=0
		    This.ScrollVert(-0.05 * This.Height * m.nDirection/120, .F., .T.)
		
		ENDCASE
		
	ENDPROC

	PROCEDURE openpdf		&& Open pdf file. Returns: .T. on success, .F. if file was not loaded
		LPARAMETERS tcFilename, tcPassword
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.ClosePDF()
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		
		LOCAL lcFilename
		m.lcFilename = ALLTRIM(EVL(NVL(m.tcFilename,""),""))
		
		IF EMPTY(m.lcFilename)
		    RETURN .F.
		ENDIF
		
		IF FILE(m.lcFilename,1)=.F.
		    This.errMsg(TEXTMERGE("File <<FULLPATH(lcFilename)>> not found"))
		    RETURN .F.
		ENDIF    
		
		LOCAL lcPassword
		m.lcPassword = IIF(VARTYPE(m.tcPassword)<>"C", "", m.tcPassword)
		
		
		DO WHILE .T.
		    This.fpdf_doc = m.loFPDF.FPDF_LoadDocument(STRCONV(m.lcFilename,9)+CHR(0), STRCONV(m.lcPassword,9)+CHR(0))
		
		    IF EMPTY(This.fpdf_doc) = .F.
		        EXIT
		    ENDIF
		    
		    LOCAL lnLoadError
		    m.lnLoadError = m.loFPDF.FPDF_GetLastError()
		    
		    IF m.lnLoadError = m.loFPDF.CONST.FPDF_ERR_PASSWORD()
		        LOCAL loPasswordInput
		        m.loPasswordInput = NEWOBJECT("pdfium_password_input", This.ClassLibrary)
		        m.loPasswordInput.out_password = m.lcPassword
		        m.loPasswordInput.in_incorrect = EMPTY(m.lcPassword)=.F.
		        m.loPasswordInput.Show(1)
		        
		        IF VARTYPE(m.loPasswordInput) = "O" AND m.loPasswordInput.out_ok = .T.
		            m.lcPassword = m.loPasswordInput.out_password
		            m.loPasswordInput = .F.
		            LOOP
		        ENDIF
		        m.loPasswordInput = .F.
		    ENDIF
		    
		    RETURN .F.
		ENDDO
		
		
		This.fpdf_pagecount = m.loFPDF.FPDF_GetPageCount(This.fpdf_doc)
		
		IF This.fpdf_pagecount > 0
		    DIMENSION This.fpdf_pages(This.fpdf_pagecount)
		    DIMENSION This.fpdf_text_pages(This.fpdf_pagecount)
		    DIMENSION This.fpdf_pages_selection(This.fpdf_pagecount,3)
		    DIMENSION This.fpdf_pages_pos(This.fpdf_pagecount,4)
		    DIMENSION This.fpdf_pages_size(This.fpdf_pagecount,2)
		    STORE 0 TO This.fpdf_pages, This.fpdf_text_pages, This.fpdf_pages_pos, This.fpdf_pages_size
		    
		    DIMENSION This.fpdf_pages_render_cache(This.fpdf_pagecount,4) && Max 4 rendered samples for page
		    STORE .F. TO This.fpdf_pages_render_cache
		ENDIF
		
		LOCAL lnPage
		FOR m.lnPage = 1 TO This.FPDF_PageCount
		    This.fpdf_pages[m.lnPage] = m.loFPDF.FPDF_LoadPage(This.FPDF_Doc, m.lnPage-1)
		    
		    This.fpdf_text_pages[m.lnPage] = m.loFPDF.FPDFText_LoadPage(This.fpdf_pages[m.lnPage])
		    
		    This.fpdf_pages_selection[m.lnPage,1] = ""
		    This.fpdf_pages_selection[m.lnPage,2] = 0
		    This.fpdf_pages_selection[m.lnPage,3] = 0
		    
		    This.fpdf_pages_size[m.lnPage,1] = m.loFPDF.FPDF_GetPageWidth(This.fpdf_pages[m.lnPage])
		    This.fpdf_pages_size[m.lnPage,2] = m.loFPDF.FPDF_GetPageHeight(This.fpdf_pages[m.lnPage])
		ENDFOR
		
		This.ViewPortUpdate()
		
		This.fpdf_opened = .T.
		
		This.WndRedraw()
		
	ENDPROC

	HIDDEN PROCEDURE pagepick
		LPARAMETERS lnCoordX, lnCoordY
		
		* lnCoordX, lnCoordY coordinates in the control space (0,0) is top left corner of the control
		
		IF This.fpdf_opened = .F.
		    RETURN 0
		ENDIF
		
		IF This.fpdf_page_first_visible = 0
		    RETURN 0
		ENDIF
		
		
		LOCAL lnPage, lnPageFound
		m.lnPageFound = 0
		FOR m.lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		    DO CASE
		    CASE BETWEEN(m.lnCoordX, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX + This.fpdf_pages_pos[m.lnPage,3]) = .F.
		         LOOP
		    CASE BETWEEN(m.lnCoordY, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY + This.fpdf_pages_pos[m.lnPage,4]) = .F.
		         LOOP
		    OTHERWISE
		        m.lnPageFound = m.lnPage
		        EXIT
		    ENDCASE
		ENDFOR
		
		RETURN m.lnPageFound
		
	ENDPROC

	PROCEDURE printdocument		&& Send document to printer with preceding setup dialog
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		IF EMPTY(This.fpdf_doc)
		    RETURN
		ENDIF
		
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		*********************************************************************
		IF This.PrintEnv.AllowPrintSetupUI = .T.
		
		    LOCAL loFrmSetup
		    m.loFrmSetup = NEWOBJECT("pdfium_print_settings", This.ClassLibrary, "", This.PrintEnv)
		    m.loFrmSetup.Show(1)
		
		    This.SetFocus()
		
		    IF VARTYPE(m.loFrmSetup)<>"O"
		        RETURN
		    ENDIF
		
		    IF m.loFrmSetup.out_ok = .F.
		        RETURN
		    ENDIF
		
		    m.loFrmSetup = .F.
		
		ENDIF
		
		IF EMPTY(This.PrintEnv.Printer)
		    RETURN
		ENDIF
		*********************************************************************
		
		
		*********************************************************************
		
		#define PHYSICALOFFSETX 112
		#define PHYSICALOFFSETY 113
		
		#define DM_ORIENTATION  1
		#define DM_PAPERSIZE    2
		#define DM_PAPERLENGTH  4
		#define DM_PAPERWIDTH   8
		#define DM_COPIES 0x00000100
		#define DM_DUPLEX 0x00001000
		#define DM_YRESOLUTION 0x00002000
		
		#DEFINE DM_OFFSET_DMFIELDS 41  && DEVMODE dmFields offset
		#define DM_OFFSET_ORIENTATION 45  && DEVMODE dmOrientation offset
		#define DM_OFFSET_PAPERSIZE 47  && DEVMODE dmPaperSize offset
		#define DM_OFFSET_PAPERLENGTH 49  && DEVMODE dmPaperLength offset
		#define DM_OFFSET_PAPERWIDTH 51  && DEVMODE dmPaperWidth offset
		#define DM_OFFSET_COPIES 55  && DEVMODE dmCopies offset
		#define DM_OFFSET_DUPLEX 63 && DEVMODE dmDuplex offset
		#define DM_OFFSET_YRESOLUTION 65 && DEVMODE dmYResolution offset
		#define DMDUP_SIMPLEX    1
		#define DMDUP_VERTICAL   2
		#define DMDUP_HORIZONTAL 3
		#define DMORIENT_PORTRAIT 1
		#define DMORIENT_LANDSCAPE 2
		
		#define DMPAPER_A4 9
		
		#define FORM_BUILTIN 0x00000001
		#define FORM_PRINTER 0x00000002
		*********************************************************************
		* Get printer document properties and printer forms
		*********************************************************************
		
		LOCAL lcPrnDevMode
		m.lcPrnDevMode = This.PrintEnv.GetPrinterDevMode(This.PrintEnv.Printer)
		
		IF EMPTY(m.lcPrnDevMode)
		    This.ErrMsg(TEXTMERGE("PrintEnv.GetPrinterDevMode returned empty value for <<This.PrintEnv.Printer>>"))
		    RETURN
		ENDIF
		
		LOCAL lnPrnFormCnt
		LOCAL laPrnForm(1,9)
		m.lnPrnFormCnt = This.PrintEnv.GetPrinterForms(@m.laPrnForm, This.PrintEnv.Printer)
		IF EMPTY(m.lnPrnFormCnt)
		    This.ErrMsg(TEXTMERGE("PrintEnv.GetPrinterForms returned empty value for <<This.PrintEnv.Printer>>"))
		    RETURN
		ENDIF
		
		LOCAL lnPrnDevModeFlags
		m.lnPrnDevModeFlags = CTOBIN(SUBSTR(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4),"4RS")
		
		
		*********************************************************************
		* Setup page ranges according to PrintEnv.PageMode 
		*********************************************************************
		LOCAL lnPageMode, lcPageList
		m.lnPageMode = 1
		m.lcPageList = ""
		
		m.lnPageMode = This.printEnv.PageMode
		m.lcPageList = This.printEnv.PageList_Parse(This.printEnv.PageList)
		
		
		LOCAL ARRAY laPageRanges(1,2)
		LOCAL lnPageRangeCnt
		m.lnPageRangeCnt = 0
		DO CASE
		CASE m.lnPageMode = 1 && All pages
		    m.lnPageRangeCnt = 1
		    DIMENSION m.laPageRanges(1,2)
		    m.laPageRanges[1,1] = 1
		    m.laPageRanges[1,2] = This.fpdf_pagecount
		
		CASE m.lnPageMode = 2 && Odd pages
		    m.lnPageRangeCnt = INT(This.fpdf_pagecount / 2) + MOD(This.fpdf_pagecount, 2)
		    LOCAL lnRange
		    FOR m.lnRange = 1 TO m.lnPageRangeCnt
		        DIMENSION m.laPageRanges(m.lnRange,2)
		        m.laPageRanges[m.lnRange,1] = m.lnRange*2 - 1
		        m.laPageRanges[m.lnRange,2] = m.lnRange*2 - 1
		    ENDFOR
		
		CASE m.lnPageMode = 3 && Even pages
		    m.lnPageRangeCnt = INT(This.fpdf_pagecount / 2)
		    LOCAL lnRange
		    FOR m.lnRange = 1 TO m.lnPageRangeCnt
		        DIMENSION m.laPageRanges(m.lnRange,2)
		        m.laPageRanges[m.lnRange,1] = m.lnRange*2
		        m.laPageRanges[m.lnRange,2] = m.lnRange*2
		    ENDFOR
		
		CASE m.lnPageMode = 4
		    LOCAL ARRAY laPageList(1)
		    m.lnPageRangeCnt = ALINES(laPageList, m.lcPageList,1+4,",")
		    LOCAL lnRange
		    FOR m.lnRange = 1 TO m.lnPageRangeCnt
		        DIMENSION m.laPageRanges(m.lnRange,2)
		        m.laPageRanges[m.lnRange,1] = INT(VAL(STREXTRACT(m.laPageList[m.lnRange], "", "-",1,2)))
		        m.laPageRanges[m.lnRange,2] = EVL(INT(VAL(STREXTRACT(m.laPageList[m.lnRange], "-", "",1,2))), m.laPageRanges[m.lnRange,1])
		    ENDFOR
		ENDCASE
		*********************************************************************
		
		
		*********************************************************************
		LOCAL lnPrinterDPI
		m.lnPrinterDPI =  EVL(IIF(BITAND(m.lnPrnDevModeFlags, DM_YRESOLUTION)<>0, CTOBIN(SUBSTR(m.lcPrnDevMode,DM_OFFSET_YRESOLUTION,2),"2RS"), 0), 600)
		
		LOCAL llPrinterHasDuplex, lnPrinterDuplex
		m.llPrinterHasDuplex = This.PrintEnv.GetPrinterDuplex(This.PrintEnv.Printer)
		
		* Get default duplex setting of the printer
		m.lnPrinterDuplex = EVL(IIF(BITAND(m.lnPrnDevModeFlags, DM_DUPLEX)<>0, CTOBIN(SUBSTR(m.lcPrnDevMode,DM_OFFSET_DUPLEX,2),"2RS"), 0), DMDUP_SIMPLEX)
		
		DO CASE
		CASE m.llPrinterHasDuplex = .F. OR This.PrintEnv.Duplex  = .F.
		    m.lnPrinterDuplex = DMDUP_SIMPLEX
		OTHERWISE
		    m.lnPrinterDuplex = DMDUP_VERTICAL
		ENDCASE
		
		
		
		LOCAL loErr
		m.loErr = .F.
		
		TRY
		
		    LOCAL lcDocName
		    m.lcDocName = This.Class
		
		    LOCAL lhDocNameHeap, lhDocNameHeapPtr
		    m.lhDocNameHeap = This.env.API_WIN.HeapCreate(0, LEN(m.lcDocName)+1, 0)
		    m.lhDocNameHeapPtr = 0
		    IF EMPTY(m.lhDocNameHeap) = .F.
		        m.lhDocNameHeapPtr = This.env.API_WIN.HeapAlloc(m.lhDocNameHeap, 0, LEN(m.lcDocName)+1)
		        IF EMPTY(m.lhDocNameHeapPtr) = .F.
		            SYS(2600, m.lhDocNameHeapPtr, LEN(m.lcDocName)+1, m.lcDocName+CHR(0))
		        ENDIF
		    ENDIF
		    
		    LOCAL lhPrinterDC
		    m.lhPrinterDC = 0
		
		    LOCAL lcDocInfo
		    m.lcDocInfo = BINTOC(20, "4RS") + BINTOC(m.lhDocNameHeapPtr, "4RS") + BINTOC(0, "4RS") + BINTOC(0, "4RS") + BINTOC(0, "4RS")
		    
		
		    LOCAL llStartDoc
		    m.llStartDoc = .T.
		    
		    LOCAL lnDocPageNum
		    m.lnDocPageNum = 0
		    
		    LOCAL lnOrientation
		    m.lnOrientation = 0
		    
		    LOCAL lnPaperSize, lnPaperSizePrev
		    m.lnPaperSize = 0
		    m.lnPaperSizePrev = 0
		
		    LOCAL lnPageRange
		    m.lnPageRange = 1
		    FOR m.lnPageRange = 1 TO m.lnPageRangeCnt
		        
		        LOCAL lnPageFrom, lnPageTo
		        m.lnPageFrom = MAX(m.laPageRanges[m.lnPageRange,1], 1)
		        m.lnPageTo = MIN(m.laPageRanges[m.lnPageRange,2], This.fpdf_pagecount)
		        
		        LOCAL lnPageIndex
		        m.lnPageIndex = m.lnPageFrom
		
		        
		        FOR m.lnPageIndex = m.lnPageFrom TO m.lnPageTo
		
		            LOCAL lnPageWidth, lnPageHeight
		            m.lnPageWidth = This.GetPageSize(m.lnPageIndex,1)  / This.env.GetPDFDPI()
		            m.lnPageHeight = This.GetPageSize(m.lnPageIndex,2) / This.env.GetPDFDPI()
		
		
		            * Find paper size 
		            m.lnPaperSize = This.PrintEnv.PaperSize
		            
		            IF BETWEEN(m.lnPaperSize, 1, m.lnPrnFormCnt)
		               m.lnPaperSize = IIF(m.laPrnForm[m.lnPaperSize,9], m.lnPaperSize, -1) && check form is supported by printer
		            ELSE
		                m.lnPaperSize = -1 
		            ENDIF
		            
		            IF m.lnPaperSize = -1 && Find fittest paper form
		                LOCAL liPrnForm, lnFitFormWidth, lnFitFormHeight
		                m.liPrnForm = 1
		                STORE 0 TO m.lnFitFormWidth, m.lnFitFormHeight 
		                FOR m.liPrnForm = 1 TO m.lnPrnFormCnt
		                    DO CASE
		                    CASE BITAND(m.laPrnForm[m.liPrnForm,1], FORM_BUILTIN) = 0
		                    CASE m.laPrnForm[m.liPrnForm,9] = .F.
		                    CASE ROUND(m.laPrnForm[m.liPrnForm,3]/1000,0) < ROUND(IIF(m.lnPageWidth < m.lnPageHeight, m.lnPageWidth, m.lnPageHeight) * 25.4, 0)
		                    CASE ROUND(m.laPrnForm[m.liPrnForm,4]/1000,0) < ROUND(IIF(m.lnPageWidth < m.lnPageHeight, m.lnPageHeight, m.lnPageWidth) * 25.4, 0)
		                    CASE m.lnFitFormWidth > 0 AND m.lnFitFormWidth < m.laPrnForm[m.liPrnForm,3]
		                    CASE m.lnFitFormHeight > 0 AND m.lnFitFormHeight < m.laPrnForm[m.liPrnForm,4]
		                    OTHERWISE
		                        m.lnPaperSize = m.liPrnForm
		                        m.lnFitFormWidth = m.laPrnForm[m.liPrnForm,3]
		                        m.lnFitFormHeight = m.laPrnForm[m.liPrnForm,4]
		                    ENDCASE
		                ENDFOR
		                m.lnPaperSize = EVL(MAX(m.lnPaperSize,0), EVL(MAX(PRTINFO(2, This.PrintEnv.Printer), 0), DMPAPER_A4 ))
		            ENDIF
		            
		            *********************************************************
		            IF BETWEEN(m.lnPaperSize, 1, m.lnPrnFormCnt) = .F.
		                THROW TEXTMERGE("Not Found Paper Form For Page number <<lnPageIndex>>, page size <<ROUND(lnPageWidth * 25.4,0)>> mm, <<ROUND(lnPageHeight * 25.4,0)>> mm ")
		            ENDIF
		            *********************************************************
		
		            IF m.lnPaperSizePrev <> m.lnPaperSize
		                m.lnPaperSizePrev = m.lnPaperSize
		                m.llStartDoc = .T.
		            ENDIF
		
		            IF m.llStartDoc
		
		                IF EMPTY(m.lhPrinterDC) = .F.
		                    This.env.API_WIN.EndDoc(m.lhPrinterDC)
		                    This.env.API_WIN.DeleteDC(m.lhPrinterDC)
		                ENDIF
		
		                m.lnDocPageNum = 0
		                
		                m.lnOrientation = IIF(m.lnPageWidth > m.lnPageHeight, DMORIENT_LANDSCAPE, DMORIENT_PORTRAIT)
		                
		                * Set paper size
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(m.lnPrnDevModeFlags, DM_PAPERSIZE), "4RS"))
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_PAPERSIZE, 2, BINTOC(m.lnPaperSize, "2RS"))
		
		                * Set duplex
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(m.lnPrnDevModeFlags, DM_DUPLEX), "4RS"))
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DUPLEX, 2, BINTOC(m.lnPrinterDuplex, "2RS"))
		                
		                * Set page orientation
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(m.lnPrnDevModeFlags, DM_ORIENTATION), "4RS"))
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_ORIENTATION, 2, BINTOC(m.lnOrientation, "2RS"))
		
		                * Set copies
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(m.lnPrnDevModeFlags, DM_COPIES), "4RS"))
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_COPIES, 2, BINTOC(EVL(This.PrintEnv.copies,1), "2RS"))
		                
		                m.lhPrinterDC = This.env.API_WIN.CreateDC(NULL, This.printenv.Printer + CHR(0), NULL, @m.lcPrnDevMode)
		
		                IF EMPTY(m.lhPrinterDC)
		                    THROW TEXTMERGE("WinApi CreateDC error on page <<lnPageIndex>>, printer <<This.PrintEnv.Printer>>")
		                ENDIF
		            
		                This.env.API_WIN.StartDoc(m.lhPrinterDC, m.lcDocInfo)
		                
		                m.llStartDoc = .F.
		            ENDIF
		
		            m.lnDocPageNum = m.lnDocPageNum + 1
		
		
		            ***********************************
		            * Render page 
		            ***********************************
		            This.env.API_WIN.StartPage(m.lhPrinterDC)
		            
		            LOCAL lnPrintX, lnPrintY, lnPrintWidth, lnPrintHeight
		            m.lnPrintX = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETY), This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETX))
		            m.lnPrintY = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETX), This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETY))
		
		            m.lnPrintWidth = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, m.laPrnForm[m.lnPaperSize,4], m.laPrnForm[m.lnPaperSize,3])
		            m.lnPrintHeight = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, m.laPrnForm[m.lnPaperSize,3], m.laPrnForm[m.lnPaperSize,4])
		            m.lnPrintWidth = (m.lnPrintWidth / (25.4 * 1000)) * m.lnPrinterDPI
		            m.lnPrintHeight = (m.lnPrintHeight / (25.4 * 1000)) * m.lnPrinterDPI
		
		            #if .F. && pdfium style scaling "fill printable area" (not implemented). Only print without scaling is implemented
		            m.lnPrintWidth = m.lnPrintWidth - m.lnPrintX * 2
		            m.lnPrintHeight = m.lnPrintHeight - m.lnPrintY * 2
		            #endif
		            
		            m.lnPrintX = 0
		            m.lnPrintY = 0
		            
		            LOCAL lnPrintRotate
		            m.lnPrintRotate = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, IIF(m.lnPageWidth > m.lnPageHeight, 0, 1), IIF(m.lnPageWidth > m.lnPageHeight, 1, 0))
		            IF m.lnPrinterDuplex = DMDUP_VERTICAL AND MOD(m.lnDocPageNum,2) = 0
		                m.lnPrintRotate = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, IIF(m.lnPageWidth > m.lnPageHeight, 2, 1), IIF(m.lnPageWidth > m.lnPageHeight, 3, 0)) 
		            ENDIF
		            
		            LOCAL lnFPDF_Page 
		            m.lnFPDF_Page = This.fpdf_pages[m.lnPageIndex]
		            
		            IF EMPTY(m.lnFPDF_Page) = .F.
		                
		                m.loFPDF.FPDF_RenderPage(m.lhPrinterDC, ;
		                    m.lnFPDF_Page, ;
		                    m.lnPrintX, ;
		                    m.lnPrintY, ;
		                    m.lnPrintWidth, ;
		                    m.lnPrintHeight, ;
		                    m.lnPrintRotate, ;
		                    m.loFPDF.CONST.FPDF_PRINTING())
		
		            ENDIF
		            
		            This.env.API_WIN.EndPage(m.lhPrinterDC)
		            ***********************************
		            * / Render page 
		            ***********************************
		
		
		        ENDFOR
		
		    ENDFOR
		    
		
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		
		FINALLY
		    IF EMPTY(m.lhPrinterDC) = .F.
		        IF m.llStartDoc = .F.
		            This.env.API_WIN.EndDoc(m.lhPrinterDC)
		        ENDIF
		        This.env.API_WIN.DeleteDC(m.lhPrinterDC)
		    ENDIF
		    
		    IF EMPTY(m.lhDocNameHeap) = .F.
		        This.env.API_WIN.HeapDestroy(m.lhDocNameHeap)
		    ENDIF
		    
		ENDTRY
		
		
		
	ENDPROC

	PROCEDURE printenv_access
		
		IF VARTYPE(This._PrintEnv) <> "O"
		    This._PrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		ENDIF
		
		RETURN This._PrintEnv
		
	ENDPROC

	PROCEDURE printenv_assign
		LPARAMETERS vNewVal
		
		ERROR 1740, TEXTMERGE("<<This.Class>>.PrintEnv")
		
	ENDPROC

	HIDDEN PROCEDURE redraw
		LPARAMETERS tnWndDC
		
		LOCAL lnWndDC
		m.lnWndDC = EVL(m.tnWndDC, This.WndDC)
		
		IF EMPTY(m.lnWndDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDIB)
		    RETURN
		ENDIF
		
		IF VARTYPE(This.DrawBufGfx)<>"O"
		    RETURN
		ENDIF
		
		IF This.UIState.GetEffectivelyVisible() = .F.
		    RETURN
		ENDIF
		
		
		
		LOCAL lnWidth, lnHeight
		m.lnWidth = This.Width
		m.lnHeight = This.Height
		
		******************************************************************************
		LOCAL loGfx
		m.loGfx = This.DrawBufGfx
		m.loGfx.FillRectangle(This.BackColorBrush, 0,0, m.lnWidth, m.lnHeight)
		
		This.renderpages()
		
		m.loGfx.Flush()
		
		******************************************************************************
		#define FF_SRCCOPY 0x00CC0020
		
		This.env.API_WIN.BitBlt(m.lnWndDC, 0,0, m.lnWidth, m.lnHeight, This.DrawBufDC, 0, 0, FF_SRCCOPY)
		
	ENDPROC

	HIDDEN PROCEDURE renderpagefromcache
		LPARAMETERS lnPageIndex, lnPageScale
		
		IF EMPTY(This.WndDC)
		    RETURN .F.
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		m.lnPageScale = EVL(m.lnPageScale,1)
		m.lnPageScale = MIN(m.lnPageScale, ALEN(This.fpdf_pages_render_cache,2))
		
		**********************************************************************
		IF VARTYPE(This.fpdf_pages_render_cache[m.lnPageIndex,m.lnPageScale]) = "O"
		    RETURN This.fpdf_pages_render_cache[m.lnPageIndex, m.lnPageScale]
		ENDIF
		**********************************************************************
		
		
		#DEFINE FF_RGBQUAD_SIZE     4
		#DEFINE FF_DIB_RGB_COLORS   0
		#DEFINE FF_BFHDR_SIZE      14
		#DEFINE FF_BHDR_SIZE       40
		#DEFINE FF_BI_RGB           0
		
		LOCAL lhPageDC
		m.lhPageDC = This.env.API_WIN.CreateCompatibleDC(This.WndDC)
		
		IF EMPTY(m.lhPageDC)
		    RETURN .F.
		ENDIF
		
		
		LOCAL lnPageWidth, lnPageHeight
		m.lnPageWidth = m.lnPageScale * This.GetPageSize(m.lnPageIndex,3)
		m.lnPageHeight = m.lnPageScale * This.GetPageSize(m.lnPageIndex,4)
		
		
		LOCAL lnBitsPerPixel
		m.lnBitsPerPixel = 16
		
		LOCAL lcBMI
		m.lcBMI = BINTOC(FF_BHDR_SIZE ,"4RS") + BINTOC(m.lnPageWidth,"4RS") + BINTOC(m.lnPageHeight, "4RS") + ;
		        (CHR(MOD(1,256)) + CHR(INT(1/256))) + (CHR(MOD(m.lnBitsPerPixel,256))+ CHR(INT(m.lnBitsPerPixel/256))) +;
		        BINTOC(FF_BI_RGB, "4RS") + REPLICATE(0h00, 20)
		
		
		LOCAL lnDibDataPtr
		m.lnDibDataPtr = 0
		
		LOCAL lhPageDIB
		m.lhPageDIB = This.env.API_WIN.CreateDIBSection(m.lhPageDC, m.lcBMI, FF_DIB_RGB_COLORS, @m.lnDibDataPtr, 0, 0)
		
		IF EMPTY(m.lhPageDIB)=.T.
		    This.env.API_WIN.DeleteDC(m.lhPageDC)
		    RETURN .F.
		ENDIF
		
		This.env.API_WIN.SelectObject(m.lhPageDC, m.lhPageDIB)
		
		LOCAL loGfx
		m.loGfx = This.env.System.Drawing.Graphics.FromHDC(m.lhPageDC)
		m.loGfx.FillRectangle(This.env.System.Drawing.Brushes.White, 0, 0, m.lnPageWidth, m.lnPageHeight)
		
		LOCAL lnFPDF_Page 
		m.lnFPDF_Page = This.fpdf_pages[m.lnPageIndex]
		
		m.loFPDF.FPDF_RenderPage(m.lhPageDC, m.lnFPDF_Page, 0, 0, m.lnPageWidth, m.lnPageHeight, 0, 0)
		
		LOCAL loBmp
		m.loBmp = This.env.System.Drawing.Bitmap.FromHbitmap(m.lhPageDIB)
		
		This.env.API_WIN.DeleteObject(m.lhPageDIB)
		This.env.API_WIN.DeleteDC(m.lhPageDC)
		
		**********************************************************************
		LOCAL loStream
		m.loStream = This.env.System.IO.MemoryStream.New()
		
		m.loBmp.Save(m.loStream, This.env.System.Drawing.Imaging.ImageFormat.Png)
		
		LOCAL loPng
		m.loPng = This.env.System.Drawing.Image.FromStream(m.loStream)
		
		This.fpdf_pages_render_cache[m.lnPageIndex, m.lnPageScale] = m.loPng
		
		RETURN m.loPng
		
		
	ENDPROC

	HIDDEN PROCEDURE renderpages
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.fpdf_page_first_visible)
		    RETURN
		ENDIF
		
		LOCAL lnPageWidthUnscaled, lnPageHeightUnscaled
		LOCAL lnPageX, lnPageY
		LOCAL lnPageWidth, lnPageHeight
		LOCAL lnPageRenderScale
		
		LOCAL lnPage
		FOR m.lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		    m.lnPageWidthUnscaled = This.GetPageSize(m.lnPage,3)
		    m.lnPageHeightUnscaled = This.GetPageSize(m.lnPage,4)
		
		    m.lnPageX = This.fpdf_pages_pos[m.lnPage,1] - This.ViewPortX
		    m.lnPageY = This.fpdf_pages_pos[m.lnPage,2] - This.ViewPortY
		    m.lnPageWidth = This.fpdf_pages_pos[m.lnPage,3]
		    m.lnPageHeight = This.fpdf_pages_pos[m.lnPage,4]
		
		
		    m.lnPageRenderScale = MAX(CEILING(m.lnPageWidth / EVL(m.lnPageWidthUnscaled,m.lnPageWidth)),1)
		    m.lnPageRenderScale = MIN(m.lnPageRenderScale, ALEN(This.fpdf_pages_render_cache,2))
		    
		    LOCAL loPng
		    m.loPng = This.RenderPageFromCache(m.lnPage, m.lnPageRenderScale)
		    
		    IF VARTYPE(m.loPng)="O"
		        This.DrawBufGfx.DrawImage(m.loPng, m.lnPageX, m.lnPageY, m.lnPageWidth, m.lnPageHeight)
		        This.RenderSearch(m.lnPage)
		        This.RenderSelection(m.lnPage)
		    ENDIF
		    
		ENDFOR
		
		
	ENDPROC

	HIDDEN PROCEDURE rendersearch
		LPARAMETERS lnPage
		
		IF m.lnPage <> This.SearchState_ResPage
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL loGfx
		m.loGfx = This.DrawBufGfx
		
		LOCAL lnRectCount
		m.lnRectCount = LEN(This.SearchState_ResRect)/32
		
		LOCAL lnRect, lcRect
		FOR m.lnRect = 1 TO m.lnRectCount
		    
		    m.lcRect = SUBSTR(This.SearchState_ResRect, 32*(m.lnRect-1) + 1, 32)
		    
		    LOCAL lnPageLeft,lnPageTop,lnPageRight,lnPageBottom
		    m.lnPageLeft = CTOBIN(SUBSTR(m.lcRect,1,8),"B")
		    m.lnPageTop = CTOBIN(SUBSTR(m.lcRect,9,8),"B")
		    m.lnPageRight = CTOBIN(SUBSTR(m.lcRect,17,8),"B")
		    m.lnPageBottom = CTOBIN(SUBSTR(m.lcRect,25,8),"B")
		    
		       
		    LOCAL lnLeft, lnTop, lnRight, lnBottom
		    STORE 0 TO m.lnLeft, m.lnTop, m.lnRight, m.lnBottom
		    
		    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPage], This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnPageLeft, m.lnPageTop, @m.lnLeft, @m.lnTop) = 0
		        LOOP
		    ENDIF
		    
		    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPage], This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnPageRight, m.lnPageBottom, @m.lnRight, @m.lnBottom) = 0
		        LOOP
		    ENDIF
		    
		    m.loGfx.FillRectangle(This.SearchBrush, m.lnLeft, m.lnTop, m.lnRight - m.lnLeft, m.lnBottom - m.lnTop)
		ENDFOR
		
		
	ENDPROC

	HIDDEN PROCEDURE renderselection
		LPARAMETERS lnPage
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL loGfx
		m.loGfx = This.DrawBufGfx
		
		LOCAL lnRectCount
		m.lnRectCount = LEN(This.fpdf_pages_selection[m.lnPage,1])/32
		
		LOCAL lnRect, lcRect
		FOR m.lnRect = 1 TO m.lnRectCount
		    
		    m.lcRect = SUBSTR(This.fpdf_pages_selection[m.lnPage,1], 32*(m.lnRect-1) + 1, 32)
		    
		    LOCAL lnPageLeft,lnPageTop,lnPageRight,lnPageBottom
		    m.lnPageLeft = CTOBIN(SUBSTR(m.lcRect,1,8),"B")
		    m.lnPageTop = CTOBIN(SUBSTR(m.lcRect,9,8),"B")
		    m.lnPageRight = CTOBIN(SUBSTR(m.lcRect,17,8),"B")
		    m.lnPageBottom = CTOBIN(SUBSTR(m.lcRect,25,8),"B")
		    
		    
		    LOCAL lnLeft, lnTop, lnRight, lnBottom
		    STORE 0 TO m.lnLeft, m.lnTop, m.lnRight, m.lnBottom
		    
		    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPage], This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnPageLeft, m.lnPageTop, @m.lnLeft, @m.lnTop) = 0
		        LOOP
		    ENDIF
		    
		    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPage], This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnPageRight, m.lnPageBottom, @m.lnRight, @m.lnBottom) = 0
		        LOOP
		    ENDIF
		        
		    m.loGfx.FillRectangle(This.SelectionBrush, m.lnLeft, m.lnTop, m.lnRight - m.lnLeft, m.lnBottom - m.lnTop)
		ENDFOR
		
	ENDPROC

	HIDDEN PROCEDURE Resize
		This.WndResize()
		
	ENDPROC

	PROCEDURE savedocument		&& Save document to file
		LPARAMETERS tcFileName
		
		IF EMPTY(This.fpdf_doc)
		    RETURN .F.
		ENDIF
		
		IF VARTYPE(m.tcFileName) <> "C"
		    RETURN .F.
		ENDIF
		
		
		LOCAL lcFileName
		m.lcFileName = ALLTRIM(EVL(NVL(m.tcFileName,""), ""))
		
		IF EMPTY(m.lcFileName)
		    RETURN .F.
		ENDIF
		
		LOCAL lcErrMsg
		m.lcErrMsg = SPACE(500)
		This.env.API_FPDF.VFPDF_SaveDocument(This.fpdf_doc, m.lcFilename, @m.lcErrMsg, LEN(m.lcErrMsg))
		
		IF EMPTY(m.lcErrMsg)=.F.
		    This.ErrMsg(ALLTRIM(m.lcErrMsg))
		    RETURN .F.
		ENDIF
		
		
	ENDPROC

	HIDDEN PROCEDURE scale_assign
		LPARAMETERS vNewVal
		
		
		This.Scale = MIN(MAX(EVL(NVL(m.vNewVal,0),0),0.2),4)
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE scrollbars_assign
		LPARAMETERS vNewVal
		
		This.ScrollBars = IIF(INLIST(m.vNewVal, 0,1,2,3), m.vNewVal, This.ScrollBars)
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE scrollhorz
		LPARAMETERS tnScroll, tlPage, tlRelative
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL lnScroll
		m.lnScroll = EVL(NVL(m.tnScroll,0),0)
		
		DO CASE
		CASE m.tlPage=.F. AND m.tlRelative = .T.
		    This.ViewPortX = This.ViewPortX + m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .T.
		    This.ViewPortX = This.ViewPortX + m.lnScroll * This.ViewPortSizeX
		    
		CASE m.tlPage=.F. AND m.tlRelative = .F.
		    This.ViewPortX = m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .F.
		    This.ViewPortX = (m.lnScroll - 1) * This.ViewPortSizeX
		
		ENDCASE
		
		This.ViewPortUpdate()
		
		This.WndRedraw()
		
	ENDPROC

	HIDDEN PROCEDURE scrollvert
		LPARAMETERS tnScroll, tlPage, tlRelative
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL lnScroll
		m.lnScroll = EVL(NVL(m.tnScroll,0),0)
		
		DO CASE
		CASE m.tlPage=.F. AND m.tlRelative = .T.
		    This.ViewPortY = This.ViewPortY + m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .T.
		    This.ViewPortY = This.ViewPortY + m.lnScroll * This.ViewPortSizeY
		    
		CASE  m.tlPage=.F. AND m.tlRelative = .F.
		    This.ViewPortY = m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .F.
		    This.ViewPortY = (m.lnScroll - 1) * This.ViewPortSizeY
		
		ENDCASE
		
		This.ViewPortUpdate()
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE searchclose		&& Stop search
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.SearchState_FindWhat = ""
		This.SearchState_Dir = 0
		
		This.SearchState_ResPage = 0
		This.SearchState_ResIndex = 0
		This.SearchState_ResCount = 0
		This.SearchState_ResRect = ""
		
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE searchtext		&& Text for searching. SearchClose must be called to stop search results rendering
		LPARAMETERS tcFindWhat, tnDirection, tlMatchCase, tlMatchWholeWord
		
		* tcFindWhat - text to find
		* tnDirection - search direction: 1 - forward (default), 2 - backward
		* tlMatchCase - .T. - case sensitive, .F. - case insensitive (default)
		* tlMatchWholeWord - .T. match whole word, .F. - not match whole word (default)
		
		* return value: -1 - error, 0 - not found, 1 - found, 2 - search ended
		
		#define SCH_ERROR -1
		#define SCH_NOT_FOUND 0
		#define SCH_FOUND 1
		#define SCH_ENDED 2
		
		#define SCH_FWD 1
		#define SCH_BCK 2
		
		#define SCH_WHITESPACE CHR(0x00)+CHR(0x09) + CHR(0x00)+CHR(0x0A) + CHR(0x00)+CHR(0x0B) + CHR(0x00)+CHR(0x0C) + CHR(0x00)+CHR(0x0D) + CHR(0x00)+CHR(0x20) + CHR(0x00)+CHR(0x85) + CHR(0x00)+CHR(0xA0) + CHR(0x16)+CHR(0x80) + CHR(0x20)+CHR(0x00) + CHR(0x20)+CHR(0x01) + CHR(0x20)+CHR(0x02) + CHR(0x20)+CHR(0x03) + CHR(0x20)+CHR(0x04) + CHR(0x20)+CHR(0x05) + CHR(0x20)+CHR(0x06) + CHR(0x20)+CHR(0x07) + CHR(0x20)+CHR(0x08) + CHR(0x20)+CHR(0x09) + CHR(0x20)+CHR(0x0A) + CHR(0x20)+CHR(0x28) + CHR(0x20)+CHR(0x29) + CHR(0x20)+CHR(0x2F) + CHR(0x20)+CHR(0x5F) + CHR(0x30)+CHR(0x00)
		#define SCH_PUNCTIATION CHR(0x00)+CHR(0x21) + CHR(0x00)+CHR(0x22) + CHR(0x00)+CHR(0x23) + CHR(0x00)+CHR(0x25) + CHR(0x00)+CHR(0x26) + CHR(0x00)+CHR(0x27) + CHR(0x00)+CHR(0x2A) + CHR(0x00)+CHR(0x2C) + CHR(0x00)+CHR(0x2D) + CHR(0x00)+CHR(0x2E) + CHR(0x00)+CHR(0x2F) + CHR(0x00)+CHR(0x3A) + CHR(0x00)+CHR(0x3B) + CHR(0x00)+CHR(0x3D) + CHR(0x00)+CHR(0x3F) + CHR(0x20)+CHR(0x10) + CHR(0x20)+CHR(0x11) + CHR(0x20)+CHR(0x12) + CHR(0x20)+CHR(0x13) + CHR(0x20)+CHR(0x14) + CHR(0x20)+CHR(0x15) + CHR(0x00)+CHR(0xAB) + CHR(0x00)+CHR(0xBB) + CHR(0x20)+CHR(0x18) + CHR(0x20)+CHR(0x19) + CHR(0x20)+CHR(0x1B) + CHR(0x20)+CHR(0x1C) + CHR(0x20)+CHR(0x1D) + CHR(0x00)+CHR(0x28) + CHR(0x00)+CHR(0x29) + CHR(0x00)+CHR(0x5B) + CHR(0x00)+CHR(0x5C) + CHR(0x00)+CHR(0x5D) + CHR(0x00)+CHR(0x7B) + CHR(0x00)+CHR(0x7D) + CHR(0x20)+CHR(0x1A) + CHR(0x20)+CHR(0x1E)
		
		IF This.fpdf_opened = .F.
		    RETURN SCH_ERROR
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL lcFindWhat, lnDirection, llMatchCase, llMatchWholeWord
		
		m.lcFindWhat = CHRTRAN(ALLTRIM(EVL(NVL(m.tcFindWhat,""),"")), CHR(10)+CHR(13)+CHR(9),"")
		m.lnDirection = EVL(NVL(m.tnDirection,0), SCH_FWD)
		m.llMatchCase = EMPTY(NVL(m.tlMatchCase,.F.))=.F.
		m.llMatchWholeWord = EMPTY(NVL(m.tlMatchWholeWord,.F.))=.F.
		
		#define LOCALE_USER_DEFAULT       0x0400
		
		#define FIND_FROMSTART            0x00400000  && look for value in source, starting at the beginning
		#define FIND_FROMEND              0x00800000  && look for value in source, starting at the end
		
		#define NORM_IGNORECASE           0x00000001  && ignore case
		#define NORM_IGNORENONSPACE       0x00000002  && ignore nonspacing chars
		#define NORM_IGNORESYMBOLS        0x00000004  && ignore symbols
		
		
		LOCAL lnSearchFlags
		m.lnSearchFlags = 0
		m.lnSearchFlags = m.lnSearchFlags + IIF(m.lnDirection = SCH_BCK, FIND_FROMEND, FIND_FROMSTART)
		m.lnSearchFlags = m.lnSearchFlags + IIF(m.llMatchCase=.T., 0, NORM_IGNORECASE)
		
		LOCAL llNewSearch
		m.llNewSearch = .F.
		DO CASE
		CASE m.lnDirection <> This.SearchState_Dir
		    m.llNewSearch = .T.
		CASE NOT m.lcFindWhat == This.SearchState_FindWhat
		    m.llNewSearch = .T.
		ENDCASE
		
		
		LOCAL lnSearchStartPage, lnSearchStartIndex
		m.lnSearchStartPage = EVL(This.SearchState_ResPage, EVL(This.fpdf_page_first_visible,1))
		m.lnSearchStartIndex = This.SearchState_ResIndex + IIF(m.lnDirection = SCH_BCK, 0, This.SearchState_ResCount)
		
		IF m.llNewSearch = .T.    
		    IF NOT (m.lcFindWhat == This.SearchState_FindWhat)
		        m.lnSearchStartPage = EVL(This.fpdf_page_first_visible,1)
		        m.lnSearchStartIndex = IIF(m.lnDirection = SCH_BCK, -1, 0)
		    ENDIF
		    
		    This.SearchClose()
		ENDIF
		
		This.SearchState_FindWhat = m.lcFindWhat
		This.SearchState_Dir = m.lnDirection
		
		
		IF EMPTY(m.lcFindWhat)
		    RETURN SCH_NOT_FOUND
		ENDIF
		
		
		
		LOCAL lnLocaleId
		m.lnLocaleId = This.i18n.GetLocaleID()
		
		LOCAL lcFindWhatUnicode
		m.lcFindWhatUnicode = ""
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    m.lcFindWhatUnicode = STRCONV(m.lcFindWhat, 5, m.lnLocaleId)
		
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		ENDTRY
		
		IF LEN(m.lcFindWhatUnicode) = 0
		    RETURN SCH_ERROR
		ENDIF
		
		
		LOCAL lnPageIndex
		m.lnPageIndex = m.lnSearchStartPage
		
		DO WHILE m.lnPageIndex > 0 AND m.lnPageIndex <= This.fpdf_pagecount
		
		    LOCAL lnFPDF_Text_Page
		    m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPageIndex]
		
		    LOCAL lnFindResIndex, lnFindResCount
		    m.lnFindResIndex = -1
		    m.lnFindResCount = 0
		
		    LOCAL lnPageTextLen, lcPageText
		    m.lnPageTextLen = MAX(m.loFPDF.FPDFText_CountChars(m.lnFPDF_Text_Page), 0)
		    
		    DO CASE
		    CASE EMPTY(m.lnPageTextLen)
		    
		    CASE m.lnDirection = SCH_FWD
		        m.lnPageTextLen = MAX(m.lnPageTextLen - m.lnSearchStartIndex, 0)
		        m.lcPageText = REPLICATE(CHR(0), m.lnPageTextLen * 2)
		        m.lnPageTextLen = m.loFPDF.FPDFText_GetText(m.lnFPDF_TEXT_PAGE, m.lnSearchStartIndex, m.lnPageTextLen, @m.lcPageText)
		
		        IF m.lnPageTextLen > 0
		            m.lnFindResIndex = This.env.API_WIN.FindNLSString(LOCALE_USER_DEFAULT, m.lnSearchFlags, m.lcPageText + CHR(0), -1, m.lcFindWhatUnicode + CHR(0), -1, @m.lnFindResCount)
		            
		            IF m.lnFindResIndex >= 0
		                m.lnFindResIndex = m.lnSearchStartIndex + m.lnFindResIndex
		            ENDIF
		        ENDIF
		    
		    CASE m.lnDirection = SCH_BCK
		        m.lnPageTextLen = MAX(IIF(m.lnSearchStartIndex < 0,  m.lnPageTextLen, m.lnSearchStartIndex), 0)
		        m.lcPageText = REPLICATE(CHR(0), m.lnPageTextLen * 2)
		        m.lnPageTextLen = m.loFPDF.FPDFText_GetText(m.lnFPDF_TEXT_PAGE, 0, m.lnPageTextLen, @m.lcPageText)
		        
		        IF m.lnPageTextLen > 0
		            m.lnFindResIndex = This.env.API_WIN.FindNLSString(LOCALE_USER_DEFAULT, m.lnSearchFlags, m.lcPageText + CHR(0), -1, m.lcFindWhatUnicode + CHR(0), -1, @m.lnFindResCount)
		        ENDIF
		    
		    ENDCASE
		
		
		    IF m.llMatchWholeWord = .T. AND m.lnFindResIndex >= 0 AND m.lnFindResCount > 0
		        LOCAL lcNextChar
		        m.lcNextChar = BINTOC(m.loFPDF.FPDFText_GetUnicode(m.lnFPDF_Text_Page, m.lnFindResIndex + m.lnFindResCount), "2RS")
		
		        DO CASE
		        CASE m.lcNextChar == CHR(0)+CHR(0)
		        CASE AT(m.lcNextChar, SCH_WHITESPACE) <> 0 
		        CASE AT(m.lcNextChar, SCH_PUNCTIATION) <> 0
		        OTHERWISE
		            m.lnSearchStartIndex = IIF(m.lnDirection = SCH_BCK, m.lnFindResIndex, m.lnFindResIndex + m.lnFindResCount)
		            LOOP
		        ENDCASE
		    ENDIF
		
		
		    IF m.lnFindResIndex >= 0 AND m.lnFindResCount > 0
		        This.SearchState_ResPage = m.lnPageIndex
		        This.SearchState_ResIndex = m.lnFindResIndex
		        This.SearchState_ResCount = m.lnFindResCount
		
		        LOCAL lnRectCount
		        m.lnRectCount = m.loFPDF.FPDFText_CountRects(m.lnFPDF_Text_Page, m.lnFindResIndex, m.lnFindResCount)
		
		        This.SearchState_ResRect = ""
		        
		        LOCAL lnPageLeft as Double, lnPageRight as Double, lnPageBottom as Double, lnPageTop as Double
		        STORE 0 TO m.lnPageLeft, m.lnPageRight, m.lnPageBottom, m.lnPageTop
		
		        LOCAL lnRect
		        FOR m.lnRect=1 TO m.lnRectCount
		            IF m.loFPDF.FPDFText_GetRect(m.lnFPDF_Text_Page, m.lnRect-1, @m.lnPageLeft, @m.lnPageTop, @m.lnPageRight, @m.lnPageBottom) > 0
		                This.SearchState_ResRect = This.SearchState_ResRect + BINTOC(m.lnPageLeft,"8")+BINTOC(m.lnPageTop,"8")+BINTOC(m.lnPageRight,"8")+BINTOC(m.lnPageBottom,"8")
		                
		                IF m.lnRect = 1
		                    LOCAL lnLeft, lnTop
		                    STORE 0 TO m.lnLeft, m.lnTop
		                    
		                    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPageIndex], 0, 0, This.fpdf_pages_pos[m.lnPageIndex,3], This.fpdf_pages_pos[m.lnPageIndex,4], 0, m.lnPageLeft, m.lnPageTop, @m.lnLeft, @m.lnTop) > 0
		                        LOCAL lnScrollVert
		                        m.lnScrollVert = This.fpdf_pages_pos[m.lnPageIndex,2] + m.lnTop
		                        m.lnScrollVert = m.lnScrollVert - This.ViewPortSizeY * 0.5
		                        This.ScrollVert(m.lnScrollVert)
		
		                        LOCAL lnScrollHorz
		                        m.lnScrollHorz = This.fpdf_pages_pos[m.lnPageIndex,1] + m.lnLeft
		                        m.lnScrollHorz = m.lnScrollHorz - This.ViewPortSizeX * 0.5
		                        This.ScrollHorz(m.lnScrollHorz)
		                    ENDIF
		                ENDIF
		            ENDIF
		        ENDFOR
		
		        This.WndRedraw()
		        
		        RETURN SCH_FOUND
		    ENDIF
		
		
		    IF m.lnDirection = SCH_BCK
		        m.lnPageIndex = m.lnPageIndex - 1
		        m.lnSearchStartIndex = -1
		    ELSE
		        m.lnPageIndex = m.lnPageIndex + 1
		        m.lnSearchStartIndex = 0
		    ENDIF
		    
		    
		    
		ENDDO
		
		IF EMPTY(This.SearchState_ResCount)=.F.
		    RETURN SCH_ENDED
		ELSE
		    RETURN SCH_NOT_FOUND
		ENDIF
		
	ENDPROC

	PROCEDURE selectioncopy		&& Copy selected text to clipboard
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		#define CF_TEXT       1
		#define CF_UNICODETEXT 13
		#DEFINE CF_LOCALE     16
		#define GMEM_MOVEABLE 0x0002
		#define GMEM_ZEROINIT 0x0040
		
		
		LOCAL lcCopyText
		m.lcCopyText = ""
		
		LOCAL lnPage, lnFPDF_TEXT_PAGE, lnSelStart, lnSelCount
		FOR m.lnPage = 1 TO This.fpdf_pagecount
		
		    m.lnFPDF_TEXT_PAGE = This.FPDF_TEXT_PAGES[m.lnPage]
		    m.lnSelStart = EVL(This.fpdf_pages_selection[m.lnPage,2],0)
		    m.lnSelCount = EVL(This.fpdf_pages_selection[m.lnPage,3],0)
		    
		    IF m.lnSelCount = 0
		        LOOP
		    ENDIF
		    
		    LOCAL lcBuffer, lnBufLen
		    m.lcBuffer = REPLICATE(CHR(0), m.lnSelCount * 2)
		    m.lnBufLen = m.loFPDF.FPDFText_GetText(m.lnFPDF_TEXT_PAGE, m.lnSelStart, m.lnSelCount, @m.lcBuffer)
		    
		    IF m.lnBufLen > 0
		        m.lcCopyText = m.lcCopyText + m.lcBuffer
		    ENDIF
		
		ENDFOR
		
		IF EMPTY(m.lcCopyText)=.F.
		    
		    LOCAL lnCopyTextLen
		    m.lnCopyTextLen = LEN(m.lcCopyText)
		
		    LOCAL lnDefaultLocaleID
		    m.lnDefaultLocaleID = EVL(This.env.API_WIN.GetSystemDefaultLCID(), 1033) &&English LocaleID = 1033
		
		    IF This.env.API_WIN.OpenClipboard(0) = 0
		        RETURN
		    ENDIF
		    
		    This.env.API_WIN.EmptyClipboard()
		
		    LOCAL lnMemHandle
		    m.lnMemHandle = This.env.API_WIN.GlobalAlloc(GMEM_MOVEABLE + GMEM_ZEROINIT, m.lnCopyTextLen+2)
		    
		    IF m.lnMemHandle <> 0
		        LOCAL lnMemPtr
		        m.lnMemPtr = This.env.API_WIN.GlobalLock(m.lnMemHandle)
		        IF m.lnMemPtr <> 0
		            SYS(2600, m.lnMemPtr, m.lnCopyTextLen, m.lcCopyText)
		        ENDIF
		        This.env.API_WIN.GlobalUnlock(m.lnMemHandle)
		        
		        This.env.API_WIN.SetClipboardData(CF_UNICODETEXT, m.lnMemHandle)
		        
		        This.env.API_WIN.GlobalFree(m.lnMemHandle)
		    ENDIF
		
		
		    LOCAL lnMemHandle
		    m.lnMemHandle = This.env.API_WIN.GlobalAlloc(GMEM_MOVEABLE + GMEM_ZEROINIT, 4)
		    IF m.lnMemHandle <> 0
		        LOCAL lnMemPtr
		        m.lnMemPtr = This.env.API_WIN.GlobalLock(m.lnMemHandle)
		        IF m.lnMemPtr <> 0
		            SYS(2600, m.lnMemPtr, 4, BINTOC(m.lnDefaultLocaleID, "4RS"))
		        ENDIF
		        This.env.API_WIN.GlobalUnlock(m.lnMemHandle)
		        
		        This.env.API_WIN.SetClipboardData(CF_LOCALE, m.lnMemHandle)
		        
		        This.env.API_WIN.GlobalFree(m.lnMemHandle)
		    ENDIF
		
		    This.env.API_WIN.CloseClipboard()
		
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE selecttext
		LPARAMETERS tnPage, tnStartIndex, tnCount
		
		* tnPage - page index, from 1 to This.fpdf_pagecount, 0 for all pages
		* tnStartIndex - Index for the start character (zero-based)
		* tnCount - Number of characters, or -1 for all remaining.
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		
		LOCAL lnPage, lnStartIndex, lnCount
		m.lnPage = EVL(m.tnPage,0)
		m.lnStartIndex = EVL(m.tnStartIndex,0)
		m.lnCount = EVL(m.tnCount, 0)
		
		IF m.lnStartIndex < 0
		    RETURN
		ENDIF
		IF m.lnCount < -1
		    RETURN
		ENDIF
		
		
		LOCAL lnPageStart, lnPageEnd
		m.lnPageStart = EVL(m.lnPage,1)
		m.lnPageEnd = EVL(m.lnPage,This.fpdf_pagecount)
		
		FOR m.lnPage = m.lnPageStart TO m.lnPageEnd
		    LOCAL lnFPDF_Text_Page
		    m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPage]
		
		    LOCAL lnCountChars
		    DO CASE
		    CASE m.lnCount = 0
		        m.lnCountChars = 0
		         
		    CASE m.lnCount = -1
		        m.lnCountChars = MAX(m.loFPDF.FPDFText_CountChars(m.lnFPDF_Text_Page) - m.lnStartIndex,0)
		
		    CASE m.loFPDF.FPDFText_CountChars(m.lnFPDF_Text_Page) >= m.lnStartIndex + m.lnCount
		        m.lnCountChars = m.lnCount
		
		    OTHERWISE
		        m.lnCountChars = 0
		
		    ENDCASE
		    
		    LOCAL lnRectCount
		    IF m.lnCountChars > 0
		        m.lnRectCount = m.loFPDF.FPDFText_CountRects(m.lnFPDF_Text_Page, m.lnStartIndex, m.lnCountChars)
		    ELSE
		        m.lnRectCount = 0
		    ENDIF
		
		    IF m.lnRectCount > 0 
		        This.fpdf_pages_selection[m.lnPage,1] = ""
		        This.fpdf_pages_selection[m.lnPage,2] = m.lnStartIndex
		        This.fpdf_pages_selection[m.lnPage,3] = m.lnCountChars
		
		        LOCAL lnPageLeft as Double, lnPageRight as Double, lnPageBottom as Double, lnPageTop as Double
		        STORE 0 TO m.lnPageLeft, m.lnPageRight, m.lnPageBottom, m.lnPageTop
		
		        LOCAL lnRect
		        FOR m.lnRect=1 TO m.lnRectCount
		            IF m.loFPDF.FPDFText_GetRect(m.lnFPDF_Text_Page, m.lnRect-1, @m.lnPageLeft, @m.lnPageTop, @m.lnPageRight, @m.lnPageBottom) > 0
		                This.fpdf_pages_selection[m.lnPage,1] = This.fpdf_pages_selection[m.lnPage,1] + BINTOC(m.lnPageLeft,"8")+BINTOC(m.lnPageTop,"8")+BINTOC(m.lnPageRight,"8")+BINTOC(m.lnPageBottom,"8")
		            ENDIF
		        ENDFOR
		    ELSE
		        This.fpdf_pages_selection[m.lnPage,1] = ""
		        This.fpdf_pages_selection[m.lnPage,2] = 0
		        This.fpdf_pages_selection[m.lnPage,3] = 0
		    ENDIF
		    
		ENDFOR
		
		This.Redraw()
		
	ENDPROC

	PROCEDURE selecttextall		&& Select all text in the document
		This.SelectText(0,0,-1)
		
	ENDPROC

	HIDDEN PROCEDURE viewportupdate
		LOCAL lnVewPortUpdateStep
		m.lnVewPortUpdateStep = 1
		
		FOR m.lnVewPortUpdateStep = 1 TO 2
		
		    This.fpdf_page_first_visible = 0
		    This.fpdf_page_last_visible = 0
		
		    *********************************************************************
		
		    This.ViewPortSizeX = MAX(This.Width - IIF(INLIST(This.ScrollBars,2,3), SYSMETRIC(5),0), 0)
		    This.ViewPortSizeY = MAX(This.Height - IIF(INLIST(This.ScrollBars,1,3), SYSMETRIC(8),0), 0)
		
		
		    *********************************************************************
		
		    IF This.ViewPortMaxX > This.ViewPortSizeX
		        This.ViewPortX = MIN(MAX(-0.5 * (This.ViewPortMaxX - This.ViewPortSizeX), This.ViewPortX), MAX(0.5 * (This.ViewPortMaxX - This.ViewPortSizeX),0))
		    ELSE
		        This.ViewPortX = 0
		    ENDIF    
		
		    This.ViewPortY = MIN(MAX(This.ViewPortY,0), MAX(This.ViewPortMaxY - This.Height,0))
		
		
		
		
		    LOCAL lnViewPortMaxXNew
		    m.lnViewPortMaxXNew = 0
		
		    *********************************************************************
		    LOCAL lnPageX, lnPageY
		    STORE 0 TO m.lnPageX, m.lnPageY
		
		    LOCAL lnPageWidthUnscaled, lnPageHeightUnscaled
		    LOCAL lnPageWidthUnscaledFirst
		    LOCAL lnPageWidth, lnPageHeight
		
		
		    LOCAL lnPageCount, lnPage
		    m.lnPageCount = This.FPDF_PageCount
		
		    FOR m.lnPage = 1 TO m.lnPageCount
		        
		        m.lnPageWidthUnscaled = This.GetPageSize(m.lnPage,3)
		        m.lnPageHeightUnscaled = This.GetPageSize(m.lnPage,4)
		        
		        IF m.lnPage = 1
		            m.lnPageWidthUnscaledFirst = m.lnPageWidthUnscaled
		        ENDIF
		
		        m.lnPageWidth = m.lnPageWidthUnscaled
		        m.lnPageHeight = m.lnPageHeightUnscaled
		
		        IF This.FitWidth
		            m.lnPageWidth = This.ViewPortSizeX * m.lnPageWidthUnscaled / EVL(m.lnPageWidthUnscaledFirst, m.lnPageWidthUnscaled)
		            m.lnPageHeight = INT(m.lnPageHeight * m.lnPageWidth / EVL(m.lnPageWidthUnscaled,1))
		        ENDIF
		        
		        m.lnPageWidth = m.lnPageWidth * This.scale
		        m.lnPageHeight = m.lnPageHeight * This.scale    
		        
		        m.lnPageX = (This.ViewPortSizeX - m.lnPageWidth) * 0.5
		        
		        IF m.lnPage > 1
		            m.lnPageY = m.lnPageY +  MIN(MAX(INT(m.lnPageWidth * 0.02),5),40) &&page separator
		        ENDIF
		        
		        This.fpdf_pages_pos[m.lnPage,1] = m.lnPageX
		        This.fpdf_pages_pos[m.lnPage,2] = m.lnPageY
		
		        This.fpdf_pages_pos[m.lnPage,3] = m.lnPageWidth
		        This.fpdf_pages_pos[m.lnPage,4] = m.lnPageHeight
		       
		        DO CASE
		        CASE This.Width < 30
		        CASE m.lnPageY + m.lnPageHeight < This.ViewPortY
		        CASE m.lnPageY > This.ViewPortY + This.ViewPortSizeY
		        OTHERWISE
		
		            IF This.fpdf_page_first_visible = 0
		                This.fpdf_page_first_visible = m.lnPage
		            ENDIF
		            
		            This.fpdf_page_last_visible = m.lnPage
		            
		        ENDCASE
		        
		      
		        m.lnPageY = m.lnPageY + m.lnPageHeight
		        
		        m.lnViewPortMaxXNew = MAX(m.lnViewPortMaxXNew, m.lnPageWidth)
		        
		    ENDFOR
		
		
		    *********************************************************************
		    IF This.ViewPortMaxX > 0 && Adjust ViewPortX after scaling
		        This.ViewPortX = INT(This.ViewPortX * m.lnViewPortMaxXNew * 10000 / This.ViewPortMaxX) / 10000
		    ENDIF
		
		    This.ViewPortMaxX = m.lnViewPortMaxXNew
		
		    *********************************************************************
		    LOCAL lnViewPortYPrev
		    m.lnViewPortYPrev = This.ViewPortY
		
		    LOCAL lnViewPortMaxYNew
		    m.lnViewPortMaxYNew = m.lnPageY
		    
		    IF This.ViewPortMaxY > 0 && Adjust ViewPortY after scaling
		        This.ViewPortY = INT(This.ViewPortY * m.lnViewPortMaxYNew * 10000 / This.ViewPortMaxY) / 10000
		    ENDIF
		    
		    This.ViewPortMaxY = m.lnViewPortMaxYNew
		    
		    
		    IF m.lnViewPortYPrev <> This.ViewPortY
		        * ViewPortY changed, need to recalculate page visibility
		        * Go to the second step
		        LOOP 
		    ENDIF
		    
		    EXIT 
		
		ENDFOR
		
		
		*********************************************************************
		* Scrollbars update
		*********************************************************************
		IF EMPTY(This.WndHandle)=.T.
		    RETURN
		ENDIF
		
		#define SIF_RANGE 0x0001
		#define SIF_PAGE 0x0002
		#define SIF_POS 0x0004
		#define SIF_DISABLENOSCROLL 0x0008
		
		*********************************************************************
		* Vertical scrollbar update
		
		LOCAL lnScrollMin, lnScrollMax, lnScrollPageSize, lnScrollPos
		IF INLIST(This.ScrollBars,2,3) AND This.ViewPortSizeY > 0
		    m.lnScrollMin = 0
		    m.lnScrollMax = This.ViewPortMaxY
		    m.lnScrollPageSize = This.ViewPortSizeY
		    m.lnScrollPos = This.ViewPortY
		ELSE
		    m.lnScrollMin = 0
		    m.lnScrollMax = 0
		    m.lnScrollPageSize = 0
		    m.lnScrollPos = 0
		ENDIF
		
		LOCAL lcScrollInfo
		m.lcScrollInfo = ;
		    BINTOC(28, "4RS")+;
		    BINTOC(SIF_RANGE+SIF_PAGE+SIF_POS, "4RS")+;
		    BINTOC(m.lnScrollMin, "4RS")+;
		    BINTOC(m.lnScrollMax, "4RS")+;
		    BINTOC(m.lnScrollPageSize, "4RS")+;
		    BINTOC(m.lnScrollPos, "4RS")+;
		    BINTOC(0, "4RS")
		
		This.env.API_WIN.SetScrollInfo(This.WndHandle, 1, m.lcScrollInfo, 1)
		
		
		*********************************************************************
		* Horizontal scrollbar update
		
		LOCAL lnScrollMin, lnScrollMax, lnScrollPageSize, lnScrollPos
		IF INLIST(This.ScrollBars,1,3) AND This.ViewPortMaxX > This.ViewPortSizeX AND This.ViewPortSizeX > 0
		    m.lnScrollMin = -0.5 * (This.ViewPortMaxX - This.ViewPortSizeX)
		    m.lnScrollMax = 0.5 * (This.ViewPortMaxX - This.ViewPortSizeX)
		    m.lnScrollPageSize = This.ViewPortSizeX
		    m.lnScrollMax = m.lnScrollMax + m.lnScrollPageSize
		    m.lnScrollPos = MIN(MAX(m.lnScrollMin, This.ViewPortX), m.lnScrollMax)
		ELSE
		    m.lnScrollMin = 0
		    m.lnScrollMax = 0
		    m.lnScrollPageSize = 0
		    m.lnScrollPos = 0
		ENDIF
		
		LOCAL lcScrollInfo
		m.lcScrollInfo = ;
		    BINTOC(28, "4RS")+;
		    BINTOC(SIF_RANGE+SIF_PAGE+SIF_POS, "4RS")+;
		    BINTOC(m.lnScrollMin, "4RS")+;
		    BINTOC(m.lnScrollMax, "4RS")+;
		    BINTOC(m.lnScrollPageSize, "4RS")+;
		    BINTOC(m.lnScrollPos, "4RS")+;
		    BINTOC(0, "4RS")
		
		This.env.API_WIN.SetScrollInfo(This.WndHandle, 0, m.lcScrollInfo, 1)
		
		
		*********************************************************************
		* Events triggering
		This.AfterViewportUpdate()
		*********************************************************************
		
		
	ENDPROC

	HIDDEN PROCEDURE wndcreate
		
		#DEFINE WNDCLASSEX_SIZE 48
		#DEFINE GW_CHILD 5
		#DEFINE GWL_WNDPROC -4
		#DEFINE GWL_HINSTANCE -6
		#DEFINE GWL_STYLE -16
		#define CS_OWNDC            0x0020
		#define CS_PARENTDC         0x0080
		#define WS_CHILD            0x40000000
		#define WS_DISABLED         0x08000000
		#define WS_VISIBLE          0x10000000
		#define WS_CLIPSIBLINGS     0x04000000
		#define WS_CLIPCHILDREN     0x02000000
		#define WS_VSCROLL          0x00200000
		#define WS_HSCROLL          0x00100000
		#define GMEM_FIXED 0x0
		#define GMEM_ZEROINIT 0x0040
		
		
		LOCAL lhWndParent
		m.lhWndParent = This.env.API_WIN.GetWindow(Thisform.HWnd, GW_CHILD) && VFP window with ScrollBars != 0 or with ShowWindow = 2 - As Top-Level Form creates his own child window
		IF EMPTY(m.lhWndParent) = .F. AND Thisform.ShowWindow = 2 AND Thisform.ScrollBars <> 0
		    m.lhWndParent = EVL(This.env.API_WIN.GetWindow(m.lhWndParent, GW_CHILD), m.lhWndParent)
		ENDIF
		IF EMPTY(m.lhWndParent)=.T. OR (Thisform.ScrollBars = 0 AND Thisform.ShowWindow <> 2)
		    m.lhWndParent = Thisform.HWnd
		ENDIF
		
		LOCAL lhInstance
		m.lhInstance = This.env.API_WIN.GetModuleHandle(NULL)
		
		
		LOCAL lcWndClassEx
		m.lcWndClassEx = REPLICATE(CHR(0), WNDCLASSEX_SIZE)
		
		IF EMPTY( This.env.API_WIN.GetClassInfoEx(m.lhInstance, This.WndClassName, @m.lcWndClassEx) )
		
		    LOCAL lnWndClassNamePtr
		    m.lnWndClassNamePtr = This.env.API_WIN.GlobalAlloc(GMEM_FIXED + GMEM_ZEROINIT, LEN(This.WndClassName)+1)
		
		    SYS(2600, m.lnWndClassNamePtr, LEN(This.WndClassName), This.WndClassName)
		
		    m.lcWndClassEx = ;
		        BINTOC(WNDCLASSEX_SIZE, "4RS")+; &&cbSize
		        BINTOC(CS_PARENTDC,"4RS")+; &&style
		        BINTOC(This.env.API_WIN.GetWindowLong(Application.HWnd, GWL_WNDPROC),"4RS")+; &&lpfnWndProc
		        BINTOC(0,"4RS")+; &&cbClsExtra
		        BINTOC(0,"4RS")+; &&cbWndExtra
		        BINTOC(m.lhInstance,"4RS")+; &&hInstance
		        BINTOC(0,"4RS")+; &&hIcon
		        BINTOC(0,"4RS")+; &&hCursor
		        BINTOC(0,"4RS")+; &&hbrBackground
		        BINTOC(0,"4RS")+; &&lpszMenuName
		        BINTOC(m.lnWndClassNamePtr,"4RS")+; &&lpszClassName
		        BINTOC(0,"4RS") &&hIconSm
		
		    This.env.API_WIN.RegisterClassEx(m.lcWndClassEx)
		
		    This.env.API_WIN.GlobalFree(m.lnWndClassNamePtr)
		    
		ENDIF
		
		
		This.WndHandle = This.env.API_WIN.CreateWindowEx( ;
		    0, ;
		    This.WndClassName, ;
		    "", ;
		    WS_CHILD + WS_CLIPCHILDREN + WS_CLIPSIBLINGS + WS_HSCROLL + WS_VSCROLL, ;
		    0,0,1,1, ;
		    m.lhWndParent, ;
		    0, ;
		    m.lhInstance, ;
		    0)
		
		
		IF EMPTY(This.WndHandle)=.T.
		    This.errMsg("CreateWindowEx returned 0")
		    RETURN
		ENDIF
		
		******************************************************
		This.WndDC = This.env.API_WIN.GetDC(This.WndHandle)
		
		
		******************************************************
		#define WM_PAINT 0x000F
		BINDEVENT(This.WndHandle, WM_PAINT, This, "WndProc")
		
		#define WM_MOUSEACTIVATE 0x0021
		BINDEVENT(This.WndHandle, WM_MOUSEACTIVATE, This, "WndProc")
		
		#define WM_MOUSEMOVE 0x0200
		#define WM_LBUTTONDOWN 0x0201
		#define WM_RBUTTONUP 0x0205
		#define WM_MOUSEWHEEL 0x020A
		BINDEVENT(This.WndHandle, WM_MOUSEMOVE, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_LBUTTONDOWN, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_RBUTTONUP, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_MOUSEWHEEL, This, "WndProc")
		
		#define WM_VSCROLL 0x0115
		BINDEVENT(This.WndHandle, WM_VSCROLL, This, "WndProc")
		
		#define WM_HSCROLL 0x0114
		BINDEVENT(This.WndHandle, WM_HSCROLL, This, "WndProc")
		
		
		
	ENDPROC

	PROCEDURE wndproc		&& Events handler of PdfiumViewer internal window. Developer must not use or redefine this method
		LPARAMETERS thWnd, tnMsg, tnWParam, tnLParam
		
		#define GWL_WNDPROC -4
		#define WM_PAINT  0x000F
		#define WM_MOUSEACTIVATE 0x0021
		#define WM_VSCROLL 0x0115
		#define WM_HSCROLL 0x0114
		#define WM_MOUSEMOVE 0x0200
		#define WM_LBUTTONDOWN 0x0201
		#define WM_RBUTTONUP 0x0205
		#define WM_MOUSEWHEEL 0x020A
		#define MK_LBUTTON 0x0001
		#define MK_RBUTTON 0x0002
		#define MK_SHIFT 0x0004
		#define MK_CONTROL 0x0008
		
		
		#define SB_LINEUP           0
		#define SB_LINELEFT         0
		#define SB_LINEDOWN         1
		#define SB_LINERIGHT        1
		#define SB_PAGEUP           2
		#define SB_PAGELEFT         2
		#define SB_PAGEDOWN         3
		#define SB_PAGERIGHT        3
		#define SB_THUMBPOSITION    4
		#define SB_THUMBTRACK       5
		#define SB_TOP              6
		#define SB_LEFT             6
		#define SB_BOTTOM           7
		#define SB_RIGHT            7
		#define SB_ENDSCROLL        8
		#define SIF_TRACKPOS 0x0010
		#define SB_SCROLLINFO_TRACKPOS BINTOC(28, "4RS")+BINTOC(SIF_TRACKPOS, "4RS")+REPLICATE(CHR(0),20)
		
		
		LOCAL lnRetVal
		m.lnRetVal = 0
		
		DO CASE
		
		CASE This.UIState.GetEffectivelyVisible() = .F.
		 
		CASE m.tnMsg = WM_PAINT
		
		    LOCAL lcPaint
		    m.lcPaint = REPLICATE(CHR(0), 256)
		
		    LOCAL lnWndDC
		    m.lnWndDC = This.env.API_WIN.BeginPaint(m.thWnd, @m.lcPaint)
		
		    This.Redraw(m.lnWndDC)
		
		    This.env.API_WIN.EndPaint(m.thWnd, m.lcPaint)
		
		
		CASE This.UIState.GetEffectivelyEnabled() = .F.
		 
		
		CASE m.tnMsg = WM_MOUSEACTIVATE
		    IF This.IsFocused = .F.
		        LOCAL lSaveMousePointer
		        m.lSaveMousePointer = This.MousePointer
		        IF TYPE("Application.ActiveForm.HWnd") = "N"
		            IF Application.ActiveForm.WindowType <> 1 OR Application.ActiveForm.HWnd = Thisform.HWnd
		                This.SetFocus()
		            ENDIF
		        ENDIF
		        This.MousePointer = m.lSaveMousePointer
		    ENDIF
		    
		CASE INLIST(m.tnMsg, WM_MOUSEMOVE, WM_MOUSEWHEEL, WM_LBUTTONDOWN, WM_RBUTTONUP) 
		    LOCAL lnMBtn, lnMShift, lnMouseX, lnMouseY
		    m.lnMBtn = BITAND(m.tnWParam, MK_LBUTTON + MK_RBUTTON)
		    m.lnMShift = BITRSHIFT(BITAND(m.tnWParam, MK_SHIFT + MK_CONTROL),2)
		    m.lnMouseX = BITAND(m.tnLParam, 0xffff)
		    m.lnMouseY = BITAND(BITRSHIFT(m.tnLParam,16), 0xffff)
		    
		    DO CASE
		    
		    CASE INLIST(m.tnMsg, WM_MOUSEMOVE) AND This.IsFocused
		        This.MouseMove(m.lnMBtn, m.lnMShift, m.lnMouseX, m.lnMouseY)
		 
		    CASE INLIST(m.tnMsg, WM_MOUSEWHEEL)
		        LOCAL lnMWDir 
		        m.lnMWDir = BITAND(BITRSHIFT(m.tnWParam,16), 0xffff)
		        m.lnMWDir = IIF(BITTEST(m.lnMWDir,15), m.lnMWDir - 0xffff, m.lnMWDir)
		        
		        This.MouseWheel(m.lnMWDir, m.lnMShift, m.lnMouseX, m.lnMouseY)
		
		    CASE INLIST(m.tnMsg, WM_LBUTTONDOWN) AND This.IsFocused
		        This.MouseDown(1, m.lnMShift, m.lnMouseX, m.lnMouseY)
		        
		    CASE INLIST(m.tnMsg, WM_RBUTTONUP) AND This.IsFocused
		        This.MouseUp(2, m.lnMShift, m.lnMouseX, m.lnMouseY)
		
		    ENDCASE
		    
		    
		CASE m.tnMsg = WM_VSCROLL
		
		    LOCAL lnSbReq
		    m.lnSbReq = BITAND(m.tnWParam, 0xffff)
		     
		    DO CASE
		    CASE m.lnSbReq = SB_LINEUP
		       This.ScrollVert(-0.05 * This.Height, .F., .T.)
		
		    CASE m.lnSbReq = SB_LINEDOWN
		       This.ScrollVert(0.05 * This.Height, .F., .T.)
		
		    CASE m.lnSbReq = SB_PAGEUP
		       This.ScrollVert(-1, .T., .T.)
		
		    CASE m.lnSbReq = SB_PAGEDOWN
		       This.ScrollVert(1, .T., .T.)
		
		    CASE m.lnSbReq = SB_TOP
		       This.ScrollVert(0, .F., .F.)
		
		    CASE m.lnSbReq = SB_BOTTOM
		       This.ScrollVert(This.ViewPortMaxY, .F., .F.)
		
		    CASE m.lnSbReq = SB_THUMBTRACK
		       LOCAL lcScrollInfo
		       m.lcScrollInfo = SB_SCROLLINFO_TRACKPOS
		
		       IF This.env.API_WIN.GetScrollInfo(m.thWnd, 1, @m.lcScrollInfo) = 1
		           LOCAL lnSbPos
		           m.lnSbPos = CTOBIN(SUBSTR(m.lcScrollInfo,25,4),"4RS")
		           This.ScrollVert(m.lnSbPos)
		       ENDIF
		    ENDCASE
		
		
		CASE m.tnMsg = WM_HSCROLL
		
		    LOCAL lnSbReq
		    m.lnSbReq = BITAND(m.tnWParam, 0xffff)
		     
		    DO CASE
		    CASE m.lnSbReq = SB_LINELEFT
		       This.ScrollHorz(-0.05 * This.Width, .F., .T.)
		
		    CASE m.lnSbReq = SB_LINERIGHT
		       This.ScrollHorz(0.05 * This.Width, .F., .T.)
		
		    CASE m.lnSbReq = SB_PAGELEFT
		       This.ScrollHorz(-1, .T., .T.)
		
		    CASE m.lnSbReq = SB_PAGERIGHT
		       This.ScrollHorz(1, .T., .T.)
		
		    CASE m.lnSbReq = SB_LEFT
		       This.ScrollHorz(-This.ViewPortMaxY, .F., .F.)
		
		    CASE m.lnSbReq = SB_RIGHT
		       This.ScrollHorz(This.ViewPortMaxY, .F., .F.)
		
		    CASE m.lnSbReq = SB_THUMBTRACK
		       LOCAL lcScrollInfo
		       m.lcScrollInfo = SB_SCROLLINFO_TRACKPOS
		
		       IF This.env.API_WIN.GetScrollInfo(m.thWnd, 0, @m.lcScrollInfo) = 1
		           LOCAL lnSbPos
		           m.lnSbPos = CTOBIN(SUBSTR(m.lcScrollInfo,25,4),"4RS")
		           This.ScrollHorz(m.lnSbPos)
		       ENDIF
		    ENDCASE
		
		
		OTHERWISE
		    LOCAL lnWndProcDefault
		    m.lnWndProcDefault = This.env.API_WIN.GetWindowLong(m.thWnd, GWL_WNDPROC)
		    m.lnRetVal = This.env.API_WIN.CallWindowProc(m.lnWndProcDefault, m.thWnd, m.tnMsg, m.tnWParam, m.tnLParam)
		
		ENDCASE
		
		
		RETURN m.lnRetVal
		
	ENDPROC

	HIDDEN PROCEDURE wndredraw
		IF EMPTY(This.WndHandle)
		    RETURN
		ENDIF
		
		This.env.API_WIN.InvalidateRect(This.WndHandle, NULL, 1)
		
	ENDPROC

	HIDDEN PROCEDURE wndrelease
		IF EMPTY(This.WndDC) = .F.
		    This.env.API_WIN.ReleaseDC(This.WndHandle, This.WndDC)
		    This.WndDC = 0
		ENDIF
		
		IF EMPTY(This.WndHandle) = .F.
		    UNBINDEVENTS(This.WndHandle)
		    This.env.API_WIN.DestroyWindow(This.WndHandle)
		    This.WndHandle = 0
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE wndresize
		IF EMPTY(This.WndHandle)
		    RETURN
		ENDIF
		
		This.ViewPortUpdate()
		This.DrawBufCreate()
		
		This.env.API_WIN.MoveWindow(This.WndHandle, This.UIState.ObjToClient(2), This.UIState.ObjToClient(1), This.Width, This.Height, 1)
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE wndshow		&& Show child window (for internal use, public for bindevent)
		
		#define SW_HIDE 0
		#define SW_SHOWNA 8
		IF EMPTY(This.WndHandle)=.F.
		    This.env.API_WIN.ShowWindow(This.WndHandle, IIF(This.UIState.GetEffectivelyVisible(), SW_SHOWNA, SW_HIDE))
		ENDIF
		
	ENDPROC

	PROCEDURE UIState.onvisible
		This.Parent.WndShow()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumviewer_cmdfocus AS commandbutton 		&& PdfiumViewer input focus holder. Library consumer must not use this class directly
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: this_access
	*</DefinedPropArrayMethod>

	*<PropValue>
		Caption = ""
		Enabled = .T.
		Height = 27
		Name = "pdfiumviewer_cmdfocus"
		Style = 0
		Visible = .T.
		Width = 27
	*</PropValue>
	
	HIDDEN PROCEDURE this_access
		LPARAMETERS cMember
		
		RETURN This.Parent
		
	ENDPROC

ENDDEFINE
