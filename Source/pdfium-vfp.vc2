*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="pdfium-vfp.vcx" CPID="1251" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS pdfium_api_fpdf AS custom 		&& Pdfium API wrapper
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="CONST" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: fpdfbitmap_create
		*m: fpdfbitmap_createex
		*m: fpdfbitmap_destroy
		*m: fpdfbitmap_fillrect
		*m: fpdfbitmap_getbuffer
		*m: fpdfbitmap_getformat
		*m: fpdfbitmap_getheight
		*m: fpdfbitmap_getstride
		*m: fpdfbitmap_getwidth
		*m: fpdffont_close
		*m: fpdffont_getfamilyname
		*m: fpdffont_getflags
		*m: fpdffont_getweight
		*m: fpdfimageobj_setbitmap
		*m: fpdfpageobj_createnewpath
		*m: fpdfpageobj_createnewrect
		*m: fpdfpageobj_createtextobj
		*m: fpdfpageobj_destroy
		*m: fpdfpageobj_getbounds
		*m: fpdfpageobj_getmatrix
		*m: fpdfpageobj_gettype
		*m: fpdfpageobj_newimageobj
		*m: fpdfpageobj_setdasharray
		*m: fpdfpageobj_setfillcolor
		*m: fpdfpageobj_setstrokecolor
		*m: fpdfpageobj_setstrokewidth
		*m: fpdfpageobj_transform
		*m: fpdfpageobj_transformf
		*m: fpdfpage_countobjects
		*m: fpdfpage_delete
		*m: fpdfpage_generatecontent
		*m: fpdfpage_getobject
		*m: fpdfpage_insertobject
		*m: fpdfpage_new
		*m: fpdfpage_removeobject
		*m: fpdfpath_bezierto
		*m: fpdfpath_lineto
		*m: fpdfpath_moveto
		*m: fpdfpath_setdrawmode
		*m: fpdftextobj_getfont
		*m: fpdftextobj_getfontsize
		*m: fpdftextobj_gettext
		*m: fpdftextobj_settextrendermode
		*m: fpdftext_closepage
		*m: fpdftext_countchars
		*m: fpdftext_countrects
		*m: fpdftext_getcharindexatpos
		*m: fpdftext_getrect
		*m: fpdftext_gettext
		*m: fpdftext_getunicode
		*m: fpdftext_loadfont
		*m: fpdftext_loadpage
		*m: fpdftext_loadstandardfont
		*m: fpdftext_settext
		*m: fpdf_closedocument
		*m: fpdf_closepage
		*m: fpdf_createnewdocument
		*m: fpdf_destroylibrary
		*m: fpdf_devicetopage
		*m: fpdf_getlasterror
		*m: fpdf_getpagecount
		*m: fpdf_getpageheight
		*m: fpdf_getpagesizebyindex
		*m: fpdf_getpagewidth
		*m: fpdf_importpages
		*m: fpdf_initlibrarywithconfig
		*m: fpdf_loaddocument
		*m: fpdf_loadmemdocument
		*m: fpdf_loadpage
		*m: fpdf_pagetodevice
		*m: fpdf_renderpage
		*m: pdfium_vfp_dll_path_access
		*m: vfpdf_addfiletozipinput
		*m: vfpdf_createfontsubset
		*m: vfpdf_createzip
		*m: vfpdf_createzipinput
		*m: vfpdf_destroyfontsubset
		*m: vfpdf_destroyzip
		*m: vfpdf_destroyzipinput
		*m: vfpdf_getfontfilename		&& pdfium-vfp.dll function; Gets font face name and returns font filename and simulations
		*m: vfpdf_savedocument		&& pdfium-vfp.dll function; Save pdf to the file
		*p: pdfium_dll_path		&& Path to file pdfium.dll
		*p: pdfium_vfp_dll_path
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,pdfium_vfp_dll_path,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_fpdf"
		pdfium_dll_path = ("")
		pdfium_vfp_dll_path = ("")
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="fpdf_initlibrarywithconfig" type="method" display="FPDF_InitLibraryWithConfig"/>
			<memberdata name="pdfium_dll_path" type="property" display="pdfium_dll_path"/>
			<memberdata name="fpdf_destroylibrary" type="method" display="FPDF_DestroyLibrary"/>
			<memberdata name="fpdf_loaddocument" type="method" display="FPDF_LoadDocument"/>
			<memberdata name="fpdf_loadmemdocument" type="method" display="FPDF_LoadMemDocument"/>
			<memberdata name="fpdf_closedocument" type="method" display="FPDF_CloseDocument"/>
			<memberdata name="fpdf_getlasterror" type="method" display="FPDF_GetLastError"/>
			<memberdata name="fpdf_getpagecount" type="method" display="FPDF_GetPageCount"/>
			<memberdata name="fpdf_loadpage" type="method" display="FPDF_LoadPage"/>
			<memberdata name="fpdf_closepage" type="method" display="FPDF_ClosePage"/>
			<memberdata name="fpdf_renderpage" type="method" display="FPDF_RenderPage"/>
			<memberdata name="fpdftext_loadpage" type="method" display="FPDFText_LoadPage"/>
			<memberdata name="fpdftext_closepage" type="method" display="FPDFText_ClosePage"/>
			<memberdata name="fpdf_getpagesizebyindex" type="method" display="FPDF_GetPageSizeByIndex"/>
			<memberdata name="fpdf_getpagewidth" type="method" display="FPDF_GetPageWidth"/>
			<memberdata name="fpdf_getpageheight" type="method" display="FPDF_GetPageHeight"/>
			<memberdata name="fpdftext_countchars" type="method" display="FPDFText_CountChars"/>
			<memberdata name="fpdftext_getcharindexatpos" type="method" display="FPDFText_GetCharIndexAtPos"/>
			<memberdata name="fpdftext_gettext" type="method" display="FPDFText_GetText"/>
			<memberdata name="fpdftext_getunicode" type="method" display="FPDFText_GetUnicode"/>
			<memberdata name="fpdftext_countrects" type="method" display="FPDFText_CountRects"/>
			<memberdata name="fpdftext_getrect" type="method" display="FPDFText_GetRect"/>
			<memberdata name="fpdf_devicetopage" type="method" display="FPDF_DeviceToPage"/>
			<memberdata name="fpdf_pagetodevice" type="method" display="FPDF_PageToDevice"/>
			<memberdata name="vfpdf_getfontfilename" type="method" display="VFPDF_GetFontFilename"/>
			<memberdata name="vfpdf_savedocument" type="method" display="VFPDF_SaveDocument"/>
			<memberdata name="fpdfpage_countobjects" type="method" display="FPDFPage_CountObjects"/>
			<memberdata name="fpdfpage_getobject" type="method" display="FPDFPage_GetObject"/>
			<memberdata name="fpdfpageobj_gettype" type="method" display="FPDFPageObj_GetType"/>
			<memberdata name="fpdftextobj_gettext" type="method" display="FPDFTextObj_GetText"/>
			<memberdata name="fpdfpageobj_getbounds" type="method" display="FPDFPageObj_GetBounds"/>
			<memberdata name="fpdfpage_removeobject" type="method" display="FPDFPage_RemoveObject"/>
			<memberdata name="fpdfpage_insertobject" type="method" display="FPDFPage_InsertObject"/>
			<memberdata name="fpdf_createnewdocument" type="method" display="FPDF_CreateNewDocument"/>
			<memberdata name="fpdfpage_new" type="method" display="FPDFPage_New"/>
			<memberdata name="fpdfpage_delete" type="method" display="FPDFPage_Delete"/>
			<memberdata name="fpdfpageobj_getmatrix" type="method" display="FPDFPageObj_GetMatrix"/>
			<memberdata name="fpdffont_close" type="method" display="FPDFFont_Close"/>
			<memberdata name="fpdftextobj_getfontsize" type="method" display="FPDFTextObj_GetFontSize"/>
			<memberdata name="fpdftextobj_getfont" type="method" display="FPDFTextObj_GetFont"/>
			<memberdata name="fpdffont_getfamilyname" type="method" display="FPDFFont_GetFamilyName"/>
			<memberdata name="fpdffont_getflags" type="method" display="FPDFFont_GetFlags"/>
			<memberdata name="fpdffont_getweight" type="method" display="FPDFFont_GetWeight"/>
			<memberdata name="fpdftext_loadfont" type="method" display="FPDFText_LoadFont"/>
			<memberdata name="fpdftext_loadstandardfont" type="method" display="FPDFText_LoadStandardFont"/>
			<memberdata name="fpdfpageobj_createnewrect" type="method" display="FPDFPageObj_CreateNewRect"/>
			<memberdata name="fpdfpageobj_destroy" type="method" display="FPDFPageObj_Destroy"/>
			<memberdata name="fpdfpageobj_setfillcolor" type="method" display="FPDFPageObj_SetFillColor"/>
			<memberdata name="fpdfpageobj_setstrokecolor" type="method" display="FPDFPageObj_SetStrokeColor"/>
			<memberdata name="fpdfpageobj_setstrokewidth" type="method" display="FPDFPageObj_SetStrokeWidth"/>
			<memberdata name="fpdfpageobj_createtextobj" type="method" display="FPDFPageObj_CreateTextObj"/>
			<memberdata name="fpdfpath_setdrawmode" type="method" display="FPDFPath_SetDrawMode"/>
			<memberdata name="fpdfpage_generatecontent" type="method" display="FPDFPage_GenerateContent"/>
			<memberdata name="fpdfpageobj_transform" type="method" display="FPDFPageObj_Transform"/>
			<memberdata name="fpdfpageobj_transformf" type="method" display="FPDFPageObj_TransformF"/>
			<memberdata name="fpdftextobj_settextrendermode" type="method" display="FPDFTextObj_SetTextRenderMode"/>
			<memberdata name="fpdftext_settext" type="method" display="FPDFText_SetText"/>
			<memberdata name="fpdfpageobj_createnewpath" type="method" display="FPDFPageObj_CreateNewPath"/>
			<memberdata name="fpdfpath_lineto" type="method" display="FPDFPath_LineTo"/>
			<memberdata name="fpdfpath_moveto" type="method" display="FPDFPath_MoveTo"/>
			<memberdata name="fpdfbitmap_create" type="method" display="FPDFBitmap_Create"/>
			<memberdata name="fpdfbitmap_destroy" type="method" display="FPDFBitmap_Destroy"/>
			<memberdata name="fpdfbitmap_createex" type="method" display="FPDFBitmap_CreateEx"/>
			<memberdata name="fpdfbitmap_getformat" type="method" display="FPDFBitmap_GetFormat"/>
			<memberdata name="fpdfbitmap_getbuffer" type="method" display="FPDFBitmap_GetBuffer"/>
			<memberdata name="fpdfbitmap_getwidth" type="method" display="FPDFBitmap_GetWidth"/>
			<memberdata name="fpdfbitmap_getheight" type="method" display="FPDFBitmap_GetHeight"/>
			<memberdata name="fpdfbitmap_getstride" type="method" display="FPDFBitmap_GetStride"/>
			<memberdata name="fpdfbitmap_fillrect" type="method" display="FPDFBitmap_FillRect"/>
			<memberdata name="fpdfpageobj_newimageobj" type="method" display="FPDFPageObj_NewImageObj"/>
			<memberdata name="fpdfimageobj_setbitmap" type="method" display="FPDFImageObj_SetBitmap"/>
			<memberdata name="fpdfpageobj_setdasharray" type="method" display="FPDFPageObj_SetDashArray"/>
			<memberdata name="fpdfpath_bezierto" type="method" display="FPDFPath_BezierTo"/>
			<memberdata name="vfpdf_createfontsubset" type="method" display="VFPDF_CreateFontSubset"/>
			<memberdata name="vfpdf_destroyfontsubset" type="method" display="VFPDF_DestroyFontSubset"/>
			<memberdata name="fpdf_importpages" type="method" display="FPDF_ImportPages"/>
			<memberdata name="vfpdf_addfiletozipinput" type="method" display="VFPDF_AddFileToZipInput"/>
			<memberdata name="vfpdf_createzip" type="method" display="VFPDF_CreateZip"/>
			<memberdata name="vfpdf_createzipinput" type="method" display="VFPDF_CreateZipInput"/>
			<memberdata name="vfpdf_destroyzip" type="method" display="VFPDF_DestroyZip"/>
			<memberdata name="vfpdf_destroyzipinput" type="method" display="VFPDF_DestroyZipInput"/>
			<memberdata name="pdfium_vfp_dll_path" type="property" display="pdfium_vfp_dll_path"/>
			<memberdata name="pdfium_vfp_dll_path_access" type="method" display="pdfium_vfp_dll_path_access"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'CONST' AS pdfium_api_fpdf_const WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "CONST", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE fpdfbitmap_create
		LPARAMETERS width as Long, height as Long, alpha as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_Create(m.width, m.height, m.alpha)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFBitmap_Create IN (This.pdfium_dll_path) AS FPDFBitmap_Create LONG width, LONG height, LONG alpha
		    m.lvRes = FPDFBitmap_Create(m.width, m.height, m.alpha)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_createex
		LPARAMETERS width as Long, height as Long, format as Long, first_scan as Long, stride as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_CreateEx(m.width, m.height, m.format, m.first_scan, m.stride)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFBitmap_CreateEx IN (This.pdfium_dll_path) AS FPDFBitmap_CreateEx LONG width, LONG height, LONG format, LONG first_scan, LONG stride
		    m.lvRes = FPDFBitmap_CreateEx(m.width, m.height, m.format, m.first_scan, m.stride)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_destroy
		LPARAMETERS bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_Destroy(m.bitmap)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDFBitmap_Destroy IN (This.pdfium_dll_path) AS FPDFBitmap_Destroy LONG bitmap
		    m.lvRes = FPDFBitmap_Destroy(m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_fillrect
		LPARAMETERS bitmap as Long, left as Integer, top as Integer, width as Integer, height as Integer, color as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_FillRect(m.bitmap, m.left, m.top, m.width, m.height, m.color)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDFBitmap_FillRect IN (This.pdfium_dll_path) AS FPDFBitmap_FillRect LONG bitmap, INTEGER left, INTEGER top, INTEGER width, INTEGER height, LONG color
		    m.lvRes = FPDFBitmap_FillRect(m.bitmap, m.left, m.top, m.width, m.height, m.color)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_getbuffer
		LPARAMETERS bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_GetBuffer(m.bitmap)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFBitmap_GetBuffer IN (This.pdfium_dll_path) AS FPDFBitmap_GetBuffer LONG bitmap
		    m.lvRes = FPDFBitmap_GetBuffer(m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_getformat
		LPARAMETERS bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_GetFormat(m.bitmap)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFBitmap_GetFormat IN (This.pdfium_dll_path) AS FPDFBitmap_GetFormat LONG bitmap
		    m.lvRes = FPDFBitmap_GetFormat(m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_getheight
		LPARAMETERS bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_GetHeight(m.bitmap)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFBitmap_GetHeight IN (This.pdfium_dll_path) AS FPDFBitmap_GetHeight LONG bitmap
		    m.lvRes = FPDFBitmap_GetHeight(m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_getstride
		LPARAMETERS bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_GetStride(m.bitmap)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFBitmap_GetStride IN (This.pdfium_dll_path) AS FPDFBitmap_GetStride LONG bitmap
		    m.lvRes = FPDFBitmap_GetStride(m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_getwidth
		LPARAMETERS bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_GetWidth(m.bitmap)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFBitmap_GetWidth IN (This.pdfium_dll_path) AS FPDFBitmap_GetWidth LONG bitmap
		    m.lvRes = FPDFBitmap_GetWidth(m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdffont_close
		LPARAMETERS font as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFFont_Close(m.font)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDFFont_Close IN (This.pdfium_dll_path) AS FPDFFont_Close LONG font
		    m.lvRes = FPDFFont_Close(m.font)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdffont_getfamilyname
		LPARAMETERS font as Long, buffer as String, length as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFFont_GetFamilyName(m.font, @m.buffer, m.length)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFFont_GetFamilyName IN (This.pdfium_dll_path) AS FPDFFont_GetFamilyName LONG font, STRING @buffer, LONG length
		    m.lvRes = FPDFFont_GetFamilyName(m.font, @m.buffer, m.length)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdffont_getflags
		LPARAMETERS font as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFFont_GetFlags(m.font)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFFont_GetFlags IN (This.pdfium_dll_path) AS FPDFFont_GetFlags LONG font
		    m.lvRes = FPDFFont_GetFlags(m.font)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdffont_getweight
		LPARAMETERS font as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFFont_GetWeight(m.font)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFFont_GetWeight IN (This.pdfium_dll_path) AS FPDFFont_GetWeight LONG font
		    m.lvRes = FPDFFont_GetWeight(m.font)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfimageobj_setbitmap
		LPARAMETERS pages as Long, count as Integer, image_object as Long, bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFImageObj_SetBitmap(m.pages, m.count, m.image_object, m.bitmap)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFImageObj_SetBitmap IN (This.pdfium_dll_path) AS FPDFImageObj_SetBitmap LONG pages, INTEGER count, LONG image_object, LONG bitmap
		    m.lvRes = FPDFImageObj_SetBitmap(m.pages, m.count, m.image_object, m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_createnewpath
		LPARAMETERS x as Single, y as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_CreateNewPath(m.x, m.y)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPageObj_CreateNewPath IN (This.pdfium_dll_path) AS FPDFPageObj_CreateNewPath SINGLE x, SINGLE y
		    m.lvRes = FPDFPageObj_CreateNewPath(m.x, m.y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_createnewrect
		LPARAMETERS x as Single, y as Single, w as Single, h as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_CreateNewRect(m.x, m.y, m.w, m.h)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPageObj_CreateNewRect IN (This.pdfium_dll_path) AS FPDFPageObj_CreateNewRect SINGLE x, SINGLE y, SINGLE w, SINGLE h
		    m.lvRes = FPDFPageObj_CreateNewRect(m.x, m.y, m.w, m.h)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_createtextobj
		LPARAMETERS page_object as Long, font as Long, font_size as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_CreateTextObj(m.page_object, m.font, m.font_size)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPageObj_CreateTextObj IN (This.pdfium_dll_path) AS FPDFPageObj_CreateTextObj LONG page_object, LONG font, SINGLE font_size
		    m.lvRes = FPDFPageObj_CreateTextObj(m.page_object, m.font, m.font_size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_destroy
		LPARAMETERS page_object as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_Destroy(m.page_object)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDFPageObj_Destroy IN (This.pdfium_dll_path) AS FPDFPageObj_Destroy LONG page_object
		    m.lvRes = FPDFPageObj_Destroy(m.page_object)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_getbounds
		LPARAMETERS page_object as Long, left as Single, bottom as Single, right as Single, top as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_GetBounds(m.page_object, @m.left, @m.bottom, @m.right, @m.top)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPageObj_GetBounds IN (This.pdfium_dll_path) AS FPDFPageObj_GetBounds LONG page_object, SINGLE @left, SINGLE @bottom, SINGLE @right, SINGLE @top
		    m.lvRes = FPDFPageObj_GetBounds(m.page_object, @m.left, @m.bottom, @m.right, @m.top)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_getmatrix
		LPARAMETERS page_object as Long, matrix as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_GetMatrix(m.page_object , @matrix)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPageObj_GetMatrix IN (This.pdfium_dll_path) AS FPDFPageObj_GetMatrix LONG page_object, STRING @matrix
		    m.lvRes = FPDFPageObj_GetMatrix(m.page_object , @matrix)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_gettype
		LPARAMETERS page_object as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_GetType(m.page_object)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFPageObj_GetType IN (This.pdfium_dll_path) AS FPDFPageObj_GetType LONG page_object
		    m.lvRes = FPDFPageObj_GetType(m.page_object)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_newimageobj
		LPARAMETERS document as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_NewImageObj(m.document)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPageObj_NewImageObj IN (This.pdfium_dll_path) AS FPDFPageObj_NewImageObj LONG document
		    m.lvRes = FPDFPageObj_NewImageObj(m.document)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_setdasharray
		LPARAMETERS page_object as Long, dash_array as String, dash_count as Long, phase as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_SetDashArray(m.page_object, m.dash_array, m.dash_count, m.phase)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPageObj_SetDashArray IN (This.pdfium_dll_path) AS FPDFPageObj_SetDashArray LONG page_object, STRING dash_array, LONG dash_count, SINGLE phase
		    m.lvRes = FPDFPageObj_SetDashArray(m.page_object, m.dash_array, m.dash_count, m.phase)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_setfillcolor
		LPARAMETERS page_object as Long, R as Long, G as Long, B as Long, A as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_SetFillColor(m.page_object, m.R, m.G, m.B, m.A)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPageObj_SetFillColor IN (This.pdfium_dll_path) AS FPDFPageObj_SetFillColor LONG page_object, LONG R, LONG G, LONG B, LONG A
		    m.lvRes = FPDFPageObj_SetFillColor(m.page_object, m.R, m.G, m.B, m.A)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_setstrokecolor
		LPARAMETERS page_object as Long, R as Long, G as Long, B as Long, A as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_SetStrokeColor(m.page_object, m.R, m.G, m.B, m.A)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPageObj_SetStrokeColor IN (This.pdfium_dll_path) AS FPDFPageObj_SetStrokeColor LONG page_object, LONG R, LONG G, LONG B, LONG A
		    m.lvRes = FPDFPageObj_SetStrokeColor(m.page_object, m.R, m.G, m.B, m.A)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_setstrokewidth
		LPARAMETERS page_object as Long, width as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_SetStrokeWidth(m.page_object, m.width)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPageObj_SetStrokeWidth IN (This.pdfium_dll_path) AS FPDFPageObj_SetStrokeWidth LONG page_object, SINGLE width
		    m.lvRes = FPDFPageObj_SetStrokeWidth(m.page_object, m.width)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_transform
		LPARAMETERS page_object as Long, a as Double, b as Double, c as Double, d as Double, e as Double, f as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_Transform(m.page_object, m.a, m.b, m.c, m.d, m.e, m.f)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDFPageObj_Transform IN (This.pdfium_dll_path) AS FPDFPageObj_Transform LONG page_object, DOUBLE a, DOUBLE b, DOUBLE c, DOUBLE d, DOUBLE e, DOUBLE f
		    m.lvRes = FPDFPageObj_Transform(m.page_object, m.a, m.b, m.c, m.d, m.e, m.f)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_transformf
		LPARAMETERS page_object as Long, matrix as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_TransformF(m.page_object, m.matrix)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPageObj_TransformF IN (This.pdfium_dll_path) AS FPDFPageObj_TransformF LONG page_object, STRING matrix
		    m.lvRes = FPDFPageObj_TransformF(m.page_object, m.matrix)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_countobjects
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_CountObjects(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFPage_CountObjects IN (This.pdfium_dll_path) AS FPDFPage_CountObjects LONG page
		    m.lvRes = FPDFPage_CountObjects(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_delete
		LPARAMETERS document as Long, page_index as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_Delete(m.document, m.page_index)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDFPage_Delete IN (This.pdfium_dll_path) AS FPDFPage_Delete LONG document, INTEGER page_index
		    m.lvRes = FPDFPage_Delete(m.document, m.page_index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_generatecontent
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_GenerateContent(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPage_GenerateContent IN (This.pdfium_dll_path) AS FPDFPage_GenerateContent LONG page
		    m.lvRes = FPDFPage_GenerateContent(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_getobject
		LPARAMETERS page as Long, index as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_GetObject(m.page, m.index)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPage_GetObject IN (This.pdfium_dll_path) AS FPDFPage_GetObject LONG page, INTEGER index
		    m.lvRes = FPDFPage_GetObject(m.page, m.index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_insertobject
		LPARAMETERS page as Long, page_object as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_InsertObject(m.page, m.page_object)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDFPage_InsertObject IN (This.pdfium_dll_path) AS FPDFPage_InsertObject LONG page, LONG page_object
		    m.lvRes = FPDFPage_InsertObject(m.page, m.page_object)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_new
		LPARAMETERS document as Long, page_index as Integer, width as Double, height as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_New(m.document, m.page_index, m.width, m.height)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPage_New IN (This.pdfium_dll_path) AS FPDFPage_New LONG document, INTEGER page_index, DOUBLE width, DOUBLE height
		    m.lvRes = FPDFPage_New(m.document, m.page_index, m.width, m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_removeobject
		LPARAMETERS page as Long, page_object as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_RemoveObject(m.page, m.page_object)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPage_RemoveObject IN (This.pdfium_dll_path) AS FPDFPage_RemoveObject LONG page, LONG page_object
		    m.lvRes = FPDFPage_RemoveObject(m.page, m.page_object)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpath_bezierto
		LPARAMETERS path as Long, x1 as Single, y1 as Single, x2 as Single, y2 as Single, x3 as Single, y3 as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPath_BezierTo(m.path, m.x1, m.y1, m.x2, m.y2, m.x3, m.y3)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPath_BezierTo IN (This.pdfium_dll_path) AS FPDFPath_BezierTo LONG path, SINGLE x1, SINGLE y1, SINGLE x2, SINGLE y2, SINGLE x3, SINGLE y3
		    m.lvRes = FPDFPath_BezierTo(m.path, m.x1, m.y1, m.x2, m.y2, m.x3, m.y3)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpath_lineto
		LPARAMETERS path as Long, x as Single, y as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPath_LineTo(m.path, m.x, m.y)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPath_LineTo IN (This.pdfium_dll_path) AS FPDFPath_LineTo LONG path, SINGLE x, SINGLE y
		    m.lvRes = FPDFPath_LineTo(m.path, m.x, m.y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpath_moveto
		LPARAMETERS path as Long, x as Single, y as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPath_MoveTo(m.path, m.x, m.y)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPath_MoveTo IN (This.pdfium_dll_path) AS FPDFPath_MoveTo LONG path, SINGLE x, SINGLE y
		    m.lvRes = FPDFPath_MoveTo(m.path, m.x, m.y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpath_setdrawmode
		LPARAMETERS page_object as Long, fillmode as Integer, stoke as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPath_SetDrawMode(m.page_object, m.fillmode, m.stoke)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFPath_SetDrawMode IN (This.pdfium_dll_path) AS FPDFPath_SetDrawMode LONG page_object, INTEGER fillmode, LONG stroke
		    m.lvRes = FPDFPath_SetDrawMode(m.page_object, m.fillmode, m.stoke)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftextobj_getfont
		LPARAMETERS text as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFTextObj_GetFont(m.text)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFTextObj_GetFont IN (This.pdfium_dll_path) AS FPDFTextObj_GetFont LONG text
		    m.lvRes = FPDFTextObj_GetFont(m.text)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftextobj_getfontsize
		LPARAMETERS text as Long, size as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFTextObj_GetFontSize(m.text, @m.size)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFTextObj_GetFontSize IN (This.pdfium_dll_path) AS FPDFTextObj_GetFontSize LONG text, SINGLE @size
		    m.lvRes = FPDFTextObj_GetFontSize(m.text, @m.size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftextobj_gettext
		LPARAMETERS text_object as Long, text_page as Long, buffer as String, length as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFTextObj_GetText(m.text_object, m.text_page, @m.buffer, m.length)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFTextObj_GetText IN (This.pdfium_dll_path) AS FPDFTextObj_GetText LONG text_object, LONG text_page, STRING @buffer, LONG length
		    m.lvRes = FPDFTextObj_GetText(m.text_object, m.text_page, @m.buffer, m.length)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftextobj_settextrendermode
		LPARAMETERS text as Long, render_mode as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFTextObj_SetTextRenderMode(m.text, m.render_mode)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFTextObj_SetTextRenderMode IN (This.pdfium_dll_path) AS FPDFTextObj_SetTextRenderMode LONG text, INTEGER render_mode
		    m.lvRes = FPDFTextObj_SetTextRenderMode(m.text, m.render_mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_closepage
		LPARAMETERS text_page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_ClosePage(m.text_page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDFText_ClosePage IN (This.pdfium_dll_path) AS FPDFText_ClosePage LONG text_page
		    m.lvRes = FPDFText_ClosePage(m.text_page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_countchars
		LPARAMETERS text_page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_CountChars(m.text_page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFText_CountChars IN (This.pdfium_dll_path) AS FPDFText_CountChars LONG text_page
		    m.lvRes = FPDFText_CountChars(m.text_page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_countrects
		LPARAMETERS text_page as Long, start_index as Integer, count as Intege
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_CountRects(m.text_page, m.start_index, m.count)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFText_CountRects IN (This.pdfium_dll_path) AS FPDFText_CountRects LONG text_page, integer start_index, integer count
		    m.lvRes = FPDFText_CountRects(m.text_page, m.start_index, m.count)
		ENDTRY
		
		RETURN m.lvRes
		
		
	ENDPROC

	PROCEDURE fpdftext_getcharindexatpos
		LPARAMETERS text_page as Long, x as Double, y as Double, xTolerance as Double, yTolerance as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_GetCharIndexAtPos(m.text_page, m.x, m.y, m.xTolerance, m.yTolerance)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFText_GetCharIndexAtPos IN (This.pdfium_dll_path) AS FPDFText_GetCharIndexAtPos LONG text_page, double x, double y, double xTolerance, double yTolerance
		    m.lvRes = FPDFText_GetCharIndexAtPos(m.text_page, m.x, m.y, m.xTolerance, m.yTolerance)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_getrect
		LPARAMETERS text_page as Long, rect_index as Integer, left as Double, top as Double, right as Double, bottom as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_GetRect(m.text_page, m.rect_index, @m.left, @m.top, @m.right, @m.bottom)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFText_GetRect IN (This.pdfium_dll_path) AS FPDFText_GetRect LONG text_page, integer rect_index, double @left, double @top, double @right, double @bottom
		    m.lvRes = FPDFText_GetRect(m.text_page, m.rect_index, @m.left, @m.top, @m.right, @m.bottom)
		ENDTRY
		
		RETURN m.lvRes
		
		
	ENDPROC

	PROCEDURE fpdftext_gettext
		LPARAMETERS text_page as Long, start_index as Integer, count as Integer, result as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_GetText(m.text_page, m.start_index, m.count, @m.result)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDFText_GetText IN (This.pdfium_dll_path) AS FPDFText_GetText LONG text_page, integer start_index, integer count, STRING @result
		    m.lvRes = FPDFText_GetText(m.text_page, m.start_index, m.count, @m.result)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_getunicode
		LPARAMETERS text_page as Long, index as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_GetUnicode(m.text_page, m.index)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFText_GetUnicode IN (This.pdfium_dll_path) AS FPDFText_GetUnicode LONG text_page, integer index
		    m.lvRes = FPDFText_GetUnicode(m.text_page, m.index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_loadfont
		LPARAMETERS document as Long, data as Long, size as Long, font_type as Integer, cid as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_LoadFont(m.document, m.data, m.size, m.font_type, m.cid)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFText_LoadFont IN (This.pdfium_dll_path) AS FPDFText_LoadFont LONG document, LONG data, LONG size, INTEGER font_type, LONG cid
		    m.lvRes = FPDFText_LoadFont(m.document, m.data, m.size, m.font_type, m.cid)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_loadpage
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_LoadPage(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFText_LoadPage IN (This.pdfium_dll_path) AS FPDFText_LoadPage LONG page
		    m.lvRes = FPDFText_LoadPage(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_loadstandardfont
		LPARAMETERS document as Long, font as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_LoadStandardFont(m.document, m.font)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFText_LoadStandardFont IN (This.pdfium_dll_path) AS FPDFText_LoadStandardFont LONG document, STRING font
		    m.lvRes = FPDFText_LoadStandardFont(m.document, m.font)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_settext
		LPARAMETERS text_object as Long, text as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_SetText(m.text_object, m.text)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDFText_SetText IN (This.pdfium_dll_path) AS FPDFText_SetText LONG text_object, STRING text
		    m.lvRes = FPDFText_SetText(m.text_object, m.text)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_closedocument
		LPARAMETERS document as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_CloseDocument(m.document)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDF_CloseDocument IN (This.pdfium_dll_path) AS FPDF_CloseDocument LONG document
		    m.lvRes = FPDF_CloseDocument(m.document)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_closepage
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_ClosePage(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDF_ClosePage IN (This.pdfium_dll_path) AS FPDF_ClosePage LONG page
		    m.lvRes = FPDF_ClosePage(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_createnewdocument
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_CreateNewDocument()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDF_CreateNewDocument IN (This.pdfium_dll_path) AS FPDF_CreateNewDocument
		    m.lvRes = FPDF_CreateNewDocument()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_destroylibrary
		
		DECLARE FPDF_DestroyLibrary IN (This.pdfium_dll_path) AS FPDF_DestroyLibrary
		
		IF PEMSTATUS(Application, "pdfium_instance_count", 5)=.T.
		
		    IF Application.pdfium_instance_count = 1
		        FPDF_DestroyLibrary()
		    ENDIF
		
		    Application.pdfium_instance_count = MAX(Application.pdfium_instance_count - 1, 0)
		
		ENDIF
		
	ENDPROC

	PROCEDURE fpdf_devicetopage
		LPARAMETERS page as Long, start_x as Integer, start_y as Integer, size_x as Integer, size_y as Integer, rotate as Integer, device_x as Integer, device_y as Integer, page_x as Double, page_y as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = m.FPDF_DeviceToPage(m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.device_x, m.device_y, @m.page_x, @m.page_y)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDF_DeviceToPage IN (This.pdfium_dll_path) AS FPDF_DeviceToPage LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer device_x, integer device_y, double @page_x, double @page_y
		    m.lvRes = m.FPDF_DeviceToPage(m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.device_x, m.device_y, @m.page_x, @m.page_y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getlasterror
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetLastError()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDF_GetLastError IN (This.pdfium_dll_path) AS FPDF_GetLastError
		    m.lvRes = FPDF_GetLastError()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getpagecount
		LPARAMETERS document as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetPageCount(m.document)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDF_GetPageCount IN (This.pdfium_dll_path) AS FPDF_GetPageCount LONG document
		    m.lvRes = FPDF_GetPageCount(m.document)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getpageheight
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetPageHeight(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE double FPDF_GetPageHeight IN (This.pdfium_dll_path) AS FPDF_GetPageHeight LONG page
		    m.lvRes = FPDF_GetPageHeight(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getpagesizebyindex
		LPARAMETERS document as Long, page_index as Integer, width as Double, height as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetPageSizeByIndex(m.document, m.page_index, @m.width, @m.height)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDF_GetPageSizeByIndex IN (This.pdfium_dll_path) AS FPDF_GetPageSizeByIndex LONG document, integer page_index, double @width, double @height
		    m.lvRes = FPDF_GetPageSizeByIndex(m.document, m.page_index, @m.width, @m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getpagewidth
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetPageWidth(m.page)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE double FPDF_GetPageWidth IN (This.pdfium_dll_path) AS FPDF_GetPageWidth LONG page
		    m.lvRes = FPDF_GetPageWidth(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_importpages
		LPARAMETERS dest_doc as Long, src_doc as Long, pagerange as String, index as Integer
		
		LOCAL m.lvRes
		TRY
		   m.lvRes = FPDF_ImportPages(m.dest_doc, m.src_doc, m.pagerange, m.index)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDF_ImportPages IN (This.pdfium_dll_path) AS FPDF_ImportPages LONG dest_doc, LONG src_doc, STRING pagerange, INTEGER index
		    m.lvRes = FPDF_ImportPages(m.dest_doc, m.src_doc, m.pagerange, m.index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_initlibrarywithconfig
		LPARAMETERS config as String
		
		DECLARE FPDF_InitLibraryWithConfig IN (This.pdfium_dll_path) AS FPDF_InitLibraryWithConfig STRING config
		
		LOCAL lcConfig
		m.lcConfig = EVL(NVL(m.config,""),"")
		IF EMPTY(m.lcConfig)
		    m.lcConfig = REPLICATE(CHR(0),24)
		    m.lcConfig = STUFF(m.lcConfig, 1,4, BINTOC(2, "4RS"))
		ELSE
		    m.lcConfig = PADR(m.lcConfig, 24, CHR(0))    
		ENDIF
		
		
		IF PEMSTATUS(Application, "pdfium_instance_count", 5)=.F.
		    ADDPROPERTY(Application, "pdfium_instance_count", 0)
		ENDIF
		
		IF Application.pdfium_instance_count = 0
		    FPDF_InitLibraryWithConfig(m.lcConfig)
		    This.FPDF_GetLastError() && Last error initialization, first call of FPDF_GetLastError() always returns 0 even if error has occured
		ENDIF
		
		Application.pdfium_instance_count = Application.pdfium_instance_count + 1
		
	ENDPROC

	PROCEDURE fpdf_loaddocument
		LPARAMETERS file_path as String, password as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_LoadDocument(m.file_path, m.password)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDF_LoadDocument IN (This.pdfium_dll_path) AS FPDF_LoadDocument STRING file_path, STRING password
		    m.lvRes = FPDF_LoadDocument(m.file_path, m.password)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_loadmemdocument
		LPARAMETERS data_buf as Long, size as Integer, password as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_LoadMemDocument(m.data_buf, m.size, m.password)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDF_LoadMemDocument IN (This.pdfium_dll_path) AS FPDF_LoadMemDocument LONG data_buf, INTEGER size, STRING password
		    m.lvRes = FPDF_LoadMemDocument(m.data_buf, m.size, m.password)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_loadpage
		LPARAMETERS document as Long, page_index as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_LoadPage(m.document, m.page_index)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG FPDF_LoadPage IN (This.pdfium_dll_path) AS FPDF_LoadPage LONG document, INTEGER page_index
		    m.lvRes = FPDF_LoadPage(m.document, m.page_index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_pagetodevice
		LPARAMETERS page as Long, start_x as Integer, start_y as Integer, size_x as Integer, size_y as Integer, rotate as Integer, page_x as Double, page_y as Double, device_x as Integer, device_y as Integer
		
		LOCAL lcDevX, lcDevY
		STORE 0h00000000 TO m.lcDevX, m.lcDevY
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_PageToDevice(m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.page_x, m.page_y, @m.lcDevX, @m.lcDevY)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FPDF_PageToDevice IN (This.pdfium_dll_path) AS FPDF_PageToDevice LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, double page_x, double page_y, string @device_x, string @device_y
		    m.lvRes = FPDF_PageToDevice(m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.page_x, m.page_y, @m.lcDevX, @m.lcDevY)
		ENDTRY
		
		m.device_x = CTOBIN(m.lcDevX, "4RS")
		m.device_y = CTOBIN(m.lcDevY, "4RS")
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_renderpage
		LPARAMETERS dc as Long, page as Long, start_x as Integer, start_y as Integer, size_x as Integer, size_y as Integer, rotate as Integer, flags as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_RenderPage(m.dc, m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.flags)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE FPDF_RenderPage IN (This.pdfium_dll_path) AS FPDF_RenderPage LONG dc, LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer flags
		    m.lvRes = FPDF_RenderPage(m.dc, m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.flags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	HIDDEN PROCEDURE pdfium_vfp_dll_path_access
		RETURN ADDBS(JUSTPATH(This.pdfium_dll_path)) + IIF(ATC("x64", SYS(17))<>0, "pdfium-vfp64.dll", "pdfium-vfp.dll")
		
	ENDPROC

	PROCEDURE vfpdf_addfiletozipinput
		LPARAMETERS zip_input as Long, filename as String, filedata as String, filedata_size as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_AddFileToZipInput(m.zip_input, m.filename, m.filedata, m.filedata_size)
		CATCH
		    SET CONSOLE OFF
		
		    DECLARE LONG VFPDF_AddFileToZipInput IN (This.pdfium_vfp_dll_path) AS VFPDF_AddFileToZipInput LONG zip_input, STRING filename, STRING filedata, LONG filedata_size
		    m.lvRes = VFPDF_AddFileToZipInput(m.zip_input, m.filename, m.filedata, m.filedata_size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_createfontsubset
		LPARAMETERS font_data as Long, font_data_size as Long, char_list as String, font_subset_data as Long, font_subset_data_size as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_CreateFontSubset(m.font_data, m.font_data_size, m.char_list, @m.font_subset_data, @m.font_subset_data_size)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE LONG VFPDF_CreateFontSubset IN (This.pdfium_vfp_dll_path) AS VFPDF_CreateFontSubset LONG font_data, LONG font_data_size, STRING char_list, LONG @font_subset_data, LONG @font_subset_data_size
		    m.lvRes = VFPDF_CreateFontSubset(m.font_data, m.font_data_size, m.char_list, @m.font_subset_data, @m.font_subset_data_size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_createzip
		LPARAMETERS zip_input as Long, zipfile_data as Long, zipfile_data_size as Long
		
		m.zipfile_data = 0
		m.zipfile_data_size = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_CreateZip(m.zip_input, @m.zipfile_data, @m.zipfile_data_size)
		CATCH
		    SET CONSOLE OFF
		
		    DECLARE LONG VFPDF_CreateZip IN (This.pdfium_vfp_dll_path) AS VFPDF_CreateZip LONG zip_input, LONG @zipfile_data, LONG @zipfile_data_size
		    m.lvRes = VFPDF_CreateZip(m.zip_input, @m.zipfile_data, @m.zipfile_data_size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_createzipinput
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_CreateZipInput()
		CATCH
		    SET CONSOLE OFF
		
		    DECLARE LONG VFPDF_CreateZipInput IN (This.pdfium_vfp_dll_path) AS VFPDF_CreateZipInput
		    m.lvRes = VFPDF_CreateZipInput()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_destroyfontsubset
		LPARAMETERS font_subset_data as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_DestroyFontSubset(m.font_subset_data)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE LONG VFPDF_DestroyFontSubset IN (This.pdfium_vfp_dll_path) AS VFPDF_DestroyFontSubset LONG font_subset_data
		    m.lvRes = VFPDF_DestroyFontSubset(m.font_subset_data)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_destroyzip
		LPARAMETERS zipfile_data as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_DestroyZip(m.zipfile_data)
		CATCH
		    SET CONSOLE OFF
		
		    DECLARE VFPDF_DestroyZip IN (This.pdfium_vfp_dll_path) AS VFPDF_DestroyZip LONG zipfile_data
		    m.lvRes = VFPDF_DestroyZip(m.zipfile_data)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_destroyzipinput
		LPARAMETERS zip_input as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_DestroyZipInput(m.zip_input)
		CATCH
		    SET CONSOLE OFF
		
		    DECLARE VFPDF_DestroyZipInput IN (This.pdfium_vfp_dll_path) AS VFPDF_DestroyZipInput LONG zip_input
		    m.lvRes = VFPDF_DestroyZipInput(m.zip_input)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_getfontfilename		&& pdfium-vfp.dll function; Gets font face name and returns font filename and simulations
		LPARAMETERS family_name as String, is_bold as Long, is_italic as Long, nCharset as Long, buffer as String, buflen as Long, bBoldSimulation as Long, bItalicSimulation as Long, bSymbolFont as Long
		
		* Algorithmic emboldening is performed.
		#define DWRITE_FONT_SIMULATIONS_BOLD 0x0001
		* Algorithmic italicization is performed.
		#define DWRITE_FONT_SIMULATIONS_OBLIQUE 0x0002
		
		LOCAL m.lnFontSimulations, m.lnSymbolFont
		STORE 0 TO m.lnFontSimulations, m.lnSymbolFont
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_GetFontFileName(@m.family_name, m.is_bold, m.is_italic, m.nCharset, @m.buffer, m.buflen, @m.lnFontSimulations, @m.lnSymbolFont)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE LONG VFPDF_GetFontFileName IN (This.pdfium_vfp_dll_path) AS VFPDF_GetFontFileName STRING @family_name, LONG is_bold, LONG is_italic, LONG nCharset, STRING @buffer, LONG buflen, LONG @nFontSimulations, LONG @bSymbolFont
		    m.lvRes = VFPDF_GetFontFileName(@m.family_name, m.is_bold, m.is_italic, m.nCharset, @m.buffer, m.buflen, @m.lnFontSimulations, @m.lnSymbolFont)
		ENDTRY
		
		IF m.lvRes <> 0
		    m.bBoldSimulation = IIF(BITAND(m.lnFontSimulations, DWRITE_FONT_SIMULATIONS_BOLD) <> 0, 1, 0)
		    m.bItalicSimulation = IIF(BITAND(m.lnFontSimulations, DWRITE_FONT_SIMULATIONS_OBLIQUE) <> 0, 1, 0)
		    m.bSymbolFont = m.lnSymbolFont
		ENDIF
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_savedocument		&& pdfium-vfp.dll function; Save pdf to the file
		LPARAMETERS document as Long, filepath as String, errMsg as String, errMsgSize as Long
		
		IF EMPTY(NVL(m.errMsg,""))
		    m.errMsg = ""
		    m.errMsgSize = 0
		ENDIF
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_SaveDocument(m.document, m.filepath, @m.errMsg, m.errMsgSize)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE LONG VFPDF_SaveDocument IN (This.pdfium_vfp_dll_path) AS VFPDF_SaveDocument LONG document, STRING filepath, STRING @errMsg, LONG errMsgSize &&errMsgSize: errMsg buffer size in chars, not in bytes
		    m.lvRes = VFPDF_SaveDocument(m.document, m.filepath, @m.errMsg, m.errMsgSize)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_fpdf_const AS custom 		&& Pdfium API constants
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: fpdfbitmap_bgr
		*m: fpdfbitmap_bgra
		*m: fpdfbitmap_bgrx
		*m: fpdfbitmap_gray
		*m: fpdfbitmap_unknown
		*m: fpdf_err_password
		*m: fpdf_fillmode_alternate
		*m: fpdf_fillmode_none
		*m: fpdf_fillmode_winding
		*m: fpdf_font_truetype
		*m: fpdf_font_type1
		*m: fpdf_pageobj_form
		*m: fpdf_pageobj_image
		*m: fpdf_pageobj_path
		*m: fpdf_pageobj_shading
		*m: fpdf_pageobj_text
		*m: fpdf_pageobj_unknown
		*m: fpdf_printing
		*m: fpdf_textrendermode_fill
		*m: fpdf_textrendermode_fill_stroke
		*m: fpdf_textrendermode_stroke
		*m: fpdf_textrendermode_unknown
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_fpdf_const"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="fpdf_err_password" type="method" display="FPDF_ERR_PASSWORD"/>
			<memberdata name="fpdf_printing" type="method" display="FPDF_PRINTING"/>
			<memberdata name="fpdf_pageobj_form" type="method" display="FPDF_PAGEOBJ_FORM"/>
			<memberdata name="fpdf_pageobj_image" type="method" display="FPDF_PAGEOBJ_IMAGE"/>
			<memberdata name="fpdf_pageobj_path" type="method" display="FPDF_PAGEOBJ_PATH"/>
			<memberdata name="fpdf_pageobj_shading" type="method" display="FPDF_PAGEOBJ_SHADING"/>
			<memberdata name="fpdf_pageobj_text" type="method" display="FPDF_PAGEOBJ_TEXT"/>
			<memberdata name="fpdf_pageobj_unknown" type="method" display="FPDF_PAGEOBJ_UNKNOWN"/>
			<memberdata name="fpdf_font_truetype" type="method" display="FPDF_FONT_TRUETYPE"/>
			<memberdata name="fpdf_font_type1" type="method" display="FPDF_FONT_TYPE1"/>
			<memberdata name="fpdf_fillmode_alternate" type="method" display="FPDF_FILLMODE_ALTERNATE"/>
			<memberdata name="fpdf_fillmode_none" type="method" display="FPDF_FILLMODE_NONE"/>
			<memberdata name="fpdf_fillmode_winding" type="method" display="FPDF_FILLMODE_WINDING"/>
			<memberdata name="fpdf_textrendermode_fill" type="method" display="FPDF_TEXTRENDERMODE_FILL"/>
			<memberdata name="fpdf_textrendermode_fill_stroke" type="method" display="FPDF_TEXTRENDERMODE_FILL_STROKE"/>
			<memberdata name="fpdf_textrendermode_stroke" type="method" display="FPDF_TEXTRENDERMODE_STROKE"/>
			<memberdata name="fpdf_textrendermode_unknown" type="method" display="FPDF_TEXTRENDERMODE_UNKNOWN"/>
			<memberdata name="fpdfbitmap_bgr" type="method" display="FPDFBitmap_BGR"/>
			<memberdata name="fpdfbitmap_bgra" type="method" display="FPDFBitmap_BGRA"/>
			<memberdata name="fpdfbitmap_bgrx" type="method" display="FPDFBitmap_BGRx"/>
			<memberdata name="fpdfbitmap_gray" type="method" display="FPDFBitmap_Gray"/>
			<memberdata name="fpdfbitmap_unknown" type="method" display="FPDFBitmap_Unknown"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE fpdfbitmap_bgr
		RETURN 2
		
	ENDPROC

	PROCEDURE fpdfbitmap_bgra
		RETURN 4
		
	ENDPROC

	PROCEDURE fpdfbitmap_bgrx
		RETURN 3
		
	ENDPROC

	PROCEDURE fpdfbitmap_gray
		RETURN 1
		
	ENDPROC

	PROCEDURE fpdfbitmap_unknown
		RETURN 0
		
	ENDPROC

	PROCEDURE fpdf_err_password
		RETURN 4
		
	ENDPROC

	PROCEDURE fpdf_fillmode_alternate
		RETURN 1
		
	ENDPROC

	PROCEDURE fpdf_fillmode_none
		RETURN 0
		
	ENDPROC

	PROCEDURE fpdf_fillmode_winding
		RETURN 2
		
	ENDPROC

	PROCEDURE fpdf_font_truetype
		RETURN 2
		
	ENDPROC

	PROCEDURE fpdf_font_type1
		RETURN 1
		
	ENDPROC

	PROCEDURE fpdf_pageobj_form
		RETURN 5
		
	ENDPROC

	PROCEDURE fpdf_pageobj_image
		RETURN 3
		
	ENDPROC

	PROCEDURE fpdf_pageobj_path
		RETURN 2
		
	ENDPROC

	PROCEDURE fpdf_pageobj_shading
		RETURN 4
		
	ENDPROC

	PROCEDURE fpdf_pageobj_text
		RETURN 1
		
	ENDPROC

	PROCEDURE fpdf_pageobj_unknown
		RETURN 0
		
	ENDPROC

	PROCEDURE fpdf_printing
		RETURN 0x800
		
	ENDPROC

	PROCEDURE fpdf_textrendermode_fill
		RETURN 0
		
	ENDPROC

	PROCEDURE fpdf_textrendermode_fill_stroke
		RETURN 2
		
	ENDPROC

	PROCEDURE fpdf_textrendermode_stroke
		RETURN 1
		
	ENDPROC

	PROCEDURE fpdf_textrendermode_unknown
		RETURN -1
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_frx AS custom 		&& FRX (VFP Reports) API
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="CONST" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_frx"
		Width = 27
		_memberdata = <VFPData>

		</VFPData>
	*</PropValue>

	ADD OBJECT 'CONST' AS pdfium_api_frx_const WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "CONST", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

ENDDEFINE

DEFINE CLASS pdfium_api_frx_const AS custom 		&& FRX (VFP Reports) API constants
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: align_center
		*m: align_left
		*m: align_right
		*m: frx_obj_comment
		*m: frx_obj_field
		*m: frx_obj_label
		*m: frx_obj_line
		*m: frx_obj_picture
		*m: frx_obj_rectangle
		*m: frx_obj_variable
		*m: outputto_file
		*m: outputto_printer
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_frx_const"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="frx_obj_comment" type="method" display="FRX_OBJ_COMMENT"/>
			<memberdata name="frx_obj_field" type="method" display="FRX_OBJ_FIELD"/>
			<memberdata name="frx_obj_label" type="method" display="FRX_OBJ_LABEL"/>
			<memberdata name="frx_obj_line" type="method" display="FRX_OBJ_LINE"/>
			<memberdata name="frx_obj_picture" type="method" display="FRX_OBJ_PICTURE"/>
			<memberdata name="frx_obj_rectangle" type="method" display="FRX_OBJ_RECTANGLE"/>
			<memberdata name="frx_obj_variable" type="method" display="FRX_OBJ_VARIABLE"/>
			<memberdata name="align_center" type="method" display="ALIGN_CENTER"/>
			<memberdata name="align_left" type="method" display="ALIGN_LEFT"/>
			<memberdata name="align_right" type="method" display="ALIGN_RIGHT"/>
			<memberdata name="outputto_file" type="method" display="OUTPUTTO_FILE"/>
			<memberdata name="outputto_printer" type="method" display="OUTPUTTO_PRINTER"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE align_center
		RETURN 2
		
	ENDPROC

	PROCEDURE align_left
		RETURN 0
		
	ENDPROC

	PROCEDURE align_right
		RETURN 1
		
	ENDPROC

	PROCEDURE frx_obj_comment
		RETURN 0
		
	ENDPROC

	PROCEDURE frx_obj_field
		RETURN 8
		
	ENDPROC

	PROCEDURE frx_obj_label
		RETURN 5
		
	ENDPROC

	PROCEDURE frx_obj_line
		RETURN 6
		
	ENDPROC

	PROCEDURE frx_obj_picture
		RETURN 17
		
	ENDPROC

	PROCEDURE frx_obj_rectangle
		RETURN 7
		
	ENDPROC

	PROCEDURE frx_obj_variable
		RETURN 18
		
	ENDPROC

	PROCEDURE outputto_file
		RETURN 2
		
	ENDPROC

	PROCEDURE outputto_printer
		RETURN 1
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_gdip AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="CONST" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: argb
		*m: checkerror
		*m: gdipbitmaplockbits
		*m: gdipbitmapunlockbits
		*m: gdipclonefontfamily
		*m: gdipclonestringformat
		*m: gdipcreatebitmapfromfile
		*m: gdipcreatebitmapfromhbitmap
		*m: gdipcreatebitmapfromscan0
		*m: gdipcreatefont
		*m: gdipcreatefontfamilyfromname
		*m: gdipcreatefromhdc
		*m: gdipcreatefromhwnd
		*m: gdipcreatesolidfill
		*m: gdipcreatestringformat
		*m: gdipdeletebrush
		*m: gdipdeletefont
		*m: gdipdeletefontfamily
		*m: gdipdeletegraphics
		*m: gdipdeleteprivatefontcollection
		*m: gdipdeletestringformat
		*m: gdipdisposeimage
		*m: gdipdrawimagei
		*m: gdipdrawstring
		*m: gdipfillrectanglei
		*m: gdipflush
		*m: gdipgetcellascent
		*m: gdipgetcelldescent
		*m: gdipgetemheight
		*m: gdipgetfamilyname
		*m: gdipgetfontcollectionfamilycount
		*m: gdipgetfontcollectionfamilylist
		*m: gdipgetfontheightgivendpi
		*m: gdipgetgenericfontfamilysansserif
		*m: gdipgetimageencoder
		*m: gdipgetimageencoders
		*m: gdipgetimageencoderssize
		*m: gdipgetimagegraphicscontext
		*m: gdipgetimageheight
		*m: gdipgetimagepixelformat
		*m: gdipgetimagewidth
		*m: gdipgetlinespacing
		*m: gdipisstyleavailable
		*m: gdipmeasurestring
		*m: gdipnewprivatefontcollection
		*m: gdipprivateaddfontfile
		*m: gdipsaveimagetofile
		*m: gdipscaleworldtransform
		*m: gdipsetcompositingmode
		*m: gdipsetcompositingquality
		*m: gdipsetinterpolationmode
		*m: gdipsetpixeloffsetmode
		*m: gdipsetsolidfillcolor
		*m: gdipsetstringformatalign
		*m: gdipsetstringformatflags
		*m: gdipsetstringformattrimming
		*m: gdipsettextcontrast
		*m: gdipsettextrenderinghint
		*m: gdipstringformatgetgenericdefault
		*m: gdipstringformatgetgenerictypographic
		*p: imageencoders
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,imageencoders,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		imageencoders = .F.
		Name = "pdfium_api_gdip"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="gdipdrawstring" type="method" display="GdipDrawString"/>
			<memberdata name="gdipmeasurestring" type="method" display="GdipMeasureString"/>
			<memberdata name="gdipcreatefontfamilyfromname" type="method" display="GdipCreateFontFamilyFromName"/>
			<memberdata name="gdipdeletefontfamily" type="method" display="GdipDeleteFontFamily"/>
			<memberdata name="gdipnewprivatefontcollection" type="method" display="GdipNewPrivateFontCollection"/>
			<memberdata name="gdipdeleteprivatefontcollection" type="method" display="GdipDeletePrivateFontCollection"/>
			<memberdata name="gdipprivateaddfontfile" type="method" display="GdipPrivateAddFontFile"/>
			<memberdata name="gdipgetfontcollectionfamilylist" type="method" display="GdipGetFontCollectionFamilyList"/>
			<memberdata name="gdipgetfontcollectionfamilycount" type="method" display="GdipGetFontCollectionFamilyCount"/>
			<memberdata name="gdipclonefontfamily" type="method" display="GdipCloneFontFamily"/>
			<memberdata name="gdipgetfamilyname" type="method" display="GdipGetFamilyName"/>
			<memberdata name="gdipgetgenericfontfamilysansserif" type="method" display="GdipGetGenericFontFamilySansSerif"/>
			<memberdata name="gdipcreatefont" type="method" display="GdipCreateFont"/>
			<memberdata name="gdipdeletefont" type="method" display="GdipDeleteFont"/>
			<memberdata name="gdipisstyleavailable" type="method" display="GdipIsStyleAvailable"/>
			<memberdata name="gdipgetfontheightgivendpi" type="method" display="GdipGetFontHeightGivenDPI"/>
			<memberdata name="gdipgetemheight" type="method" display="GdipGetEmHeight"/>
			<memberdata name="gdipgetcellascent" type="method" display="GdipGetCellAscent"/>
			<memberdata name="gdipgetcelldescent" type="method" display="GdipGetCellDescent"/>
			<memberdata name="gdipgetlinespacing" type="method" display="GdipGetLineSpacing"/>
			<memberdata name="gdipcreatefromhwnd" type="method" display="GdipCreateFromHWND"/>
			<memberdata name="gdipdeletegraphics" type="method" display="GdipDeleteGraphics"/>
			<memberdata name="checkerror" type="method" display="CheckError"/>
			<memberdata name="gdipcreatebitmapfromhbitmap" type="method" display="GdipCreateBitmapFromHBITMAP"/>
			<memberdata name="gdipdisposeimage" type="method" display="GdipDisposeImage"/>
			<memberdata name="gdipcreatebitmapfromfile" type="method" display="GdipCreateBitmapFromFile"/>
			<memberdata name="gdipgetimagewidth" type="method" display="GdipGetImageWidth"/>
			<memberdata name="gdipgetimageheight" type="method" display="GdipGetImageHeight"/>
			<memberdata name="gdipcreatebitmapfromscan0" type="method" display="GdipCreateBitmapFromScan0"/>
			<memberdata name="gdipgetimagepixelformat" type="method" display="GdipGetImagePixelFormat"/>
			<memberdata name="gdipgetimagegraphicscontext" type="method" display="GdipGetImageGraphicsContext"/>
			<memberdata name="gdipdrawimagei" type="method" display="GdipDrawImageI"/>
			<memberdata name="gdipsaveimagetofile" type="method" display="GdipSaveImageToFile"/>
			<memberdata name="gdipgetimageencoderssize" type="method" display="GdipGetImageEncodersSize"/>
			<memberdata name="gdipgetimageencoders" type="method" display="GdipGetImageEncoders"/>
			<memberdata name="gdipgetimageencoder" type="method" display="GdipGetImageEncoder"/>
			<memberdata name="imageencoders" type="property" display="ImageEncoders"/>
			<memberdata name="gdipcreatesolidfill" type="method" display="GdipCreateSolidFill"/>
			<memberdata name="gdipdeletebrush" type="method" display="GdipDeleteBrush"/>
			<memberdata name="argb" type="method" display="ARGB"/>
			<memberdata name="gdipfillrectanglei" type="method" display="GdipFillRectangleI"/>
			<memberdata name="gdipsetsolidfillcolor" type="method" display="GdipSetSolidFillColor"/>
			<memberdata name="gdipflush" type="method" display="GdipFlush"/>
			<memberdata name="gdipcreatefromhdc" type="method" display="GdipCreateFromHDC"/>
			<memberdata name="gdipstringformatgetgenericdefault" type="method" display="GdipStringFormatGetGenericDefault"/>
			<memberdata name="gdipstringformatgetgenerictypographic" type="method" display="GdipStringFormatGetGenericTypographic"/>
			<memberdata name="gdipdeletestringformat" type="method" display="GdipDeleteStringFormat"/>
			<memberdata name="gdipclonestringformat" type="method" display="GdipCloneStringFormat"/>
			<memberdata name="gdipcreatestringformat" type="method" display="GdipCreateStringFormat"/>
			<memberdata name="gdipsetstringformatflags" type="method" display="GdipSetStringFormatFlags"/>
			<memberdata name="gdipsetstringformattrimming" type="method" display="GdipSetStringFormatTrimming"/>
			<memberdata name="gdipsetstringformatalign" type="method" display="GdipSetStringFormatAlign"/>
			<memberdata name="gdipsetcompositingmode" type="method" display="GdipSetCompositingMode"/>
			<memberdata name="gdipsetcompositingquality" type="method" display="GdipSetCompositingQuality"/>
			<memberdata name="gdipsetinterpolationmode" type="method" display="GdipSetInterpolationMode"/>
			<memberdata name="gdipsetpixeloffsetmode" type="method" display="GdipSetPixelOffsetMode"/>
			<memberdata name="gdipsettextrenderinghint" type="method" display="GdipSetTextRenderingHint"/>
			<memberdata name="gdipsettextcontrast" type="method" display="GdipSetTextContrast"/>
			<memberdata name="gdipscaleworldtransform" type="method" display="GdipScaleWorldTransform"/>
			<memberdata name="gdipbitmaplockbits" type="method" display="GdipBitmapLockBits"/>
			<memberdata name="gdipbitmapunlockbits" type="method" display="GdipBitmapUnlockBits"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'CONST' AS pdfium_api_gdip_const WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "CONST", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE argb
		LPARAMETERS Alpha, RedOrRGB, Green, Blue
		
		LOCAL lnARGB
		m.lnARGB = 0
		
		DO CASE
		CASE PCOUNT() = 1
		    m.lnARGB = BITLSHIFT(BITAND(m.Alpha, 0xFF), 24) + 0x00FFFFFF
		
		CASE PCOUNT() = 2
		    LOCAL lnRGB
		    m.lnRGB = m.RedOrRGB
		    m.lnARGB = BITLSHIFT(BITAND(m.Alpha, 0xFF), 24)+;
		        BITLSHIFT(BITAND(m.lnRGB, 0x000000FF), 16)+;
		        BITAND(m.lnRGB, 0x0000FF00)+;
		        BITRSHIFT(BITAND(m.lnRGB, 0x00FF0000), 16)
		
		CASE PCOUNT() = 3
		    m.lnARGB = BITLSHIFT(0xFF, 24)+;
		        BITLSHIFT(BITAND(m.RedOrRGB, 0xFF), 16)+;
		        BITLSHIFT(BITAND(m.Green, 0xFF), 8)+;
		        BITAND(m.Blue, 0xFF)
		
		CASE PCOUNT() = 4
		    m.lnARGB = BITLSHIFT(BITAND(m.Alpha, 0xFF), 24)+;
		        BITLSHIFT(BITAND(m.RedOrRGB, 0xFF), 16)+;
		        BITLSHIFT(BITAND(m.Green, 0xFF), 8)+;
		        BITAND(m.Blue,0xFF)
		ENDCASE
		
		RETURN m.lnARGB
		
	ENDPROC

	PROCEDURE checkerror
		LPARAMETERS GdipStatus, NoRaiseError
		
		IF EMPTY(m.GdipStatus)
		    RETURN m.GdipStatus
		ENDIF
		
		IF m.NoRaiseError
		    RETURN m.GdipStatus
		ENDIF
		
		
		LOCAL lcErrMsg
		lcErrMsg = TEXTMERGE("Gdiplus function returned error status <<m.GdipStatus>>")
		
		LOCAL laStack(1), lnStackCount
		m.lnStackCount = ASTACKINFO(m.laStack)
		IF m.lnStackCount > 1
		    m.lcErrMsg = m.lcErrMsg + NVL(CHR(13) + EVL(m.laStack[m.lnStackCount-1, 6], NULL), "")
		ENDIF
		
		ERROR (m.lcErrMsg)
		
	ENDPROC

	PROCEDURE Destroy
		This.ImageEncoders = .F.
		
	ENDPROC

	PROCEDURE gdipbitmaplockbits
		LPARAMETERS bitmap as Long, rect as String, flags as Long, format as Long, lockedBitmapData as String
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipBitmapLockBits(m.bitmap, m.rect, m.flags, m.format, @m.lockedBitmapData)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipBitmapLockBits IN GDIPLUS.DLL AS WinApi_GdipBitmapLockBits Long bitmap, String rect, Long flags, Long format, String @lockedBitmapData
		
		    m.lvRes = WinApi_GdipBitmapLockBits(m.bitmap, m.rect, m.flags, m.format, @m.lockedBitmapData)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipbitmapunlockbits
		LPARAMETERS bitmap as Long, lockedBitmapData as String
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipBitmapUnlockBits(m.bitmap, m.lockedBitmapData)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipBitmapUnlockBits IN GDIPLUS.DLL AS WinApi_GdipBitmapUnlockBits Long bitmap, String lockedBitmapData
		
		    m.lvRes = WinApi_GdipBitmapUnlockBits(m.bitmap, m.lockedBitmapData)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipclonefontfamily
		LPARAMETERS FontFamily as Long, ClonedFontFamily as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCloneFontFamily(m.FontFamily, @m.ClonedFontFamily)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipCloneFontFamily IN GDIPLUS.DLL AS WinApi_GdipCloneFontFamily Long FontFamily, Long @ClonedFontFamily
		
		    m.lvRes = WinApi_GdipCloneFontFamily(m.FontFamily, @m.ClonedFontFamily)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipclonestringformat
		LPARAMETERS StringFormat as Long, newFormat as Long
		
		m.newFormat = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCloneStringFormat(m.StringFormat, @m.newFormat)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipCloneStringFormat IN GDIPLUS.DLL AS WinApi_GdipCloneStringFormat Long StringFormat, Long @newFormat
		
		    m.lvRes = WinApi_GdipCloneStringFormat(m.StringFormat, @m.newFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatebitmapfromfile
		LPARAMETERS filename as String, bitmap as Long
		
		m.bitmap = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateBitmapFromFile(m.filename, @m.bitmap)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipCreateBitmapFromFile IN GDIPLUS.DLL AS WinApi_GdipCreateBitmapFromFile String filename, Long @bitmap
		
		    m.lvRes = WinApi_GdipCreateBitmapFromFile(m.filename, @m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatebitmapfromhbitmap
		LPARAMETERS hbitmap as Long, hpalette as Long, hGpBitmap as Long
		
		m.hGpBitmap = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateBitmapFromHBITMAP(m.hbitmap, m.hpalette, @m.hGpBitmap)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipCreateBitmapFromHBITMAP IN GDIPLUS.DLL AS WinApi_GdipCreateBitmapFromHBITMAP Long hbitmap, Long hpalette, Long @hGpBitmap
		
		    m.lvRes = WinApi_GdipCreateBitmapFromHBITMAP(m.hbitmap, m.hpalette, @m.hGpBitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatebitmapfromscan0
		LPARAMETERS width as Long, height as Long, stride as Long, format as Long, scan0 as String, bitmap as Long
		
		m.bitmap = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateBitmapFromScan0(m.width, m.height, m.stride, m.format, m.scan0, @m.bitmap)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipCreateBitmapFromScan0 IN GDIPLUS.DLL AS WinApi_GdipCreateBitmapFromScan0 Long width, Long height, Long stride, Long format, String scan0, Long @bitmap
		
		    m.lvRes = WinApi_GdipCreateBitmapFromScan0(m.width, m.height, m.stride, m.format, m.scan0, @m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatefont
		LPARAMETERS FontFamily as Long, emSize as Single, Style as Long, Unit as Long, font as Long
		
		m.font = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateFont(m.FontFamily, m.emSize, m.Style, m.Unit, @m.font)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipCreateFont IN GDIPLUS.DLL AS WinApi_GdipCreateFont Long FontFamily, Single emSize, Long style, Long unit, Long @font
		
		    m.lvRes = WinApi_GdipCreateFont(m.FontFamily, m.emSize, m.Style, m.Unit, @m.font)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatefontfamilyfromname
		LPARAMETERS FaceName as String, FontCollection as Long, FontFamily as Long
		
		m.FontFamily = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateFontFamilyFromName(m.FaceName, m.FontCollection, @m.FontFamily)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipCreateFontFamilyFromName IN GDIPLUS.DLL AS WinApi_GdipCreateFontFamilyFromName String FaceName, Long FontCollection, Long @FontFamily
		
		    m.lvRes = WinApi_GdipCreateFontFamilyFromName(m.FaceName, m.FontCollection, @m.FontFamily)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatefromhdc
		LPARAMETERS hdc as Long, graphics as Long
		
		m.graphics = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateFromHDC(m.hdc, @m.graphics)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipCreateFromHDC IN GDIPLUS.DLL AS WinApi_GdipCreateFromHDC Long hdc, Long @graphics
		
		    m.lvRes = WinApi_GdipCreateFromHDC(m.hdc, @m.graphics)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatefromhwnd
		LPARAMETERS hwnd as Long, graphics as Long
		
		m.graphics = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateFromHWND(m.hwnd, @m.graphics)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipCreateFromHWND IN GDIPLUS.DLL AS WinApi_GdipCreateFromHWND Long hwnd, Long @graphics
		
		    m.lvRes = WinApi_GdipCreateFromHWND(m.hwnd, @m.graphics)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatesolidfill
		LPARAMETERS color as Long, brush as Long
		
		m.brush = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateSolidFill(m.color, @m.brush)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipCreateSolidFill IN GDIPLUS.DLL AS WinApi_GdipCreateSolidFill Long color, Long @brush
		
		    m.lvRes = WinApi_GdipCreateSolidFill(m.color, @m.brush)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatestringformat
		LPARAMETERS formatAttributes as Integer, language as Integer, StringFormat as Long
		
		m.StringFormat = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateStringFormat(m.formatAttributes, m.language, @m.StringFormat)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipCreateStringFormat IN GDIPLUS.DLL AS WinApi_GdipCreateStringFormat Integer formatAttributes, Integer language, Long @StringFormat
		
		    m.lvRes = WinApi_GdipCreateStringFormat(m.formatAttributes, m.language, @m.StringFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdeletebrush
		LPARAMETERS brush as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDeleteBrush(m.brush)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipDeleteBrush IN GDIPLUS.DLL AS WinApi_GdipDeleteBrush Long brush
		
		    m.lvRes = WinApi_GdipDeleteBrush(m.brush)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdeletefont
		LPARAMETERS font as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDeleteFont(m.font)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipDeleteFont IN GDIPLUS.DLL AS WinApi_GdipDeleteFont Long font
		
		    m.lvRes = WinApi_GdipDeleteFont(m.font)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdeletefontfamily
		LPARAMETERS FontFamily as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDeleteFontFamily(m.FontFamily)    
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipDeleteFontFamily IN GDIPLUS.DLL AS WinApi_GdipDeleteFontFamily Long FontFamily
		
		    m.lvRes = WinApi_GdipDeleteFontFamily(m.FontFamily)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdeletegraphics
		LPARAMETERS graphics as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDeleteGraphics(m.graphics)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipDeleteGraphics IN GDIPLUS.DLL AS WinApi_GdipDeleteGraphics Long graphics
		
		    m.lvRes = WinApi_GdipDeleteGraphics(m.graphics)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdeleteprivatefontcollection
		LPARAMETERS FontCollection as Long
		
		m.FontCollection = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDeletePrivateFontCollection(@m.FontCollection)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipDeletePrivateFontCollection IN GDIPLUS.DLL AS WinApi_GdipDeletePrivateFontCollection Long @FontCollection
		
		    m.lvRes = WinApi_GdipDeletePrivateFontCollection(@m.FontCollection)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdeletestringformat
		LPARAMETERS StringFormat as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDeleteStringFormat(m.StringFormat)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipDeleteStringFormat IN GDIPLUS.DLL AS WinApi_GdipDeleteStringFormat Long StringFormat
		
		    m.lvRes = WinApi_GdipDeleteStringFormat(m.StringFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdisposeimage
		LPARAMETERS image as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDisposeImage(m.image)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipDisposeImage IN GDIPLUS.DLL AS WinApi_GdipDisposeImage Long image
		
		    m.lvRes = WinApi_GdipDisposeImage(m.image)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdrawimagei
		LPARAMETERS graphics as Long, image as Long, x as Integer, y as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDrawImageI(m.graphics, m.image, m.x, m.y)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipDrawImageI IN GDIPLUS.DLL AS WinApi_GdipDrawImageI Long graphics, Long image, Integer x, Integer y
		
		    m.lvRes = WinApi_GdipDrawImageI(m.graphics, m.image, m.x, m.y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdrawstring
		LPARAMETERS graphics as Long, str as String, length as Long, thefont as Long, layoutRect as String, StringFormat as Long, brush as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDrawString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, m.brush)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE Long GdipDrawString IN GDIPLUS.DLL AS WinApi_GdipDrawString Long graphics, String str, Long length, Long thefont, String @layoutRect, Long StringFormat, Long brush
		    m.lvRes = WinApi_GdipDrawString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, m.brush)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipfillrectanglei
		LPARAMETERS graphics as Long, brush as Long, x as Long, y as Long, width as Long, height as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipFillRectangleI(m.graphics, m.brush, m.x, m.y, m.width, m.height)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipFillRectangleI IN GDIPLUS.DLL AS WinApi_GdipFillRectangleI Long graphics, Long brush, Long x, Long y, Long width, Long height
		
		    m.lvRes = WinApi_GdipFillRectangleI(m.graphics, m.brush, m.x, m.y, m.width, m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipflush
		LPARAMETERS graphics as Long, intention as Long
		
		m.intention = EVL(m.intention, 0)
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipFlush(m.graphics, m.intention)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipFlush IN GDIPLUS.DLL AS WinApi_GdipFlush Long graphics, Long intention
		
		    m.lvRes = WinApi_GdipFlush(m.graphics, m.intention)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetcellascent
		LPARAMETERS family as Long, style as Long, CellAscent as Long
		
		m.CellAscent = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetCellAscent(m.family, m.style, @m.CellAscent)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetCellAscent IN GDIPLUS.DLL AS WinApi_GdipGetCellAscent Long family, Long style, Long @CellAscent
		
		    m.lvRes = WinApi_GdipGetCellAscent(m.family, m.style, @m.CellAscent)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetcelldescent
		LPARAMETERS family as Long, style as Long, CellDescent as Long
		
		m.CellDescent = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetCellDescent(m.family, m.style, @m.CellDescent)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetCellDescent IN GDIPLUS.DLL AS WinApi_GdipGetCellDescent Long family, Long style, Long @CellDescent
		
		    m.lvRes = WinApi_GdipGetCellDescent(m.family, m.style, @m.CellDescent)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetemheight
		LPARAMETERS family as Long, style as Long, EmHeight as Long
		
		m.EmHeight = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetEmHeight(m.family, m.style, @m.EmHeight)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetEmHeight IN GDIPLUS.DLL AS WinApi_GdipGetEmHeight Long family, Long style, Long @EmHeight
		
		    m.lvRes = WinApi_GdipGetEmHeight(m.family, m.style, @m.EmHeight)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetfamilyname
		LPARAMETERS FontFamily as Long, Name as String, Language as Integer
		
		#define LF_FACESIZE 32
		
		m.Name = REPLICATE(CHR(0), LF_FACESIZE * 2)
		m.Language = EVL(NVL(m.Language,0),0)
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetFamilyName(m.FontFamily, @m.Name, m.Language)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetFamilyName IN GDIPLUS.DLL AS WinApi_GdipGetFamilyName Long FontFamily, String @Name, Integer Language
		
		    m.lvRes = WinApi_GdipGetFamilyName(m.FontFamily, @m.Name, m.Language)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetfontcollectionfamilycount
		LPARAMETERS FontCollection as Long, numFound as Long
		
		m.numFound = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetFontCollectionFamilyCount(m.FontCollection, @m.numFound)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetFontCollectionFamilyCount IN GDIPLUS.DLL AS WinApi_GdipGetFontCollectionFamilyCount Long fontCollection, Long @numFound
		
		    m.lvRes = WinApi_GdipGetFontCollectionFamilyCount(m.FontCollection, @m.numFound)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetfontcollectionfamilylist
		LPARAMETERS FontCollection as Long, numSought as Long, gpfamilies as String, numFound as Long
		
		m.gpfamilies = REPLICATE(CHR(0), m.numSought * 4)
		m.numFound = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetFontCollectionFamilyList(m.FontCollection, m.numSought, @m.gpfamilies, @m.numFound)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetFontCollectionFamilyList IN GDIPLUS.DLL AS WinApi_GdipGetFontCollectionFamilyList Long fontCollection, Long numSought, String @gpfamilies, Long @numFound
		
		    m.lvRes = WinApi_GdipGetFontCollectionFamilyList(m.FontCollection, m.numSought, @m.gpfamilies, @m.numFound)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetfontheightgivendpi
		LPARAMETERS font as Long, dpi as Single, height as Long
		
		m.height = 0.0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetFontHeightGivenDPI(m.font, m.dpi, @m.height)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetFontHeightGivenDPI IN GDIPLUS.DLL AS WinApi_GdipGetFontHeightGivenDPI Long font, Single dpi, Single @height
		
		    m.lvRes = WinApi_GdipGetFontHeightGivenDPI(m.font, m.dpi, @m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetgenericfontfamilysansserif
		LPARAMETERS nativeFamily as Long
		
		m.nativeFamily = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetGenericFontFamilySansSerif(@m.nativeFamily)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetGenericFontFamilySansSerif IN GDIPLUS.DLL AS WinApi_GdipGetGenericFontFamilySansSerif Long @nativeFamily
		
		    m.lvRes = WinApi_GdipGetGenericFontFamilySansSerif(@m.nativeFamily)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetimageencoder
		LPARAMETERS MimeType as String
		
		IF VARTYPE(This.ImageEncoders) != "O"
		    
		    This.ImageEncoders = NEWOBJECT("Collection")
		
		    #define ClsidOffset 0
		    #define MimeTypeOffset 48
		    #define ImageCodecInfoSize 76
		
		    #define HEAP_CREATE_ENABLE_EXECUTE 0x00040000
		    #define HEAP_ZERO_MEMORY 0x00000008
		
		    LOCAL lhHeap, lnHeapPtr
		    STORE 0 TO m.lhHeap, m.lnHeapPtr
		
		    TRY
		
		        LOCAL loWin as Pdfium_api_win OF pdfium-vfp.vcx
		        m.loWin = NEWOBJECT("pdfium_api_win", This.ClassLibrary)
		
		        LOCAL lnEncodersCount, lnBufSize
		        STORE 0 TO m.lnEncodersCount, m.lnBufSize
		
		        This.CheckError(This.GdipGetImageEncodersSize(@m.lnEncodersCount, @m.lnBufSize))
		
		        IF EMPTY(m.lnBufSize)
		            EXIT
		        ENDIF
		
		        m.lhHeap = m.loWin.HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, m.lnBufSize, m.lnBufSize)
		        IF EMPTY(m.lhHeap)
		            EXIT
		        ENDIF
		
		        m.lnHeapPtr = m.loWin.HeapAlloc(m.lhHeap, HEAP_ZERO_MEMORY, m.lnBufSize)
		        IF EMPTY(m.lnHeapPtr)
		            EXIT
		        ENDIF
		
		        This.CheckError(This.GdipGetImageEncoders(m.lnEncodersCount, m.lnBufSize, m.lnHeapPtr))
		        
		        LOCAL liEncoder, lnEncPtr
		        m.liEncoder = 1
		        FOR m.liEncoder = 1 TO m.lnEncodersCount
		            
		            m.lnEncPtr = m.lnHeapPtr + (m.liEncoder - 1) * ImageCodecInfoSize
		
		            LOCAL lnMimeTypePtr
		            m.lnMimeTypePtr = CTOBIN(SYS(2600, m.lnEncPtr + MimeTypeOffset, 4), "4RS")
		            
		            IF EMPTY(m.lnMimeTypePtr)
		                LOOP
		            ENDIF
		            
		            LOCAL lcEncMimeType
		            m.lcEncMimeType = SYS(2600, m.lnMimeTypePtr, m.lnBufSize - (m.lnMimeTypePtr - m.lnHeapPtr))
		            m.lcEncMimeType = STRCONV(m.lcEncMimeType,6)
		            m.lcEncMimeType = LEFT(m.lcEncMimeType, AT(CHR(0), m.lcEncMimeType)-1)
		            m.lcEncMimeType = LOWER(ALLTRIM(m.lcEncMimeType))
		            
		            LOCAL lcEncCLSID
		            m.lcEncCLSID = SYS(2600, m.lnEncPtr + ClsidOffset, 16)
		            
		            IF EMPTY(This.ImageEncoders.GetKey(m.lcEncMimeType))
		                This.ImageEncoders.Add(m.lcEncCLSID, m.lcEncMimeType)
		            ENDIF
		            
		        ENDFOR
		
		    FINALLY
		        IF EMPTY(m.lnHeapPtr)=.F.
		            m.loWin.HeapFree(m.lhHeap, 0, m.lnHeapPtr)
		            m.lnHeapPtr = 0 
		        ENDIF
		        
		        IF EMPTY(m.lhHeap)=.F.
		            m.loWin.HeapDestroy(m.lhHeap)
		            m.lhHeap = 0 
		        ENDIF
		        
		    ENDTRY
		
		ENDIF
		
		IF EMPTY(m.MimeType)
		    RETURN ""
		ENDIF
		
		LOCAL lcImageEncoderCLSID
		m.lcImageEncoderCLSID = ""
		
		LOCAL liImageEncoder
		m.liImageEncoder = This.ImageEncoders.GetKey(LOWER(ALLTRIM(m.MimeType)))
		IF m.liImageEncoder > 0
		    m.lcImageEncoderCLSID = This.ImageEncoders.Item(m.liImageEncoder)
		ENDIF
		
		RETURN m.lcImageEncoderCLSID
		
	ENDPROC

	PROCEDURE gdipgetimageencoders
		LPARAMETERS numEncoders as Long, size as Long, encoders as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetImageEncoders(m.numEncoders, m.size, m.encoders)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetImageEncoders IN GDIPLUS.DLL AS WinApi_GdipGetImageEncoders Long numEncoders, Long size, Long encoders
		
		    m.lvRes = WinApi_GdipGetImageEncoders(m.numEncoders, m.size, m.encoders)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetimageencoderssize
		LPARAMETERS numEncoders as Long, size as Long
		
		m.numEncoders = 0
		m.size = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetImageEncodersSize(@m.numEncoders, @m.size)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetImageEncodersSize IN GDIPLUS.DLL AS WinApi_GdipGetImageEncodersSize Long @numEncoders, Long @size
		
		    m.lvRes = WinApi_GdipGetImageEncodersSize(@m.numEncoders, @m.size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetimagegraphicscontext
		LPARAMETERS image as Long, graphics as Long
		
		m.graphics = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetImageGraphicsContext(m.image, @m.graphics)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetImageGraphicsContext IN GDIPLUS.DLL AS WinApi_GdipGetImageGraphicsContext Long image, Long @graphics
		
		    m.lvRes = WinApi_GdipGetImageGraphicsContext(m.image, @m.graphics)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetimageheight
		LPARAMETERS image as Long, height as Long
		
		m.height = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetImageHeight(m.image, @m.height)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetImageHeight IN GDIPLUS.DLL AS WinApi_GdipGetImageHeight Long image, Long @height
		
		    m.lvRes = WinApi_GdipGetImageHeight(m.image, @m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetimagepixelformat
		LPARAMETERS image as Long, format as Long
		
		m.format = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetImagePixelFormat(m.image, @m.format)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetImagePixelFormat IN GDIPLUS.DLL AS WinApi_GdipGetImagePixelFormat Long image, Long @format
		
		    m.lvRes = WinApi_GdipGetImagePixelFormat(m.image, @m.format)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetimagewidth
		LPARAMETERS image as Long, width as Long
		
		m.width = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetImageWidth(m.image, @m.width)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetImageWidth IN GDIPLUS.DLL AS WinApi_GdipGetImageWidth Long image, Long @width
		
		    m.lvRes = WinApi_GdipGetImageWidth(m.image, @m.width)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetlinespacing
		LPARAMETERS family as Long, style as Long, LineSpacing as Long
		
		m.LineSpacing = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetLineSpacing(m.family, m.style, @m.LineSpacing)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipGetLineSpacing IN GDIPLUS.DLL AS WinApi_GdipGetLineSpacing Long family, Long style, Long @LineSpacing
		
		    m.lvRes = WinApi_GdipGetLineSpacing(m.family, m.style, @m.LineSpacing)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipisstyleavailable
		LPARAMETERS family as Long, style as Long, IsStyleAvailable as Long
		
		m.IsStyleAvailable = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipIsStyleAvailable(m.family, m.style, @m.IsStyleAvailable)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipIsStyleAvailable IN GDIPLUS.DLL AS WinApi_GdipIsStyleAvailable Long family, Long style, Long @IsStyleAvailable
		
		    m.lvRes = WinApi_GdipIsStyleAvailable(m.family, m.style, @m.IsStyleAvailable)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipmeasurestring
		LPARAMETERS graphics as Long, str as String, length as Long, thefont as Long, layoutRect as String, StringFormat as Long, boundingBox as String, codepointsFitted as Long, linesFilled as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipMeasureString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, @m.boundingBox, @m.codepointsFitted, @m.linesFilled)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipMeasureString IN GDIPLUS.DLL AS WinApi_GdipMeasureString ;
		        Long graphics, String str, Long length, Long thefont, String @layoutRect, Long StringFormat, String @boundingBox, Long @codepointsFitted, Long @linesFilled
		
		    m.lvRes = WinApi_GdipMeasureString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, @m.boundingBox, @m.codepointsFitted, @m.linesFilled)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipnewprivatefontcollection
		LPARAMETERS FontCollection as Long
		
		m.FontCollection = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipNewPrivateFontCollection(@m.FontCollection)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipNewPrivateFontCollection IN GDIPLUS.DLL AS WinApi_GdipNewPrivateFontCollection Long @FontCollection
		
		    m.lvRes = WinApi_GdipNewPrivateFontCollection(@m.FontCollection)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipprivateaddfontfile
		LPARAMETERS FontCollection as Long, FileName as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipPrivateAddFontFile(m.FontCollection, m.FileName)    
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipPrivateAddFontFile IN GDIPLUS.DLL AS WinApi_GdipPrivateAddFontFile Long FontCollection, String FileName
		
		    m.lvRes = WinApi_GdipPrivateAddFontFile(m.FontCollection, m.FileName)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsaveimagetofile
		LPARAMETERS image as Long, filename as String, clsidEncoder as String, EncoderParameters as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSaveImageToFile(m.image, m.filename, m.clsidEncoder, m.EncoderParameters)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipSaveImageToFile IN GDIPLUS.DLL AS WinApi_GdipSaveImageToFile Long image, String filename, String clsidEncoder, Long EncoderParameters
		
		    m.lvRes = WinApi_GdipSaveImageToFile(m.image, m.filename, m.clsidEncoder, m.EncoderParameters)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipscaleworldtransform
		LPARAMETERS graphics as Long, sx as Single, sy as Single, order as Long
		
		m.order = EVL(m.order, 0)
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipScaleWorldTransform(m.graphics, m.sx, m.sy, m.order)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipScaleWorldTransform IN GDIPLUS.DLL AS WinApi_GdipScaleWorldTransform Long graphics, Single sx, Single sy, Long order
		
		    m.lvRes = WinApi_GdipScaleWorldTransform(m.graphics, m.sx, m.sy, m.order)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetcompositingmode
		LPARAMETERS graphics as Long, mode as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetCompositingMode(m.graphics, m.mode)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipSetCompositingMode IN GDIPLUS.DLL AS WinApi_GdipSetCompositingMode Long graphics, Long mode
		
		    m.lvRes = WinApi_GdipSetCompositingMode(m.graphics, m.mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetcompositingquality
		LPARAMETERS graphics as Long, quality as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetCompositingQuality(m.graphics, m.quality)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipSetCompositingQuality IN GDIPLUS.DLL AS WinApi_GdipSetCompositingQuality Long graphics, Long quality
		
		    m.lvRes = WinApi_GdipSetCompositingQuality(m.graphics, m.quality)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetinterpolationmode
		LPARAMETERS graphics as Long, mode as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetInterpolationMode(m.graphics, m.mode)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipSetInterpolationMode IN GDIPLUS.DLL AS WinApi_GdipSetInterpolationMode Long graphics, Long mode
		
		    m.lvRes = WinApi_GdipSetInterpolationMode(m.graphics, m.mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetpixeloffsetmode
		LPARAMETERS graphics as Long, mode as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetPixelOffsetMode(m.graphics, m.mode)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipSetPixelOffsetMode IN GDIPLUS.DLL AS WinApi_GdipSetPixelOffsetMode Long graphics, Long mode
		
		    m.lvRes = WinApi_GdipSetPixelOffsetMode(m.graphics, m.mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetsolidfillcolor
		LPARAMETERS brush as Long, color as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetSolidFillColor(m.brush, m.color)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipSetSolidFillColor IN GDIPLUS.DLL AS WinApi_GdipSetSolidFillColor Long brush, Long color
		
		    m.lvRes = WinApi_GdipSetSolidFillColor(m.brush, m.color)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetstringformatalign
		LPARAMETERS StringFormat as Long, align as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetStringFormatAlign(m.StringFormat, m.align)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipSetStringFormatAlign IN GDIPLUS.DLL AS WinApi_GdipSetStringFormatAlign Long StringFormat, Long align
		
		    m.lvRes = WinApi_GdipSetStringFormatAlign(m.StringFormat, m.align)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetstringformatflags
		LPARAMETERS StringFormat as Long, flags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetStringFormatFlags(m.StringFormat, m.flags)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipSetStringFormatFlags IN GDIPLUS.DLL AS WinApi_GdipSetStringFormatFlags Long StringFormat, Long flags
		
		    m.lvRes = WinApi_GdipSetStringFormatFlags(m.StringFormat, m.flags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetstringformattrimming
		LPARAMETERS StringFormat as Long, trimming as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetStringFormatTrimming(m.StringFormat, m.trimming)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipSetStringFormatTrimming IN GDIPLUS.DLL AS WinApi_GdipSetStringFormatTrimming Long StringFormat, Long trimming
		
		    m.lvRes = WinApi_GdipSetStringFormatTrimming(m.StringFormat, m.trimming)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsettextcontrast
		LPARAMETERS graphics as Long, contrast as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetTextContrast(m.graphics, m.contrast)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipSetTextContrast IN GDIPLUS.DLL AS WinApi_GdipSetTextContrast Long graphics, Long contrast
		
		    m.lvRes = WinApi_GdipSetTextContrast(m.graphics, m.contrast)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsettextrenderinghint
		LPARAMETERS graphics as Long, mode as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetTextRenderingHint(m.graphics, m.mode)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipSetTextRenderingHint IN GDIPLUS.DLL AS WinApi_GdipSetTextRenderingHint Long graphics, Long mode
		
		    m.lvRes = WinApi_GdipSetTextRenderingHint(m.graphics, m.mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipstringformatgetgenericdefault
		LPARAMETERS StringFormat as Long
		
		m.StringFormat = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipStringFormatGetGenericDefault(@m.StringFormat)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipStringFormatGetGenericDefault IN GDIPLUS.DLL AS WinApi_GdipStringFormatGetGenericDefault Long @StringFormat
		
		    m.lvRes = WinApi_GdipStringFormatGetGenericDefault(@m.StringFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipstringformatgetgenerictypographic
		LPARAMETERS StringFormat as Long
		
		m.StringFormat = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipStringFormatGetGenericTypographic(@m.StringFormat)
		CATCH
		    SET CONSOLE OFF    
		    
		    DECLARE Long GdipStringFormatGetGenericTypographic IN GDIPLUS.DLL AS WinApi_GdipStringFormatGetGenericTypographic Long @StringFormat
		
		    m.lvRes = WinApi_GdipStringFormatGetGenericTypographic(@m.StringFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_gdip_const AS custom 		&& Gdiplus constants
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: gdip_fontstylebold
		*m: gdip_fontstyleitalic
		*m: gdip_fontstyleregular
		*m: gdip_fontstylestrikeout
		*m: gdip_fontstyleunderline
		*m: gdip_imagelockmoderead
		*m: gdip_imagelockmodeuserinputbuf
		*m: gdip_imagelockmodewrite
		*m: gdip_pixelformat32bppargb
		*m: gdip_stringalignmentcenter
		*m: gdip_stringalignmentfar
		*m: gdip_stringalignmentnear
		*m: gdip_stringformatflagslinelimit
		*m: gdip_stringtrimmingcharacter
		*m: gdip_stringtrimmingellipsischaracter
		*m: gdip_stringtrimmingellipsispath
		*m: gdip_stringtrimmingellipsisword
		*m: gdip_stringtrimmingnone
		*m: gdip_stringtrimmingword
		*m: gdip_unitpoint
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_gdip_const"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="gdip_unitpoint" type="method" display="Gdip_UnitPoint"/>
			<memberdata name="gdip_fontstylebold" type="method" display="Gdip_FontStyleBold"/>
			<memberdata name="gdip_fontstyleregular" type="method" display="Gdip_FontStyleRegular"/>
			<memberdata name="gdip_fontstyleitalic" type="method" display="Gdip_FontStyleItalic"/>
			<memberdata name="gdip_fontstyleunderline" type="method" display="Gdip_FontStyleUnderline"/>
			<memberdata name="gdip_fontstylestrikeout" type="method" display="Gdip_FontStyleStrikeout"/>
			<memberdata name="gdip_stringformatflagslinelimit" type="method" display="Gdip_StringFormatFlagsLineLimit"/>
			<memberdata name="gdip_stringalignmentcenter" type="method" display="Gdip_StringAlignmentCenter"/>
			<memberdata name="gdip_stringalignmentfar" type="method" display="Gdip_StringAlignmentFar"/>
			<memberdata name="gdip_stringalignmentnear" type="method" display="Gdip_StringAlignmentNear"/>
			<memberdata name="gdip_stringtrimmingcharacter" type="method" display="Gdip_StringTrimmingCharacter"/>
			<memberdata name="gdip_stringtrimmingellipsischaracter" type="method" display="Gdip_StringTrimmingEllipsisCharacter"/>
			<memberdata name="gdip_stringtrimmingellipsispath" type="method" display="Gdip_StringTrimmingEllipsisPath"/>
			<memberdata name="gdip_stringtrimmingellipsisword" type="method" display="Gdip_StringTrimmingEllipsisWord"/>
			<memberdata name="gdip_stringtrimmingnone" type="method" display="Gdip_StringTrimmingNone"/>
			<memberdata name="gdip_stringtrimmingword" type="method" display="Gdip_StringTrimmingWord"/>
			<memberdata name="gdip_pixelformat32bppargb" type="method" display="Gdip_PixelFormat32bppARGB"/>
			<memberdata name="gdip_imagelockmoderead" type="method" display="Gdip_ImageLockModeRead"/>
			<memberdata name="gdip_imagelockmodewrite" type="method" display="Gdip_ImageLockModeWrite"/>
			<memberdata name="gdip_imagelockmodeuserinputbuf" type="method" display="Gdip_ImageLockModeUserInputBuf"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE gdip_fontstylebold
		RETURN 1
		
	ENDPROC

	PROCEDURE gdip_fontstyleitalic
		RETURN 2
		
	ENDPROC

	PROCEDURE gdip_fontstyleregular
		RETURN 0
		
	ENDPROC

	PROCEDURE gdip_fontstylestrikeout
		RETURN 8
		
	ENDPROC

	PROCEDURE gdip_fontstyleunderline
		RETURN 4
		
	ENDPROC

	PROCEDURE gdip_imagelockmoderead
		RETURN 0x0001
		
	ENDPROC

	PROCEDURE gdip_imagelockmodeuserinputbuf
		RETURN 0x0004
		
	ENDPROC

	PROCEDURE gdip_imagelockmodewrite
		RETURN 0x0002
		
	ENDPROC

	PROCEDURE gdip_pixelformat32bppargb
		RETURN (10 + 0x2000 + 0x00040000 + 0x00020000 + 0x00200000)
		
	ENDPROC

	PROCEDURE gdip_stringalignmentcenter
		RETURN 1
		
	ENDPROC

	PROCEDURE gdip_stringalignmentfar
		RETURN 2
		
	ENDPROC

	PROCEDURE gdip_stringalignmentnear
		RETURN 0
		
	ENDPROC

	PROCEDURE gdip_stringformatflagslinelimit
		RETURN 0x00002000
		
	ENDPROC

	PROCEDURE gdip_stringtrimmingcharacter
		RETURN 1
		
	ENDPROC

	PROCEDURE gdip_stringtrimmingellipsischaracter
		RETURN 3
		
	ENDPROC

	PROCEDURE gdip_stringtrimmingellipsispath
		RETURN 5
		
	ENDPROC

	PROCEDURE gdip_stringtrimmingellipsisword
		RETURN 4
		
	ENDPROC

	PROCEDURE gdip_stringtrimmingnone
		RETURN 0
		
	ENDPROC

	PROCEDURE gdip_stringtrimmingword
		RETURN 2
		
	ENDPROC

	PROCEDURE gdip_unitpoint
		RETURN 3
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_win AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: bcryptclosealgorithmprovider
		*m: bcryptcreatehash
		*m: bcryptdestroyhash
		*m: bcryptdestroykey
		*m: bcryptencrypt
		*m: bcryptfinishhash
		*m: bcryptgeneratesymmetrickey
		*m: bcryptgetproperty
		*m: bcrypthashdata
		*m: bcryptopenalgorithmprovider
		*m: beginpaint
		*m: bitblt
		*m: callwindowproc
		*m: closeclipboard
		*m: closeprinter
		*m: createcompatibledc
		*m: createdc
		*m: createdibsection
		*m: createwindowex
		*m: deletedc
		*m: deleteobject
		*m: destroywindow
		*m: devicecapabilities
		*m: documentproperties
		*m: emptyclipboard
		*m: enddoc
		*m: endpage
		*m: endpaint
		*m: enumforms
		*m: findnlsstring
		*m: getclassinfoex
		*m: getclipboarddata
		*m: getdc
		*m: getdefaultprinter
		*m: getdevicecaps
		*m: getkeystate
		*m: getmodulehandle
		*m: getopenclipboardwindow
		*m: getsavefilenamea
		*m: getscrollinfo
		*m: getsystemdefaultlcid
		*m: gettickcount
		*m: getwindow
		*m: getwindowlong
		*m: globalalloc
		*m: globalfree
		*m: globallock
		*m: globalunlock
		*m: heapalloc
		*m: heapcreate
		*m: heapdestroy
		*m: heapfree
		*m: invalidaterect
		*m: isclipboardformatavailable
		*m: movewindow
		*m: openclipboard
		*m: openprinter
		*m: registerclassex
		*m: releasedc
		*m: selectobject
		*m: setclipboarddata
		*m: setdefaultprinter
		*m: setscrollinfo
		*m: shellexecute
		*m: showwindow		&& Specifies the Form window to show the Form or Toolbar in at creation time.
		*m: startdoc
		*m: startpage
		*m: uuidcreate
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_win"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="getmodulehandle" type="method" display="GetModuleHandle"/>
			<memberdata name="getwindowlong" type="method" display="GetWindowLong"/>
			<memberdata name="getclassinfoex" type="method" display="GetClassInfoEx"/>
			<memberdata name="registerclassex" type="method" display="RegisterClassEx"/>
			<memberdata name="createwindowex" type="method" display="CreateWindowEx"/>
			<memberdata name="movewindow" type="method" display="MoveWindow"/>
			<memberdata name="destroywindow" type="method" display="DestroyWindow"/>
			<memberdata name="getwindow" type="method" display="GetWindow"/>
			<memberdata name="bitblt" type="method" display="BitBlt"/>
			<memberdata name="createdibsection" type="method" display="CreateDIBSection"/>
			<memberdata name="selectobject" type="method" display="SelectObject"/>
			<memberdata name="deleteobject" type="method" display="DeleteObject"/>
			<memberdata name="createcompatibledc" type="method" display="CreateCompatibleDC"/>
			<memberdata name="getdc" type="method" display="GetDC"/>
			<memberdata name="releasedc" type="method" display="ReleaseDC"/>
			<memberdata name="deletedc" type="method" display="DeleteDC"/>
			<memberdata name="createdc" type="method" display="CreateDC"/>
			<memberdata name="findnlsstring" type="method" display="FindNLSString"/>
			<memberdata name="getsystemdefaultlcid" type="method" display="GetSystemDefaultLCID"/>
			<memberdata name="openprinter" type="method" display="OpenPrinter"/>
			<memberdata name="closeprinter" type="method" display="ClosePrinter"/>
			<memberdata name="documentproperties" type="method" display="DocumentProperties"/>
			<memberdata name="getdefaultprinter" type="method" display="GetDefaultPrinter"/>
			<memberdata name="setdefaultprinter" type="method" display="SetDefaultPrinter"/>
			<memberdata name="devicecapabilities" type="method" display="DeviceCapabilities"/>
			<memberdata name="getdevicecaps" type="method" display="GetDeviceCaps"/>
			<memberdata name="enumforms" type="method" display="EnumForms"/>
			<memberdata name="startpage" type="method" display="StartPage"/>
			<memberdata name="endpage" type="method" display="EndPage"/>
			<memberdata name="enddoc" type="method" display="EndDoc"/>
			<memberdata name="startdoc" type="method" display="StartDoc"/>
			<memberdata name="heapalloc" type="method" display="HeapAlloc"/>
			<memberdata name="heapcreate" type="method" display="HeapCreate"/>
			<memberdata name="heapdestroy" type="method" display="HeapDestroy"/>
			<memberdata name="heapfree" type="method" display="HeapFree"/>
			<memberdata name="globalalloc" type="method" display="GlobalAlloc"/>
			<memberdata name="globalfree" type="method" display="GlobalFree"/>
			<memberdata name="globallock" type="method" display="GlobalLock"/>
			<memberdata name="globalunlock" type="method" display="GlobalUnlock"/>
			<memberdata name="beginpaint" type="method" display="BeginPaint"/>
			<memberdata name="endpaint" type="method" display="EndPaint"/>
			<memberdata name="invalidaterect" type="method" display="InvalidateRect"/>
			<memberdata name="callwindowproc" type="method" display="CallWindowProc"/>
			<memberdata name="setscrollinfo" type="method" display="SetScrollInfo"/>
			<memberdata name="getscrollinfo" type="method" display="GetScrollInfo"/>
			<memberdata name="showwindow" type="method" display="ShowWindow"/>
			<memberdata name="getkeystate" type="method" display="GetKeyState"/>
			<memberdata name="closeclipboard" type="method" display="CloseClipboard"/>
			<memberdata name="emptyclipboard" type="method" display="EmptyClipboard"/>
			<memberdata name="getclipboarddata" type="method" display="GetClipboardData"/>
			<memberdata name="isclipboardformatavailable" type="method" display="IsClipboardFormatAvailable"/>
			<memberdata name="openclipboard" type="method" display="OpenClipboard"/>
			<memberdata name="setclipboarddata" type="method" display="SetClipboardData"/>
			<memberdata name="getopenclipboardwindow" type="method" display="GetOpenClipboardWindow"/>
			<memberdata name="gettickcount" type="method" display="GetTickCount"/>
			<memberdata name="uuidcreate" type="method" display="UuidCreate"/>
			<memberdata name="bcryptopenalgorithmprovider" type="method" display="BCryptOpenAlgorithmProvider"/>
			<memberdata name="bcryptgeneratesymmetrickey" type="method" display="BCryptGenerateSymmetricKey"/>
			<memberdata name="bcryptencrypt" type="method" display="BCryptEncrypt"/>
			<memberdata name="bcryptdestroykey" type="method" display="BCryptDestroyKey"/>
			<memberdata name="bcryptclosealgorithmprovider" type="method" display="BCryptCloseAlgorithmProvider"/>
			<memberdata name="bcryptdestroyhash" type="method" display="BCryptDestroyHash"/>
			<memberdata name="bcryptfinishhash" type="method" display="BCryptFinishHash"/>
			<memberdata name="bcrypthashdata" type="method" display="BCryptHashData"/>
			<memberdata name="bcryptcreatehash" type="method" display="BCryptCreateHash"/>
			<memberdata name="bcryptgetproperty" type="method" display="BCryptGetProperty"/>
			<memberdata name="getsavefilenamea" type="method" display="GetSaveFileNameA"/>
			<memberdata name="shellexecute" type="method" display="ShellExecute"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE bcryptclosealgorithmprovider
		LPARAMETERS hAlgorithm as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptCloseAlgorithmProvider(m.hAlgorithm, m.dwFlags)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG BCryptCloseAlgorithmProvider IN BCrypt.DLL AS WinApi_BCryptCloseAlgorithmProvider LONG hAlgorithm, LONG dwFlags
		    m.lvRes = WinApi_BCryptCloseAlgorithmProvider(m.hAlgorithm, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptcreatehash
		LPARAMETERS hAlgorithm as Long, phHash as Long, pbHashObject as Long, cbHashObject as Long, pbSecret as String, cbSecret as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptCreateHash(m.hAlgorithm, @m.phHash, m.pbHashObject, m.cbHashObject, m.pbSecret, m.cbSecret, m.dwFlags)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG BCryptCreateHash IN BCrypt.DLL AS WinApi_BCryptCreateHash LONG hAlgorithm, LONG @phHash, LONG pbHashObject, LONG cbHashObject, STRING pbSecret, LONG cbSecret, LONG dwFlags
		    m.lvRes = WinApi_BCryptCreateHash(m.hAlgorithm, @m.phHash, m.pbHashObject, m.cbHashObject, m.pbSecret, m.cbSecret, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptdestroyhash
		LPARAMETERS hHash as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptDestroyHash(m.hHash)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG BCryptDestroyHash IN BCrypt.DLL AS WinApi_BCryptDestroyHash LONG hHash
		    m.lvRes = WinApi_BCryptDestroyHash(m.hHash)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptdestroykey
		LPARAMETERS hKey as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptDestroyKey(m.hKey)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG BCryptDestroyKey IN BCrypt.DLL AS WinApi_BCryptDestroyKey LONG hKey
		    m.lvRes = WinApi_BCryptDestroyKey(m.hKey)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptencrypt
		LPARAMETERS hKey as Long, pbInput as String, cbInput as Long, pPaddingInfo as String, pbIV as String, cbIV as Long, pbOutput as String, cbOutput as Long, pcbResult as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptEncrypt(@m.hKey, m.pbInput, m.cbInput, m.pPaddingInfo, @m.pbIV, m.cbIV, @m.pbOutput, m.cbOutput, @m.pcbResult, m.dwFlags)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG BCryptEncrypt IN BCrypt.DLL AS WinApi_BCryptEncrypt LONG hKey, STRING pbInput, LONG cbInput, STRING pPaddingInfo, STRING @pbIV, LONG cbIV, STRING @pbOutput, LONG cbOutput, LONG @pcbResult, LONG dwFlags
		    m.lvRes = WinApi_BCryptEncrypt(@m.hKey, m.pbInput, m.cbInput, m.pPaddingInfo, @m.pbIV, m.cbIV, @m.pbOutput, m.cbOutput, @m.pcbResult, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptfinishhash
		LPARAMETERS hHash as Long, pbOutput as String, cbOutput as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptFinishHash(m.hHash, @m.pbOutput, m.cbOutput, m.dwFlags)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG BCryptFinishHash IN BCrypt.DLL AS WinApi_BCryptFinishHash LONG hHash, STRING @pbOutput, LONG cbOutput, LONG dwFlags
		    m.lvRes = WinApi_BCryptFinishHash(m.hHash, @m.pbOutput, m.cbOutput, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptgeneratesymmetrickey
		LPARAMETERS phAlgorithm as Long, phKey as Long, pbKeyObject as String, cbKeyObject as Long, pbSecret as String, cbSecret as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptGenerateSymmetricKey(m.phAlgorithm, @m.phKey, m.pbKeyObject, m.cbKeyObject, m.pbSecret, m.cbSecret, m.dwFlags)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG BCryptGenerateSymmetricKey IN BCrypt.DLL AS WinApi_BCryptGenerateSymmetricKey LONG phAlgorithm, LONG @phKey, STRING pbKeyObject, LONG cbKeyObject, STRING pbSecret, LONG cbSecret, LONG dwFlags
		    m.lvRes = WinApi_BCryptGenerateSymmetricKey(m.phAlgorithm, @m.phKey, m.pbKeyObject, m.cbKeyObject, m.pbSecret, m.cbSecret, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptgetproperty
		LPARAMETERS hObject as Long, pszProperty as String, pbOutput as Long, cbOutput as Long, pcbResult as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptGetProperty(m.hObject, m.pszProperty, @m.pbOutput, m.cbOutput, @m.pcbResult, m.dwFlags)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG BCryptGetProperty IN BCrypt.DLL AS WinApi_BCryptGetProperty LONG hObject, STRING pszProperty, LONG @pbOutput, LONG cbOutput, LONG @pcbResult, LONG dwFlags
		    m.lvRes = WinApi_BCryptGetProperty(m.hObject, m.pszProperty, @m.pbOutput, m.cbOutput, @m.pcbResult, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcrypthashdata
		LPARAMETERS hHash as Long, pbInput as String, cbInput as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptHashData(m.hHash, m.pbInput, m.cbInput, m.dwFlags)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG BCryptHashData IN BCrypt.DLL AS WinApi_BCryptHashData LONG hHash, STRING pbInput, LONG cbInput, LONG dwFlags
		    m.lvRes = WinApi_BCryptHashData(m.hHash, m.pbInput, m.cbInput, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptopenalgorithmprovider
		LPARAMETERS phAlgorithm as Long, pszAlgId as String, pszImplementation as String, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptOpenAlgorithmProvider(@m.phAlgorithm, m.pszAlgId, m.pszImplementation, m.dwFlags)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG BCryptOpenAlgorithmProvider IN BCrypt.DLL AS WinApi_BCryptOpenAlgorithmProvider LONG @phAlgorithm, STRING pszAlgId, STRING pszImplementation, LONG dwFlags
		    m.lvRes = WinApi_BCryptOpenAlgorithmProvider(@m.phAlgorithm, m.pszAlgId, m.pszImplementation, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE beginpaint
		LPARAMETERS hWnd as Long, lpPaint as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BeginPaint(m.hWnd, @m.lpPaint)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG BeginPaint IN user32 AS WinApi_BeginPaint LONG hWnd, STRING @lpPaint
		    m.lvRes = WinApi_BeginPaint(m.hWnd, @m.lpPaint)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bitblt
		LPARAMETERS hdc as Long, nXDest as Integer, nYDest as Integer, nWidth as Integer, nHeight as Integer, hdcSrc as Long, nXSrc as Integer, nYSrc as Integer, nRop as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BitBlt(m.hdc, m.nXDest, m.nYDest, m.nWidth, m.nHeight, m.hdcSrc, m.nXSrc, m.nYSrc, m.nRop)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER BitBlt IN Gdi32 AS WinApi_BitBlt LONG hdc, INTEGER nXDest, INTEGER nYDest, INTEGER nWidth, INTEGER nHeight, LONG hdcSrc, INTEGER nXSrc, INTEGER nYSrc, INTEGER nRop
		    m.lvRes = WinApi_BitBlt(m.hdc, m.nXDest, m.nYDest, m.nWidth, m.nHeight, m.hdcSrc, m.nXSrc, m.nYSrc, m.nRop)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE callwindowproc
		LPARAMETERS lpPrevWndFunc as Long, hWnd as Long, Msg as Long, wParam as Long, lParam as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CallWindowProc(m.lpPrevWndFunc, m.hWnd, m.Msg, m.wParam, m.lParam)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG CallWindowProc IN User32 AS WinApi_CallWindowProc LONG lpPrevWndFunc, LONG hWnd, LONG Msg, LONG wParam, LONG lParam
		    m.lvRes = WinApi_CallWindowProc(m.lpPrevWndFunc, m.hWnd, m.Msg, m.wParam, m.lParam)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE closeclipboard
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CloseClipboard()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER CloseClipboard IN user32 AS WinApi_CloseClipboard
		    m.lvRes = WinApi_CloseClipboard()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE closeprinter
		LPARAMETERS hPrinter as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_ClosePrinter(m.hPrinter)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER ClosePrinter IN winspool.drv AS WinApi_ClosePrinter INTEGER hPrinter
		    m.lvRes = WinApi_ClosePrinter(m.hPrinter)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE createcompatibledc
		LPARAMETERS hDC as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CreateCompatibleDC(m.hDC)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER CreateCompatibleDC IN Gdi32 AS WinApi_CreateCompatibleDC INTEGER hDC
		    m.lvRes = WinApi_CreateCompatibleDC(m.hDC)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE createdc
		LPARAMETERS pwszDriver as String, pwszDevice as String, pszPort as String, pdm as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CreateDC(m.pwszDriver, m.pwszDevice, m.pszPort, @m.pdm)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG CreateDC IN Gdi32 AS WinApi_CreateDC STRING pwszDriver, STRING pwszDevice, STRING pszPort, STRING @pdm
		    m.lvRes = WinApi_CreateDC(m.pwszDriver, m.pwszDevice, m.pszPort, @m.pdm)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE createdibsection
		LPARAMETERS hdc as Integer, pbmi as String, iUsage as Long, ppvBits as Integer, hSection as Integer, dwOffset as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CreateDIBSection(m.hdc, m.pbmi, m.iUsage, @m.ppvBits, m.hSection, m.dwOffset)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER CreateDIBSection IN Gdi32 AS WinApi_CreateDIBSection INTEGER hdc, STRING pbmi, LONG iUsage, INTEGER @ppvBits, INTEGER hSection, LONG dwOffset
		    m.lvRes = WinApi_CreateDIBSection(m.hdc, m.pbmi, m.iUsage, @m.ppvBits, m.hSection, m.dwOffset)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE createwindowex
		LPARAMETERS ;
		    dwExStyle as Long, ;
		    lpClassName as String,;
		    lpWindowName as String, ;
		    dwStyle as Long,;
		    x as Integer, ;
		    y as Integer, ;
		    nWidth as Integer, ;
		    nHeight as Integer,;
		    hWndParent as Long, ;
		    hMenu as Long, ;
		    hInstance as Long,;
		    lpParam as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CreateWindowEx(;
		        m.dwExStyle,;
		        m.lpClassName,;
		        m.lpWindowName,;
		        m.dwStyle,;
		        m.x,;
		        m.y,;
		        m.nWidth,;
		        m.nHeight,;
		        m.hWndParent,;
		        m.hMenu,;
		        m.hInstance,;
		        m.lpParam)
		
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG CreateWindowEx IN user32 AS WinApi_CreateWindowEx  ;
		        LONG dwExStyle, ;
		        STRING lpClassName,;
		        STRING lpWindowName, ;
		        LONG dwStyle,;
		        INTEGER x, ;
		        INTEGER y, ;
		        INTEGER nWidth, ;
		        INTEGER nHeight,;
		        LONG hWndParent, ;
		        LONG hMenu, ;
		        LONG hInstance,;
		        LONG lpParam  
		
		    m.lvRes = WinApi_CreateWindowEx(;
		        m.dwExStyle,;
		        m.lpClassName,;
		        m.lpWindowName,;
		        m.dwStyle,;
		        m.x,;
		        m.y,;
		        m.nWidth,;
		        m.nHeight,;
		        m.hWndParent,;
		        m.hMenu,;
		        m.hInstance,;
		        m.lpParam)
		
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE deletedc
		LPARAMETERS hdc as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DeleteDC(m.hdc)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE Long DeleteDC IN Gdi32 AS WinApi_DeleteDC Long hdc
		    m.lvRes = WinApi_DeleteDC(m.hdc)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE deleteobject
		LPARAMETERS hObject as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DeleteObject(m.hObject)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER DeleteObject IN Gdi32 AS WinApi_DeleteObject INTEGER hObject
		    m.lvRes = WinApi_DeleteObject(m.hObject)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE destroywindow
		LPARAMETERS hWnd as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DestroyWindow(m.hWnd)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG DestroyWindow IN user32 AS WinApi_DestroyWindow LONG hWnd
		    m.lvRes = WinApi_DestroyWindow(m.hWnd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE devicecapabilities
		LPARAMETERS pDevice as String, pPort as String, fwCapability as Integer, pOutput as String, pDevMode as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DeviceCapabilities(m.pDevice, m.pPort, m.fwCapability, @m.pOutput, @m.pDevMode)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER DeviceCapabilities IN winspool.drv AS WinApi_DeviceCapabilities STRING pDevice, STRING pPort, INTEGER fwCapability, STRING @pOutput, STRING @pDevMode
		    m.lvRes = WinApi_DeviceCapabilities(m.pDevice, m.pPort, m.fwCapability, @m.pOutput, @m.pDevMode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE documentproperties
		LPARAMETERS hWnd as Integer, hPrinter as Integer, pDeviceName as String, pDevModeOutput as String, pDevModeInput as String, fMode as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DocumentProperties(m.hWnd, m.hPrinter, m.pDeviceName, @m.pDevModeOutput, @m.pDevModeInput, m.fMode)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER DocumentProperties IN winspool.drv AS WinApi_DocumentProperties INTEGER hWnd, INTEGER hPrinter, STRING pDeviceName, STRING @pDevModeOutput, STRING @pDevModeInput, INTEGER fMode
		    m.lvRes = WinApi_DocumentProperties(m.hWnd, m.hPrinter, m.pDeviceName, @m.pDevModeOutput, @m.pDevModeInput, m.fMode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE emptyclipboard
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EmptyClipboard()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER EmptyClipboard IN user32 AS WinApi_EmptyClipboard
		    m.lvRes = WinApi_EmptyClipboard()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE enddoc
		LPARAMETERS hdc as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EndDoc(m.hdc)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER EndDoc IN GDI32 AS WinApi_EndDoc INTEGER hdc
		    m.lvRes = WinApi_EndDoc(m.hdc)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE endpage
		LPARAMETERS hdc as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EndPage(m.hdc)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER EndPage IN GDI32 AS WinApi_EndPage INTEGER hdc
		    m.lvRes = WinApi_EndPage(m.hdc)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE endpaint
		LPARAMETERS hWnd as Long, lpPaint as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EndPaint(m.hWnd, m.lpPaint)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER EndPaint IN user32 AS WinApi_EndPaint LONG hWnd, STRING lpPaint
		    m.lvRes = WinApi_EndPaint(m.hWnd, m.lpPaint)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE enumforms
		LPARAMETERS hPrinter as Long, Level as Long, pForm as Long, cbBuf as Long, pcbNeeded as Long, pcReturned as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EnumForms(m.hPrinter, m.Level, m.pForm, m.cbBuf, @m.pcbNeeded, @m.pcReturned)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG EnumForms IN winspool.drv AS WinApi_EnumForms LONG hPrinter, LONG Level, LONG pForm, LONG cbBuf, LONG @pcbNeeded, LONG @pcReturned
		    m.lvRes = WinApi_EnumForms(m.hPrinter, m.Level, m.pForm, m.cbBuf, @m.pcbNeeded, @m.pcReturned)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE findnlsstring
		LPARAMETERS ;
		    Locale as Integer, ;
		    dwFindNLSStringFlags as Integer, ;
		    lpStringSource as String, ;
		    cchSource as Integer, ;
		    lpStringValue as Integer, ;
		    cchValue as Integer, ;
		    pcchFound as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_FindNLSString(m.Locale, m.dwFindNLSStringFlags, m.lpStringSource, m.cchSource, m.lpStringValue, m.cchValue, @m.pcchFound)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER FindNLSString IN Kernel32 AS WinApi_FindNLSString ;
		        INTEGER Locale, ;
		        INTEGER dwFindNLSStringFlags, ;
		        STRING lpStringSource, ;
		        INTEGER cchSource, ;
		        STRING lpStringValue, ;
		        INTEGER cchValue, ;
		        INTEGER @pcchFound
		
		    m.lvRes = WinApi_FindNLSString(m.Locale, m.dwFindNLSStringFlags, m.lpStringSource, m.cchSource, m.lpStringValue, m.cchValue, @m.pcchFound)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getclassinfoex
		LPARAMETERS hInstance as Long, lpClassName as String, lpWndClassEx as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetClassInfoEx(m.hInstance, m.lpClassName, @m.lpWndClassEx)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER GetClassInfoEx IN user32 AS WinApi_GetClassInfoEx LONG hInstance, STRING lpClassName, STRING @lpWndClassEx
		    m.lvRes = WinApi_GetClassInfoEx(m.hInstance, m.lpClassName, @m.lpWndClassEx)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getclipboarddata
		LPARAMETERS uFormat as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetClipboardData(m.uFormat)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER GetClipboardData IN user32 AS WinApi_GetClipboardData INTEGER uFormat
		    m.lvRes = WinApi_GetClipboardData(m.uFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getdc
		LPARAMETERS hWnd as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetDC(m.hWnd)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetDC IN User32 AS WinApi_GetDC LONG hWnd
		    m.lvRes = WinApi_GetDC(m.hWnd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getdefaultprinter
		LPARAMETERS pszBuffer as String, pcchBuffer as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetDefaultPrinter(@m.pszBuffer, @m.pcchBuffer)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER GetDefaultPrinter IN WINSPOOL.DRV  AS WinApi_GetDefaultPrinter STRING @pszBuffer, LONG @pcchBuffer
		    m.lvRes = WinApi_GetDefaultPrinter(@m.pszBuffer, @m.pcchBuffer)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getdevicecaps
		LPARAMETERS hdc as Long, nIndex as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetDeviceCaps(m.hdc, m.nIndex)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetDeviceCaps IN Gdi32 AS WinApi_GetDeviceCaps LONG hdc, LONG nIndex 
		    m.lvRes = WinApi_GetDeviceCaps(m.hdc, m.nIndex)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getkeystate
		LPARAMETERS vKey as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetKeyState(m.vKey)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE SHORT GetKeyState IN user32 AS WinApi_GetKeyState INTEGER vKey
		    m.lvRes = WinApi_GetKeyState(m.vKey)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getmodulehandle
		LPARAMETERS lpModuleName as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetModuleHandle(m.lpModuleName)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER GetModuleHandle IN kernel32 AS WinApi_GetModuleHandle STRING lpModuleName
		    m.lvRes = WinApi_GetModuleHandle(m.lpModuleName)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getopenclipboardwindow
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetOpenClipboardWindow()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER GetOpenClipboardWindow IN user32 AS WinApi_GetOpenClipboardWindow
		    m.lvRes = WinApi_GetOpenClipboardWindow()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getsavefilenamea
		LPARAMETERS LPOPENFILENAMEA as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetSaveFileNameA(@m.LPOPENFILENAMEA)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetSaveFileNameA IN Comdlg32.dll AS WinApi_GetSaveFileNameA STRING @LPOPENFILENAMEA
		    m.lvRes = WinApi_GetSaveFileNameA(@m.LPOPENFILENAMEA)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getscrollinfo
		LPARAMETERS hwnd as Long, nBar as Integer, lpsi as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetScrollInfo(m.hwnd, m.nBar, @m.lpsi)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetScrollInfo IN User32 AS WinApi_GetScrollInfo LONG hwnd, INTEGER nBar, STRING @lpsi
		    m.lvRes = WinApi_GetScrollInfo(m.hwnd, m.nBar, @m.lpsi)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getsystemdefaultlcid
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetSystemDefaultLCID()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER GetSystemDefaultLCID IN Kernel32 AS WinApi_GetSystemDefaultLCID
		    m.lvRes = WinApi_GetSystemDefaultLCID()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gettickcount
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetTickCount()
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetTickCount IN Kernel32 AS WinApi_GetTickCount
		    m.lvRes = WinApi_GetTickCount()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getwindow
		LPARAMETERS hWnd as Long, uCmd as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetWindow(m.hWnd, m.uCmd)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetWindow IN user32 AS WinApi_GetWindow LONG hWnd, LONG uCmd
		    m.lvRes = WinApi_GetWindow(m.hWnd, m.uCmd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getwindowlong
		LPARAMETERS hWnd as Long, nIndex as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetWindowLong(m.hWnd, m.nIndex)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GetWindowLong IN user32 AS WinApi_GetWindowLong LONG hWnd, INTEGER nIndex
		    m.lvRes = WinApi_GetWindowLong(m.hWnd, m.nIndex)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globalalloc
		LPARAMETERS nFlags as Long, nSize as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalAlloc(m.nFlags, m.nSize)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE Long GlobalAlloc IN Kernel32 AS WinApi_GlobalAlloc Long nFlags, Long nSize
		    m.lvRes = WinApi_GlobalAlloc(m.nFlags, m.nSize)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globalfree
		LPARAMETERS nHandle as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalFree(m.nHandle)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE Long GlobalFree IN Kernel32 AS WinApi_GlobalFree Long nHandle
		    m.lvRes = WinApi_GlobalFree(m.nHandle)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globallock
		LPARAMETERS hMem as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalLock(m.hMem)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GlobalLock IN Kernel32 AS WinApi_GlobalLock LONG hMem
		    m.lvRes = WinApi_GlobalLock(m.hMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globalunlock
		LPARAMETERS hMem as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalUnlock(m.hMem)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG GlobalUnlock IN Kernel32 AS WinApi_GlobalUnlock LONG hMem
		    m.lvRes = WinApi_GlobalUnlock(m.hMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE heapalloc
		LPARAMETERS hHeap as Integer, dwFlags as Integer, dwBytes as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_HeapAlloc(m.hHeap, m.dwFlags, m.dwBytes)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HeapAlloc IN Kernel32 AS WinApi_HeapAlloc INTEGER hHeap, INTEGER dwFlags, INTEGER dwBytes
		    m.lvRes = WinApi_HeapAlloc(m.hHeap, m.dwFlags, m.dwBytes)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE heapcreate
		LPARAMETERS dwOptions as Integer, dwInitialSize as Integer, dwMaxSize as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_HeapCreate(m.dwOptions, m.dwInitialSize, m.dwMaxSize)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HeapCreate IN Kernel32 AS WinApi_HeapCreate INTEGER dwOptions, INTEGER dwInitialSize, INTEGER dwMaxSize
		    m.lvRes = WinApi_HeapCreate(m.dwOptions, m.dwInitialSize, m.dwMaxSize)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE heapdestroy
		LPARAMETERS hHeap as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_HeapDestroy(m.hHeap)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HeapDestroy IN Kernel32 AS WinApi_HeapDestroy INTEGER hHeap
		    m.lvRes = WinApi_HeapDestroy(m.hHeap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE heapfree
		LPARAMETERS hHeap as Integer, dwFlags as Integer, pMem as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_HeapFree(m.hHeap, m.dwFlags, m.pMem)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER HeapFree IN Kernel32 AS WinApi_HeapFree INTEGER hHeap, INTEGER dwFlags, INTEGER lpMem
		    m.lvRes = WinApi_HeapFree(m.hHeap, m.dwFlags, m.pMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE invalidaterect
		LPARAMETERS hWnd as Long, lpRect as String, bErase as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_InvalidateRect(m.hWnd, m.lpRect, m.bErase)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG InvalidateRect IN User32 AS WinApi_InvalidateRect LONG hWnd, STRING lpRect, LONG bErase
		    m.lvRes = WinApi_InvalidateRect(m.hWnd, m.lpRect, m.bErase)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE isclipboardformatavailable
		LPARAMETERS uFormat as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_IsClipboardFormatAvailable(m.uFormat)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER IsClipboardFormatAvailable IN user32 AS WinApi_IsClipboardFormatAvailable INTEGER uFormat
		    m.lvRes = WinApi_IsClipboardFormatAvailable(m.uFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE movewindow
		LPARAMETERS hWnd as Long, X as Integer, Y as Integer, nWidth as Integer, nHeight as Integer, bRepaint as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_MoveWindow(m.hWnd, m.X, m.Y, m.nWidth, m.nHeight, m.bRepaint)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG MoveWindow IN user32 AS WinApi_MoveWindow LONG hWnd, INTEGER X, INTEGER Y, INTEGER nWidth, INTEGER nHeight, INTEGER bRepaint
		    m.lvRes = WinApi_MoveWindow(m.hWnd, m.X, m.Y, m.nWidth, m.nHeight, m.bRepaint)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE openclipboard
		LPARAMETERS hWndNewOwner as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_OpenClipboard(m.hWndNewOwner)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER OpenClipboard IN user32 AS WinApi_OpenClipboard INTEGER hWndNewOwner
		    m.lvRes = WinApi_OpenClipboard(m.hWndNewOwner)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE openprinter
		LPARAMETERS pPrinterName as String, phPrinter as Integer, pDefault as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_OpenPrinter(m.pPrinterName, @m.phPrinter, m.pDefault)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER OpenPrinter IN winspool.drv AS WinApi_OpenPrinter STRING pPrinterName, INTEGER @phPrinter, INTEGER pDefault
		    m.lvRes = WinApi_OpenPrinter(m.pPrinterName, @m.phPrinter, m.pDefault)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE registerclassex
		LPARAMETERS lpWndClassEx as String 
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_RegisterClassEx(m.lpWndClassEx)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG RegisterClassEx IN user32 AS WinApi_RegisterClassEx STRING lpWndClassEx
		    m.lvRes = WinApi_RegisterClassEx(m.lpWndClassEx)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE releasedc
		LPARAMETERS hWnd as Long, hDC as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_ReleaseDC(m.hWnd, m.hDC)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE Long ReleaseDC IN User32 AS WinApi_ReleaseDC Long hWnd, Long hDC
		    m.lvRes = WinApi_ReleaseDC(m.hWnd, m.hDC)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE selectobject
		LPARAMETERS hdc as Integer, hgdiobj as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SelectObject(m.hdc, m.hgdiobj)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER SelectObject IN Gdi32 AS WinApi_SelectObject INTEGER hdc, INTEGER hgdiobj
		    m.lvRes = WinApi_SelectObject(m.hdc, m.hgdiobj)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE setclipboarddata
		LPARAMETERS uFormat as Integer, hMem as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SetClipboardData(m.uFormat, m.hMem)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER SetClipboardData IN user32 AS WinApi_SetClipboardData INTEGER uFormat, INTEGER hMem
		    m.lvRes = WinApi_SetClipboardData(m.uFormat, m.hMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE setdefaultprinter
		LPARAMETERS pszPrinter as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SetDefaultPrinter(m.pszPrinter)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER SetDefaultPrinter IN WINSPOOL.DRV  AS WinApi_SetDefaultPrinter STRING pszPrinter
		    m.lvRes = WinApi_SetDefaultPrinter(m.pszPrinter)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE setscrollinfo
		LPARAMETERS hwnd as Long, nBar as Integer, lpsi as String, redraw as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SetScrollInfo(m.hwnd, m.nBar, m.lpsi, m.redraw)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER SetScrollInfo IN User32 AS WinApi_SetScrollInfo LONG hwnd, INTEGER nBar, STRING lpsi, LONG redraw
		    m.lvRes = WinApi_SetScrollInfo(m.hwnd, m.nBar, m.lpsi, m.redraw)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE shellexecute
		LPARAMETERS hwnd as Long, lpOperation as String, lpFile as String, lpParameters as String, lpDirectory as String, nShowCmd as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_ShellExecute(m.hwnd, m.lpOperation, m.lpFile, m.lpParameters, m.lpDirectory, m.nShowCmd)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE Long ShellExecuteA IN Shell32 AS WinApi_ShellExecute Long hwnd, String lpOperation, String lpFile, String lpParameters, String lpDirectory, Integer nShowCmd
		    m.lvRes = WinApi_ShellExecute(m.hwnd, m.lpOperation, m.lpFile, m.lpParameters, m.lpDirectory, m.nShowCmd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE showwindow		&& Specifies the Form window to show the Form or Toolbar in at creation time.
		LPARAMETERS hWnd as Long, nCmdShow as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_ShowWindow(m.hWnd, m.nCmdShow)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE LONG ShowWindow IN User32 AS WinApi_ShowWindow LONG hWnd, INTEGER nCmdShow
		    m.lvRes = WinApi_ShowWindow(m.hWnd, m.nCmdShow)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE startdoc
		LPARAMETERS hdc as Integer, lpdi as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_StartDoc(m.hdc, m.lpdi)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER StartDoc IN GDI32 AS WinApi_StartDoc INTEGER hdc, STRING lpdi
		    m.lvRes = WinApi_StartDoc(m.hdc, m.lpdi)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE startpage
		LPARAMETERS hdc as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_StartPage(m.hdc)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER StartPage IN GDI32 AS WinApi_StartPage INTEGER hdc
		    m.lvRes = WinApi_StartPage(m.hdc)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE uuidcreate
		LPARAMETERS Uuid
		
		m.Uuid = REPLICATE(CHR(0), 16)
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_UuidCreate(@m.Uuid)
		CATCH
		    SET CONSOLE OFF    
		    DECLARE INTEGER UuidCreate IN Rpcrt4.dll AS WinApi_UuidCreate STRING @Uuid
		    m.lvRes = WinApi_UuidCreate(@m.Uuid)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_env AS custom 		&& Pdfium Environment Configuration Object. Usage: create, setup and pass as first parameter of PdfiumViewer.Init, PdfiumReport.Init
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="API_FPDF" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="API_WIN" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="API_FRX" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="API_GDIP" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: errfmt
		*m: errmsg
		*m: foxenv_restore		&& Restore VFP environment to the state before first call of This.FoxEnv_Set or first call after last This.FoxEnv_Restore call
		*m: foxenv_set		&& Sets VFP environment to fit pdfium-vfp requirements
		*m: getappname		&& Returns file name of application executable (app, exe) from the top of the call stack. Returns empty string if there is no application executable in stack
		*m: getpdfdpi		&& PDF standart resolution (72 DPI)
		*m: getsavefilename		&& SaveAs dialog
		*m: getscreendpix		&& Screen horizontal DPI (constant 96 DPI)
		*m: getscreendpiy		&& Screen vertical DPI (constant 96 DPI)
		*m: getuniquetempcursorname
		*m: getuniquetempfilename		&& Returns uniquie not existent filename in %userprofile%\AppData\Local\Temp
		*m: ok		&& Return TRUE if enviroment setup ended up with success
		*m: setup		&& Setup environment (from external environment if neccessary)
		*m: setuprelease
		*p: foxenv_prev		&& VFP environment state saving by This.FoxEnv_Set and restoring by This.FoxEnv_Restore
		*p: pdfium_dll_path		&& Path to file pdfium.dll. Filename without path also accepted
		*p: privatefonts		&& Collection of non system (custom / private) fonts. Key must be the font face name, Value - path to the font file
		*p: setup_ok
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,Error,foxenv_prev,Height,HelpContextID,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,setup_ok,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		foxenv_prev = .F.
		Height = 27
		Name = "pdfium_env"
		pdfium_dll_path = (IIF(FILE(ADDBS(JUSTPATH(This.ClassLibrary))+"pdfium.dll",1), ADDBS(JUSTPATH(This.ClassLibrary)), "") + IIF(ATC("x64", SYS(17))<>0 , "pdfium64.dll", "pdfium.dll"))
		privatefonts = .F.
		setup_ok = .F.
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="pdfium_dll_path" type="property" display="pdfium_dll_path"/>
			<memberdata name="errmsg" type="method" display="ErrMsg"/>
			<memberdata name="ok" type="method" display="ok"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="setuprelease" type="method" display="SetupRelease"/>
			<memberdata name="getpdfdpi" type="method" display="GetPDFDPI"/>
			<memberdata name="getscreendpix" type="method" display="GetScreenDPIX"/>
			<memberdata name="getscreendpiy" type="method" display="GetScreenDPIY"/>
			<memberdata name="getuniquetempfilename" type="method" display="GetUniqueTempFileName"/>
			<memberdata name="privatefonts" type="property" display="PrivateFonts"/>
			<memberdata name="getappname" type="method" display="GetAppName"/>
			<memberdata name="foxenv_prev" type="property" display="FoxEnv_Prev"/>
			<memberdata name="foxenv_restore" type="method" display="FoxEnv_Restore"/>
			<memberdata name="foxenv_set" type="method" display="FoxEnv_Set"/>
			<memberdata name="setup_ok" type="property" display="Setup_Ok"/>
			<memberdata name="getsavefilename" type="method" display="GetSaveFileName"/>
			<memberdata name="errfmt" type="method" display="ErrFmt"/>
			<memberdata name="getuniquetempcursorname" type="method" display="GetUniqueTempCursorName"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'API_FPDF' AS pdfium_api_fpdf WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_FPDF", ;
		Top = 0, ;
		Width = 0, ;
		CONST.Name = "CONST"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'API_FRX' AS pdfium_api_frx WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_FRX", ;
		Top = 0, ;
		Width = 0, ;
		CONST.Name = "CONST"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'API_GDIP' AS pdfium_api_gdip WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_GDIP", ;
		Top = 0, ;
		Width = 0, ;
		CONST.Name = "CONST"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'API_WIN' AS pdfium_api_win WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_WIN", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE Destroy
		This.PrivateFonts = .F.
		This.SetupRelease()
		
		This.FoxEnv_Prev = .F.
		
	ENDPROC

	PROCEDURE errfmt
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		m.lcMsg = ""
		
		DO CASE
		CASE VARTYPE(m.tvMsg)="O"
		
		    LOCAL lcLineContents
		    m.lcLineContents = ""
		
		    LOCAL laStack(1), lnStack
		    m.lnStack = ASTACKINFO(laStack)
		    IF m.lnStack > 2
		        m.lcLineContents = m.laStack[lnStack - 2, 6]
		    ENDIF
		
		    m.lcMsg = ;
		        m.tvMsg.Message + ;
		        RTRIM(" " + NVL(m.tvMsg.Details,"")) + ;
		        RTRIM(" " + NVL(m.tvMsg.UserValue,"")) + ;
		        CHR(13) + "Procedure: " + m.tvMsg.Procedure + ;
		        CHR(13) + "LineContents: " + m.lcLineContents
		
		CASE VARTYPE(m.tvMsg)="C"
		    m.lcMsg = ALLTRIM(m.tvMsg)
		
		ENDCASE
		
		RETURN m.lcMsg
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		m.lcMsg = This.ErrFmt(m.tvMsg)
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		MESSAGEBOX(This.Class + " ("+This.ClassLibrary+"): " + m.lcMsg, 0+48, This.Class + " ("+This.ClassLibrary+")")
		
	ENDPROC

	PROCEDURE foxenv_restore		&& Restore VFP environment to the state before first call of This.FoxEnv_Set or first call after last This.FoxEnv_Restore call
		IF VARTYPE(This.FoxEnv_Prev) <> "O"
		    RETURN
		ENDIF
		
		LOCAL loFoxEnv
		m.loFoxEnv = This.FoxEnv_Prev
		This.FoxEnv_Prev = .F.
		
		LOCAL lcVal
		
		m.lcVal = m.loFoxEnv.SET_COMPATIBLE
		IF m.lcVal <> SET("Compatible")
		    SET COMPATIBLE &lcVal
		ENDIF
		
		m.lcVal = m.loFoxEnv.SET_CONSOLE
		SET CONSOLE &lcVal
		
	ENDPROC

	PROCEDURE foxenv_set		&& Sets VFP environment to fit pdfium-vfp requirements
		IF VARTYPE(This.FoxEnv_Prev) <> "O"
		    This.FoxEnv_Prev = NEWOBJECT("Empty")
		    ADDPROPERTY(This.FoxEnv_Prev, "SET_COMPATIBLE", SET("Compatible"))
		    ADDPROPERTY(This.FoxEnv_Prev, "SET_CONSOLE", SET("Console"))
		ENDIF
		
		IF UPPER(SET("Compatible")) <> "OFF"
		    SET COMPATIBLE OFF
		ENDIF
		
		SET CONSOLE OFF
		
	ENDPROC

	PROCEDURE getappname		&& Returns file name of application executable (app, exe) from the top of the call stack. Returns empty string if there is no application executable in stack
		LOCAL ARRAY laStack(1)
		LOCAL lnStack, liStack
		m.lnStack = ASTACKINFO(laStack)
		
		FOR m.liStack = m.lnStack TO 1 STEP -1
		
		    IF INLIST(LOWER(JUSTEXT(m.laStack[m.liStack,2])), "app", "exe") = .F.
		        LOOP
		    ENDIF
		    
		    RETURN m.laStack[m.liStack,2]
		
		ENDFOR
		
		RETURN ""
		
	ENDPROC

	PROCEDURE getpdfdpi		&& PDF standart resolution (72 DPI)
		RETURN 72
		
	ENDPROC

	PROCEDURE getsavefilename		&& SaveAs dialog
		LPARAMETERS cFileName, cDefaultExtension, cFileExtensions
		
		#define OPENFILENAME_SIZE 88
		#define OFN_EXPLORER 0x00080000  
		#define OFN_OVERWRITEPROMPT 0x00000002
		
		
		LOCAL lcFile, lcDefExt, lcFilter
		m.lcFile = PADR(EVL(m.cFileName,""), 48000, CHR(0)) + CHR(0)+CHR(0)
		m.lcDefExt = EVL(m.cDefaultExtension, "")
		m.lcFilter = EVL(m.cFileExtensions, "*." + EVL(m.lcDefExt, "*")) + CHR(0) + EVL(m.cFileExtensions, "*." + EVL(m.lcDefExt, "*")) + CHR(0) + CHR(0)
		
		LOCAL lhHeap, lnPtrFile, lnPtrDefExt, lnPtrFilter, lnLenFile  
		STORE 0 TO m.lhHeap, m.lnPtrFile, m.lnPtrDefExt, m.lnPtrFilter, m.lnLenFile
		
		LOCAL lcSavePath
		m.lcSavePath = FULLPATH(".")
		
		LOCAL llRes
		m.llRes = .F.
		
		LOCAL lcResFile
		m.lcResFile = ""
		
		TRY
		    m.lhHeap = This.API_WIN.HeapCreate(0, 0, 0)
		    IF EMPTY(m.lhHeap)
		        EXIT
		    ENDIF
		
		    m.lnLenFile = LEN(m.lcFile)
		    m.lnPtrFile = This.API_WIN.HeapAlloc(m.lhHeap, 0, m.lnLenFile)
		    IF EMPTY(m.lnPtrFile)
		        EXIT
		    ENDIF
		    SYS(2600, m.lnPtrFile, m.lnLenFile, m.lcFile)
		
		    IF EMPTY(m.lcDefExt)=.F.
		        m.lnPtrDefExt = This.API_WIN.HeapAlloc(m.lhHeap, 0, LEN(m.lcDefExt))  
		        IF EMPTY(m.lnPtrDefExt)
		            EXIT
		        ENDIF  
		        SYS(2600, m.lnPtrDefExt, LEN(m.lcDefExt), m.lcDefExt)
		    ENDIF
		
		    IF EMPTY(m.lcFilter)=.F.
		        m.lnPtrFilter = This.API_WIN.HeapAlloc(m.lhHeap, 0, LEN(m.lcFilter))  
		        IF EMPTY(m.lnPtrFilter)
		            EXIT
		        ENDIF  
		        SYS(2600, m.lnPtrFilter, LEN(m.lcFilter), m.lcFilter)
		    ENDIF
		      
		    LOCAL lpOFN As String  
		      m.lpOFN = BINTOC(OPENFILENAME_SIZE, "4RS") ; && DWORD lStructSize  
		      + BINTOC(0, "4RS") ; && HWND hwndOwner  
		      + BINTOC(0, "4RS") ; && HINSTANCE hInstance  
		      + BINTOC(m.lnPtrFilter, "4RS") ; && LPCTSTR lpstrFilter  
		      + BINTOC(0, "4RS") ; && LPTSTR lpstrCustomFilter  
		      + BINTOC(0, "4RS") ; && DWORD nMaxCustFilter  
		      + BINTOC(0, "4RS") ; && DWORD nFilterIndex  
		      + BINTOC(m.lnPtrFile, "4RS") ; && LPTSTR lpstrFile  
		      + BINTOC(m.lnLenFile, "4RS") ; && DWORD nMaxFile  
		      + BINTOC(0, "4RS") ; && LPTSTR lpstrFileTitle  
		      + BINTOC(0, "4RS") ; && DWORD nMaxFileTitle  
		      + BINTOC(0, "4RS") ; && LPCTSTR lpstrInitialDir  
		      + BINTOC(0, "4RS") ; && LPCTSTR lpstrTitle  
		      + BINTOC(OFN_EXPLORER + OFN_OVERWRITEPROMPT, "4RS") ; && DWORD Flags  
		      + BINTOC(0, "2RS") ; && WORD nFileOffset  
		      + BINTOC(0, "2RS") ; && WORD nFileExtension  
		      + BINTOC(m.lnPtrDefExt, "4RS") ; && LPCTSTR lpstrDefExt  
		      + BINTOC(0, "4RS") ; && LPARAM lCustData  
		      + BINTOC(0, "4RS") ; && LPOFNHOOKPROC lpfnHook  
		      + BINTOC(0, "4RS") ; && LPCTSTR lpTemplateName  
		      + BINTOC(0, "4RS") ; && void * pvReserved  
		      + BINTOC(0, "4RS") ; && DWORD dwReserved  
		      + BINTOC(0, "4RS") && DWORD FlagsEx  
		      
		
		
		    IF EMPTY(This.API_WIN.GetSaveFileNameA(@m.lpOFN))
		        EXIT
		    ENDIF
		    
		    m.llRes = .T.
		
		    m.lcResFile = SYS(2600, m.lnPtrFile, m.lnLenFile)
		    m.lcResFile = LEFT(m.lcResFile, AT(CHR(0), m.lcResFile)-1)
		    
		
		FINALLY
		
		    IF EMPTY(m.lnPtrFile) = .F.
		        This.API_WIN.HeapFree(m.lhHeap, 0, m.lnPtrFile)
		        m.lnPtrFile = 0
		    ENDIF
		
		    IF EMPTY(m.lnPtrDefExt) = .F.
		        This.API_WIN.HeapFree(m.lhHeap, 0, m.lnPtrDefExt)
		        m.lnPtrDefExt = 0
		    ENDIF
		    
		    IF EMPTY(m.lnPtrFilter) = .F.
		        This.API_WIN.HeapFree(m.lhHeap, 0, m.lnPtrFilter)
		        m.lnPtrFilter = 0
		    ENDIF
		    
		    IF EMPTY(m.lhHeap) = .F.
		        This.API_WIN.HeapDestroy(m.lhHeap)
		        m.lhHeap = 0
		    ENDIF
		ENDTRY
		
		CD (m.lcSavePath)
		
		
		RETURN IIF(m.llRes, m.lcResFile, "")
		
		
	ENDPROC

	PROCEDURE getscreendpix		&& Screen horizontal DPI (constant 96 DPI)
		RETURN 96
		
	ENDPROC

	PROCEDURE getscreendpiy		&& Screen vertical DPI (constant 96 DPI)
		RETURN 96
		
	ENDPROC

	PROCEDURE getuniquetempcursorname
		#define RPC_S_OK 0
		#define RPC_S_UUID_LOCAL_ONLY 1824
		
		LOCAL lcCursorName
		m.lcCursorName = ""
		
		LOCAL i
		FOR m.i = 1 TO 500
		    
		    LOCAL lcUuid
		    m.lcUuid = ""
		    IF INLIST(This.API_WIN.UuidCreate(@m.lcUuid), RPC_S_OK, RPC_S_UUID_LOCAL_ONLY) = .F.
		        m.lcUuid = SYS(2015)
		    ENDIF
		    m.lcUuid = CHRTRAN(TRANSFORM(0h + m.lcUuid), '-', '')
		
		    m.lcCursorName = This.Class + m.lcUuid
		    
		    IF USED(m.lcCursorName)
		        m.lcCursorName = ""
		        LOOP
		    ENDIF
		
		    EXIT
		ENDFOR
		
		RETURN m.lcCursorName
		
		
	ENDPROC

	PROCEDURE getuniquetempfilename		&& Returns uniquie not existent filename in %userprofile%\AppData\Local\Temp
		LPARAMETERS tcFileExt
		
		#define RPC_S_OK 0
		#define RPC_S_UUID_LOCAL_ONLY 1824
		
		LOCAL lcFileExt
		m.lcFileExt = ALLTRIM(EVL(NVL(m.tcFileExt,""),""), 1, " ", ".")
		
		LOCAL lcPath
		m.lcPath = ADDBS(SYS(2023))
		
		LOCAL lcFilename
		m.lcFilename = ""
		
		LOCAL i
		FOR m.i = 1 TO 500
		    
		    LOCAL lcUuid
		    m.lcUuid = ""
		    IF INLIST(This.API_WIN.UuidCreate(@m.lcUuid), RPC_S_OK, RPC_S_UUID_LOCAL_ONLY) = .F.
		        m.lcUuid = SYS(2015)
		    ENDIF
		    m.lcUuid = TRANSFORM(0h + m.lcUuid)
		    
		    m.lcFilename = m.lcPath + "pdfium_vfp_" + m.lcUuid + IIF(EMPTY(m.lcFileExt), "", "." + m.lcFileExt)
		    
		    IF FILE(m.lcFilename,1) OR DIRECTORY(m.lcFilename,1)
		        m.lcFilename = ""
		        LOOP
		    ENDIF
		
		    EXIT
		ENDFOR
		
		RETURN m.lcFilename
		
		
	ENDPROC

	PROCEDURE Init
		This.PrivateFonts = NEWOBJECT("Collection")
		
	ENDPROC

	PROCEDURE ok		&& Return TRUE if enviroment setup ended up with success
		RETURN This.setup_ok
		
	ENDPROC

	PROCEDURE setup		&& Setup environment (from external environment if neccessary)
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.SetupRelease()
		
		IF VARTYPE(m.toEnv)="O"
		    This.pdfium_dll_path = EVL(NVL(m.toEnv.pdfium_dll_path,""), This.pdfium_dll_path)
		    This.PrivateFonts = IIF(VARTYPE(m.toEnv.PrivateFonts)="O", m.toEnv.PrivateFonts, This.PrivateFonts)
		ENDIF
		
		
		*****************************************************************
		* Pdfium.dll binding
		*****************************************************************
		This.pdfium_dll_path = FULLPATH(ALLTRIM(EVL(NVL(This.pdfium_dll_path,""),"")))
		
		IF FILE(This.pdfium_dll_path,1)=.F.
		    This.errMsg(TEXTMERGE("<<This.Class>>.pdfium_dll_path: File <<This.pdfium_dll_path>> does not exist"))
		    RETURN .F.
		ENDIF
		
		This.API_FPDF.pdfium_dll_path = This.pdfium_dll_path
		
		
		
		*****************************************************************
		* Pdfium library initialization
		*****************************************************************
		This.setup_ok = .F.
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    This.API_FPDF.FPDF_InitLibraryWithConfig()
		    
		    This.setup_ok = .T.
		
		CATCH TO m.loErr
		    This.errMsg(m.loErr)
		ENDTRY
		
		IF This.setup_ok = .F.
		    RETURN .F.
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE setuprelease
		
		IF This.setup_ok = .F.
		    RETURN
		ENDIF
		
		This.setup_ok = .F.
		
		This.API_FPDF.FPDF_DestroyLibrary()
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_i18n AS custom 		&& PdfiumViewer Internationalization Helper. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="API_WIN" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: getlocaleid		&& Returns system locale id
		*m: text		&& Returns all of the text in a text-entry area of a control.
		*m: text_cn
		*m: text_de
		*m: text_en
		*m: text_es
		*m: text_fr
		*m: text_ru
		*p: localeid
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,Error,Height,HelpContextID,localeid,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		localeid = 1033
		Name = "pdfium_i18n"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="localeid" type="property" display="LocaleID"/>
			<memberdata name="getlocaleid" type="method" display="GetLocaleID"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'API_WIN' AS pdfium_api_win WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_WIN", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE getlocaleid		&& Returns system locale id
		RETURN This.LocaleID
		
	ENDPROC

	PROCEDURE Init
		This.LocaleID = This.API_WIN.GetSystemDefaultLCID()
		
	ENDPROC

	PROCEDURE text		&& Returns all of the text in a text-entry area of a control.
		* This code is generated by BUILD\BUILD_I18N.prg
		
		LPARAMETERS tcTxtID
		
		LOCAL lcTxtID
		m.lcTxtID = UPPER(ALLTRIM(EVL(NVL(m.tcTxtID,""),"")))
		
		IF EMPTY(m.lcTxtID)
		RETURN ""
		ENDIF
		
		
		DO CASE 
		
		CASE This.LocaleID = 2052
		RETURN This.text_cn(m.lcTxtID)
		
		CASE This.LocaleID = 1031
		RETURN This.text_de(m.lcTxtID)
		
		CASE This.LocaleID = 1033
		RETURN This.text_en(m.lcTxtID)
		
		CASE This.LocaleID = 1034
		RETURN This.text_es(m.lcTxtID)
		
		CASE This.LocaleID = 1036
		RETURN This.text_fr(m.lcTxtID)
		
		CASE This.LocaleID = 1049
		RETURN This.text_ru(m.lcTxtID)
		
		OTHERWISE
		RETURN This.text_en(m.lcTxtID)
		
		ENDCASE
		
	ENDPROC

	HIDDEN PROCEDURE text_cn
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_CN.XML for LocaleID = 2052
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(184) + CHR(180) + CHR(214) + CHR(198)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(200) + CHR(171) + CHR(209) + CHR(161)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(188) + CHR(244) + CHR(199) + CHR(208)
		
		
		CASE m.tcTxtID == "MNU_PASTE"
		RETURN CHR(213) + CHR(179) + CHR(204) + CHR(249)
		
		
		CASE m.tcTxtID == "MNU_CLEAR"
		RETURN CHR(199) + CHR(229) + CHR(192) + CHR(237)
		
		
		CASE m.tcTxtID == "REPORTVIEWER_TITLE"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161) + CHR(212) + CHR(164) + CHR(192) + CHR(192)
		
		
		CASE m.tcTxtID == "SEARCH_NOT_FOUND"
		RETURN CHR(195) + CHR(187) + CHR(211) + CHR(208) + CHR(183) + CHR(162) + CHR(207) + CHR(214)
		
		
		CASE m.tcTxtID == "SEARCH_ENDED"
		RETURN CHR(203) + CHR(209) + CHR(203) + CHR(247) + CHR(205) + CHR(234) + CHR(177) + CHR(207)
		
		
		CASE m.tcTxtID == "BTN_PRINT"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161)
		
		
		CASE m.tcTxtID == "PRINTENV_TITLE"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161) + CHR(201) + CHR(232) + CHR(214) + CHR(195)
		
		
		CASE m.tcTxtID == "PRINTENV_OK"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161)
		
		
		CASE m.tcTxtID == "PRINTENV_CANCEL"
		RETURN CHR(200) + CHR(161) + CHR(207) + CHR(251)
		
		
		CASE m.tcTxtID == "PRINTENV_PRINTER"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161) + CHR(187) + CHR(250)
		
		
		CASE m.tcTxtID == "PRINTENV_COPIES"
		RETURN CHR(183) + CHR(221) + CHR(202) + CHR(253)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE"
		RETURN CHR(210) + CHR(179) + CHR(195) + CHR(230)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ALL"
		RETURN CHR(203) + CHR(249) + CHR(211) + CHR(208)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ODD"
		RETURN CHR(189) + CHR(246) + CHR(198) + CHR(230) + CHR(202) + CHR(253) + CHR(210) + CHR(179)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_EVEN"
		RETURN CHR(189) + CHR(246) + CHR(197) + CHR(188) + CHR(202) + CHR(253) + CHR(210) + CHR(179)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_PAGELIST"
		RETURN CHR(192) + CHR(253) + CHR(200) + CHR(231) + CHR(58) + CHR(32) + CHR(49) + CHR(45) + CHR(51) + CHR(44) + CHR(32) + CHR(53) + CHR(45) + CHR(56) + CHR(44) + CHR(32) + CHR(57)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_DUPLEX"
		RETURN CHR(203) + CHR(171) + CHR(195) + CHR(230) + CHR(180) + CHR(242) + CHR(211) + CHR(161)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE"
		RETURN CHR(214) + CHR(189) + CHR(213) + CHR(197) + CHR(185) + CHR(230) + CHR(184) + CHR(241)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE_AUTO"
		RETURN CHR(215) + CHR(212) + CHR(182) + CHR(175) + CHR(209) + CHR(161) + CHR(212) + CHR(241)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_TITLE"
		RETURN CHR(202) + CHR(228) + CHR(200) + CHR(235) + CHR(195) + CHR(220) + CHR(194) + CHR(235)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_PROMPT"
		RETURN CHR(80) + CHR(68) + CHR(70) + CHR(32) + CHR(206) + CHR(196) + CHR(188) + CHR(254) + CHR(202) + CHR(220) + CHR(195) + CHR(220) + CHR(194) + CHR(235) + CHR(177) + CHR(163) + CHR(187) + CHR(164) + CHR(161) + CHR(163) + CHR(202) + CHR(228) + CHR(200) + CHR(235) + CHR(195) + CHR(220) + CHR(194) + CHR(235) + CHR(188) + CHR(180) + CHR(191) + CHR(201) + CHR(180) + CHR(242) + CHR(191) + CHR(170) + CHR(206) + CHR(196) + CHR(188) + CHR(254) + CHR(161) + CHR(163)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_INCORRECTPASSWORD"
		RETURN CHR(195) + CHR(220) + CHR(194) + CHR(235) + CHR(180) + CHR(237) + CHR(206) + CHR(243)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_OK"
		RETURN CHR(180) + CHR(242) + CHR(191) + CHR(170) + CHR(206) + CHR(196) + CHR(181) + CHR(181)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_CANCEL"
		RETURN CHR(200) + CHR(161) + CHR(207) + CHR(251)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_TITLE"
		RETURN CHR(209) + CHR(161) + CHR(212) + CHR(241) + CHR(180) + CHR(242) + CHR(211) + CHR(161) + CHR(187) + CHR(250)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_OK"
		RETURN CHR(211) + CHR(166) + CHR(211) + CHR(195)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_CANCEL"
		RETURN CHR(200) + CHR(161) + CHR(207) + CHR(251)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_de
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_DE.XML for LocaleID = 1031
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(75) + CHR(111) + CHR(112) + CHR(105) + CHR(101) + CHR(114) + CHR(101) + CHR(110)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(65) + CHR(108) + CHR(108) + CHR(101) + CHR(115) + CHR(32) + CHR(109) + CHR(97) + CHR(114) + CHR(107) + CHR(105) + CHR(101) + CHR(114) + CHR(101) + CHR(110)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_en
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_EN.XML for LocaleID = 1033
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(121)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(83) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(116) + CHR(32) + CHR(97) + CHR(108) + CHR(108)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(67) + CHR(117) + CHR(116)
		
		
		CASE m.tcTxtID == "MNU_PASTE"
		RETURN CHR(80) + CHR(97) + CHR(115) + CHR(116) + CHR(101)
		
		
		CASE m.tcTxtID == "MNU_CLEAR"
		RETURN CHR(67) + CHR(108) + CHR(101) + CHR(97) + CHR(114)
		
		
		CASE m.tcTxtID == "REPORTVIEWER_TITLE"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(32) + CHR(112) + CHR(114) + CHR(101) + CHR(118) + CHR(105) + CHR(101) + CHR(119)
		
		
		CASE m.tcTxtID == "SEARCH_NOT_FOUND"
		RETURN CHR(78) + CHR(111) + CHR(116) + CHR(32) + CHR(102) + CHR(111) + CHR(117) + CHR(110) + CHR(100)
		
		
		CASE m.tcTxtID == "SEARCH_ENDED"
		RETURN CHR(83) + CHR(101) + CHR(97) + CHR(114) + CHR(99) + CHR(104) + CHR(32) + CHR(101) + CHR(110) + CHR(100) + CHR(101) + CHR(100)
		
		
		CASE m.tcTxtID == "BTN_PRINT"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PRINTENV_TITLE"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(32) + CHR(115) + CHR(101) + CHR(116) + CHR(116) + CHR(105) + CHR(110) + CHR(103)
		
		
		CASE m.tcTxtID == "PRINTENV_OK"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PRINTENV_CANCEL"
		RETURN CHR(67) + CHR(97) + CHR(110) + CHR(99) + CHR(101) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTENV_PRINTER"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(101) + CHR(114)
		
		
		CASE m.tcTxtID == "PRINTENV_COPIES"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(105) + CHR(101) + CHR(115)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE"
		RETURN CHR(80) + CHR(97) + CHR(103) + CHR(101) + CHR(115)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ALL"
		RETURN CHR(65) + CHR(108) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ODD"
		RETURN CHR(79) + CHR(100) + CHR(100) + CHR(32) + CHR(112) + CHR(97) + CHR(103) + CHR(101) + CHR(115) + CHR(32) + CHR(111) + CHR(110) + CHR(108) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_EVEN"
		RETURN CHR(69) + CHR(118) + CHR(101) + CHR(110) + CHR(32) + CHR(112) + CHR(97) + CHR(103) + CHR(101) + CHR(115) + CHR(32) + CHR(111) + CHR(110) + CHR(108) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_PAGELIST"
		RETURN CHR(69) + CHR(120) + CHR(97) + CHR(109) + CHR(112) + CHR(108) + CHR(101) + CHR(58) + CHR(32) + CHR(49) + CHR(45) + CHR(51) + CHR(44) + CHR(32) + CHR(53) + CHR(45) + CHR(56) + CHR(44) + CHR(32) + CHR(57)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_DUPLEX"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(32) + CHR(111) + CHR(110) + CHR(32) + CHR(98) + CHR(111) + CHR(116) + CHR(104) + CHR(32) + CHR(115) + CHR(105) + CHR(100) + CHR(101) + CHR(115)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE"
		RETURN CHR(80) + CHR(97) + CHR(112) + CHR(101) + CHR(114) + CHR(32) + CHR(115) + CHR(105) + CHR(122) + CHR(101)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE_AUTO"
		RETURN CHR(65) + CHR(117) + CHR(116) + CHR(111) + CHR(109) + CHR(97) + CHR(116) + CHR(105) + CHR(99) + CHR(32) + CHR(99) + CHR(104) + CHR(111) + CHR(105) + CHR(99) + CHR(101)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_TITLE"
		RETURN CHR(73) + CHR(110) + CHR(112) + CHR(117) + CHR(116) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_PROMPT"
		RETURN CHR(80) + CHR(68) + CHR(70) + CHR(32) + CHR(102) + CHR(105) + CHR(108) + CHR(101) + CHR(32) + CHR(105) + CHR(115) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100) + CHR(32) + CHR(112) + CHR(114) + CHR(111) + CHR(116) + CHR(101) + CHR(99) + CHR(116) + CHR(101) + CHR(100) + CHR(46) + CHR(32) + CHR(73) + CHR(110) + CHR(112) + CHR(117) + CHR(116) + CHR(32) + CHR(97) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100) + CHR(32) + CHR(116) + CHR(111) + CHR(32) + CHR(111) + CHR(112) + CHR(101) + CHR(110) + CHR(32) + CHR(116) + CHR(104) + CHR(101) + CHR(32) + CHR(102) + CHR(105) + CHR(108) + CHR(101) + CHR(46)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_INCORRECTPASSWORD"
		RETURN CHR(73) + CHR(110) + CHR(99) + CHR(111) + CHR(114) + CHR(114) + CHR(101) + CHR(99) + CHR(116) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_OK"
		RETURN CHR(79) + CHR(112) + CHR(101) + CHR(110) + CHR(32) + CHR(100) + CHR(111) + CHR(99) + CHR(117) + CHR(109) + CHR(101) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_CANCEL"
		RETURN CHR(67) + CHR(97) + CHR(110) + CHR(99) + CHR(101) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_TITLE"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(101) + CHR(114) + CHR(32) + CHR(115) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(116) + CHR(105) + CHR(111) + CHR(110)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_OK"
		RETURN CHR(65) + CHR(112) + CHR(112) + CHR(108) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_CANCEL"
		RETURN CHR(67) + CHR(97) + CHR(110) + CHR(99) + CHR(101) + CHR(108)
		
		OTHERWISE
		RETURN m.tcTxtID
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_es
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_ES.XML for LocaleID = 1034
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(105) + CHR(97) + CHR(114)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(83) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(99) + CHR(105) + CHR(111) + CHR(110) + CHR(97) + CHR(114) + CHR(32) + CHR(116) + CHR(111) + CHR(100) + CHR(111)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_fr
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_FR.XML for LocaleID = 1036
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(105) + CHR(101) + CHR(114)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(83) + CHR(233) + CHR(108) + CHR(101) + CHR(99) + CHR(116) + CHR(105) + CHR(111) + CHR(110) + CHR(110) + CHR(101) + CHR(114) + CHR(32) + CHR(116) + CHR(111) + CHR(117) + CHR(116)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_ru
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_RU.XML for LocaleID = 1049
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(202) + CHR(238) + CHR(239) + CHR(232) + CHR(240) + CHR(238) + CHR(226) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(194) + CHR(251) + CHR(225) + CHR(240) + CHR(224) + CHR(242) + CHR(252) + CHR(32) + CHR(226) + CHR(241) + CHR(229)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(194) + CHR(251) + CHR(240) + CHR(229) + CHR(231) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "MNU_PASTE"
		RETURN CHR(194) + CHR(241) + CHR(242) + CHR(224) + CHR(226) + CHR(232) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "MNU_CLEAR"
		RETURN CHR(211) + CHR(228) + CHR(224) + CHR(235) + CHR(232) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "REPORTVIEWER_TITLE"
		RETURN CHR(207) + CHR(240) + CHR(238) + CHR(241) + CHR(236) + CHR(238) + CHR(242) + CHR(240) + CHR(32) + CHR(239) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(232)
		
		
		CASE m.tcTxtID == "SEARCH_NOT_FOUND"
		RETURN CHR(205) + CHR(229) + CHR(32) + CHR(237) + CHR(224) + CHR(233) + CHR(228) + CHR(229) + CHR(237) + CHR(238)
		
		
		CASE m.tcTxtID == "SEARCH_ENDED"
		RETURN CHR(207) + CHR(238) + CHR(232) + CHR(241) + CHR(234) + CHR(32) + CHR(231) + CHR(224) + CHR(226) + CHR(229) + CHR(240) + CHR(248) + CHR(229) + CHR(237)
		
		
		CASE m.tcTxtID == "BTN_PRINT"
		RETURN CHR(207) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTENV_TITLE"
		RETURN CHR(207) + CHR(224) + CHR(240) + CHR(224) + CHR(236) + CHR(229) + CHR(242) + CHR(240) + CHR(251) + CHR(32) + CHR(239) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(232)
		
		
		CASE m.tcTxtID == "PRINTENV_OK"
		RETURN CHR(207) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTENV_CANCEL"
		RETURN CHR(206) + CHR(242) + CHR(236) + CHR(229) + CHR(237) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTENV_PRINTER"
		RETURN CHR(207) + CHR(240) + CHR(232) + CHR(237) + CHR(242) + CHR(229) + CHR(240)
		
		
		CASE m.tcTxtID == "PRINTENV_COPIES"
		RETURN CHR(202) + CHR(238) + CHR(239) + CHR(232) + CHR(232)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE"
		RETURN CHR(209) + CHR(242) + CHR(240) + CHR(224) + CHR(237) + CHR(232) + CHR(246) + CHR(251)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ALL"
		RETURN CHR(194) + CHR(241) + CHR(229)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ODD"
		RETURN CHR(210) + CHR(238) + CHR(235) + CHR(252) + CHR(234) + CHR(238) + CHR(32) + CHR(237) + CHR(229) + CHR(247) + CHR(229) + CHR(242) + CHR(237) + CHR(251) + CHR(229)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_EVEN"
		RETURN CHR(210) + CHR(238) + CHR(235) + CHR(252) + CHR(234) + CHR(238) + CHR(32) + CHR(247) + CHR(229) + CHR(242) + CHR(237) + CHR(251) + CHR(229)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_PAGELIST"
		RETURN CHR(205) + CHR(224) + CHR(239) + CHR(240) + CHR(232) + CHR(236) + CHR(229) + CHR(240) + CHR(58) + CHR(32) + CHR(49) + CHR(45) + CHR(51) + CHR(44) + CHR(32) + CHR(53) + CHR(45) + CHR(56) + CHR(44) + CHR(32) + CHR(57)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_DUPLEX"
		RETURN CHR(196) + CHR(226) + CHR(243) + CHR(241) + CHR(242) + CHR(238) + CHR(240) + CHR(238) + CHR(237) + CHR(237) + CHR(255) + CHR(255) + CHR(32) + CHR(239) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE"
		RETURN CHR(208) + CHR(224) + CHR(231) + CHR(236) + CHR(229) + CHR(240) + CHR(32) + CHR(225) + CHR(243) + CHR(236) + CHR(224) + CHR(227) + CHR(232)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE_AUTO"
		RETURN CHR(192) + CHR(226) + CHR(242) + CHR(238) + CHR(226) + CHR(251) + CHR(225) + CHR(238) + CHR(240)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_TITLE"
		RETURN CHR(194) + CHR(226) + CHR(229) + CHR(228) + CHR(232) + CHR(242) + CHR(229) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(252)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_PROMPT"
		RETURN CHR(80) + CHR(68) + CHR(70) + CHR(32) + CHR(244) + CHR(224) + CHR(233) + CHR(235) + CHR(32) + CHR(231) + CHR(224) + CHR(249) + CHR(232) + CHR(249) + CHR(229) + CHR(237) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(229) + CHR(236) + CHR(46) + CHR(32) + CHR(194) + CHR(226) + CHR(229) + CHR(228) + CHR(232) + CHR(242) + CHR(229) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(252) + CHR(32) + CHR(228) + CHR(235) + CHR(255) + CHR(32) + CHR(238) + CHR(242) + CHR(234) + CHR(240) + CHR(251) + CHR(242) + CHR(232) + CHR(255) + CHR(32) + CHR(244) + CHR(224) + CHR(233) + CHR(235) + CHR(224) + CHR(46)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_INCORRECTPASSWORD"
		RETURN CHR(205) + CHR(229) + CHR(239) + CHR(240) + CHR(224) + CHR(226) + CHR(232) + CHR(235) + CHR(252) + CHR(237) + CHR(251) + CHR(233) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(252)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_OK"
		RETURN CHR(206) + CHR(242) + CHR(234) + CHR(240) + CHR(251) + CHR(242) + CHR(252) + CHR(32) + CHR(228) + CHR(238) + CHR(234) + CHR(243) + CHR(236) + CHR(229) + CHR(237) + CHR(242)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_CANCEL"
		RETURN CHR(206) + CHR(242) + CHR(236) + CHR(229) + CHR(237) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_TITLE"
		RETURN CHR(194) + CHR(251) + CHR(225) + CHR(238) + CHR(240) + CHR(32) + CHR(239) + CHR(240) + CHR(232) + CHR(237) + CHR(242) + CHR(229) + CHR(240) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_OK"
		RETURN CHR(209) + CHR(238) + CHR(245) + CHR(240) + CHR(224) + CHR(237) + CHR(232) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_CANCEL"
		RETURN CHR(206) + CHR(242) + CHR(236) + CHR(229) + CHR(237) + CHR(224)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_password_input AS form 		&& Password input form
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtPassword" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOk" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTitle" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFocusHolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPrompt" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblIncorrect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgPasswordShow" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgPasswordHide" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: in_incorrect		&& Incorrect password flag
		*p: out_ok		&& .T. - User pressed ok button, .F. - user pressed cancel
		*p: out_password		&& Inputted password
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BindControls = .F.
		BorderStyle = 2
		Caption = ""
		DoCreate = .T.
		Height = 187
		Icon = (NVL(EVL(JUSTPATH(This.ClassLibrary),NULL)+"\images\wwrite.ico",""))
		in_incorrect = .F.
		KeyPreview = .T.
		MaxButton = .F.
		MinButton = .F.
		Name = "pdfium_password_input"
		out_ok = .F.
		out_password = ("")
		ShowWindow = 1
		TitleBar = 0
		Visible = .T.
		Width = 331
		WindowType = 1
		_memberdata = <VFPData>
			<memberdata name="in_incorrect" type="property" display="In_Incorrect"/>
			<memberdata name="out_ok" type="property" display="Out_Ok"/>
			<memberdata name="out_password" type="property" display="Out_Password"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Cancel", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 192, ;
		Name = "cmdCancel", ;
		TabIndex = 3, ;
		Top = 144, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFocusHolder' AS commandbutton WITH ;
		Caption = "", ;
		Height = 27, ;
		Left = 444, ;
		Name = "cmdFocusHolder", ;
		Style = 1, ;
		TabIndex = 4, ;
		Top = 276, ;
		Width = 36
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOk' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Ok", ;
		Default = .T., ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 12, ;
		Name = "cmdOk", ;
		TabIndex = 2, ;
		Top = 144, ;
		Width = 160
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 300, ;
		Name = "i18n", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'imgPasswordHide' AS image WITH ;
		Height = 24, ;
		Left = 291, ;
		MousePointer = 15, ;
		Name = "imgPasswordHide", ;
		PictureVal = , ;
		Top = 73, ;
		Visible = .F., ;
		Width = 24
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'imgPasswordShow' AS image WITH ;
		Height = 24, ;
		Left = 291, ;
		MousePointer = 15, ;
		Name = "imgPasswordShow", ;
		PictureVal = , ;
		Top = 73, ;
		Visible = .F., ;
		Width = 24
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'lblIncorrect' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Incorrect password", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		ForeColor = 255,0,0, ;
		Height = 19, ;
		Left = 12, ;
		Name = "lblIncorrect", ;
		TabIndex = 5, ;
		Top = 106, ;
		Width = 300
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPrompt' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "This file is protected by password. Input password to open the file", ;
		FontBold = .F., ;
		FontName = "Segoe UI", ;
		FontSize = 9, ;
		Height = 33, ;
		Left = 12, ;
		Name = "lblPrompt", ;
		TabIndex = 5, ;
		Top = 36, ;
		Width = 300, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblTitle' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Input password", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 12, ;
		Name = "lblTitle", ;
		TabIndex = 5, ;
		Top = 12, ;
		Width = 300
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'txtPassword' AS pdfium_textbox WITH ;
		ControlSource = "Thisform.out_password", ;
		Format = "KF", ;
		Height = 27, ;
		InputMask = "", ;
		Left = 12, ;
		MaxLength = 255, ;
		Name = "txtPassword", ;
		PasswordChar = "", ;
		TabIndex = 1, ;
		Top = 72, ;
		Width = 276
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />
	
	PROCEDURE Init
		This.BindControls = .T.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 27 AND EMPTY(m.nShiftAltCtrl)
		    This.out_ok = .F.
		    This.Hide()
		ENDIF
		
		
	ENDPROC

	PROCEDURE Load
		CLEAR TYPEAHEAD 
		
		
		
		
	ENDPROC

	PROCEDURE Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_TITLE")
		
		This.txtPassword.Value = This.Out_Password
		This.lblIncorrect.Visible = This.in_incorrect
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.out_ok = .F.
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdCancel.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_CANCEL")
		
	ENDPROC

	PROCEDURE cmdOk.Click
		
		Thisform.Out_Ok = .T.
		
		Thisform.Hide()
		
		
	ENDPROC

	PROCEDURE cmdOk.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_OK")
		
	ENDPROC

	PROCEDURE imgPasswordHide.Click
		This.Visible = .F.
		This.Parent.txtPassword.ResetToDefault("PasswordChar")
		This.Parent.txtPassword.InteractiveChange()
		This.Parent.txtPassword.SelStart = LEN(This.Parent.txtPassword.Text)
		
	ENDPROC

	PROCEDURE imgPasswordHide.Init
		This.PictureVal = STRCONV("iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAASnSURBVEhL7ZR7aFt1FMd/v/u+N69C3dwUpkWx7fLqc0xcZTIEFVe"+"FgmBfaZO1Da7+4R/6h8Ol9TFRhCKFdq3UPuI/boNVNhi+YFERtiZp0qKydi1tpfXFZpv0Jmnuy3PT24zVig78R/ADyb055/zON79zzu+H/udOwM3e9keN938NbDxRs6+j02y29IqJ5JujwwOvGeYcDQ0NVlIQdhGIEQiSoC"+"Q5LVoYZqWvr2/dCPlL8gJNXn85RZFnBMH0YCK51h0cGujS7SD8Ek3RJ+C1kCQphGGFoihIVuQVsH2LNfzx/Ox346FQSNbjt0MaTzQ1Gf7Z7ai4oGjqIwLP1ztcbhSLhkNlrspVROCDkPSaosgXpawUUzVlBWnaPo7jq1mOf"+"85kLXjW6apYmopFZo10efI72KKxtaPfYjb5NXCJ6+vdweHNnQDY42kv1jScHBsbWA4EAsT80koNJogXBV6o0yAgJYpvB4cHX90M3yS/A52mlrb3rVbrcQhckhUpYbZYavc7nDg+Gbnc1HS8ENPogmAxvessq3j+xs3EXHBk8"+"AvwnXE43ROqig5ZbdanS0oc1ngs8pmR8pYA/HOfzWZ7K53JLGqSclgjlTOKrD3D8/zR/Q43Co72XzpQVf6JpGh3IQ1XsDzrc7pc0dhkZAY+s/ZS1zko3RNmi7W2uLj0l6l4NKznzZWo3vvCfSyFpwmC5KTUxiEowVXd3uA5d"+"pBh2C8ZhhEyqVQ3TFeuXB5Px/0kS0/LsvRbyibYz/X0pHV7s8/nYmjT14qqYDktOYLBwSVCd9Ca/IoZZjSbTr+xlVyHEehfobm0JEmI5bmAx9eRExgdHViQlex5WFJkWU0V5YKBsaGhqWw2dUrPRdDEy7otJ6ARhKJp0CYSi"+"/rvPBmVg7GkVFVBugjDcoEWrz+guwiFPJFKp8KapppysQYwBKyeCpD0r00BUn0PJibBslxXo9fr0G06NK0twIpZmqaRCl2UQYRm2S5Pa0fXyEj/j1Jq7Ygo0D8Y4XCWvA/D6J4UxWQCq7hHt+WaPBWJrDnc5TdNJlOdKmtH7"+"BXu8eloNBGJRCRXZfUCgXE9RVG5AwZ/B7EcexjOCQ6ODn/6/cREFoy45Zi/hqKYs9Azazaz4R8dPv2VnvvWQYtFIqWlzkKbreApJSvVudxV1+Kx8PWpaHjG4SyfgFI5VA0VQklIEFI4nn/M7ihD8clwCJZjd1nVRzBB9sTqW"+"ieM7webWXc4aM1efzfPcyd1VzqTOksSxOD8zO7LoVC33NDWthdKRhIqsYciqHGW4+5Ni2JuujztnSWqLFcHPzwdNFLl+JOATnNr25OYpN6BaXCqiorSKfEGNO6KhtESCOh12geX0uOCIHBQMSSmxfzdtZ3bTvIW8Vj0+kMPF"+"A1hgrwqyTIBd9E90INKhmaqoOEHYOKKIfGMlM1+DpdeAUxlbandtVWu29hxB9tpbGw00bTlbpWUrHA6kKSi35fndi3rZWtpaasgaPoiL5j2JpPJ120m+lRvb++GsfSfCfwdDSACu7vE8dzu9WSyBi68bwzXziW6U6Zj0Z/sL"+"vcVRVZii3N7zi8uhlTD9Z8HoT8A5bAHNfkKxCkAAAAASUVORK5CYII=",14)
		
	ENDPROC

	PROCEDURE imgPasswordShow.Click
		This.Visible = .F.
		This.Parent.txtPassword.PasswordChar = ""
		This.Parent.txtPassword.InteractiveChange()
		This.Parent.txtPassword.SelStart = LEN(This.Parent.txtPassword.Text)
		
	ENDPROC

	PROCEDURE imgPasswordShow.Init
		This.PictureVal = STRCONV("iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAPxSURBV"+"EhL7ZRfaBxFHMdn9u/s7l1DHjQ2TTHFUqsBa1SKiKKSVqGGRi2o1Oz9SS53xT5IEGPBlxxtkWIffGmSW7zLXa4BEarWaC1UK6WgiE1JBNGWEmvQ+iAid7e7t//Hmbu9lJKYV33o52Fn9"+"7u/+f125vedBbf5z4HhuC6jo6PSn1V7E8dAiWEZzvXqRlQQbkxMTOhhyL+yboFk6mA/hoFKbh8jebtYjm1M8H0feL53A2J4ETL4g4I2+UljwhqsWeDV+PBTvCAeUxRlJ01WN83fMMCLJ"+"HwJBIAnSTtJ2KOSpNxJixq6fsnz8Fsni1PnmxluwoTjCmoyfUhRIl8jEe2s1fRTdUPfVcpPbZ7J5/p54B7lIHu4lM8NdHfdtdGyzD69VjstSdIjCAlfxZMH3gjTrHDLCgYT6SPt7e1vG"+"6bxR+D5mWJ+co7qaiI1wPLCMY5l74UQku3xf/Qcb6xczJ2h7xPDmT0MyxUkWe6oVqrZ8nRunOqUlQJqfESNtrXNWLa1bOvmM7OzhStUjw2N7JXkyGnPdYHrunMAQp8Uep7jeODY5t5iX"+"mt+hJraxknCWUWObKlVKqnSdC5P9UaB/UOv3Y04uMgwLGs71tPlgnaJ6vF4HGEWLQqi2O3V7f5iMXeO6olEZjeHhLOO4ywhDu/QNM1sxqce5iX5fBD42K27D5TL2nKjBzwMxpRIpM2yr"+"COt5BSflbYiSdpmW/aZVnIKvXccew4haavhwu5QBqXS+/O2bbyjRKJtDM+8SbWwyYGLMSarx17zuQmPcUD1tSC6SF6TGOCGUgOMGUguAEPg0OdGAQ8Gxw1Dr4iiNK6qQ71Uo/A8vm5b1"+"i8iEp+Lx9N9oQzU1I"+"FnRRHtsm3752hUWA5lsJ9sEUJoXNf1v33GP061lSbHkukkaXLBMutLlmHuaTVZTab6id/niHOA77mfknUGPMeRJnPAIn0pFSY/p3GvxFI9CkJfCEjcrFdr+8"+"pF7SOqs/RCWVyYX9h+Xw9UohtewBC/vKP3oasLl+ev/LBw+er9PQ9+DxnYy/PC48RB28nh+6nuWMlyIddInhhOv0iMcEpWlI3VSuXoyaJ2opGUsOokx4Yyr5Pg96gN66bxMdlF7fq1O7"+"68cCHrxWKZTTRmZib3Ox2J/3eTFR2UZWXA9Vxg29YYMcm79F2LVQUoanLkSYbjD0dk+QnaY9PQ/yLjd6Rxy6SBPgm5h65IlpQO8vMDpm5843jBodni1MVmhpusWaAFPaEQsi8Rx/SRf0"+"4Xy3LEacQUngeI168BzHwLOPDh9NSJz8Ipq1i3QIvBwUGF56MdAetuAEAgFnRrWzo7f81ms7fY+jb/RwD4B+vrrUXeOtApAAAAAElFTkSuQmCC",14)
	ENDPROC

	PROCEDURE lblIncorrect.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_INCORRECTPASSWORD")
	ENDPROC

	PROCEDURE lblPrompt.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_PROMPT")
	ENDPROC

	PROCEDURE lblTitle.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_TITLE")
	ENDPROC

	PROCEDURE txtPassword.InteractiveChange
		DO CASE
		CASE EMPTY(NVL(This.Value,""))
		    This.Parent.imgPasswordShow.Visible = .F.
		    This.Parent.imgPasswordHide.Visible = .F.
		
		CASE EMPTY(This.PasswordChar) = .T.
		    This.Parent.imgPasswordShow.Visible = .F.
		    This.Parent.imgPasswordHide.Visible = .T.
		
		OTHERWISE
		    This.Parent.imgPasswordShow.Visible = .T.
		    This.Parent.imgPasswordHide.Visible = .F.
		    
		ENDCASE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_pdfmeta AS custom 		&& PDF metadata (author,creator etc) + encryption (by password) + permission (read, edit, print etc)
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: author		&& The name of the person who created the document
		*p: creator		&& The the name of the application that created the document
		*p: keywords		&& The keywords associated with the document
		*p: ownerpassword		&& The password for the owner of the document. Owner password protects permissions of the document (Permit_* properties) . The same value as user password are not allowed. Mandatory if user password is set
		*p: permit_copy		&& Reader can copy the text and the graphics of the document; Owner password must be set to apply permission to the output doc
		*p: permit_edit		&& Reader can add or modify the annotations and form fields of the document. Owner password must be set to apply permission to the output doc
		*p: permit_edit_all		&& Reader can edit the contents of the document other than annotations, form fields. Owner password must be set to apply permission to the output doc
		*p: permit_print		&& Reader can print the document; Owner password must be set to apply permission to the output doc
		*p: producer		&& The name of the application that produced the document
		*p: subject		&& The subject of the document
		*p: title		&& The title of the document
		*p: userpassword		&& The password for the reader of the document. Document is encrypted if user password is set. Owner password is mandatory if User password is not empty
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,Error,Height,HelpContextID,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		author = ("")
		creator = ("")
		Height = 27
		keywords = ("")
		Name = "pdfium_pdfmeta"
		ownerpassword = ("")
		permit_copy = .T.
		permit_edit = .T.
		permit_edit_all = .T.
		permit_print = .T.
		producer = ("pdfium-vfp")
		subject = ("")
		title = ("")
		userpassword = ("")
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="author" type="property" display="Author"/>
			<memberdata name="creator" type="property" display="Creator"/>
			<memberdata name="keywords" type="property" display="Keywords"/>
			<memberdata name="ownerpassword" type="property" display="OwnerPassword"/>
			<memberdata name="producer" type="property" display="Producer"/>
			<memberdata name="subject" type="property" display="Subject"/>
			<memberdata name="title" type="property" display="Title"/>
			<memberdata name="userpassword" type="property" display="UserPassword"/>
		</VFPData>
	*</PropValue>

ENDDEFINE

DEFINE CLASS pdfium_print_env AS custom 		&& Print configuration state for PdfiumViewer and PdfiumReport.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="API_WIN" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: foxdefaultprinter_get		&& Returns VFP default printer (SET("Printer", 3))
		*m: foxdefaultprinter_restore		&& Restore VFP default printer to the value before first FoxDefaultPrinter_Set call or before first FoxDefaultPrinter_Set after previous FoxDefaultPrinter_Restore call
		*m: foxdefaultprinter_set		&& Set VFP default printer. If input parameter is empty default printer is set to This.Printer
		*m: getprinterdevmode		&& Return output structure DEVMODE from DocumentProperties win32api function
		*m: getprinterduplex		&& Returns printer duplex support: .T. - duplex is supported, .F. - duplex is not supported.
		*m: getprinterforms		&& Return full list of paper forms with the flag indicating that  form is supported by printer
		*m: getprintertitle
		*m: pagelist_parse		&& Parse page list input (string), returns valid string of page list
		*m: setup		&& Copy print configuration from external pdfium_print_env object
		*m: setupdefault		&& Set default values (as they are on Init)
		*m: statelen		&& Return length of the state stack
		*m: statepop		&& Restores object's state from stack saved by This.StatePush call
		*m: statepush		&& Stores object's state in the stack
		*m: sysdefaultprinter_get		&& Returns system default printer
		*m: sysdefaultprinter_restore		&& Restore system default printer to the value before first SysDefaultPrinter_Set call or before first SysDefaultPrinter_Set after previous SysDefaultPrinter_Restore call
		*m: sysdefaultprinter_set		&& Set system default printer. If input parameter is empty default printer is set to This.Printer
		*p: allowprintsetupui		&& Allows print setup dialog to be shown to a user. This is instructions to application using this object not to show any print settings dialogs. Values .T. (Default) | .F. | NULL
		*p: allowsetdefaultprinter		&& Allows set default printer. This is instructions to application using this object not to change default vfp printer. Values .T. (default) | .F. | NULL
		*p: copies		&& Number of  copies; Default value = 1
		*p: duplex		&& Duplex mode .T. | .F. (Default) | NULL
		*p: foxdefaultprinter_prev		&& VFP default printer before FoxDefaultPrinter_Set call
		*p: pagelist		&& List of pages to print (comma separated), supports intervals: 1,2-5,10; Default value = empty string
		*p: pagemode		&& 1 (default) - all, 2 - only odd, 3 - only even, 4 - PageList
		*p: papersize		&& Paper size index (like PRTINFO(2) returns); -1 - auto choice the fittest to the document; 0 (default) - unknown paper size
		*p: printer		&& Printer name; Default value = VFP default printer (sys("printer",3))
		*p: statestacksize		&& Size of StateStack
		*p: sysdefaultprinter_prev		&& System default printer before SysDefaultPrinter_Set call
		*a: statestack[1,0]		&& State store for This.StatePush and This.StatePop
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,Error,foxdefaultprinter_prev,Height,HelpContextID,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,statestacksize,statestack,sysdefaultprinter_prev,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		allowprintsetupui = .T.
		allowsetdefaultprinter = .T.
		copies = 1
		duplex = .F.
		foxdefaultprinter_prev = ("")
		Height = 27
		Name = "pdfium_print_env"
		pagelist = ("")
		pagemode = 1
		papersize = 0
		printer = ("")
		statestacksize = 0
		sysdefaultprinter_prev = ("")
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="duplex" type="property" display="Duplex"/>
			<memberdata name="printer" type="property" display="Printer"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="sysdefaultprinter_restore" type="method" display="SysDefaultPrinter_Restore"/>
			<memberdata name="sysdefaultprinter_set" type="method" display="SysDefaultPrinter_Set"/>
			<memberdata name="sysdefaultprinter_prev" type="property" display="SysDefaultPrinter_Prev"/>
			<memberdata name="copies" type="property" display="Copies"/>
			<memberdata name="pagelist" type="property" display="PageList"/>
			<memberdata name="pagemode" type="property" display="PageMode"/>
			<memberdata name="pagelist_parse" type="method" display="PageList_Parse"/>
			<memberdata name="getprinterforms" type="method" display="GetPrinterForms"/>
			<memberdata name="getprinterdevmode" type="method" display="GetPrinterDevMode"/>
			<memberdata name="papersize" type="property" display="PaperSize"/>
			<memberdata name="getprinterduplex" type="method" display="GetPrinterDuplex"/>
			<memberdata name="allowprintsetupui" type="property" display="AllowPrintSetupUI"/>
			<memberdata name="allowsetdefaultprinter" type="property" display="AllowSetDefaultPrinter"/>
			<memberdata name="foxdefaultprinter_prev" type="property" display="FoxDefaultPrinter_Prev"/>
			<memberdata name="foxdefaultprinter_restore" type="method" display="FoxDefaultPrinter_Restore"/>
			<memberdata name="foxdefaultprinter_set" type="method" display="FoxDefaultPrinter_Set"/>
			<memberdata name="getprintertitle" type="method" display="GetPrinterTitle"/>
			<memberdata name="statepop" type="method" display="StatePop"/>
			<memberdata name="statepush" type="method" display="StatePush"/>
			<memberdata name="statestack" type="property" display="StateStack"/>
			<memberdata name="statestacksize" type="property" display="StateStackSize"/>
			<memberdata name="setupdefault" type="method" display="SetupDefault"/>
			<memberdata name="foxdefaultprinter_get" type="method" display="FoxDefaultPrinter_Get"/>
			<memberdata name="sysdefaultprinter_get" type="method" display="SysDefaultPrinter_Get"/>
			<memberdata name="statelen" type="method" display="StateLen"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'API_WIN' AS pdfium_api_win WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_WIN", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE foxdefaultprinter_get		&& Returns VFP default printer (SET("Printer", 3))
		RETURN EVL(SET("Printer",3),"")
		
	ENDPROC

	PROCEDURE foxdefaultprinter_restore		&& Restore VFP default printer to the value before first FoxDefaultPrinter_Set call or before first FoxDefaultPrinter_Set after previous FoxDefaultPrinter_Restore call
		
		IF EMPTY(NVL(This.FoxDefaultPrinter_Prev,"")) = .T.
		    RETURN .F.
		ENDIF
		
		SET PRINTER TO NAME (This.FoxDefaultPrinter_Prev)
		
		This.FoxDefaultPrinter_Prev = ""
		
		
	ENDPROC

	PROCEDURE foxdefaultprinter_set		&& Set VFP default printer. If input parameter is empty default printer is set to This.Printer
		LPARAMETERS tcPrinter
		
		LOCAL lcPrinter
		m.lcPrinter = EVL(NVL(m.tcPrinter,""), EVL(NVL(This.Printer,""),""))
		
		IF EMPTY(m.lcPrinter) = .T.
		    RETURN .F.
		ENDIF
		
		IF EMPTY(This.FoxDefaultPrinter_Prev)
		    This.FoxDefaultPrinter_Prev = This.FoxDefaultPrinter_Get()
		ENDIF
		
		SET PRINTER TO NAME (m.lcPrinter)
		
		
	ENDPROC

	PROCEDURE getprinterdevmode		&& Return output structure DEVMODE from DocumentProperties win32api function
		LPARAMETERS lcPrinter
		
		* lcPrinter - printer name
		* Return: DEVMODE structure (as STRING)
		
		IF EMPTY(NVL(m.lcPrinter,""))
		    RETURN ""
		ENDIF
		
		
		#define DM_OUT_BUFFER 2
		#define DM_IN_BUFFER  8
		#define DM_IN_PROMPT  4
		
		LOCAL lcPrnDevMode
		m.lcPrnDevMode = ""
		
		LOCAL lhPrinter
		m.lhPrinter = 0
		
		This.API_WIN.OpenPrinter(m.lcPrinter, @m.lhPrinter, 0)
		
		IF m.lhPrinter = 0 
		    RETURN ""
		ENDIF
		
		LOCAL lnBufSize
		m.lnBufsize = This.API_WIN.DocumentProperties(Application.HWnd, m.lhPrinter, m.lcPrinter, NULL, NULL, 0)
		
		IF m.lnBufSize > 0
		    m.lcPrnDevMode = REPLICATE(CHR(0), m.lnBufsize)
		    This.API_WIN.DocumentProperties(Application.HWnd, m.lhPrinter, m.lcPrinter, @m.lcPrnDevMode, NULL, DM_OUT_BUFFER)
		ENDIF
		
		IF LEN(CHRTRAN(m.lcPrnDevMode, CHR(0), "")) = 0
		    m.lcPrnDevMode = ""
		ENDIF
		
		This.API_WIN.ClosePrinter(m.lhPrinter)
		
		RETURN m.lcPrnDevMode
		
	ENDPROC

	PROCEDURE getprinterduplex		&& Returns printer duplex support: .T. - duplex is supported, .F. - duplex is not supported.
		LPARAMETERS lcPrinter
		
		IF EMPTY(NVL(m.lcPrinter,""))
		    RETURN 0
		ENDIF
		
		#define DC_DUPLEX 7
		
		RETURN EMPTY(This.API_WIN.DeviceCapabilities(m.lcPrinter, NULL, DC_DUPLEX, NULL, NULL)) = .F.
		
	ENDPROC

	PROCEDURE getprinterforms		&& Return full list of paper forms with the flag indicating that  form is supported by printer
		LPARAMETERS laPrnForm, lcPrinter
		
		* laPrnForm - output array (form-info-1 of EnumForms + additional columns)
		* lcPrinter - printer name
		* Return: number of forms of printer 
		
		* laPrnForm[,1] - Flags
		* laPrnForm[,2] - pName
		* laPrnForm[,3] - Size width
		* laPrnForm[,4] - Size height
		* laPrnForm[,5] - ImageableArea Left
		* laPrnForm[,6] - ImageableArea Top
		* laPrnForm[,7] - ImageableArea Width
		* laPrnForm[,8] - ImageableArea Height
		* laPrnForm[,9] - Form is supported by the printer .T. | .F.
		
		IF EMPTY(NVL(m.lcPrinter,""))
		    RETURN 0
		ENDIF
		
		#define DC_PAPERS 2
		
		
		LOCAL lhPrinter
		m.lhPrinter = 0
		
		This.API_WIN.OpenPrinter(m.lcPrinter, @m.lhPrinter, 0)
		
		IF m.lhPrinter = 0 
		    RETURN 0
		ENDIF
		
		LOCAL lnPrnFormCnt
		m.lnPrnFormCnt = 0
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    LOCAL lnBufSize, lnFormHeap, lnFormHeapPtr
		    STORE 0 TO m.lnBufSize, m.lnFormHeap, m.lnFormHeapPtr
		
		    This.API_WIN.EnumForms(m.lhPrinter, 1,  0, 0, @m.lnBufSize, 0)
		    IF m.lnBufSize = 0
		        EXIT
		    ENDIF
		    m.lnFormHeap = This.API_WIN.HeapCreate(0, m.lnBufSize, 0)
		    IF EMPTY(m.lnFormHeap)
		        EXIT
		    ENDIF
		    m.lnFormHeapPtr = This.API_WIN.HeapAlloc(m.lnFormHeap, 0, m.lnBufSize)
		    IF EMPTY(m.lnFormHeapPtr)
		        EXIT
		    ENDIF
		    This.API_WIN.EnumForms(m.lhPrinter, 1, m.lnFormHeapPtr, m.lnBufSize, @m.lnBufSize, @m.lnPrnFormCnt)
		    IF EMPTY(m.lnPrnFormCnt)
		        EXIT
		    ENDIF
		    
		    DIMENSION m.laPrnForm(m.lnPrnFormCnt, 9)
		    
		    LOCAL liForm, lnFormOffs
		    m.liForm = 1
		    m.lnFormOffs = m.lnFormHeapPtr
		    FOR m.liForm = 1 TO m.lnPrnFormCnt
		        m.laPrnForm[m.liForm,1] = CTOBIN(SYS(2600, m.lnFormOffs, 4),"4RS") && Flags
		        m.laPrnForm[m.liForm,2] = SYS(2600, CTOBIN(SYS(2600, m.lnFormOffs+4, 4),"4RS"), 31) &&pName
		        m.laPrnForm[m.liForm,3] = CTOBIN(SYS(2600, m.lnFormOffs+8, 4),"4RS") &&Size width
		        m.laPrnForm[m.liForm,4] = CTOBIN(SYS(2600, m.lnFormOffs+12, 4),"4RS") &&Size height
		        m.laPrnForm[m.liForm,5] = CTOBIN(SYS(2600, m.lnFormOffs+16, 4),"4RS") && ImageableArea Left
		        m.laPrnForm[m.liForm,6] = CTOBIN(SYS(2600, m.lnFormOffs+20, 4),"4RS") && ImageableArea Top
		        m.laPrnForm[m.liForm,7] = CTOBIN(SYS(2600, m.lnFormOffs+24, 4),"4RS") && ImageableArea Width
		        m.laPrnForm[m.liForm,8] = CTOBIN(SYS(2600, m.lnFormOffs+28, 4),"4RS") && ImageableArea Height
		        m.laPrnForm[m.liForm,9] = .F.
		        m.lnFormOffs = m.lnFormOffs + 32        
		    ENDFOR
		
		CATCH TO m.loErr
		    
		FINALLY
		    IF EMPTY(m.lnFormHeap) = .F.
		        This.API_WIN.HeapDestroy(m.lnFormHeap)
		    ENDIF
		
		    This.API_WIN.ClosePrinter(m.lhPrinter)
		ENDTRY
		
		IF VARTYPE(m.loErr) = "O"
		    RETURN 0
		ENDIF
		
		LOCAL lcPapers, lnPaperCnt, liPaper, lnFormID
		m.lnPaperCnt = This.API_WIN.DeviceCapabilities(m.lcPrinter, NULL, DC_PAPERS, NULL, NULL)
		
		IF m.lnPaperCnt <> 0
		    m.lcPapers = REPLICATE(CHR(0), m.lnPaperCnt * 2)
		    m.lnPaperCnt = This.API_WIN.DeviceCapabilities(m.lcPrinter, NULL, DC_PAPERS, @m.lcPapers, NULL)
		    m.liPaper = 1
		    FOR m.liPaper = 1 TO m.lnPaperCnt
		        m.lnFormID = CTOBIN(SUBSTR(m.lcPapers, (m.liPaper-1)*2 + 1, 2), "2RS")
		        IF BETWEEN(m.lnFormID, 1, m.lnPrnFormCnt)
		            m.laPrnForm[m.lnFormID,9] = .T.
		        ENDIF
		    ENDFOR
		ENDIF
		
		
		RETURN m.lnPrnFormCnt
		
	ENDPROC

	PROCEDURE getprintertitle
		LPARAMETERS lcPrinter
		
		m.lcPrinter = EVL(NVL(m.lcPrinter,""), NVL(This.Printer,""))
		
		IF EMPTY(m.lcPrinter) = .T.
		    RETURN ""
		ENDIF
		
		LOCAL ARRAY laPrinters(1)
		LOCAL lnPrinters, liPrinter
		m.lnPrinters = APRINTERS(laPrinters,1)
		m.liPrinter = ASCAN(m.laPrinters, m.lcPrinter, 1, m.lnPrinters, 1, 15)
		IF m.liPrinter > 0
		    RETURN m.laPrinters[m.liPrinter,1]
		ENDIF
		
		RETURN ""
		
	ENDPROC

	PROCEDURE Init
		This.Printer = This.FoxDefaultPrinter_Get()
		
	ENDPROC

	PROCEDURE pagelist_parse		&& Parse page list input (string), returns valid string of page list
		LPARAMETERS m.tcPageList
		
		LOCAL lcPageList
		m.lcPageList = m.tcPageList
		
		IF INLIST(VARTYPE(m.lcPageList), "C", "N") = .F.
		    m.lcPageList = ""
		ENDIF
		
		m.lcPageList = LEFT(ALLTRIM(EVL(NVL(m.lcPageList,""),"")),200)
		m.lcPageList = CHRTRAN(m.lcPageList, ";.Ee", ",")
		
		
		LOCAL ARRAY laGroups(1)
		LOCAL lnGroups
		m.lnGroups = ALINES(laGroups, m.lcPageList, 1+4, ",")
		
		IF m.lnGroups = 0
		    RETURN ""
		ENDIF
		
		LOCAL ARRAY laGroups2(lnGroups * 2)
		LOCAL lnGroups2
		m.lnGroups2 = 0
		
		LOCAL i, lcGroup, lnLVal, lnRVal, lnEVal
		m.i = 1
		FOR m.i = 1 TO m.lnGroups
		    m.lcGroup = m.laGroups[m.i]
		    
		    m.lnLVal = MAX(INT(VAL(LEFT(STREXTRACT(m.lcGroup, "", "-",1,2),10))), 0)
		    m.lnRVal = MAX(INT(VAL(LEFT(STREXTRACT(m.lcGroup, "-", "",1,2),10))), 0)
		
		    m.lnEVal = m.lnLVal
		    m.lnLVal = EVL(MIN(m.lnEVal, m.lnRVal), m.lnEVal)
		    m.lnRVal = MAX(m.lnEVal, m.lnRVal)
		
		    IF EMPTY(m.lnLVal)
		        LOOP
		    ENDIF
		    
		    m.lnGroups2 = m.lnGroups2 + 1 
		    m.laGroups2[m.lnGroups2] = m.lnLVal
		    
		    m.lnGroups2 = m.lnGroups2 + 1 
		    m.laGroups2[m.lnGroups2] = m.lnRVal
		    
		ENDFOR
		
		
		
		LOCAL i, lnLInd, lnLVal, lnRVal
		
		DO WHILE .T.
		    m.i = 1
		    m.lnLInd = 1
		    m.lnLVal = 0
		    m.lnRVal = 0
		    DO WHILE m.i < m.lnGroups2 
		        
		        DO CASE
		        CASE m.laGroups2[m.lnLInd] > m.laGroups2[m.i]
		            m.lnLVal = m.laGroups2[m.lnLInd]
		            m.laGroups2[m.lnLInd] = m.laGroups2[m.i]
		            m.laGroups2[m.lnLInd+1] = m.laGroups2[m.i+1]
		               
		            m.laGroups2[m.i] = m.lnLVal
		            m.laGroups2[m.i+1] = m.lnRVal
		            m.lnLInd = m.i
		
		        CASE m.lnRVal < m.laGroups2[m.i]
		            m.lnLInd = m.i
		            m.lnRVal = m.laGroups2[m.i+1]
		
		        
		        CASE m.lnRVal = m.laGroups2[m.i]
		            m.lnRVal = m.laGroups2[m.i+1]
		
		        CASE m.lnRVal < m.laGroups2[m.i+1]
		            m.laGroups2[m.i] = m.lnRVal
		            m.lnRVal = m.laGroups2[m.i+1]
		
		        OTHERWISE
		            m.laGroups2[m.i] = m.lnRVal
		            m.laGroups2[m.i+1] = m.lnRVal
		        ENDCASE
		        
		        m.i = m.i + 2
		        
		    ENDDO
		
		    IF m.lnLVal = 0
		        EXIT
		    ENDIF
		ENDDO
		
		
		
		m.lcPageList = ""
		
		LOCAL i, lnLVal, lnRVal
		m.i = 1
		m.lnLVal = 0
		m.lnRVal = 0
		DO WHILE m.i < m.lnGroups2
		    
		    IF m.lnRVal = m.laGroups2[m.i+1]
		        m.i = m.i + 2
		        LOOP
		    ENDIF
		    
		    IF m.lnRVal = m.laGroups2[m.i]
		        m.lnLVal = m.laGroups2[m.i]
		        m.lnRVal = m.laGroups2[m.i+1]
		        m.i = m.i + 2
		        LOOP
		    ENDIF
		    
		    m.lcPageList = m.lcPageList + ;
		        IIF(m.lnLVal = m.lnRVal, "", "-" + TRANSFORM(m.lnRVal)) + ;
		        IIF(EMPTY(m.lcPageList), "", ", ") + ;
		        TRANSFORM(m.laGroups2[m.i])
		   
		    m.lnLVal = m.laGroups2[m.i]
		    m.lnRVal = m.laGroups2[m.i+1]
		    m.i = m.i + 2
		ENDDO
		
		m.lcPageList = m.lcPageList + IIF(m.lnLVal = m.lnRVal, "", "-" + TRANSFORM(m.lnRVal))
		
		
		RETURN m.lcPageList
		
		
	ENDPROC

	PROCEDURE setup		&& Copy print configuration from external pdfium_print_env object
		LPARAMETERS toPrintEnvSrc as pdfium_print_env of pdfium-vfp, tlCopyAsIs, tcFields, tcFieldsExcept
		
		* toPrintEnvSrc: if Object passed then copies state from it, if NULL is passed then set state to undefined
		* tcFields: restore fields those matching this list (format: string of comma separated field names)
		* tcFieldsExcept: restore fields except those matching this list (format: string of comma separated field names).
		
		LOCAL lcFields, lcFieldsExcept
		m.lcFields = ALLTRIM(CHRTRAN(EVL(NVL(m.tcFields,""),""), " ", ""), 1, ",")
		m.lcFieldsExcept = ALLTRIM(CHRTRAN(EVL(NVL(m.lcFieldsExcept,""),""), " ",""), 1, ",")
		
		**************************************************************
		* Store props according to tcFieldsExcept and tcFields
		**************************************************************
		
		LOCAL ARRAY laPropState(1,2) 
		LOCAL lnPropStateCnt
		m.lnPropStateCnt = 0
		
		IF EMPTY(m.lcFields)=.F. OR EMPTY(m.lcFieldsExcept) = .F.
		    LOCAL ARRAY laProps(1)
		    LOCAL lnProps, liProp
		    m.lnProps = AMEMBERS(laProps, This, 0, "U+G")
		
		    FOR m.liProp = 1 TO m.lnProps
		
		        LOCAL lcPropName
		        m.lcPropName = ALLTRIM(m.laProps[m.liProp])
		
		        IF EMPTY(m.lcFields)=.F. AND ATC(","+m.lcPropName+",", ","+m.lcFields+",") = 0
		            LOOP
		        ENDIF
		
		        IF EMPTY(m.lcFieldsExcept)=.F. AND ATC(","+m.lcPropName+",", ","+m.lcFieldsExcept+",") <> 0
		            LOOP
		        ENDIF
		
		        m.lnPropStateCnt = m.lnPropStateCnt + 1
		        DIMENSION m.laPropState(m.lnPropStateCnt, 2)
		
		        m.laPropState[m.lnPropStateCnt, 1] = m.lcPropName
		        m.laPropState[m.lnPropStateCnt, 2] = This.&lcPropName
		
		    ENDFOR
		ENDIF
		**************************************************************
		
		DO CASE
		CASE VARTYPE(m.toPrintEnvSrc)="O" AND m.tlCopyAsIs
		    This.Printer = m.toPrintEnvSrc.Printer
		    This.Copies = m.toPrintEnvSrc.Copies
		    This.PageMode = m.toPrintEnvSrc.PageMode
		    This.PageList = m.toPrintEnvSrc.PageList
		    This.Duplex = m.toPrintEnvSrc.Duplex
		    This.PaperSize = m.toPrintEnvSrc.PaperSize
		    This.AllowPrintSetupUI = m.toPrintEnvSrc.AllowPrintSetupUI
		    This.AllowSetDefaultPrinter = m.toPrintEnvSrc.AllowSetDefaultPrinter
		
		CASE VARTYPE(m.toPrintEnvSrc)="O"
		    IF NOT ALLTRIM(LOWER(EVL(NVL(m.toPrintEnvSrc.Printer,""), This.Printer))) == ALLTRIM(LOWER(This.Printer))
		        This.PaperSize = 0
		    ENDIF
		
		    This.Printer = EVL(NVL(m.toPrintEnvSrc.Printer,""), This.Printer)
		    This.Copies = EVL(NVL(m.toPrintEnvSrc.Copies, 0), This.Copies)
		    This.PageMode = EVL(NVL(m.toPrintEnvSrc.PageMode, 0), This.PageMode)
		    This.PageList = EVL(NVL(m.toPrintEnvSrc.PageList, ""), This.PageList)
		    This.Duplex = NVL(m.toPrintEnvSrc.Duplex, This.Duplex)
		    This.PaperSize = EVL(EVL(NVL(m.toPrintEnvSrc.PaperSize, 0), NVL(This.PaperSize,0)), EVL(MAX(PRTINFO(2, NVL(This.Printer,"")),0), -1))
		    This.AllowPrintSetupUI = NVL(m.toPrintEnvSrc.AllowPrintSetupUI, This.AllowPrintSetupUI)
		    This.AllowSetDefaultPrinter = NVL(m.toPrintEnvSrc.AllowSetDefaultPrinter, This.AllowSetDefaultPrinter)
		
		
		CASE ISNULL(m.toPrintEnvSrc)
		    This.Printer = ""
		    This.Copies = 0
		    This.PageMode = 0
		    This.PageList = ""
		    This.Duplex = NULL
		    This.PaperSize = 0
		    This.AllowPrintSetupUI = NULL
		    This.AllowSetDefaultPrinter = NULL
		
		ENDCASE
		
		
		**************************************************************
		* Restore props according to tcFieldsExcept and tcFields
		**************************************************************
		LOCAL liProp
		FOR m.liProp = 1 TO m.lnPropStateCnt
		
		    LOCAL lcPropName
		    m.lcPropName = ALLTRIM(m.laPropState[m.liProp, 1])
		
		    This.&lcPropName = m.laPropState[m.liProp, 2]
		
		ENDFOR
		**************************************************************
		
	ENDPROC

	PROCEDURE setupdefault		&& Set default values (as they are on Init)
		LPARAMETERS tlCopyAsIs, tcFields, tcFieldsExcept
		
		* tcFields: restore fields those matching this list (format: string of comma separated field names)
		* tcFieldsExcept: restore fields except those matching this list (format: string of comma separated field names).
		
		LOCAL loPrintEnv
		m.loPrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		
		This.Setup(m.loPrintEnv, m.tlCopyAsIs, m.tcFieldsExcept, m.tcFields)
		
	ENDPROC

	PROCEDURE statelen		&& Return length of the state stack
		RETURN This.StateStackSize
		
	ENDPROC

	PROCEDURE statepop		&& Restores object's state from stack saved by This.StatePush call
		LPARAMETERS tcFields, tcFieldsExcept
		
		* tcFields: restore fields those matching this list (format: string of comma separated field names)
		* tcFieldsExcept: restore fields except those matching this list (format: string of comma separated field names).
		
		
		IF EMPTY(This.StateStackSize)
		    RETURN 0
		ENDIF
		
		LOCAL lSavePrintEnv
		m.lSavePrintEnv = This.StateStack[This.StateStackSize]
		
		This.Setup(m.lSavePrintEnv, .T., m.tcFieldsExcept, m.tcFields)
		
		This.StateStack[This.StateStackSize] = .F.
		This.StateStackSize = This.StateStackSize - 1
		
		IF EMPTY(This.StateStackSize) = .F.
		    DIMENSION This.StateStack(This.StateStackSize)
		ENDIF    
		
		RETURN This.StateStackSize
		
	ENDPROC

	PROCEDURE statepush		&& Stores object's state in the stack
		This.StateStackSize = This.StateStackSize + 1
		DIMENSION This.StateStack(This.StateStackSize)
		
		LOCAL lSavePrintEnv
		m.lSavePrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		
		m.lSavePrintEnv.Setup(This, .T.)
		
		This.StateStack[This.StateStackSize] = m.lSavePrintEnv
		
		RETURN This.StateStackSize
		
	ENDPROC

	PROCEDURE sysdefaultprinter_get		&& Returns system default printer
		
		LOCAL lcBuf, lnBufLen
		m.lcBuf = REPLICATE(CHR(0),2000)
		m.lnBufLen = LEN(m.lcBuf)
		
		LOCAL lcPrinter
		m.lcPrinter = ""
		
		IF This.API_WIN.GetDefaultPrinter(@m.lcBuf, @m.lnBufLen) <> 0
		    IF m.lnBufLen > 0
		        m.lcPrinter = SUBSTR(m.lcBuf, 1, m.lnBufLen)
		    ENDIF
		ENDIF    
		
		RETURN m.lcPrinter
		
	ENDPROC

	PROCEDURE sysdefaultprinter_restore		&& Restore system default printer to the value before first SysDefaultPrinter_Set call or before first SysDefaultPrinter_Set after previous SysDefaultPrinter_Restore call
		IF EMPTY(NVL(This.SysDefaultPrinter_Prev,""))
		    RETURN .F.
		ENDIF
		
		IF This.API_WIN.SetDefaultPrinter(This.SysDefaultPrinter_Prev) = 0
		    RETURN .F.
		ENDIF
		
		This.SysDefaultPrinter_Prev = ""
		
	ENDPROC

	PROCEDURE sysdefaultprinter_set		&& Set system default printer. If input parameter is empty default printer is set to This.Printer
		LPARAMETERS tcPrinter
		
		LOCAL lcPrinter
		m.lcPrinter = EVL(NVL(m.tcPrinter,""), EVL(NVL(This.Printer,""),""))
		
		IF EMPTY(m.lcPrinter) = .T.
		    RETURN .F.
		ENDIF
		
		IF EMPTY(This.SysDefaultPrinter_Prev)
		    This.SysDefaultPrinter_Prev = This.SysDefaultPrinter_Get()
		ENDIF    
		
		IF This.API_WIN.SetDefaultPrinter(This.Printer) = 0
		    RETURN .F.
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_print_settings AS form 		&& Print settings dialog.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmbPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDuplex" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOk" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="PrintEnv" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCopies" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCopies" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ogrPageMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPageMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtPageList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPageList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFocusHolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmbPaperSize" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPaperSize" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: cancel		&& Specifies if a CommandButton is the Cancel button.
		*m: papersizerequery
		*m: setup
		*p: out_ok		&& .T. - User pressed ok button, .F. - user pressed cancel
		*p: printenvin
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN printenvin
	*<PropValue>
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BindControls = .F.
		BorderStyle = 2
		Caption = "Print setup"
		DoCreate = .T.
		Height = 297
		Icon = (NVL(EVL(JUSTPATH(This.ClassLibrary),NULL)+"\images\wwrite.ico",""))
		KeyPreview = .T.
		MaxButton = .F.
		MinButton = .F.
		Name = "pdfium_print_settings"
		out_ok = .F.
		printenvin = .F.
		ShowWindow = 1
		Visible = .T.
		Width = 435
		WindowType = 1
		_memberdata = <VFPData>
			<memberdata name="out_ok" type="property" display="Out_Ok"/>
			<memberdata name="papersizerequery" type="method" display="PaperSizeRequery"/>
			<memberdata name="cancel" type="method" display="Cancel"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="printenvin" type="property" display="PrintEnvIn"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'chkDuplex' AS checkbox WITH ;
		Alignment = 4, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Duplex printing", ;
		ControlSource = "Thisform.PrintEnv.duplex", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 20, ;
		Left = 12, ;
		Name = "chkDuplex", ;
		TabIndex = 4, ;
		Top = 125, ;
		Width = 177, ;
		WordWrap = .F.
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmbPaperSize' AS combobox WITH ;
		BoundColumn = 2, ;
		BoundTo = .T., ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "160,0", ;
		ControlSource = "", ;
		DisplayCount = 21, ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 28, ;
		Left = 12, ;
		Name = "cmbPaperSize", ;
		Style = 2, ;
		TabIndex = 5, ;
		Top = 180, ;
		Width = 180
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmbPrinters' AS combobox WITH ;
		BoundColumn = 1, ;
		BoundTo = .T., ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "370,200", ;
		ControlSource = "Thisform.PrintEnv.printer", ;
		DisplayCount = 30, ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 28, ;
		Left = 12, ;
		Name = "cmbPrinters", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 28, ;
		Width = 408
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Cancel", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 237, ;
		Name = "cmdCancel", ;
		TabIndex = 10, ;
		Top = 252, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFocusHolder' AS commandbutton WITH ;
		Caption = "", ;
		Height = 27, ;
		Left = 444, ;
		Name = "cmdFocusHolder", ;
		Style = 1, ;
		TabIndex = 1, ;
		Top = 276, ;
		Width = 36
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOk' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Ok", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 74, ;
		Name = "cmdOk", ;
		TabIndex = 9, ;
		Top = 252, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 336, ;
		Name = "i18n", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'lblCopies' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Copies", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblCopies", ;
		TabIndex = 12, ;
		Top = 69, ;
		Width = 117
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPageList' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "For example: 1,2, 4 -5", ;
		Enabled = .T., ;
		FontBold = .F., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 248, ;
		Name = "lblPageList", ;
		TabIndex = 11, ;
		Top = 183, ;
		Width = 143
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPageMode' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Pages", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 227, ;
		Name = "lblPageMode", ;
		TabIndex = 15, ;
		Top = 69, ;
		Width = 171
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPaperSize' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Paper size", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblPaperSize", ;
		TabIndex = 14, ;
		Top = 158, ;
		Width = 173
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPrinters' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Printer", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblPrinters", ;
		TabIndex = 13, ;
		Top = 4, ;
		Width = 173
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'ogrPageMode' AS optiongroup WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		ButtonCount = 4, ;
		ControlSource = "Thisform.PrintEnv.PageMode", ;
		Height = 121, ;
		Left = 221, ;
		Name = "ogrPageMode", ;
		TabIndex = 7, ;
		Top = 90, ;
		Value = 1, ;
		Width = 208, ;
		Option1.AutoSize = .F., ;
		Option1.Caption = "All", ;
		Option1.FontName = "Segoe UI", ;
		Option1.FontSize = 10, ;
		Option1.Height = 19, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 5, ;
		Option1.Value = 1, ;
		Option1.Width = 193, ;
		Option2.AutoSize = .F., ;
		Option2.Caption = "Odd pages only", ;
		Option2.FontName = "Segoe UI", ;
		Option2.FontSize = 10, ;
		Option2.Height = 19, ;
		Option2.Left = 5, ;
		Option2.Name = "Option2", ;
		Option2.Top = 34, ;
		Option2.Width = 193, ;
		Option3.AutoSize = .F., ;
		Option3.Caption = "Even pages only", ;
		Option3.FontName = "Segoe UI", ;
		Option3.FontSize = 10, ;
		Option3.Height = 19, ;
		Option3.Left = 5, ;
		Option3.Name = "Option3", ;
		Option3.PictureMargin = 0, ;
		Option3.PictureSpacing = 0, ;
		Option3.Top = 63, ;
		Option3.Width = 193, ;
		Option4.AutoSize = .F., ;
		Option4.Caption = "", ;
		Option4.FontName = "Segoe UI", ;
		Option4.FontSize = 10, ;
		Option4.Height = 19, ;
		Option4.Left = 5, ;
		Option4.Name = "Option4", ;
		Option4.Top = 94, ;
		Option4.Width = 19
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'PrintEnv' AS pdfium_print_env WITH ;
		Left = 288, ;
		Name = "PrintEnv", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'txtCopies' AS pdfium_textbox WITH ;
		ControlSource = "Thisform.PrintEnv.copies", ;
		Height = 27, ;
		InputMask = "9999", ;
		Left = 12, ;
		Name = "txtCopies", ;
		TabIndex = 3, ;
		Top = 90, ;
		Width = 113
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtPageList' AS pdfium_textbox WITH ;
		ControlSource = "Thisform.PrintEnv.PageList", ;
		Height = 27, ;
		InputMask = "", ;
		Left = 242, ;
		Name = "txtPageList", ;
		TabIndex = 8, ;
		TabStop = .F., ;
		Top = 180, ;
		Width = 173
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />
	
	PROCEDURE cancel		&& Specifies if a CommandButton is the Cancel button.
		Thisform.out_ok = .F.
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE Destroy
		This.PrintEnvIn = .F.
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toPrintEnvIn as pdfium_print_env of pdfium-vfp.vcx
		
		This.PrintEnvIn = m.toPrintEnvIn
		This.PrintEnv.Setup(This.PrintEnvIn)
		
		This.BindControls = .T.
		
		LOCAL ARRAY laPrinters(1)
		LOCAL lnPrinters
		m.lnPrinters = APRINTERS(laPrinters,1)
		
		LOCAL i, llHasComments
		m.llHasComments = .F.
		FOR m.i = 1 TO m.lnPrinters
		    LOCAL lcPrinter, lcComment
		    m.lcPrinter = RTRIM(EVL(NVL(m.laPrinters[m.i,1], ""),""))
		    m.lcComment = RTRIM(EVL(NVL(m.laPrinters[m.i,4],""),""))
		
		    IF EMPTY(m.lcPrinter)
		        LOOP
		    ENDIF
		    
		    IF EMPTY(m.lcComment)=.F.
		        m.llHasComments = .T.
		    ENDIF
		
		    This.cmbPrinters.AddItem(m.lcPrinter)
		    This.cmbPrinters.AddListItem(m.lcComment, m.i, 2)
		    
		    IF RTRIM(LOWER(This.PrintEnv.Printer)) == RTRIM(LOWER(m.lcPrinter))
		        This.PrintEnv.Printer = m.lcPrinter &&Fix uppercase printer name of set(printer,3) result
		    ENDIF
		ENDFOR
		
		IF m.llHasComments = .F.
		    This.cmbPrinters.ColumnWidths = STREXTRACT(This.cmbPrinters.ColumnWidths, "", ",",1,2) + ",0"
		ENDIF
		
		This.PaperSizeRequery()
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 27 AND EMPTY(m.nShiftAltCtrl)
		    This.Cancel()
		ENDIF
		
		
	ENDPROC

	PROCEDURE Load
		CLEAR TYPEAHEAD 
		
	ENDPROC

	PROCEDURE papersizerequery
		
		#define FORM_BUILTIN 0x00000001
		#define FORM_PRINTER 0x00000002
		
		This.cmbPaperSize.Clear()
		
		LOCAL lnPrnFormCnt
		LOCAL ARRAY laPrnForm(1,9)
		m.lnPrnFormCnt = This.PrintEnv.GetPrinterForms(@m.laPrnForm, This.PrintEnv.Printer)
		IF EMPTY(m.lnPrnFormCnt)
		    RETURN
		ENDIF
		
		This.cmbPaperSize.AddItem(Thisform.i18n.text("PRINTENV_PAPERSIZE_AUTO"))
		This.cmbPaperSize.AddListItem("-1", 1, 2)
		
		LOCAL liPrnForm, lcPrnForm, llPrnFormFound
		m.liPrnForm = 1
		m.llPrnFormFound = .F.
		FOR m.liPrnForm = 1 TO m.lnPrnFormCnt
		    m.lcPrnForm = RTRIM(TRANSFORM(EVL(NVL(m.laPrnForm[m.liPrnForm,2], ""),"")))
		
		    IF EMPTY(m.lcPrnForm)
		        LOOP
		    ENDIF
		    
		    IF m.laPrnForm[m.liPrnForm,9] = .F.
		        LOOP
		    ENDIF
		    
		    IF BITAND(m.laPrnForm[m.liPrnForm,1], FORM_BUILTIN) = 0
		        LOOP
		    ENDIF
		    
		    This.cmbPaperSize.AddItem(m.lcPrnForm)
		    This.cmbPaperSize.AddListItem(TRANSFORM(m.liPrnForm), This.cmbPaperSize.ListCount, 2)
		
		    IF m.liPrnForm = This.PrintEnv.PaperSize
		        m.llPrnFormFound = .T.
		    ENDIF
		ENDFOR
		
		IF m.llPrnFormFound = .F. AND This.PrintEnv.PaperSize <> -1
		    This.PrintEnv.PaperSize = EVL(MAX(PRTINFO(2, This.PrintEnv.Printer),0), -1)
		ENDIF
		
		This.cmbPaperSize.Value = TRANSFORM(This.Printenv.PaperSize)
		
	ENDPROC

	PROCEDURE Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_TITLE")
		
	ENDPROC

	PROCEDURE setup
		IF NVL(This.PrintEnv.AllowSetDefaultPrinter, .F.) = .T.
		    This.PrintEnv.FoxDefaultPrinter_Set()
		ENDIF
		
		IF VARTYPE(This.PrintEnvIn) = "O"
		    This.PrintEnvIn.Setup(This.PrintEnv)
		ENDIF
		
		Thisform.Out_Ok = .T.
		
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE chkDuplex.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_DUPLEX")
		
		
	ENDPROC

	PROCEDURE cmbPaperSize.InteractiveChange
		Thisform.PrintEnv.PaperSize = INT(VAL(This.Value))
	ENDPROC

	PROCEDURE cmbPrinters.InteractiveChange
		Thisform.PrintEnv.Printer = This.Value
		Thisform.PaperSizeRequery()
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.Cancel()
		
	ENDPROC

	PROCEDURE cmdCancel.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_CANCEL")
		
	ENDPROC

	PROCEDURE cmdOk.Click
		Thisform.Setup()
	ENDPROC

	PROCEDURE cmdOk.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_OK")
		
	ENDPROC

	PROCEDURE lblCopies.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_COPIES")
	ENDPROC

	PROCEDURE lblPageList.Init
		DODEFAULT()
		
		This.ForeColor = This.DisabledForeColor
		
		
	ENDPROC

	PROCEDURE lblPageList.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.Parent.txtPageList.SetFocus()
		
	ENDPROC

	PROCEDURE lblPageList.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_PAGELIST")
		
		This.Visible = EMPTY(This.Parent.txtPageList.Value)
		
		
	ENDPROC

	PROCEDURE lblPageMode.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE")
		
		
	ENDPROC

	PROCEDURE lblPaperSize.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAPERSIZE")
		
	ENDPROC

	PROCEDURE lblPrinters.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PRINTER")
		
	ENDPROC

	PROCEDURE ogrPageMode.InteractiveChange
		Thisform.txtPageList.TabStop = (This.Value = 4)
		
	ENDPROC

	PROCEDURE ogrPageMode.Option1.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_ALL")
	ENDPROC

	PROCEDURE ogrPageMode.Option2.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_ODD")
	ENDPROC

	PROCEDURE ogrPageMode.Option3.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_EVEN")
		
	ENDPROC

	PROCEDURE ogrPageMode.ProgrammaticChange
		Thisform.txtPageList.TabStop = (This.Value = 4)
		
	ENDPROC

	PROCEDURE txtPageList.GotFocus
		DODEFAULT()
		
		This.Parent.lblPageList.Visible = .F.
		This.Parent.ogrPageMode.Value = 4
		
	ENDPROC

	PROCEDURE txtPageList.LostFocus
		DODEFAULT()
		
		Thisform.Refresh()
		This.Parent.ogrPageMode.Value = IIF(EMPTY(This.Value), 1, 4)
		
		This.Value = Thisform.PrintEnv.PageList_Parse(This.Value)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_printer_selection AS form 		&& Printer selection dialog.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmbPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDuplex" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOk" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="PrintEnv" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFocusHolder" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: cancel		&& Specifies if a CommandButton is the Cancel button.
		*m: setup
		*p: out_ok		&& .T. - User pressed ok button, .F. - user pressed cancel
		*p: printenvin
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN printenvin
	*<PropValue>
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BindControls = .F.
		BorderStyle = 2
		Caption = "Print setup"
		DoCreate = .T.
		Height = 163
		Icon = (NVL(EVL(JUSTPATH(This.ClassLibrary),NULL)+"\images\wwrite.ico",""))
		KeyPreview = .T.
		MaxButton = .F.
		MinButton = .F.
		Name = "pdfium_printer_selection"
		out_ok = .F.
		printenvin = .F.
		ShowWindow = 1
		Visible = .T.
		Width = 435
		WindowType = 1
		_memberdata = <VFPData>
			<memberdata name="out_ok" type="property" display="Out_Ok"/>
			<memberdata name="cancel" type="method" display="Cancel"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="printenvin" type="property" display="PrintEnvIn"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'chkDuplex' AS checkbox WITH ;
		Alignment = 4, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Duplex printing", ;
		ControlSource = "Thisform.PrintEnv.duplex", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 20, ;
		Left = 12, ;
		Name = "chkDuplex", ;
		TabIndex = 4, ;
		Top = 72, ;
		Width = 177, ;
		WordWrap = .F.
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmbPrinters' AS combobox WITH ;
		BoundColumn = 1, ;
		BoundTo = .T., ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "370,200", ;
		ControlSource = "Thisform.PrintEnv.printer", ;
		DisplayCount = 30, ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 28, ;
		Left = 12, ;
		Name = "cmbPrinters", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 28, ;
		Width = 408
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Cancel", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 235, ;
		Name = "cmdCancel", ;
		TabIndex = 10, ;
		Top = 108, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFocusHolder' AS commandbutton WITH ;
		Caption = "", ;
		Height = 27, ;
		Left = 444, ;
		Name = "cmdFocusHolder", ;
		Style = 1, ;
		TabIndex = 1, ;
		Top = 276, ;
		Width = 36
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOk' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Ok", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 72, ;
		Name = "cmdOk", ;
		TabIndex = 9, ;
		Top = 108, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 336, ;
		Name = "i18n", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'lblPrinters' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Printer", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblPrinters", ;
		TabIndex = 13, ;
		Top = 4, ;
		Width = 173
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'PrintEnv' AS pdfium_print_env WITH ;
		Left = 288, ;
		Name = "PrintEnv", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE cancel		&& Specifies if a CommandButton is the Cancel button.
		Thisform.out_ok = .F.
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE Destroy
		This.PrintEnvIn = .F.
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toPrintEnvIn as pdfium_print_env of pdfium-vfp.vcx
		
		This.PrintEnvIn = m.toPrintEnvIn
		This.PrintEnv.Setup(This.PrintEnvIn)
		
		This.BindControls = .T.
		
		LOCAL ARRAY laPrinters(1)
		LOCAL lnPrinters
		m.lnPrinters = APRINTERS(laPrinters,1)
		
		LOCAL i, llHasComments
		m.llHasComments = .F.
		FOR m.i = 1 TO m.lnPrinters
		    LOCAL lcPrinter, lcComment
		    m.lcPrinter = RTRIM(EVL(NVL(m.laPrinters[m.i,1], ""),""))
		    m.lcComment = RTRIM(EVL(NVL(m.laPrinters[m.i,4],""),""))
		
		    IF EMPTY(m.lcPrinter)
		        LOOP
		    ENDIF
		    
		    IF EMPTY(m.lcComment)=.F.
		        m.llHasComments = .T.
		    ENDIF
		
		    This.cmbPrinters.AddItem(m.lcPrinter)
		    This.cmbPrinters.AddListItem(m.lcComment, m.i, 2)
		    
		    IF RTRIM(LOWER(This.PrintEnv.Printer)) == RTRIM(LOWER(m.lcPrinter))
		        This.PrintEnv.Printer = m.lcPrinter &&Fix uppercase printer name of set(printer,3) result
		    ENDIF
		ENDFOR
		
		IF m.llHasComments = .F.
		    This.cmbPrinters.ColumnWidths = STREXTRACT(This.cmbPrinters.ColumnWidths, "", ",",1,2) + ",0"
		ENDIF
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 27 AND EMPTY(m.nShiftAltCtrl)
		    This.Cancel()
		ENDIF
		
	ENDPROC

	PROCEDURE Load
		CLEAR TYPEAHEAD 
		
	ENDPROC

	PROCEDURE Refresh
		This.Caption = Thisform.i18n.text("PRINTER_SELECTION_TITLE")
		
	ENDPROC

	PROCEDURE setup
		IF NVL(This.PrintEnv.AllowSetDefaultPrinter, .F.) = .T.
		    This.PrintEnv.FoxDefaultPrinter_Set()
		ENDIF
		
		IF VARTYPE(This.PrintEnvIn) = "O"
		    This.PrintEnvIn.Setup(This.PrintEnv)
		ENDIF
		
		Thisform.Out_Ok = .T.
		
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE chkDuplex.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_DUPLEX")
		
		
	ENDPROC

	PROCEDURE cmbPrinters.InteractiveChange
		Thisform.PrintEnv.Printer = This.Value
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.Cancel()
		
	ENDPROC

	PROCEDURE cmdCancel.Refresh
		This.Caption = Thisform.i18n.text("PRINTER_SELECTION_CANCEL")
		
	ENDPROC

	PROCEDURE cmdOk.Click
		Thisform.Setup()
		
		
	ENDPROC

	PROCEDURE cmdOk.Refresh
		This.Caption = Thisform.i18n.text("PRINTER_SELECTION_OK")
		
	ENDPROC

	PROCEDURE lblPrinters.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PRINTER")
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_textbox AS textbox 		&& Pdfium-vfp Textbox. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: contextmenu
		*m: selectall
		*p: allow_lost_focus
		*p: changed		&& .T. on InteractiveChange
		*p: mousefocused		&& Focused by Click
		*p: prevvalue		&& Value on GotFocus event
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN allow_lost_focus
	PROTECTED changed,mousefocused,prevvalue
	*<PropValue>
		Alignment = 0
		allow_lost_focus = .T.
		changed = .F.
		EnableHyperlinks = .F.
		FontName = "Segoe UI"
		FontSize = 10
		Format = "K"
		Height = 27
		mousefocused = 0
		Name = "pdfium_textbox"
		prevvalue = 
		SelectOnEntry = .T.
		Width = 173
		_memberdata = <VFPData>
			<memberdata name="changed" type="property" display="Changed"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="mousefocused" type="property" display="MouseFocused"/>
			<memberdata name="prevvalue" type="property" display="PrevValue"/>
			<memberdata name="selectall" type="method" display="SelectAll"/>
			<memberdata name="allow_lost_focus" type="property" display="allow_lost_focus"/>
		</VFPData>
	*</PropValue>
	
	PROTECTED PROCEDURE contextmenu
		LOCAL lcMenuName
		m.lcMenuName = "_context_menu"
		
		DEFINE POPUP (m.lcMenuName) FROM MROW(), MCOL() MARGIN RELATIVE SHORTCUT FONT 'Segoe UI', 10
		
		LOCAL lcSelect, lcClipboard
		m.lcSelect = IIF(EMPTY(This.SelLength)=.T., "SKIP FOR .T.", "")
		m.lcClipboard = IIF(EMPTY(_CLIPTEXT)=.T., "SKIP FOR .T.", "")
		
		LOCAL i
		m.i=9000
		
		m.i=m.i+1
		DEFINE BAR (m.i) OF _context_menu PROMPT (Thisform.i18n.text("MNU_CUT")) PICTRES _MED_CUT  &lcSelect
		ON SELECTION BAR (m.i) OF _context_menu poThis.KeyPress(24,2)
		
		m.i=m.i+1
		DEFINE BAR (m.i) OF _context_menu PROMPT (Thisform.i18n.text("MNU_COPY")) PICTRES _MED_COPY &lcSelect
		ON SELECTION BAR (m.i) OF _context_menu poThis.KeyPress(3,2)
		
		DEFINE BAR _med_paste OF _context_menu PROMPT (Thisform.i18n.text("MNU_PASTE")) PICTRES _MED_PASTE &lcClipboard
		DEFINE BAR _med_slcta OF _context_menu PROMPT (Thisform.i18n.text("MNU_SLCTA"))
		DEFINE BAR _med_clear OF _context_menu PROMPT (Thisform.i18n.text("MNU_CLEAR")) &lcSelect
		
		RETURN m.lcMenuName
		
	ENDPROC

	PROCEDURE GotFocus
		DODEFAULT()
		
		This.PrevValue = This.Value
		
		IF This.SelectOnEntry
		    This.MouseFocused = MDOWN()
		    This.SelectAll()
		ENDIF
		
		
		This.allow_lost_focus = .T.
		
	ENDPROC

	PROCEDURE InteractiveChange
		This.Changed = .T.
		
		This.allow_lost_focus = .F.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode=44 AND VARTYPE(This.Value) = 'N'
		    KEYBOARD '.' PLAIN CLEAR
		ENDIF
		
		IF m.nKeyCode=3 AND m.nShiftAltCtrl=2
		    IF INLIST(VARTYPE(This.SelText),'C')
		        _cliptext = ALLTRIM(NVL(This.SelText,''))
		        NODEFAULT
		    ENDIF
		ENDIF
		
		IF m.nKeyCode=24 AND m.nShiftAltCtrl=2
		    IF INLIST(VARTYPE(This.SelText),'C')
		        _cliptext = ALLTRIM(NVL(This.SelText,''))
		        This.SelText = ''
		        NODEFAULT
		    ENDIF
		ENDIF
		
		
		IF INLIST(m.nKeyCode, 13, 27, 9)
		    This.allow_lost_focus = .T.
		ENDIF
		
	ENDPROC

	PROCEDURE LostFocus
		IF VARTYPE(This.Value)="C"
		    IF NOT (This.Value == ALLTRIM(This.Value,1,CHR(13),CHR(10)))
		        This.Value = ALLTRIM(This.Value,1,CHR(13),CHR(10))
		    ENDIF
		ENDIF
		
		*******************************************************
		LOCAL lcInvalidChars
		m.lcInvalidChars = ""
		LOCAL i
		FOR m.i=0x1 TO 0x1F
		    m.lcInvalidChars = m.lcInvalidChars + CHR(m.i)
		ENDFOR
		FOR m.i=0x7F TO 0x84
		    m.lcInvalidChars = m.lcInvalidChars + CHR(m.i)
		ENDFOR
		FOR m.i=0x86 TO 0x9F
		    m.lcInvalidChars = m.lcInvalidChars + CHR(m.i)
		ENDFOR
		
		IF VARTYPE(This.Value) = 'C'
		    IF NOT (This.Value == CHRTRAN(This.Value, m.lcInvalidChars, ''))
		        This.Value = CHRTRAN(This.Value, m.lcInvalidChars, '')
		    ENDIF    
		ENDIF
		*******************************************************
		
		#define VK_LBUTTON 0x01
		#define VK_RBUTTON 0x02
		IF This.allow_lost_focus = .F. AND This.SelStart+1 >= LEN(This.Text) AND NOT EMPTY(This.Value) AND NOT MDOWN() 
		    IF This.env.API_WIN.GetKeyState(VK_LBUTTON)>=0 AND This.env.API_WIN.GetKeyState(VK_RBUTTON)>=0 
		        This.SelStart = LEN(This.Text)
		        NODEFAULT
		        RETURN
		    ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.SelectOnEntry
		    IF This.SelLength <> 0 AND This.MouseFocused
		        NODEFAULT
		    ENDIF
		ENDIF
		This.MouseFocused = .F.
		
	ENDPROC

	PROCEDURE RightClick
		LOCAL lcMenuName
		m.lcMenuName = This.ContextMenu()
		
		PRIVATE poThis
		m.poThis = This
		IF CNTBAR(m.lcMenuName)<>0
		    ACTIVATE POPUP &lcMenuName
		ENDIF
		m.poThis = NULL
		
		
	ENDPROC

	PROCEDURE selectall
		This.SelStart = 0
		This.SelLength = 255
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_uistate AS custom 		&& UI states handling (visible, enable) respecting PageFrames. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: geteffectivelyenabled
		*m: geteffectivelyvisible
		*m: getispageframe
		*m: objtoclient
		*m: onenabled
		*m: onvisible
		*m: setstate
		*m: _onactivate
		*m: _ondeactivate
		*m: _onenabled
		*m: _onvisible
		*p: effectivelyenabled
		*p: effectivelyvisible
		*p: ispageframe
		*p: _ispagedeactivated
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,effectivelyenabled,effectivelyvisible,Error,Height,HelpContextID,ispageframe,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod,_ispagedeactivated
	*<PropValue>
		effectivelyenabled = .F.
		effectivelyvisible = .F.
		Height = 24
		ispageframe = .F.
		Name = "pdfium_uistate"
		Tag = ""
		Width = 37
		_ispagedeactivated = .F.
		_memberdata = <VFPData>
			<memberdata name="objtoclient" display="ObjToClient"/>
			<memberdata name="addobject" display="AddObject"/>
			<memberdata name="writemethod" display="WriteMethod"/>
			<memberdata name="writeexpression" display="WriteExpression"/>
			<memberdata name="whatsthishelpid" display="WhatsThisHelpID"/>
			<memberdata name="tag" display="Tag"/>
			<memberdata name="showwhatsthis" display="ShowWhatsThis"/>
			<memberdata name="saveasclass" display="SaveAsClass"/>
			<memberdata name="resettodefault" display="ResetToDefault"/>
			<memberdata name="removeobject" display="RemoveObject"/>
			<memberdata name="readmethod" display="ReadMethod"/>
			<memberdata name="readexpression" display="ReadExpression"/>
			<memberdata name="picture" display="Picture"/>
			<memberdata name="parentclass" display="ParentClass"/>
			<memberdata name="parent" display="Parent"/>
			<memberdata name="objects" display="Objects"/>
			<memberdata name="newobject" display="Newobject"/>
			<memberdata name="helpcontextid" display="HelpContextID"/>
			<memberdata name="error" display="Error"/>
			<memberdata name="controls" display="Controls"/>
			<memberdata name="classlibrary" display="ClassLibrary"/>
			<memberdata name="addproperty" display="AddProperty"/>
			<memberdata name="setstate" display="SetState"/>
			<memberdata name="effectivelyenabled" display="EffectivelyEnabled"/>
			<memberdata name="effectivelyvisible" display="EffectivelyVisible"/>
			<memberdata name="geteffectivelyenabled" display="GetEffectivelyEnabled"/>
			<memberdata name="geteffectivelyvisible" display="GetEffectivelyVisible"/>
			<memberdata name="ispageframe" display="IsPageFrame"/>
			<memberdata name="getispageframe" display="GetIsPageFrame"/>
			<memberdata name="onenabled" display="OnEnabled"/>
			<memberdata name="onvisible" display="OnVisible"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE Destroy
		UNBINDEVENTS(This)
		
	ENDPROC

	PROCEDURE geteffectivelyenabled
		RETURN This.EffectivelyEnabled
		
	ENDPROC

	PROCEDURE geteffectivelyvisible
		RETURN This.EffectivelyVisible
		
	ENDPROC

	PROCEDURE getispageframe
		RETURN This.IsPageFrame
		
	ENDPROC

	PROCEDURE Init
		LOCAL loControl
		m.loControl = This.Parent
		
		This.IsPageFrame = .F.
		
		BINDEVENT(m.loControl, "Visible", This, "_OnVisible",1)
		BINDEVENT(m.loControl, "Enabled", This, "_OnEnabled",1)
		
		DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		    IF UPPER(m.loControl.BASECLASS) == [PAGE] THEN
		        This.IsPageFrame = .T.
		
		        BINDEVENT(m.loControl, "Activate", This, "_OnActivate",1)
		        BINDEVENT(m.loControl, "Deactivate", This, "_OnDeactivate",1)
		        BINDEVENT(m.loControl, "Enabled", This, "_OnEnabled",1)
		        BINDEVENT(m.loControl.Parent, "Visible", This, "_OnVisible",1)
		        BINDEVENT(m.loControl.Parent, "Enabled", This, "_OnEnabled",1)
		    ENDIF
		    m.loControl = m.loControl.PARENT
		ENDDO
		
		This.SetState()
		
	ENDPROC

	PROCEDURE objtoclient
		*********************************************************************
		** Copied from GDPIPlusX xfcBitmap.ObjToClientEx
		**
		** This replaces OBJTOCLIENT that has bugs with pageframes and SP2
		*********************************************************************
		LPARAMETERS tnType 
		
		* tnType:  1 = Top  2 = Left
		
		
		IF This.GetIsPageframe() = .F.
		    RETURN OBJTOCLIENT(This.Parent, m.tnType)
		ENDIF
		
		LOCAL loControl
		m.loControl = This.Parent
		
		
		*!* TabOrientation parameters
		#DEFINE CON_TABOR_TOP    0
		#DEFINE CON_TABOR_BOTTOM 1
		#DEFINE CON_TABOR_LEFT   2
		#DEFINE CON_TABOR_RIGHT  3
		
		LOCAL lnPosition AS INTEGER
		m.lnPosition = 0
		
		DO CASE
		
		CASE m.tnType = 1 && Top
		    DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		        IF PEMSTATUS(m.loControl, [Top],5) THEN && Defined Property
		            m.lnPosition = m.lnPosition + m.loControl.TOP
		        ENDIF
		        IF UPPER(m.loControl.BASECLASS) == [PAGE] THEN
		            IF m.loControl.PARENT.TABORIENTATION = CON_TABOR_TOP THEN    && Top
		                m.lnPosition = m.lnPosition + ;
		                    m.loControl.PARENT.HEIGHT - ;
		                    m.loControl.PARENT.PAGEHEIGHT - ;
		                    m.loControl.PARENT.BORDERWIDTH * 2
		            ELSE
		                m.lnPosition = m.lnPosition + 1
		            ENDIF
		        ENDIF
		        m.loControl = m.loControl.PARENT
		    ENDDO
		
		CASE m.tnType = 2 && Left
		    DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		        IF PEMSTATUS(m.loControl, [Left], 5) THEN && Defined Property
		            m.lnPosition = m.lnPosition + m.loControl.LEFT
		        ENDIF
		        IF UPPER(m.loControl.BASECLASS) == [PAGE]
		            IF m.loControl.PARENT.TABORIENTATION = CON_TABOR_LEFT THEN    && Left
		                m.lnPosition = m.lnPosition + ;
		                    m.loControl.PARENT.WIDTH - ;
		                    m.loControl.PARENT.PAGEWIDTH - ;
		                    m.loControl.PARENT.BORDERWIDTH * 2
		            ELSE
		                m.lnPosition = m.lnPosition + 1
		            ENDIF
		        ENDIF
		        m.loControl = m.loControl.PARENT
		    ENDDO
		
		ENDCASE
		
		RETURN m.lnPosition
		
	ENDPROC

	PROCEDURE onenabled
	ENDPROC

	PROCEDURE onvisible
	ENDPROC

	HIDDEN PROCEDURE setstate
		LOCAL loControl
		m.loControl = This.Parent
		
		
		LOCAL llPrevVisible, llPrevEnabled
		m.llPrevVisible = This.EffectivelyVisible
		m.llPrevEnabled = This.EffectivelyEnabled
		
		This.EffectivelyVisible = m.loControl.Visible
		This.EffectivelyEnabled = m.loControl.Enabled
		
		
		IF This._IsPageDeactivated
		    This.EffectivelyVisible = .F.
		ENDIF
		
		DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		    IF UPPER(m.loControl.BASECLASS) == [PAGE] THEN
		        IF m.loControl.Enabled = .F.
		            This.EffectivelyEnabled = .F.
		        ENDIF
		       IF m.loControl.Parent.Enabled = .F.
		            This.EffectivelyEnabled = .F.
		        ENDIF
		
		        IF m.loControl.Parent.Visible = .F.
		            This.EffectivelyVisible = .F.
		        ENDIF
		        
		        IF BETWEEN(m.loControl.Parent.ActivePage, 1, m.loControl.Parent.PageCount)
		            IF m.loControl.Parent.Pages(m.loControl.Parent.ActivePage) != m.loControl
		                This.EffectivelyVisible = .F.
		            ENDIF
		        ENDIF
		    ENDIF
		    m.loControl = m.loControl.PARENT
		ENDDO
		
		DO CASE
		CASE m.llPrevVisible <> This.EffectivelyVisible
		    This.OnVisible()
		CASE m.llPrevEnabled <> This.EffectivelyEnabled
		    This.OnEnabled()
		ENDCASE
		
	ENDPROC

	PROCEDURE _onactivate
		This.SetState()
		
	ENDPROC

	PROCEDURE _ondeactivate
		This._IsPageDeactivated = .T.
		This.SetState()
		This._IsPageDeactivated = .F.
		
		
	ENDPROC

	PROCEDURE _onenabled
		LPARAMETERS tlEnabled
		This.SetState()
		
	ENDPROC

	PROCEDURE _onvisible
		LPARAMETERS tlVisible
		This.SetState()
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport AS reportlistener 		&& Report listener with integrated report preview based on PdfiumViewer control
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: batchbegin
		*m: batchend
		*m: errlogshow
		*m: errmsg
		*m: finalize
		*m: fontsrelease
		*m: gdipprivatefontsload
		*m: gdipprivatefontsrelease
		*m: getfont
		*m: getfontsubset
		*m: getrenderer		&& Get current renderer object. Not an object return value means that default pdfiumreport_renderer_pdf is used
		*m: printenvdefault_access
		*m: printenvdefault_assign
		*m: printenv_access
		*m: printenv_assign
		*m: process_frxdynamics
		*m: process_frxheader
		*m: process_frxpicture
		*m: runrenderer		&& Runs report rendering with specified renderer object (subclass of pdfiumreport_renderer_base). Returns path to the temporary file containing rendering output results or empty string if there is nothing to render. Temp file must be deleted by  a caller
		*m: saveas_pdfmeta_access
		*m: saveas_pdfmeta_assign
		*m: setrenderer		&& Sets renderer object (subclass of pdfiumreport_renderer_base). If not an object value is passed then default pdfiumreport_renderer_pdf is used
		*p: batchmode
		*p: batchmodeauto		&& .T. if report was created by  _REPORTOUTPUT (= PdfiumReport.app)  and NOPAGEEJECT was set
		*p: batchpagecount		&& Total page count of a batch
		*p: env		&& pdfium_env object
		*p: errlog
		*p: ext_func_getfiledata		&& User's function name with signature String (String). That accepts the filename at return file data. Example: return FILETOSTR(m.cFileName) where cFileName is the function's parameter
		*p: fonts
		*p: fontsubset
		*p: gdipprivatefontshandle
		*p: printenv		&& Print configuration state (pdfium_print_env object). ; Read-only; Overrides default print settings when report is printed from preview window or by TO PRINTER clause with This.ToPrinterNative=.T.
		*p: printenvdefault
		*p: renderer		&& User set renderer object  (subclass of pdfiumreport_renderer_base). If not an object then default pdfiumreport_renderer_pdf is used
		*p: repobj
		*p: repobjcursor
		*p: repobjdynamicscursor
		*p: rep_offsetx
		*p: rep_offsety
		*p: rep_pagecount
		*p: rep_wholepage
		*p: saveas_filename		&& Filename suggestion for "save as" dialog
		*p: saveas_pdfmeta		&& Pdfium_pdfmeta object; Output PDF metadata + encryption (password) and reader permissions
		*p: screengfx
		*p: toprinternative		&& TO PRINTER clause handing mode:: .T. - report is printed by VFP (PdfiumReport does nothing) ; .F. (default) - report is printed by PdfiumReport (renders report to PDF and prints PDF)
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _printenv		&& Print configuration state (pdfium_print_env object)
		*p: _printenvdefault
		*p: _saveas_pdfmeta
	*</DefinedPropArrayMethod>

	HIDDEN batchmodeauto,batchmode,batchpagecount,env,errlog,fontsubset,fonts,gdipprivatefontshandle,renderer,repobjcursor,repobjdynamicscursor,repobj,rep_offsetx,rep_offsety,rep_pagecount,rep_wholepage,screengfx,_printenvdefault,_printenv,_saveas_pdfmeta
	*<PropValue>
		AllowModalMessages = .T.
		batchmode = .F.
		batchmodeauto = .F.
		batchpagecount = 0
		DynamicLineHeight = .F.
		env = .F.
		errlog = ("")
		ext_func_getfiledata = ("")
		fonts = .F.
		fontsubset = .F.
		FRXDataSession = 0
		gdipprivatefontshandle = 0
		Height = 23
		ListenerType = -1
		Name = "pdfiumreport"
		printenv = .F.
		printenvdefault = .F.
		QuietMode = .F.
		renderer = .F.
		repobj = .F.
		repobjcursor = ("")
		repobjdynamicscursor = ("")
		rep_offsetx = 0
		rep_offsety = 0
		rep_pagecount = 0
		rep_wholepage = .F.
		saveas_filename = ("")
		saveas_pdfmeta = .F.
		screengfx = .F.
		SendGDIPlusImage = 1
		toprinternative = .F.
		TwoPassProcess = .T.
		Width = 23
		_memberdata = <VFPData>
			<memberdata name="env" type="property" display="env"/>
			<memberdata name="errlog" type="property" display="ErrLog"/>
			<memberdata name="errlogshow" type="method" display="ErrLogShow"/>
			<memberdata name="errmsg" type="method" display="ErrMsg"/>
			<memberdata name="finalize" type="method" display="Finalize"/>
			<memberdata name="batchbegin" type="method" display="BatchBegin"/>
			<memberdata name="batchend" type="method" display="BatchEnd"/>
			<memberdata name="batchmode" type="property" display="BatchMode"/>
			<memberdata name="batchmodeauto" type="property" display="BatchModeAuto"/>
			<memberdata name="saveas_filename" type="property" display="SaveAs_Filename"/>
			<memberdata name="printenv" type="property" display="PrintEnv"/>
			<memberdata name="printenv_access" type="method" display="PrintEnv_Access"/>
			<memberdata name="printenv_assign" type="method" display="PrintEnv_Assign"/>
			<memberdata name="_printenv" type="property" display="_PrintEnv"/>
			<memberdata name="printenvdefault" type="property" display="PrintEnvDefault"/>
			<memberdata name="printenvdefault_access" type="method" display="PrintEnvDefault_Access"/>
			<memberdata name="printenvdefault_assign" type="method" display="PrintEnvDefault_Assign"/>
			<memberdata name="_printenvdefault" type="property" display="_PrintEnvDefault"/>
			<memberdata name="toprinternative" type="property" display="ToPrinterNative"/>
			<memberdata name="saveas_pdfmeta" type="property" display="SaveAs_PDFMeta"/>
			<memberdata name="saveas_pdfmeta_access" type="method" display="SaveAs_PDFMeta_Access"/>
			<memberdata name="saveas_pdfmeta_assign" type="method" display="SaveAs_PDFMeta_Assign"/>
			<memberdata name="_saveas_pdfmeta" type="property" display="_SaveAs_PDFMeta"/>
			<memberdata name="ext_func_getfiledata" type="method" display="Ext_Func_GetFileData"/>
			<memberdata name="renderer" type="property" display="Renderer"/>
			<memberdata name="fonts" type="property" display="Fonts"/>
			<memberdata name="getfont" type="method" display="GetFont"/>
			<memberdata name="screengfx" type="property" display="ScreenGfx"/>
			<memberdata name="process_frxdynamics" type="method" display="Process_FrxDynamics"/>
			<memberdata name="process_frxheader" type="method" display="Process_FrxHeader"/>
			<memberdata name="process_frxpicture" type="method" display="Process_FrxPicture"/>
			<memberdata name="rep_offsetx" type="property" display="Rep_OffsetX"/>
			<memberdata name="rep_offsety" type="property" display="Rep_OffsetY"/>
			<memberdata name="rep_pagecount" type="property" display="Rep_PageCount"/>
			<memberdata name="rep_wholepage" type="property" display="Rep_WholePage"/>
			<memberdata name="gdipprivatefontshandle" type="property" display="GdipPrivateFontsHandle"/>
			<memberdata name="gdipprivatefontsload" type="method" display="GdipPrivateFontsLoad"/>
			<memberdata name="gdipprivatefontsrelease" type="method" display="GdipPrivateFontsRelease"/>
			<memberdata name="batchpagecount" type="property" display="BatchPageCount"/>
			<memberdata name="fontsrelease" type="method" display="FontsRelease"/>
			<memberdata name="fontsubset" type="property" display="FontSubset"/>
			<memberdata name="getfontsubset" type="method" display="GetFontSubset"/>
			<memberdata name="setrenderer" type="method" display="SetRenderer"/>
			<memberdata name="runrenderer" type="method" display="RunRenderer"/>
			<memberdata name="repobjcursor" type="property" display="RepObjCursor"/>
			<memberdata name="repobjdynamicscursor" type="property" display="RepObjDynamicsCursor"/>
			<memberdata name="repobj" type="property" display="RepObj"/>
			<memberdata name="getrenderer" type="method" display="GetRenderer"/>
		</VFPData>
		_printenv = .F.
		_printenvdefault = .F.
		_saveas_pdfmeta = .F.
	*</PropValue>
	
	PROCEDURE batchbegin
		This.BatchMode = .T.
		This.BatchPageCount = 0
		
		
	ENDPROC

	PROCEDURE batchend
		IF This.BatchMode = .F.
		    RETURN
		ENDIF
		
		This.Finalize()
		
		This.BatchMode = .F.
		
	ENDPROC

	PROCEDURE Destroy
		IF VARTYPE(This.env) = "O"
		    This.FontsRelease()
		    This.GdipPrivateFontsRelease()
		
		    IF EMPTY(This.ScreenGfx) = .F.
		        This.env.API_GDIP.GdipDeleteGraphics(This.ScreenGfx)
		    ENDIF
		ENDIF
		
		This.env = .F.
		This._PrintEnv = .F.
		This._PrintEnvDefault = .F.
		This.Fonts = .F.
		This.FontSubset = .F.
		This.ScreenGfx = 0
		
		This.RepObj = .F.
		
		IF EMPTY(This.RepObjCursor) = .F. AND USED(This.RepObjCursor)
		    USE IN (This.RepObjCursor)
		ENDIF
		This.RepObjCursor = ""
		
		IF EMPTY(This.RepObjDynamicsCursor) = .F. AND USED(This.RepObjDynamicsCursor)
		    USE IN (This.RepObjDynamicsCursor)
		ENDIF
		This.RepObjDynamicsCursor = ""
		
		This._SaveAs_PDFMeta = .F.
		
		This.PreviewContainer = NULL
		This.Renderer = .F.
		
	ENDPROC

	HIDDEN PROCEDURE errlogshow
		IF EMPTY(This.errLog)
		    RETURN
		ENDIF
		
		IF This.QuietMode
		    RETURN
		ENDIF
		
		IF This.AllowModalMessages
		    This.DoMessage(LEFT(This.errLog, 500), 0+48, This.Class + " ("+This.ClassLibrary+")")
		ELSE
		    This.DoStatus(LEFT(This.errLog, 250))
		ENDIF
		
		This.errLog = ""
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		m.lcMsg = This.env.ErrFmt(m.tvMsg)
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		This.errLog = LEFT(IIF(EMPTY(This.errLog), "", This.errLog + CHR(13) + CHR(13)) + m.lcMsg, 10000)
		
	ENDPROC

	HIDDEN PROCEDURE finalize
		
		LOCAL lSaveSafety
		m.lSaveSafety = SET("Safety")
		
		LOCAL lcTempFileName
		m.lcTempFileName = ""
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    SET SAFETY OFF
		
		    IF This.BatchPageCount = 0
		        EXIT
		    ENDIF
		        
		    IF This.CommandClauses.OUTPUTTO = This.env.API_FRX.CONST.OUTPUTTO_PRINTER() AND This.ToPrinterNative = .T. && VFP native output to the printer, do nothing
		        EXIT
		    ENDIF
		
		    IF This.CommandClauses.PREVIEW = .F. AND ;
		       INLIST(This.CommandClauses.OUTPUTTO,This.env.API_FRX.CONST.OUTPUTTO_PRINTER(),This.env.API_FRX.CONST.OUTPUTTO_FILE())=.F. 
		
		        ** not preview or output to the printer or to the file
		        EXIT
		    ENDIF
		
		
		    *************************************************
		    * Rendering report in renderer specific format
		    *************************************************
		    LOCAL loRenderer
		    m.loRenderer = This.Renderer
		    IF VARTYPE(m.loRenderer) <> "O"
		        m.loRenderer = NEWOBJECT("PdfiumReport_renderer_pdf", This.ClassLibrary, "", This.env)
		    ENDIF
		
		    m.lcTempFileName = This.RunRenderer(m.loRenderer)
		
		    IF FILE(m.lcTempFileName,1) = .F.
		        EXIT
		    ENDIF
		    *************************************************
		    
		    LOCAL llPreview
		    m.llPreview = (This.CommandClauses.PREVIEW OR This.CommandClauses.ISDESIGNERLOADED)
		
		    DO CASE
		    CASE This.CommandClauses.OUTPUTTO = This.env.API_FRX.CONST.OUTPUTTO_FILE() && output to the file
		        IF EMPTY(This.CommandClauses.TOFILE) = .F.
		            COPY FILE (m.lcTempFileName) TO (This.CommandClauses.TOFILE)
		        ENDIF
		        
		    CASE NOT (LOWER(m.loRenderer.Class) == "pdfiumreport_renderer_pdf")
		        LOCAL lcOutputFileName
		        m.lcOutputFileName = ALLTRIM(This.SaveAs_Filename)
		        m.lcOutputFileName = IIF(EMPTY(m.lcOutputFileName), "", FORCEEXT(m.lcOutputFileName, LTRIM(m.loRenderer.GetFileExtension(),1,' ', '.')))
		        m.lcOutputFileName = This.env.GetSaveFileName(m.lcOutputFileName, LTRIM(m.loRenderer.GetFileExtension(),1,' ', '.'))
		        IF EMPTY(m.lcOutputFileName) = .F.
		            COPY FILE (m.lcTempFileName) TO (m.lcOutputFileName)
		            IF m.llPreview
		                This.env.API_Win.ShellExecute(0, "Open", FULLPATH(m.lcOutputFileName), NULL, SYS(2023), 1)
		            ENDIF
		        ENDIF
		
		    CASE This.CommandClauses.OUTPUTTO = This.env.API_FRX.CONST.OUTPUTTO_PRINTER() AND This.CommandClauses.ISDESIGNERLOADED = .F. && output to the printer
		        This.PreviewContainer = NEWOBJECT("PdfiumReportViewer", This.ClassLibrary, "", This.env, This.PrintEnv)
		        This.PreviewContainer.SetReport(This)
		        This.PreviewContainer.OpenPDF(m.lcTempFileName, This.SaveAs_PDFMeta.UserPassword)
		
		        IF This.CommandClauses.PROMPT
		            This.PreviewContainer.Show()
		        ENDIF
		        
		        This.PreviewContainer.PrintReport()
		    
		    
		    CASE m.llPreview 
		        This.PreviewContainer = NEWOBJECT("PdfiumReportViewer", This.ClassLibrary, "", This.env, This.PrintEnv)
		        This.PreviewContainer.SetReport(This)
		        This.PreviewContainer.OpenPDF(m.lcTempFileName, This.SaveAs_PDFMeta.UserPassword)
		        This.PreviewContainer.SaveAs_Filename = EVL(NVL(This.SaveAs_Filename,""),"")
		        This.PreviewContainer.Show(1)
		    
		    ENDCASE
		
		
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		    This.errLogShow()
		
		FINALLY
		
		    SET SAFETY &lSaveSafety
		    
		    TRY
		        IF FILE(m.lcTempFileName,1)
		            DELETE FILE (m.lcTempFileName)
		        ENDIF
		    CATCH
		    ENDTRY
		    
		    This.RepObj = .F.
		
		    IF EMPTY(This.RepObjCursor) = .F. AND USED(This.RepObjCursor)
		        USE IN (This.RepObjCursor)
		    ENDIF
		    This.RepObjCursor = ""
		
		    IF EMPTY(This.RepObjDynamicsCursor) = .F. AND USED(This.RepObjDynamicsCursor)
		        USE IN (This.RepObjDynamicsCursor)
		    ENDIF
		    This.RepObjDynamicsCursor = ""
		
		    This.PreviewContainer = NULL
		    
		    This._PrintEnv = .F.
		
		    This.FontsRelease()
		    This.GdipPrivateFontsRelease()
		
		    
		ENDTRY
		
		
	ENDPROC

	HIDDEN PROCEDURE fontsrelease
		LOCAL loFont
		FOR EACH m.loFont IN This.Fonts FOXOBJECT
		    IF VARTYPE(m.loFont) <> "O"
		        LOOP
		    ENDIF
		    
		    IF EMPTY(m.loFont.GdipFont) = .F.
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipDeleteFont(m.loFont.GdipFont))
		        m.loFont.GdipFont = 0
		    ENDIF
		
		    IF EMPTY(m.loFont.GdipFontFamily) = .F.
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipDeleteFontFamily(m.loFont.GdipFontFamily))
		        m.loFont.GdipFontFamily = 0
		    ENDIF
		
		ENDFOR
		
		This.Fonts.Remove(-1)
		This.FontSubset.Remove(-1)
		
	ENDPROC

	HIDDEN PROCEDURE gdipprivatefontsload
		This.GdipPrivateFontsRelease()
		
		IF This.env.PrivateFonts.Count = 0
		    RETURN
		ENDIF
		
		LOCAL lhPrivateFontCollection
		m.lhPrivateFontCollection = 0
		
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipNewPrivateFontCollection(@m.lhPrivateFontCollection))
		
		IF EMPTY(m.lhPrivateFontCollection)
		    RETURN
		ENDIF
		
		This.GdipPrivateFontsHandle = m.lhPrivateFontCollection
		
		LOCAL lcFontPath
		m.lcFontPath = ""
		FOR EACH m.lcFontPath IN This.env.PrivateFonts FOXOBJECT
		
		    IF FILE(ALLTRIM(m.lcFontPath),1)
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipPrivateAddFontFile(This.GdipPrivateFontsHandle, STRCONV(ALLTRIM(m.lcFontPath),5) + CHR(0)))
		    ENDIF
		    
		ENDFOR
		
	ENDPROC

	HIDDEN PROCEDURE gdipprivatefontsrelease
		
		IF EMPTY(NVL(This.GdipPrivateFontsHandle,0)) = .F.
		    LOCAL lhPrivateFontCollection
		    m.lhPrivateFontCollection = This.GdipPrivateFontsHandle
		    
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipDeletePrivateFontCollection(@m.lhPrivateFontCollection))
		ENDIF
		
		This.GdipPrivateFontsHandle = 0
		
	ENDPROC

	HIDDEN PROCEDURE getfont
		LPARAMETERS loRepObj
		
		LOCAL lcFontID
		m.lcFontID = m.loRepObj.FontFace
		m.lcFontID = m.lcFontID + "<"+TRANSFORM(m.loRepObj.FontSize)+">"
		IF m.loRepObj.FontBold
		    m.lcFontID = m.lcFontID + "<B>"
		ENDIF
		IF m.loRepObj.FontItalic
		    m.lcFontID = m.lcFontID + "<I>"
		ENDIF
		IF m.loRepObj.FontUnderline
		    m.lcFontID = m.lcFontID + "<U>"
		ENDIF
		IF m.loRepObj.FontStrikeout
		    m.lcFontID = m.lcFontID + "<S>"
		ENDIF
		m.lcFontID = m.lcFontID + "<"+TRANSFORM(m.loRepObj.FontCharset)+">"
		
		***********************************************************
		* Font has been found
		***********************************************************
		LOCAL lnFontIndex
		m.lnFontIndex = This.Fonts.GetKey(m.lcFontID)
		IF m.lnFontIndex > 0
		    RETURN This.Fonts[m.lnFontIndex]
		ENDIF
		***********************************************************
		
		***********************************************************
		* Font hasn't been found, create it
		***********************************************************
		LOCAL llFontPrivate
		m.llFontPrivate = .F.
		
		LOCAL lhGdipFont, lhGdipFontFamily, liFont
		STORE 0 TO m.lhGdipFont, m.lhGdipFontFamily
		m.liFont = 1
		
		FOR m.liFont = 1 TO 3
		    
		    DO CASE
		    CASE m.liFont = 1
		        m.lhGdipFontFamily = 0
		        
		        IF This.env.API_GDIP.GdipCreateFontFamilyFromName(STRCONV(m.loRepObj.FontFace,5) + CHR(0), 0, @m.lhGdipFontFamily) != 0
		            m.lhGdipFontFamily = 0
		        ENDIF
		        
		    CASE m.liFont = 2
		        
		        m.lhGdipFontFamily = 0
		        
		        IF This.env.API_GDIP.GdipCreateFontFamilyFromName(STRCONV(m.loRepObj.FontFace,5) + CHR(0), This.GdipPrivateFontsHandle, @m.lhGdipFontFamily) != 0
		            m.lhGdipFontFamily = 0
		        ENDIF
		        
		        IF EMPTY(m.lhGdipFontFamily) = .F.
		            m.llFontPrivate = .T.
		        ENDIF
		        
		            
		    OTHERWISE && If report font is not found, take fallback font
		
		        m.lhGdipFontFamily = 0
		        
		        IF This.env.API_GDIP.GdipGetGenericFontFamilySansSerif(@m.lhGdipFontFamily) != 0
		            m.lhGdipFontFamily = 0
		        ENDIF
		
		    ENDCASE
		    
		
		    IF EMPTY(m.lhGdipFontFamily) = .T.
		        LOOP
		    ENDIF
		    
		    m.lhGdipFont = 0
		    
		    IF This.env.API_GDIP.GdipCreateFont( ;
		        m.lhGdipFontFamily, ;
		        m.loRepObj.FontSize, ;
		        ( ;
		            IIF(m.loRepObj.FontBold, This.env.API_GDIP.CONST.Gdip_FontStyleBold(), 0) + ;
		            IIF(m.loRepObj.FontItalic, This.env.API_GDIP.CONST.Gdip_FontStyleItalic(), 0) + ; 
		            IIF(m.loRepObj.FontUnderline, This.env.API_GDIP.CONST.Gdip_FontStyleUnderline(), 0) + ;
		            IIF(m.loRepObj.FontStrikeout, This.env.API_GDIP.CONST.Gdip_FontStyleStrikeout(), 0) ;
		        ),;
		        This.env.API_GDIP.CONST.Gdip_UnitPoint(), ;
		        @m.lhGdipFont) != 0
		    
		        m.lhGdipFont = 0
		        
		    ENDIF
		
		    IF EMPTY(m.lhGdipFont) = .F.
		        EXIT
		    ENDIF
		    
		ENDFOR
		***********************************************************
		
		IF EMPTY(m.lhGdipFont) = .T.
		    THROW TEXTMERGE("Error on creation GDI+ Font for the font face <<m.loRepObj.FontFace>>")
		ENDIF
		
		LOCAL lcFontFamilyNameUnicode, lcFontFamilyName
		m.lcFontFamilyNameUnicode = ""
		m.lcFontFamilyName = ""
		
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetFamilyName(m.lhGdipFontFamily, @m.lcFontFamilyNameUnicode, 0))
		
		m.lcFontFamilyName = RTRIM(STRCONV(m.lcFontFamilyNameUnicode, 6), 1, CHR(0), " ")
		
		
		***********************************************************
		* Font filename and simulations
		***********************************************************
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL llFontFileFound, lcFontFileName
		m.llFontFileFound = .F.
		m.lcFontFileName = ""
		
		LOCAL lnBoldSimulation, lnItalicSimulation
		STORE 0 TO m.lnBoldSimulation, m.lnItalicSimulation
		
		LOCAL lnIsSymbolFont
		m.lnIsSymbolFont = 0
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    
		    m.lcFontFileName = REPLICATE(CHR(0),255*2)
		
		    LOCAL lnGetFont
		    m.lnGetFont = m.loFPDF.VFPDF_GetFontFileName( ;
		                    m.lcFontFamilyNameUnicode+CHR(0), ;
		                    IIF(m.loRepObj.FontBold,1,0), ;
		                    IIF(m.loRepObj.FontItalic,1,0), ;
		                    m.loRepObj.FontCharset, ;
		                    @m.lcFontFileName, ;
		                    LEN(m.lcFontFileName), ;
		                    @m.lnBoldSimulation, ;
		                    @m.lnItalicSimulation, ;
		                    @m.lnIsSymbolFont)
		                    
		    IF m.lnGetFont = 1
		        m.lcFontFileName = STRCONV(m.lcFontFileName,6)
		        m.lcFontFileName = ALLTRIM(m.lcFontFileName, 1, CHR(0), " ")
		        m.llFontFileFound = FILE(m.lcFontFileName)
		    ENDIF
		    
		    IF m.llFontFileFound = .F.
		        * Font is not found
		        
		        * Private font collection searching
		        LOCAL lnPrivateFontKey
		        m.lnPrivateFontKey = This.env.PrivateFonts.GetKey(m.lcFontFamilyName) 
		        IF EMPTY(m.lnPrivateFontKey)
		            EXIT
		        ENDIF
		  
		        m.lcFontFileName = ALLTRIM(This.env.PrivateFonts.Item(m.lnPrivateFontKey))
		
		        m.llFontFileFound = FILE(m.lcFontFileName)
		        
		        m.lnIsSymbolFont = INLIST(m.loRepObj.FontCharset, 2)
		        m.lnBoldSimulation = 1
		        m.lnItalicSimulation = 1
		        
		        IF EMPTY(m.lhGdipFontFamily) = .F.
		            IF This.env.API_GDIP.GdipIsStyleAvailable(m.lhGdipFontFamily, This.env.API_GDIP.CONST.Gdip_FontStyleBold(), @m.lnBoldSimulation) != 0
		                m.lnBoldSimulation = 0
		            ENDIF
		            m.lnBoldSimulation = IIF(m.lnBoldSimulation = 1, 0, 1)
		
		
		            IF This.env.API_GDIP.GdipIsStyleAvailable(m.lhGdipFontFamily, This.env.API_GDIP.CONST.Gdip_FontStyleItalic(), @m.lnItalicSimulation) != 0
		                m.lnItalicSimulation = 0
		            ENDIF
		            m.lnItalicSimulation = IIF(m.lnItalicSimulation = 1, 0, 1)
		
		        ENDIF
		
		    ENDIF
		
		CATCH TO m.loErr
		    m.llFontFileFound = .F.
		
		    This.ErrMsg(m.loErr)
		
		FINALLY
		    IF m.llFontFileFound = .F.
		        m.lcFontFileName = ""
		        m.lnBoldSimulation = 0
		        m.lnItalicSimulation = 0
		        m.lnIsSymbolFont = 0
		    ENDIF
		ENDTRY
		***********************************************************
		
		
		
		LOCAL loFont as PdfiumReport_repfont OF pdfium-vfp.vcx
		m.loFont = NEWOBJECT("PdfiumReport_repfont", This.ClassLibrary)
		
		m.loFont.GdipFont = m.lhGdipFont
		m.loFont.GdipFontFamily = m.lhGdipFontFamily
		m.loFont.FontPrivate = m.llFontPrivate
		m.loFont.FontFace = m.lcFontFamilyName
		
		
		LOCAL lnFontHeight
		m.lnFontHeight = 0
		
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetFontHeightGivenDPI(m.lhGdipFont, 96, @m.lnFontHeight))
		
		m.loFont.FontSize = m.loRepObj.FontSize
		m.loFont.FontHeight = MAX(m.lnFontHeight, 0)
		m.loFont.FontHeightCeil = CEILING(m.loFont.FontHeight)
		
		m.loFont.LineHeight = m.loFont.FontHeight
		
		
		
		LOCAL lnCellDescent, lnCellAscent, lnLineSpacing, lnEmHeight
		
		m.lnCellDescent = 0
		IF This.env.API_GDIP.GdipGetCellDescent(m.lhGdipFontFamily, 0, @m.lnCellDescent) != 0
		    m.lnCellDescent = 0
		ENDIF
		
		
		m.lnCellAscent = 0
		IF This.env.API_GDIP.GdipGetCellAscent(m.lhGdipFontFamily, 0, @m.lnCellAscent) != 0
		    m.lnCellAscent = 0
		ENDIF
		
		m.lnLineSpacing = 0
		IF This.env.API_GDIP.GdipGetLineSpacing(m.lhGdipFontFamily, 0, @m.lnLineSpacing) != 0
		    m.lnLineSpacing = 0
		ENDIF
		
		
		m.lnEmHeight = 0
		IF This.env.API_GDIP.GdipGetEmHeight(m.lhGdipFontFamily, 0, @m.lnEmHeight) != 0
		    m.lnEmHeight = 0
		ENDIF
		
		IF EMPTY(m.lnEmHeight) = .F.
		    m.loFont.FontDescent = m.loFont.LineHeight * m.lnCellDescent / m.lnEmHeight
		    m.loFont.FontAscent = m.loFont.LineHeight * m.lnCellAscent / m.lnEmHeight
		    m.loFont.LineSpacing = m.loFont.LineHeight * m.lnLineSpacing / m.lnEmHeight
		ELSE
		    m.loFont.FontDescent = 0
		    m.loFont.FontAscent = 0
		    m.loFont.LineSpacing = 0
		ENDIF
		
		
		
		m.loFont.FontFileName = m.lcFontFileName
		m.loFont.FontBold = (m.loRepObj.FontBold and m.lnBoldSimulation = 0)
		m.loFont.FontItalic = (m.loRepObj.FontItalic and m.lnItalicSimulation = 0)
		m.loFont.FontSymbol = EMPTY(m.lnIsSymbolFont)=.F.
		
		
		This.Fonts.Add(m.loFont, m.lcFontID)
		
		RETURN m.loFont
		
	ENDPROC

	HIDDEN PROCEDURE getfontsubset
		LPARAMETERS loRepObj, llAddChars
		
		IF EMPTY(m.loRepObj.Font.FontFileName) = .T.
		    RETURN .F.
		ENDIF
		
		LOCAL loFontSubset
		IF This.FontSubset.GetKey(m.loRepObj.Font.FontFileName) = 0
		    m.loFontSubset = NEWOBJECT("Empty")
		    ADDPROPERTY(m.loFontSubset, "CharSubset", "")
		    ADDPROPERTY(m.loFontSubset, "FontFileName", m.loRepObj.Font.FontFileName)
		    This.FontSubset.Add(m.loFontSubset, m.loRepObj.Font.FontFileName)
		ELSE
		    m.loFontSubset = This.FontSubset.Item(m.loRepObj.Font.FontFileName)
		ENDIF
		
		IF m.llAddChars = .T.
		    LOCAL liChar, lcChar
		    m.liChar = 1
		    FOR m.liChar = 1 TO LEN(m.loRepObj.Text)/2
		        m.lcChar = 0h + SUBSTR(m.loRepObj.Text, m.liChar * 2 - 1, 2)
		        IF INLIST(m.lcChar, 0h0A00, 0h0D00)
		            LOOP
		        ENDIF
		        IF AT(m.lcChar, m.loFontSubset.CharSubset) = 0
		            m.loFontSubset.CharSubset = m.loFontSubset.CharSubset + m.lcChar
		        ENDIF
		    ENDFOR
		ENDIF
		
		RETURN m.loFontSubset
		
	ENDPROC

	PROCEDURE getrenderer		&& Get current renderer object. Not an object return value means that default pdfiumreport_renderer_pdf is used
		RETURN This.Renderer
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.env = NEWOBJECT("pdfium_env", This.ClassLibrary)
		This.env.Setup(m.toEnv)
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		LOCAL lnScreenGfx
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateFromHWND(Application.HWnd, @m.lnScreenGfx))
		This.ScreenGfx = m.lnScreenGfx
		
		This.Renderer = .F.
		
		This.Fonts = NEWOBJECT("Collection")
		This.FontSubset = NEWOBJECT("Collection")
		
	ENDPROC

	PROCEDURE LoadReport
		This.env.FoxEnv_Set()
		
		This.Rep_PageCount = 0
		
		This.ListenerType = -1
		This.DynamicLineHeight = .F. && must be .F., otherwise text field height calculated incorrectly when font is not installed in system (Private Font)
		
		********************************************************
		LOCAL loPrintEnv
		m.loPrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		m.loPrintEnv.Setup(This.PrintEnv)
		This.PrintEnv.Setup(m.loPrintEnv, .T.)
		m.loPrintEnv = .F.
		
		IF This.CommandClauses.OUTPUTTO = This.env.API_FRX.CONST.OUTPUTTO_PRINTER()
		    This.PrintEnv.AllowPrintSetupUI = This.CommandClauses.PROMPT
		ENDIF
		
		********************************************************
		
		********************************************************
		IF This.CommandClauses.OUTPUTTO = This.env.API_FRX.CONST.OUTPUTTO_PRINTER() AND This.ToPrinterNative = .T. && VFP native output to the printer, do nothing
		    This.ListenerType = 0
		    RETURN
		ENDIF
		********************************************************
		
		IF This.BatchModeAuto = .F. AND This.BatchMode = .F.
		    This.BatchPageCount = 0
		ENDIF
		
		This.BatchModeAuto = This.CommandClauses.NOPAGEEJECT
		This.CommandClauses.NOPAGEEJECT = .F.
		
		
	ENDPROC

	PROCEDURE OnPreviewClose
		LPARAMETERS lPrint
		
		This.PreviewContainer = NULL
		
	ENDPROC

	PROCEDURE printenvdefault_access
		
		IF VARTYPE(This._PrintEnvDefault) <> "O"
		    This._PrintEnvDefault = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		    This._PrintEnvDefault.Setup(NULL)
		ENDIF
		
		RETURN This._PrintEnvDefault
		
	ENDPROC

	PROCEDURE printenvdefault_assign
		LPARAMETERS vNewVal
		
		ERROR 1740, TEXTMERGE("<<This.Class>>.PrintEnvDefault")
		
	ENDPROC

	PROCEDURE printenv_access
		
		IF VARTYPE(This._PrintEnv) <> "O"
		    This._PrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		    This._PrintEnv.Setup(This.PrintEnvDefault, .T.)
		ENDIF
		
		RETURN This._PrintEnv
		
	ENDPROC

	PROCEDURE printenv_assign
		LPARAMETERS vNewVal
		
		ERROR 1740, TEXTMERGE("<<This.Class>>.PrintEnv")
		
	ENDPROC

	HIDDEN PROCEDURE process_frxdynamics
		LPARAMETERS loRepObj, m.lcDynamicsXML
		
		IF EMPTY(NVL(m.lcDynamicsXML,""))
		    RETURN
		ENDIF
		
		LOCAL loFRXC
		m.loFRXC = This.env.API_FRX.CONST
		
		LOCAL lSaveArea
		m.lSaveArea = SELECT()
		
		LOCAL lSetNull
		m.lSetNull = SET("Null")
		
		TRY
		    SET NULL OFF
		
		    IF EMPTY(This.RepObjDynamicsCursor)
		        This.RepObjDynamicsCursor = This.env.GetUniqueTempCursorName()
		    ENDIF
		
		    CREATE CURSOR (This.RepObjDynamicsCursor) (Name c(100), Execute c(10), ExecWhen M, Script M, FName c(100), FSize c(10), FStyle c(10), Width c(10), Height c(10), penrgb c(10), pena c(5), fillrgb c(10), filla c(5))
		
		
		    LOCAL lcAliasCursor    
		    m.lcAliasCursor = This.RepObjDynamicsCursor
		
		
		    LOCAL llRes
		    m.llRes = .T.
		    TRY
		        XMLTOCURSOR(m.lcDynamicsXML, m.lcAliasCursor, 1024+8192)
		    CATCH
		        m.llRes = .F.
		    ENDTRY
		    IF m.llRes = .F.
		        EXIT        
		    ENDIF
		
		    LOCAL loDS
		    SELECT (m.lcAliasCursor)
		    GO TOP
		    SCAN
		        SELECT (m.lcAliasCursor)
		        SCATTER NAME m.loDS MEMO
		        
		        SELECT (m.lSaveArea)
		
		        DO CASE
		        CASE ALLTRIM(m.loDS.Name) == "Microsoft.VFP.Reporting.Builder.Rotate"
		            m.loRepObj.Rotate = CAST(m.loDS.Execute AS I)
		            
		        CASE EMPTY(m.loDS.ExecWhen)
		
		        CASE EVALUATE(m.loDS.ExecWhen) = .F.
		        
		        
		        CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_FIELD()
		            IF EMPTY(m.loDS.Script) = .F.
		                IF INLIST(m.loRepObj.FontCharset,0,1)=.F.
		                    m.loRepObj.Text = STRCONV(RTRIM(EVALUATE(m.loDS.Script)),5,m.loRepObj.FontCharset,2)
		                ELSE
		                    m.loRepObj.Text = STRCONV(RTRIM(EVALUATE(m.loDS.Script)),5)
		                ENDIF
		            ENDIF
		            
		            IF EMPTY(m.loDS.FName) = .F.
		                m.loRepObj.FontFace = LTRIM(ALLTRIM(m.loDS.FName), "@")
		            ENDIF
		
		            IF EMPTY(CAST(m.loDS.FSize as I)) = .F.
		                m.loRepObj.FontSize = CAST(m.loDS.FSize as I)
		            ENDIF
		
		            IF EMPTY(m.loDS.FStyle)=.F.
		                m.loRepObj.FontBold = BITTEST(CAST(m.loDS.FStyle as I),0)
		                m.loRepObj.FontItalic = BITTEST(CAST(m.loDS.FStyle as I),1)
		                m.loRepObj.FontUnderline = BITTEST(CAST(m.loDS.FStyle as I),2)
		                m.loRepObj.FontStrikeout = BITTEST(CAST(m.loDS.FStyle as I),7)
		            ENDIF
		            
		            IF CAST(m.loDS.FillRgb as I) >= 0 AND EMPTY(m.loDS.FillRgb)=.F.
		                m.loRepObj.FillRed = BITRSHIFT(BITAND(CAST(m.loDS.FillRgb as I), 0x0000FF),0)
		                m.loRepObj.FillGreen = BITRSHIFT(BITAND(CAST(m.loDS.FillRgb as I), 0x00FF00),8)
		                m.loRepObj.FillBlue = BITRSHIFT(BITAND(CAST(m.loDS.FillRgb as I), 0xFF0000),16)
		            ENDIF
		            
		            IF CAST(m.loDS.PenA as I) >= 0 AND EMPTY(m.loDS.PenA)=.F.
		                m.loRepObj.PenAlpha = BITAND(CAST(m.loDS.PenA as I), 0xFF)
		            ENDIF
		
		            IF CAST(m.loDS.PenRgb as I) >= 0 AND EMPTY(m.loDS.PenRgb)=.F.
		                m.loRepObj.PenRed = BITRSHIFT(BITAND(CAST(m.loDS.PenRgb as I), 0x0000FF),0)
		                m.loRepObj.PenGreen = BITRSHIFT(BITAND(CAST(m.loDS.PenRgb as I), 0x00FF00),8)
		                m.loRepObj.PenBlue = BITRSHIFT(BITAND(CAST(m.loDS.PenRgb as I), 0xFF0000),16)
		            ENDIF
		
		            IF CAST(m.loDS.FillA as I) >= 0 AND EMPTY(m.loDS.FillA)=.F.
		                m.loRepObj.FillAlpha = BITAND(CAST(m.loDS.FillA as I), 0xFF)
		                m.loRepObj.Transparent = IIF(m.loRepObj.FillAlpha = 0, 1, 0)
		            ENDIF
		
		        
		        CASE INLIST(m.loRepObj.ObjType, m.loFRXC.FRX_OBJ_RECTANGLE(), m.loFRXC.FRX_OBJ_PICTURE())
		            m.loRepObj.SizeWidth = IIF(CAST(m.loDS.Width AS I) >= 0, CAST(m.loDS.Width AS I) / 10, m.loRepObj.SizeWidth)
		            m.loRepObj.SizeHeight = IIF(CAST(m.loDS.Height AS I) >= 0, CAST(m.loDS.Height AS I) / 10, m.loRepObj.SizeHeight)
		        
		        ENDCASE
		        
		    ENDSCAN
		
		FINALLY    
		    SET NULL &lSetNull
		    SELECT (m.lSaveArea)
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE process_frxheader
		This.Rep_WholePage = .F.
		This.Rep_OffsetX = 0
		This.Rep_OffsetY = 0
		
		*************************************************
		IF (This.FRXDatasession > -1) AND (This.FRXDatasession <> SET("DATASESSION"))
		    SET DATASESSION TO (This.FRXDatasession)
		ENDIF
		
		LOCAL lnFRXRecNo
		m.lnFRXRecNo = RECNO("FRX")
		
		GO TOP IN FRX && Header record
		
		IF FRX.Top = .T.
		    This.Rep_WholePage = .T.
		ENDIF
		
		LOCAL lcPrinter
		m.lcPrinter = ALLTRIM(STREXTRACT(STREXTRACT(CHRTRAN(Frx.Expr,CHR(13),CHR(10)), "DEVICE",CHR(10),1,1)+CHR(10), "=", CHR(10),1,1), 1, " ", CHR(10))
		
		IF BETWEEN(m.lnFRXRecNo, 1, RECCOUNT("FRX"))
		    GO (m.lnFRXRecNo) IN FRX
		ENDIF
		
		SET DATASESSION TO (This.CurrentDataSession)
		*************************************************
		
		IF EMPTY(m.lcPrinter)=.F.
		    IF EMPTY(This.PrintEnv.GetPrinterTitle(m.lcPrinter))
		        m.lcPrinter = ""
		    ENDIF
		ENDIF
		
		IF EMPTY(m.lcPrinter)=.T.
		    m.lcPrinter = This.PrintEnv.SysDefaultPrinter_Get()
		ENDIF
		
		
		IF EMPTY(m.lcPrinter) = .F. AND This.Rep_WholePage = .F. 
		
		    #define PHYSICALOFFSETX 112
		    #define PHYSICALOFFSETY 113
		
		    LOCAL lnPrinterDPI
		    m.lnPrinterDPI = EVL(MAX(PRTINFO(11, m.lcPrinter),0), 600)
		
		    LOCAL lhPrinterDC
		    m.lhPrinterDC = This.env.API_WIN.CreateDC(NULL, m.lcPrinter + CHR(0), NULL, NULL)
		
		    IF EMPTY(m.lhPrinterDC) = .F.
		        TRY
		            This.Rep_OffsetX = This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETX) / m.lnPrinterDPI
		            This.Rep_OffsetY = This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETY) / m.lnPrinterDPI
		            
		        FINALLY
		            This.env.API_WIN.DeleteDC(m.lhPrinterDC)
		        ENDTRY
		    ENDIF
		ENDIF
		
		
	ENDPROC

	HIDDEN PROCEDURE process_frxpicture
		LPARAMETERS loRepObj, GDIPlusImage as Long
		
		m.loRepObj.PictureVal = ""
		
		LOCAL lcTempFileName
		m.lcTempFileName = This.env.GetUniqueTempFileName("png")
		
		
		LOCAL lhImage
		m.lhImage = 0
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    DO CASE
		    CASE EMPTY(m.GDIPlusImage)=.F.
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateBitmapFromHBITMAP(m.GDIPlusImage, 0, @m.lhImage))
		        
		        m.loRepObj.PictureFilename = ""
		    
		    CASE EMPTY(m.loRepObj.PictureFilename) = .T. 
		    
		    CASE FILE(m.loRepObj.PictureFilename)
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateBitmapFromFile(STRCONV(m.loRepObj.PictureFilename,5) + CHR(0), @m.lhImage))
		    
		    CASE EMPTY(This.Ext_Func_GetFileData) = .F.
		        
		        LOCAL lSaveSafety
		        m.lSaveSafety = SET("Safety")
		        SET SAFETY OFF
		        
		        TRY
		            LOCAL lcExt_Func_GetFileData
		            lcExt_Func_GetFileData = ALLTRIM(This.Ext_Func_GetFileData)
		
		            STRTOFILE(&lcExt_Func_GetFileData.(m.loRepObj.PictureFilename), m.lcTempFileName, 0)
		
		            This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateBitmapFromFile(STRCONV(m.lcTempFileName,5) + CHR(0), @m.lhImage))
		            
		        FINALLY
		            SET SAFETY &lSaveSafety
		        ENDTRY
		
		
		    OTHERWISE
		        ERROR 1, m.loRepObj.PictureFilename
		    
		    ENDCASE
		       
		    IF EMPTY(m.lhImage)
		        EXIT
		    ENDIF
		    
		    
		    **************************************************
		    * Image scaling
		    **************************************************
		    LOCAL lnImgWidth, lnImgHeight, lnImgPixelFormat
		    STORE 0 TO m.lnImgWidth, m.lnImgHeight, m.lnImgPixelFormat
		    
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetImageWidth(m.lhImage, @m.lnImgWidth))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetImageHeight(m.lhImage, @m.lnImgHeight))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetImagePixelFormat(m.lhImage, @m.lnImgPixelFormat))
		    
		
		    DO CASE
		    CASE m.loRepObj.PictureScale = 0 && Clip
		        m.lnImgWidth = MIN(m.lnImgWidth, m.loRepObj.SizeWidth)
		        m.lnImgHeight = MIN(m.lnImgHeight, m.loRepObj.SizeHeight)
		
		        LOCAL lhImageClipped, lhGfxClipped
		        STORE 0 TO m.lhImageClipped, m.lhGfxClipped
		        
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateBitmapFromScan0(m.lnImgWidth, m.lnImgHeight, 0, m.lnImgPixelFormat, NULL, @m.lhImageClipped))
		        
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetImageGraphicsContext(m.lhImageClipped, @m.lhGfxClipped))
		        
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipDrawImageI(m.lhGfxClipped, m.lhImage, 0, 0))
		
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipDisposeImage(m.lhImage))
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipDeleteGraphics(m.lhGfxClipped))
		        
		        m.lhImage = m.lhImageClipped
		        
		        m.lhGfxClipped = 0
		        m.lhImageClipped = 0
		        
		    CASE m.loRepObj.PictureScale = 1 && Scale Keep shape
		        LOCAL lnScale
		        m.lnScale = MIN(IIF(EMPTY(m.lnImgWidth), 0, m.loRepObj.SizeWidth / m.lnImgWidth), IIF(EMPTY(m.lnImgHeight), 0, m.loRepObj.SizeHeight / m.lnImgHeight))
		        
		        m.lnImgWidth = INT(m.lnImgWidth * m.lnScale)
		        m.lnImgHeight = INT(m.lnImgHeight * m.lnScale)
		
		    OTHERWISE && Scale Stretch
		        m.lnImgWidth = m.loRepObj.SizeWidth
		        m.lnImgHeight = m.loRepObj.SizeHeight
		
		    ENDCASE
		
		
		    LOCAL lcImgEncoder
		    m.lcImgEncoder = This.env.API_GDIP.GdipGetImageEncoder("image/png")
		    
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSaveImageToFile(m.lhImage, STRCONV(m.lcTempFileName,5)+CHR(0), m.lcImgEncoder, 0))
		    
		    m.loRepObj.SizeWidth = m.lnImgWidth
		    m.loRepObj.SizeHeight = m.lnImgHeight
		
		    m.loRepObj.PictureVal = FILETOSTR(m.lcTempFileName)
		    
		    
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		    
		FINALLY
		
		    IF EMPTY(m.lhImage) = .F.
		        This.env.API_GDIP.GdipDisposeImage(m.lhImage)
		        m.lhImage = 0
		    ENDIF
		    
		    IF FILE(m.lcTempFileName,1)
		        DELETE FILE (m.lcTempFileName)
		    ENDIF
		    
		ENDTRY
		
	ENDPROC

	PROCEDURE Render
		LPARAMETERS nFRXRecno, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage
		
		IF This.TwoPassProcess AND This.CurrentPass = 0
		    RETURN DODEFAULT(m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
		ENDIF
		
		IF This.ListenerType = 0 AND This.ToPrinterNative = .T. && VFP native output to the printer, do nothing
		    RETURN DODEFAULT(m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
		ENDIF
		
		IF This.PageNo < This.CommandClauses.RANGEFROM
		    RETURN 
		ENDIF
		
		IF This.PageNo > This.CommandClauses.RANGETO AND This.CommandClauses.RANGETO > 0
		    RETURN
		ENDIF
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		
		LOCAL loFRXC
		m.loFRXC = This.env.API_FRX.CONST
		
		LOCAL lSaveArea
		m.lSaveArea = SELECT()
		
		
		*************************************************
		* New page
		*************************************************
		IF This.PageNo > This.Rep_PageCount
		
		    This.Rep_PageCount = This.Rep_PageCount + 1
		    This.BatchPageCount = This.BatchPageCount + 1
		
		    IF This.Rep_PageCount = 1
		        This.Process_FrxHeader()
		    ENDIF
		    
		    IF This.BatchPageCount = 1
		        This.FontsRelease()
		        This.GdipPrivateFontsLoad()
		        This.RepObj = NEWOBJECT("PdfiumReport_repobj", This.ClassLibrary, "", This.env, This.ScreenGfx)
		
		        IF EMPTY(This.RepObjCursor)
		            This.RepObjCursor = This.env.GetUniqueTempCursorName()
		        ENDIF
		    ENDIF
		ENDIF
		
		
		
		*************************************************
		* Frx record extraction
		*************************************************
		IF (This.FRXDatasession > -1) AND (This.FRXDatasession <> SET("DATASESSION"))
		    SET DATASESSION TO (This.FRXDatasession)
		ENDIF
		
		GO m.nFRXRecNo IN FRX
		
		LOCAL loFrx
		SCATTER NAME m.loFrx MEMO
		
		SET DATASESSION TO (This.CurrentDataSession)
		*************************************************
		
		
		*************************************************
		* RepObj creation
		*************************************************
		LOCAL loRepObj as PdfiumReport_repobj OF pdfium-vfp.vcx
		m.loRepObj = This.RepObj
		
		*************************************************
		* RepObj setup
		*************************************************
		IF USED(This.RepObjCursor) = .F.
		    CREATE CURSOR (This.RepObjCursor) ( ;
		        ObjID i, ;
		        Rep_PageWidth n(12,2), ;
		        Rep_PageHeight n(12,2), ;
		        Rep_PageNo i, ;
		        Rep_PageTotal i, ;
		        Batch_PageNo i, ;
		        ObjType i, ;
		        Text M, ;
		        PictureFilename M, ;
		        PictureVal M, ;
		        PosLeft n(12,2), ;
		        PosTop n(12,2), ;
		        PosTopRev n(12,2), ;
		        SizeWidth n(12,2), ;
		        SizeHeight n(12,2), ;
		        FontFace M,;
		        FontSize i, ;
		        FontBold l, ;
		        FontItalic l, ;
		        FontUnderline l, ;
		        FontStrikeout l, ;
		        FontCharset i, ;
		        LineSpacing n(12,2), ;
		        FillRed i, ;
		        FillGreen i, ;
		        FillBlue i, ;
		        FillAlpha i, ;
		        PenRed i, ;
		        PenGreen i, ;
		        PenBlue i, ;
		        PenAlpha i, ;
		        PenPat i, ;
		        PenSize i, ;
		        FillPat i, ;
		        Transparent i, ;
		        Align i, ;
		        LineType i, ;
		        RectCurvature i, ;
		        ContinuationType i,;
		        PictureScale i, ;
		        Rotate i ;
		    )
		    
		    SELECT (m.lSaveArea)
		ENDIF
		
		m.loRepObj.Rep_PageWidth = This.GetPageWidth() / 10
		m.loRepObj.Rep_PageHeight = This.GetPageHeight() / 10
		
		m.loRepObj.Rep_PageNo = This.Rep_PageCount
		
		m.loRepObj.Rep_PageTotal = This.PageTotal
		
		m.loRepObj.Batch_PageNo = This.BatchPageCount
		
		m.loRepObj.ObjType = m.loFrx.ObjType
		
		m.loRepObj.Text = ""
		m.loRepObj.PictureFilename = ""
		m.loRepObj.PictureVal = ""
		
		IF INLIST(m.loFrx.ObjType, m.loFRXC.FRX_OBJ_FIELD(), m.loFRXC.FRX_OBJ_LABEL())
		    m.loRepObj.Text = m.cContentsToBeRendered
		ENDIF
		
		IF INLIST(m.loFrx.ObjType, m.loFRXC.FRX_OBJ_PICTURE())
		    m.loRepObj.PictureFilename = m.cContentsToBeRendered
		ENDIF
		
		
		m.loRepObj.PosLeft = m.nLeft / 10
		m.loRepObj.PosTop = m.nTop / 10
		m.loRepObj.PosTopRev = m.loRepObj.Rep_PageHeight - m.loRepObj.PosTop
		m.loRepObj.SizeWidth = m.nWidth / 10
		m.loRepObj.SizeHeight = m.nHeight / 10
		
		m.loRepObj.PosLeft = m.loRepObj.PosLeft - This.Rep_OffsetX * 96
		m.loRepObj.PosTop = m.loRepObj.PosTop - This.Rep_OffsetY * 96
		m.loRepObj.PosTopRev = m.loRepObj.PosTopRev + This.Rep_OffsetY * 96
		
		m.loRepObj.Font = .F.
		
		m.loRepObj.FontFace = LTRIM(ALLTRIM(m.loFrx.FontFace), "@")
		m.loRepObj.FontSize = m.loFrx.FontSize
		m.loRepObj.FontBold = BITTEST(m.loFrx.FontStyle,0)
		m.loRepObj.FontItalic = BITTEST(m.loFrx.FontStyle,1)
		m.loRepObj.FontUnderline = BITTEST(m.loFrx.FontStyle,2)
		m.loRepObj.FontStrikeout = BITTEST(m.loFrx.FontStyle,7)
		m.loRepObj.FontCharset = m.loFrx.ResOID
		
		m.loRepObj.LineSpacing = IIF(m.loFrx.ObjType = m.loFRXC.FRX_OBJ_LABEL(), m.loFrx.Spacing, 0)
		
		* (-1,-1,-1) - default color
		m.loRepObj.FillRed = IIF(m.loFrx.FillRed=-1, 255, m.loFrx.FillRed)
		m.loRepObj.FillGreen = IIF(m.loFrx.FillGreen=-1, 255, m.loFrx.FillGreen)
		m.loRepObj.FillBlue = IIF(m.loFrx.FillBlue=-1, 255, m.loFrx.FillBlue)
		m.loRepObj.FillAlpha = 255
		
		* (-1,-1,-1) - default color
		m.loRepObj.PenRed = IIF(m.loFrx.PenRed=-1, 0, m.loFrx.PenRed)
		m.loRepObj.PenGreen = IIF(m.loFrx.PenGreen=-1, 0, m.loFrx.PenGreen)
		m.loRepObj.PenBlue = IIF(m.loFrx.PenBlue=-1, 0, m.loFrx.PenBlue)
		m.loRepObj.PenAlpha = 255
		
		m.loRepObj.PenPat = m.loFrx.PenPat
		m.loRepObj.PenSize = m.loFrx.PenSize
		
		m.loRepObj.FillPat = m.loFrx.FillPat
		
		m.loRepObj.Transparent = IIF(BITTEST(m.loFrx.Mode,0),1,0) && Transparency: 0 - Opaque, 1 - Transparent
		
		m.loRepObj.Align = 0
		m.loRepObj.LineType = 0
		m.loRepObj.RectCurvature = 0
		
		DO CASE
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_FIELD()
		    m.loRepObj.Align = m.loFrx.Offset && FRX_OBJ_FIELD Alignment: 0 - left, 1 - right, 2 - center
		
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		    m.loRepObj.Align = ICASE(ATC("@I", m.loFrx.Picture)<>0, 2, ATC("@J", m.loFrx.Picture)<>0, 1, 0)
		
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_LINE()
		    m.loRepObj.LineType = IIF(m.loFrx.Offset = 1, 1, 2) && Line type: 1 - horizonal, 2 - vertical
		
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_RECTANGLE()
		    m.loRepObj.RectCurvature = m.loFrx.Offset
		    
		ENDCASE
		
		m.loRepObj.ContinuationType = m.nObjectContinuationType
		
		m.loRepObj.PictureScale = IIF(m.loFrx.ObjType = m.loFRXC.FRX_OBJ_PICTURE(), m.loFrx.General, 0)
		
		m.loRepObj.Rotate = 0
		
		
		
		*************************************************
		* Dynamic properties processing 
		*************************************************
		This.Process_FrxDynamics(m.loRepObj, m.loFrx.Style)
		*************************************************
		
		
		*************************************************
		* Additional processing before rendering
		*************************************************
		DO CASE
		CASE INLIST(m.loFrx.ObjType, m.loFRXC.FRX_OBJ_FIELD(), m.loFRXC.FRX_OBJ_LABEL()) && Text
		    
		    m.loRepObj.Font = This.GetFont(m.loRepObj) && Font object assignment
		    m.loRepObj.FontSubset = This.GetFontSubset(m.loRepObj, .T.)
		
		
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_PICTURE() && Picture
		
		    This.Process_FrxPicture(m.loRepObj, m.GDIPlusImage)
		
		
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_LINE() && Line
		
		    m.loRepObj.PosLeft = m.loRepObj.PosLeft + IIF(m.loRepObj.LineType = 1, 0, m.loRepObj.PenSize * 0.5)
		    m.loRepObj.PosTop = m.loRepObj.PosTop + IIF(m.loRepObj.LineType = 1, m.loRepObj.PenSize * 0.5, 0)
		    m.loRepObj.PosTopRev = m.loRepObj.PosTopRev - IIF(m.loRepObj.LineType = 1, m.loRepObj.PenSize * 0.5, 0)
		
		    
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_RECTANGLE() && Rectangle
		
		    m.loRepObj.PosLeft = m.loRepObj.PosLeft + m.loRepObj.PenSize * 0.5
		    m.loRepObj.PosTop = m.loRepObj.PosTop + m.loRepObj.PenSize * 0.5
		    m.loRepObj.PosTopRev = m.loRepObj.PosTopRev - m.loRepObj.PenSize * 0.5
		    m.loRepObj.SizeWidth = m.loRepObj.SizeWidth - m.loRepObj.PenSize
		    m.loRepObj.SizeHeight = m.loRepObj.SizeHeight - m.loRepObj.PenSize
		
		ENDCASE
		
		
		m.loRepObj.ObjID = RECCOUNT(This.RepObjCursor) + 1
		
		SELECT (This.RepObjCursor)
		APPEND BLANK
		GATHER NAME m.loRepObj MEMO
		SELECT (m.lSaveArea)
		
	ENDPROC

	PROCEDURE runrenderer		&& Runs report rendering with specified renderer object (subclass of pdfiumreport_renderer_base). Returns path to the temporary file containing rendering output results or empty string if there is nothing to render. Temp file must be deleted by  a caller
		LPARAMETERS loRenderer as pdfiumreport_renderer_base OF pdfium-vfp.vcx
		
		IF VARTYPE(m.loRenderer) <> "O"
		    RETURN ""
		ENDIF
		
		IF This.BatchPageCount = 0
		    RETURN ""
		ENDIF
		
		IF RECCOUNT(This.RepObjCursor) = 0
		    RETURN ""
		ENDIF
		
		LOCAL loFRXC
		m.loFRXC = This.env.API_FRX.CONST
		
		
		LOCAL lcTempFileName
		m.lcTempFileName = ""
		
		LOCAL lSaveArea
		m.lSaveArea = SELECT()
		TRY
		    m.loRenderer.Begin(This.SaveAs_PDFMeta)
		
		    LOCAL loRepObj
		    m.loRepObj = NEWOBJECT("PdfiumReport_repobj", This.ClassLibrary, "", This.env, This.ScreenGfx)
		
		    SELECT (This.RepObjCursor)
		    GO TOP
		    SCAN
		        SELECT (This.RepObjCursor)
		        SCATTER NAME m.loRepObj MEMO ADDITIVE
		
		        IF INLIST(m.loRepObj.ObjType, m.loFRXC.FRX_OBJ_FIELD(), m.loFRXC.FRX_OBJ_LABEL()) && Text
		            m.loRepObj.Font = This.GetFont(m.loRepObj) && Font object assignment
		            m.loRepObj.FontSubset = This.GetFontSubset(m.loRepObj)
		        ENDIF
		        
		        m.loRenderer.Render(m.loRepObj)
		    ENDSCAN
		
		    m.lcTempFileName = m.loRenderer.Finalize(This.SaveAs_PDFMeta)
		
		    IF VARTYPE(m.lcTempFileName) != "C" 
		        m.lcTempFileName = ""
		    ENDIF
		
		    IF FILE(m.lcTempFileName,1) = .F.
		        m.lcTempFileName = ""
		    ENDIF
		
		FINALLY
		    SELECT (m.lSaveArea)
		ENDTRY
		
		RETURN m.lcTempFileName
		
	ENDPROC

	PROCEDURE saveas_pdfmeta_access
		
		IF VARTYPE(This._SaveAs_PDFMeta) <> "O"
		    This._SaveAs_PDFMeta = NEWOBJECT("pdfium_pdfmeta", This.ClassLibrary)
		ENDIF
		
		RETURN This._SaveAs_PDFMeta
		
	ENDPROC

	PROCEDURE saveas_pdfmeta_assign
		LPARAMETERS vNewVal
		
		ERROR 1740, TEXTMERGE("<<This.Class>>.SaveAs_PDFMeta")
		
	ENDPROC

	PROCEDURE setrenderer		&& Sets renderer object (subclass of pdfiumreport_renderer_base). If not an object value is passed then default pdfiumreport_renderer_pdf is used
		LPARAMETERS toRenderer
		
		This.Renderer = IIF(VARTYPE(m.toRenderer)<>"O", .F., m.toRenderer)
		
	ENDPROC

	PROCEDURE UnloadReport
		
		IF This.BatchModeAuto = .F. AND This.BatchMode = .F.
		    This.Finalize()
		ENDIF
		
		This.env.FoxEnv_Restore()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport_renderer_base AS custom 		&& PdfiumReport renderer implementor base class  (in the meaning of bridge design pattern);
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: begin
		*m: finalize
		*m: getfileextension
		*m: render		&& Occurs when Report Engine is ready to provide output for each layout object in a band.
		*p: env
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	PROTECTED env
	*<PropValue>
		env = .F.
		Height = 27
		Name = "pdfiumreport_renderer_base"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="finalize" type="method" display="Finalize"/>
			<memberdata name="render" type="method" display="Render"/>
			<memberdata name="begin" type="method" display="Begin"/>
			<memberdata name="env" type="property" display="env"/>
			<memberdata name="getfileextension" type="method" display="GetFileExtension"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE begin
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
	ENDPROC

	PROCEDURE finalize
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
	ENDPROC

	PROCEDURE getfileextension
		RETURN ""
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp.vcx
		
		This.env = NEWOBJECT("pdfium_env", This.ClassLibrary)
		This.env.Setup(m.toEnv)
		
	ENDPROC

	PROCEDURE render		&& Occurs when Report Engine is ready to provide output for each layout object in a band.
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport_renderer_docx AS pdfiumreport_renderer_base OF "pdfium-vfp.vcx" 		&& DOCX rendering implementation
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: getfont
		*m: render_frxfield
		*m: render_frxlabel
		*m: render_frxline
		*m: render_frxpicture
		*m: render_frxrectangle
		*m: render_text
		*m: write_content_types
		*m: write_docprops
		*m: write_document
		*m: write_fonttable
		*m: write_rels
		*m: write_settings
		*m: write_styles
		*m: xmlescape
		*p: docrels
		*p: fontfiles
		*p: fonts
		*p: pages		&& An array used to access individual Pages in a PageFrame object.
		*p: vfpdf_zip_input
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,docrels,Error,fontfiles,fonts,HelpContextID,NewObject,Objects,pages,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,vfpdf_zip_input,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		docrels = .F.
		fontfiles = .F.
		fonts = .F.
		Name = "pdfiumreport_renderer_docx"
		pages = .F.
		vfpdf_zip_input = 0
		_memberdata = <VFPData>
			<memberdata name="pages" type="property" display="Pages"/>
			<memberdata name="render_frxfield" type="method" display="Render_FrxField"/>
			<memberdata name="render_frxlabel" type="method" display="Render_FrxLabel"/>
			<memberdata name="render_frxline" type="method" display="Render_FrxLine"/>
			<memberdata name="render_frxrectangle" type="method" display="Render_FrxRectangle"/>
			<memberdata name="render_frxpicture" type="method" display="Render_FrxPicture"/>
			<memberdata name="render_text" type="method" display="Render_Text"/>
			<memberdata name="write_settings" type="method" display="Write_Settings"/>
			<memberdata name="write_styles" type="method" display="Write_Styles"/>
			<memberdata name="xmlescape" type="method" display="XmlEscape"/>
			<memberdata name="fontfiles" type="property" display="FontFiles"/>
			<memberdata name="write_content_types" type="method" display="Write_Content_Types"/>
			<memberdata name="write_rels" type="method" display="Write_Rels"/>
			<memberdata name="write_docprops" type="method" display="Write_DocProps"/>
			<memberdata name="write_document" type="method" display="Write_Document"/>
			<memberdata name="write_fonttable" type="method" display="Write_FontTable"/>
			<memberdata name="fonts" type="property" display="Fonts"/>
			<memberdata name="getfont" type="method" display="GetFont"/>
			<memberdata name="docrels" type="property" display="DocRels"/>
			<memberdata name="vfpdf_zip_input" type="property" display="vfpdf_zip_input"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE begin
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
		This.vfpdf_zip_input = This.env.API_FPDF.VFPDF_CreateZipInput()
		
		This.Fonts = NEWOBJECT("Collection")
		This.FontFiles = NEWOBJECT("Collection")
		This.Pages = NEWOBJECT("Collection")
		This.DocRels = NEWOBJECT("Collection")
		
		
		LOCAL loRel
		m.loRel = NEWOBJECT("Empty")
		ADDPROPERTY(m.loRel, "Id", "rId1")
		ADDPROPERTY(m.loRel, "Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles")
		ADDPROPERTY(m.loRel, "Target", "styles.xml")
		This.DocRels.Add(m.loRel, m.loRel.Id)
		
		m.loRel = NEWOBJECT("Empty")
		ADDPROPERTY(m.loRel, "Id", "rId2")
		ADDPROPERTY(m.loRel, "Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings")
		ADDPROPERTY(m.loRel, "Target", "settings.xml")
		This.DocRels.Add(m.loRel, m.loRel.Id)
		
		m.loRel = NEWOBJECT("Empty")
		ADDPROPERTY(m.loRel, "Id", "rId3")
		ADDPROPERTY(m.loRel, "Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings")
		ADDPROPERTY(m.loRel, "Target", "webSettings.xml")
		This.DocRels.Add(m.loRel, m.loRel.Id)
		
		m.loRel = NEWOBJECT("Empty")
		ADDPROPERTY(m.loRel, "Id", "rId4")
		ADDPROPERTY(m.loRel, "Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable")
		ADDPROPERTY(m.loRel, "Target", "fontTable.xml")
		This.DocRels.Add(m.loRel, m.loRel.Id)
		
		
		
	ENDPROC

	PROCEDURE finalize
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
		IF EMPTY(This.vfpdf_zip_input)
		    RETURN
		ENDIF
		
		
		LOCAL lnZipFileData, lnZipFileDataSize
		STORE 0 TO m.lnZipFileData, m.lnZipFileDataSize
		
		LOCAL lcTempFileName
		m.lcTempFileName = ""
		
		TRY
		    This.Write_Content_Types()
		    This.Write_Settings()
		    This.Write_Styles()
		    This.Write_FontTable()
		
		    This.Write_Document()
		
		    This.Write_DocProps()
		    This.Write_Rels()
		    
		    m.lcTempFileName = This.env.GetUniqueTempFileName("docx")
		
		    IF This.env.API_FPDF.VFPDF_CreateZip(This.vfpdf_zip_input, @m.lnZipFileData, @m.lnZipFileDataSize) = 1
		        STRTOFILE(SYS(2600, m.lnZipFileData, m.lnZipFileDataSize), m.lcTempFileName)
		    ENDIF
		
		FINALLY
		    IF EMPTY(m.lnZipFileData) = .F.
		        This.env.API_FPDF.VFPDF_DestroyZip(m.lnZipFileData)
		        STORE 0 TO m.lnZipFileData, m.lnZipFileDataSize
		    ENDIF
		        
		    IF EMPTY(This.vfpdf_zip_input) = .F.
		        This.env.API_FPDF.VFPDF_DestroyZipInput(This.vfpdf_zip_input)
		        This.vfpdf_zip_input = 0
		    ENDIF
		    
		    This.Fonts = .F.
		    This.FontFiles = .F.
		    This.Pages = .F.
		    This.DocRels = .F.
		    
		ENDTRY
		
		RETURN m.lcTempFileName
		
	ENDPROC

	PROCEDURE getfileextension
		RETURN "docx"
		
	ENDPROC

	HIDDEN PROCEDURE getfont
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		
		LOCAL lcFontName
		m.lcFontName = m.loRepObj.FontFace
		
		
		***********************************************************
		* Font has been found
		***********************************************************
		LOCAL lnFontIndex
		m.lnFontIndex = This.Fonts.GetKey(m.lcFontName)
		IF m.lnFontIndex > 0
		    RETURN This.Fonts[m.lnFontIndex]
		ENDIF
		***********************************************************
		
		***********************************************************
		* Font hasn't been found, load it from file
		***********************************************************
		
		LOCAL lcFontsPath
		m.lcFontsPath = "word/fonts"
		
		
		LOCAL loFontFile
		m.loFontFile = .F.
		
		*!*    LOCAL lhHeap, lnFontDataPtr, lnSubsetData, lnSubsetDataSize
		*!*    STORE 0 TO m.lhHeap, m.lnFontDataPtr, m.lnSubsetData, m.lnSubsetDataSize
		
		*!*    TRY
		*!*        IF FILE(m.loRepObj.Font.FontFileName, 1) = .F.
		*!*            * Font file doesn't exist OR FILENAME HAS UNICODE SYMBOLS
		*!*            EXIT
		*!*        ENDIF
		
		*!*        IF This.FontFiles.GetKey(m.loRepObj.Font.FontFileName) > 0
		*!*            m.loFontFile = This.FontFiles.Item(m.loRepObj.Font.FontFileName)
		*!*            EXIT
		*!*        ENDIF
		*!*        
		
		*!*        m.loFontFile = NEWOBJECT("Empty")
		*!*        ADDPROPERTY(m.loFontFile, "rid", "rId" + TRANSFORM(This.FontFiles.Count+1))
		*!*        ADDPROPERTY(m.loFontFile, "FontFileName", "font" + TRANSFORM(This.FontFiles.Count+1) + ".odttf")
		
		*!*        LOCAL lcFontData, lnFontDataSize
		*!*        m.lcFontData = FILETOSTR(m.loRepObj.Font.FontFileName)
		*!*        m.lnFontDataSize = LEN(m.lcFontData)
		*!*        
		*!*        This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, m.lcFontsPath + "/" + m.loFontFile.FontFileName, m.lcFontData, m.lnFontDataSize)
		
		*!*        This.FontFiles.Add(m.loFontFile, m.loRepObj.Font.FontFileName)
		
		*!*        IF m.loRepObj.Font.FontSymbol
		*!*            EXIT
		*!*        ENDIF
		
		*!*        m.lhHeap = This.env.API_WIN.HeapCreate(0, m.lnFontDataSize, 0)
		*!*        IF EMPTY(m.lhHeap)
		*!*            EXIT
		*!*        ENDIF
		
		*!*        m.lnFontDataPtr = This.env.API_WIN.HeapAlloc(m.lhHeap, 0, m.lnFontDataSize)
		*!*        IF EMPTY(m.lnFontDataPtr)
		*!*            EXIT
		*!*        ENDIF
		
		*!*        SYS(2600, m.lnFontDataPtr, m.lnFontDataSize, m.lcFontData)
		
		*!*        IF m.loFPDF.VFPDF_CreateFontSubset(m.lnFontDataPtr, m.lnFontDataSize, m.loRepObj.FontSubset.CharSubset + CHR(0), @m.lnSubsetData, @m.lnSubsetDataSize) = 1
		*!*            This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, m.lcFontsPath + "/" + m.loFontFile.FontFileName, SYS(2600, m.lnSubsetData, m.lnSubsetDataSize), m.lnSubsetDataSize)
		*!*        ENDIF
		
		
		*!*    FINALLY
		*!*        
		*!*        IF EMPTY(m.lnSubsetData)=.F.
		*!*            m.loFPDF.VFPDF_DestroyFontSubset(m.lnSubsetData)
		*!*            m.lnSubsetData = 0
		*!*            m.lnSubsetDataSize = 0
		*!*        ENDIF
		
		*!*        IF EMPTY(m.lnFontDataPtr)=.F.
		*!*            This.env.API_WIN.HeapFree(m.lhHeap, 0, m.lnFontDataPtr)
		*!*            m.lnFontDataPtr = 0 
		*!*        ENDIF
		
		*!*        IF EMPTY(m.lhHeap)=.F.
		*!*            This.env.API_WIN.HeapDestroy(m.lhHeap)
		*!*            m.lhHeap = 0 
		*!*        ENDIF
		
		*!*    ENDTRY
		
		
		LOCAL loFont
		m.loFont = NEWOBJECT("empty")
		ADDPROPERTY(m.loFont, "Name", m.lcFontName)
		ADDPROPERTY(m.loFont, "FontFile", m.loFontFile)
		
		This.Fonts.Add(m.loFont, m.lcFontName)
		
		RETURN m.loFont
		
		
	ENDPROC

	PROCEDURE render
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		IF EMPTY(This.vfpdf_zip_input)
		    RETURN
		ENDIF
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL loFRXC
		m.loFRXC = This.env.API_FRX.CONST
		
		
		*************************************************
		* Create new page
		*************************************************
		IF m.loRepObj.Batch_PageNo > This.Pages.Count
		
		    LOCAL lnPageWidth, lnPageHeight
		    m.lnPageWidth = INT(m.loRepObj.Rep_PageWidth * m.lnDpiCoef)
		    m.lnPageHeight = INT(m.loRepObj.Rep_PageHeight * m.lnDpiCoef)
		
		    LOCAL loPage
		    m.loPage = NEWOBJECT("Empty")
		    ADDPROPERTY(m.loPage, "PageWidth", m.lnPageWidth)
		    ADDPROPERTY(m.loPage, "PageHeight", m.lnPageHeight)
		    ADDPROPERTY(m.loPage, "ContentXML", "")
		
		    This.Pages.Add(m.loPage)
		
		ENDIF
		
		
		*************************************************
		
		DO CASE
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_FIELD()
		    This.Render_FrxField(m.loRepObj)
		   
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		    This.Render_FrxLabel(m.loRepObj)
		
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_LINE()
		    This.Render_FrxLine(m.loRepObj)
		
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_RECTANGLE()
		    This.Render_FrxRectangle(m.loRepObj)
		
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_PICTURE()
		    This.Render_FrxPicture(m.loRepObj)
		
		ENDCASE
		*************************************************
		
	ENDPROC

	HIDDEN PROCEDURE render_frxfield
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		This.Render_Text(m.loRepObj)
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxlabel
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		This.Render_Text(m.loRepObj)
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxline
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		LOCAL loFRXC
		m.loFRXC = This.env.API_FRX.CONST
		
		
		LOCAL loPage
		m.loPage = This.Pages.Item(This.Pages.Count)
		
		LOCAL lnEmuCoef
		m.lnEmuCoef = 914400 / 96
		
		LOCAL lnLineWidth
		IF m.loRepObj.PenPat >= 1
		    m.lnLineWidth = INT(MAX(m.loRepObj.PenSize, 1) * m.lnEmuCoef)
		ELSE
		    m.lnLineWidth = 0
		ENDIF
		
		IF EMPTY(m.lnLineWidth)
		    RETURN
		ENDIF
		
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = INT(m.loRepObj.PosLeft * m.lnEmuCoef)
		m.lnTop = INT(m.loRepObj.PosTop * m.lnEmuCoef)
		m.lnWidth = INT(m.loRepObj.SizeWidth * m.lnEmuCoef)
		m.lnHeight = INT(m.loRepObj.SizeHeight * m.lnEmuCoef)
		
		IF m.loRepObj.LineType = 1
		    * Horizontal line
		    m.lnHeight = 0
		ELSE
		    * Vertical line
		    m.lnWidth = 0
		ENDIF
		
		
		m.lnLeft = m.lnLeft + INT((m.lnWidth * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) - m.lnWidth * 0.5)
		m.lnTop = m.lnTop + INT(-(m.lnWidth * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) - m.lnHeight * 0.5)
		
		
		
		LOCAL lnRotate
		m.lnRotate = INT(m.loRepObj.Rotate * 60000)
		
		
		LOCAL lcDash
		DO CASE
		CASE m.loRepObj.PenPat = 8 && Normal
		    m.lcDash = '<a:prstDash val="solid"/>'
		
		CASE m.loRepObj.PenPat = 1 && Dot
		    m.lcDash = '<a:prstDash val="dot"/>'
		    
		CASE m.loRepObj.PenPat = 2 && Dash
		    m.lcDash = '<a:prstDash val="dash"/>'
		    
		CASE m.loRepObj.PenPat = 3 && Dash-dot
		    m.lcDash = '<a:prstDash val="dashDot"/>'
		    
		CASE m.loRepObj.PenPat = 4 && Dash-dot-dot
		    m.lcDash = '<a:prstDash val="lgDashDotDot"/>'
		
		OTHERWISE && Normal
		    m.lcDash = '<a:prstDash val="solid"/>'
		
		ENDCASE
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		
		    TEXT TO m.loPage.ContentXML ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <w:drawing>
		        <wp:anchor distT="0" distB="0" distL="0" distR="0" simplePos="0" relativeHeight="<<m.loRepObj.ObjID>>" behindDoc="0" locked="0" layoutInCell="0" allowOverlap="1">
		            <wp:simplePos x="0" y="0" />
		            <wp:positionH relativeFrom="margin">
		                <wp:posOffset><<m.lnLeft>></wp:posOffset>
		            </wp:positionH>
		            <wp:positionV relativeFrom="margin">
		                <wp:posOffset><<m.lnTop>></wp:posOffset>
		            </wp:positionV>
		            <wp:extent cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		            <wp:effectExtent l="0" t="0" r="0" b="0"/>
		            <wp:wrapNone />
		            <wp:docPr id="<<m.loRepObj.ObjID>>" name="Line<<m.loRepObj.ObjID>>" />
		            <wp:cNvGraphicFramePr>
		                <a:graphicFrameLocks
		                    xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" 
		                    noDrilldown="1" noSelect="1" noMove="1" noResize="1"/>
		            </wp:cNvGraphicFramePr>
		            <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
		                <a:graphicData uri="http://schemas.microsoft.com/office/word/2010/wordprocessingShape">
		                    <wps:wsp>
		                        <wps:cNvCnPr />
		                        <wps:spPr>
		                            <a:xfrm rot="<<m.lnRotate>>">
		                                <a:off x="0" y="0" />
		                                <a:ext cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		                            </a:xfrm>
		                            <a:prstGeom prst="line">
		                                <a:avLst />
		                            </a:prstGeom>
		                            <a:ln w="<<m.lnLineWidth>>">
		                                <a:solidFill>
		                                   <a:srgbClr val="<<STRCONV(CHR(m.loRepObj.PenRed)+CHR(m.loRepObj.PenGreen)+CHR(m.loRepObj.PenBlue),15)>>">
		                                       <a:alpha val="<<INT(100000 * m.loRepObj.PenAlpha/255)>>" />
		                                   </a:srgbClr>
		                                 </a:solidFill>
		                                 <<m.lcDash>>
		                                <a:miter lim="800%" />
		                                <a:headEnd />
		                                <a:tailEnd />
		                            </a:ln>
		                        </wps:spPr>
		                        <wps:bodyPr />
		                    </wps:wsp>
		                </a:graphicData>
		            </a:graphic>
		        </wp:anchor>
		    </w:drawing>
		    ENDTEXT
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE render_frxpicture
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		LOCAL loFRXC
		m.loFRXC = This.env.API_FRX.CONST
		
		
		LOCAL loPage
		m.loPage = This.Pages.Item(This.Pages.Count)
		
		LOCAL lnEmuCoef
		m.lnEmuCoef = 914400 / 96
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = INT(m.loRepObj.PosLeft * m.lnEmuCoef)
		m.lnTop = INT(m.loRepObj.PosTop * m.lnEmuCoef)
		m.lnWidth = INT(m.loRepObj.SizeWidth * m.lnEmuCoef)
		m.lnHeight = INT(m.loRepObj.SizeHeight * m.lnEmuCoef)
		
		
		m.lnLeft = m.lnLeft + INT((m.lnWidth * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) - m.lnWidth * 0.5)
		m.lnTop = m.lnTop + INT(-(m.lnWidth * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) - m.lnHeight * 0.5)
		
		LOCAL lnRotate
		m.lnRotate = INT(m.loRepObj.Rotate * 60000)
		
		
		IF EMPTY(m.loRepObj.PictureVal) = .T.
		    RETURN
		ENDIF
		
		
		LOCAL lcMediaPath
		m.lcMediaPath = "word/media"
		
		LOCAL lcImageFile
		m.lcImageFile = TEXTMERGE("image<<m.loRepObj.ObjID>>.png")
		
		This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, m.lcMediaPath + "/" + m.lcImageFile, m.loRepObj.PictureVal, LEN(m.loRepObj.PictureVal))
		
		
		LOCAL loRel
		m.loRel = NEWOBJECT("Empty")
		ADDPROPERTY(m.loRel, "Id", TEXTMERGE("rId<<This.DocRels.Count + 1>>"))
		ADDPROPERTY(m.loRel, "Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image")
		ADDPROPERTY(m.loRel, "Target", TEXTMERGE("media/<<m.lcImageFile>>"))
		This.DocRels.Add(m.loRel, m.loRel.Id)
		
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		
		    TEXT TO m.loPage.ContentXML ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <w:drawing>
		        <wp:anchor distT="0" distB="0" distL="0" distR="0" simplePos="0" relativeHeight="<<m.loRepObj.ObjID>>" behindDoc="0" locked="0" layoutInCell="0" allowOverlap="1">
		            <wp:simplePos x="0" y="0" />
		            <wp:positionH relativeFrom="margin">
		                <wp:posOffset><<m.lnLeft>></wp:posOffset>
		            </wp:positionH>
		            <wp:positionV relativeFrom="margin">
		                <wp:posOffset><<m.lnTop>></wp:posOffset>
		            </wp:positionV>
		            <wp:extent cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		            <wp:effectExtent l="0" t="0" r="0" b="0"/>
		            <wp:wrapNone />
		            <wp:docPr id="<<m.loRepObj.ObjID>>" name="Picture<<m.loRepObj.ObjID>>" />
		            <wp:cNvGraphicFramePr>
		                <a:graphicFrameLocks
		                    xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" 
		                    noDrilldown="1" noSelect="1" noMove="1" noResize="1"/>
		            </wp:cNvGraphicFramePr>
		            <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
		                <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">
		                    <pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">
		                        <pic:nvPicPr>
		                            <pic:cNvPr id="<<m.loRepObj.ObjID>>" name="Picture<<m.loRepObj.ObjID>>" />
		                            <pic:cNvPicPr preferRelativeResize="0" />
		                        </pic:nvPicPr>
		                        <pic:blipFill>
		                            <a:blip r:embed="<<This.XmlEscape(m.loRel.Id)>>" />
		                            <a:stretch>
		                                <a:fillRect />
		                            </a:stretch>
		                        </pic:blipFill>
		                        <pic:spPr>
		                            <a:xfrm rot="<<m.lnRotate>>">
		                                <a:off x="0" y="0" />
		                                <a:ext cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		                            </a:xfrm>
		                            <a:prstGeom prst="rect">
		                                <a:avLst />
		                            </a:prstGeom>
		                        </pic:spPr>
		                    </pic:pic>
		                </a:graphicData>
		            </a:graphic>
		        </wp:anchor>
		    </w:drawing>
		    ENDTEXT
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE render_frxrectangle
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		LOCAL loFRXC
		m.loFRXC = This.env.API_FRX.CONST
		
		
		LOCAL loPage
		m.loPage = This.Pages.Item(This.Pages.Count)
		
		LOCAL lnEmuCoef
		m.lnEmuCoef = 914400 / 96
		
		LOCAL lnLineWidth
		IF m.loRepObj.PenPat >= 1
		    m.lnLineWidth = INT(MAX(m.loRepObj.PenSize, 1) * m.lnEmuCoef)
		ELSE
		    m.lnLineWidth = 0
		ENDIF
		
		   
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = INT(m.loRepObj.PosLeft * m.lnEmuCoef)
		m.lnTop = INT(m.loRepObj.PosTop * m.lnEmuCoef)
		m.lnWidth = INT(m.loRepObj.SizeWidth * m.lnEmuCoef)
		m.lnHeight = INT(m.loRepObj.SizeHeight * m.lnEmuCoef)
		
		
		m.lnLeft = m.lnLeft + INT((m.lnWidth * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) - m.lnWidth * 0.5)
		m.lnTop = m.lnTop + INT(-(m.lnWidth * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) - m.lnHeight * 0.5)
		
		
		LOCAL lnRotate
		m.lnRotate = INT(m.loRepObj.Rotate * 60000)
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		
		
		    LOCAL lcDash
		    DO CASE
		    CASE m.loRepObj.PenPat = 8 && Normal
		        m.lcDash = '<a:prstDash val="solid"/>'
		
		    CASE m.loRepObj.PenPat = 1 && Dot
		        m.lcDash = '<a:prstDash val="dot"/>'
		        
		    CASE m.loRepObj.PenPat = 2 && Dash
		        m.lcDash = '<a:prstDash val="dash"/>'
		        
		    CASE m.loRepObj.PenPat = 3 && Dash-dot
		        m.lcDash = '<a:prstDash val="dashDot"/>'
		        
		    CASE m.loRepObj.PenPat = 4 && Dash-dot-dot
		        m.lcDash = '<a:prstDash val="lgDashDotDot"/>'
		
		    OTHERWISE && Normal
		        m.lcDash = '<a:prstDash val="solid"/>'
		
		    ENDCASE
		
		
		    LOCAL llFill, llStroke
		    DO CASE
		    CASE m.loRepObj.Transparent = 0 AND m.loRepObj.FillPat > 0 AND m.loRepObj.PenPat = 0
		        m.llFill = .T.
		        m.llStroke = .F.
		    CASE m.loRepObj.Transparent = 0 AND m.loRepObj.FillPat > 0
		        m.llFill = .T.
		        m.llStroke = .T.
		    OTHERWISE 
		        m.llFill = .F.
		        m.llStroke = .T.
		    ENDCASE
		
		    LOCAL lcFill
		    IF m.llFill = .F.
		        m.lcFill = "<a:noFill />"
		    ELSE
		        TEXT TO m.lcFill TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <a:solidFill>
		           <a:srgbClr val="<<STRCONV(CHR(m.loRepObj.FillRed)+CHR(m.loRepObj.FillGreen)+CHR(m.loRepObj.FillBlue),15)>>">
		               <a:alpha val="<<INT(100000 * m.loRepObj.FillAlpha/255)>>" />
		           </a:srgbClr>
		         </a:solidFill>
		        ENDTEXT
		    ENDIF
		
		    LOCAL lcStroke
		    IF m.llStroke = .F. OR EMPTY(m.lnLineWidth)
		        m.lcStroke = "<a:noFill />"
		    ELSE
		        TEXT TO m.lcStroke TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <a:solidFill>
		           <a:srgbClr val="<<STRCONV(CHR(m.loRepObj.PenRed)+CHR(m.loRepObj.PenGreen)+CHR(m.loRepObj.PenBlue),15)>>">
		               <a:alpha val="<<INT(100000 * m.loRepObj.PenAlpha/255)>>" />
		           </a:srgbClr>
		         </a:solidFill>
		         <<m.lcDash>>
		        ENDTEXT
		    ENDIF
		
		
		    LOCAL lcRectGeom
		    DO CASE
		    CASE m.loRepObj.RectCurvature = 0 && Normal rectangle
		
		        TEXT TO m.lcRectGeom TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <a:prstGeom prst="rect">
		            <a:avLst />
		        </a:prstGeom>
		        ENDTEXT
		
		    CASE BETWEEN(m.loRepObj.RectCurvature, 1, 98) AND m.loRepObj.RectCurvature <= MAX(m.lnWidth, m.lnHeight)/2  && Rounded rectangle
		
		        LOCAL lnRay
		        m.lnRay = ROUND(IIF(m.lnWidth > m.lnHeight, MIN(m.loRepObj.RectCurvature * m.lnEmuCoef, INT(m.lnHeight / 2)), MIN(m.loRepObj.RectCurvature * m.lnEmuCoef, INT(m.lnWidth / 2))), 0)
		        
		        LOCAL lnRight, lnBottom
		        m.lnRight = m.lnWidth
		        m.lnBottom = m.lnHeight
		
		
		        TEXT TO m.lcRectGeom TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <a:custGeom>
		            <a:pathLst>
		                <a:path>
		                    <a:moveTo>
		                        <a:pt x="<<m.lnRay>>" y="<<m.lnBottom>>"/>
		                    </a:moveTo>
		                    <a:lnTo>
		                        <a:pt x="<<m.lnRight - m.lnRay>>" y="<<m.lnBottom>>"/>
		                    </a:lnTo>
		                    <a:cubicBezTo>
		                        <a:pt x="<<m.lnRight>>" y="<<m.lnBottom>>"/>
		                        <a:pt x="<<m.lnRight>>" y="<<m.lnBottom>>"/>
		                        <a:pt x="<<m.lnRight>>" y="<<m.lnBottom - m.lnRay>>"/>
		                    </a:cubicBezTo>
		                    <a:lnTo>
		                        <a:pt x="<<m.lnRight>>" y="<<m.lnRay>>"/>
		                    </a:lnTo>
		                    <a:cubicBezTo>
		                        <a:pt x="<<m.lnRight>>" y="0"/>
		                        <a:pt x="<<m.lnRight>>" y="0"/>
		                        <a:pt x="<<m.lnRight - m.lnRay>>" y="0"/>
		                    </a:cubicBezTo>
		                    <a:lnTo>
		                        <a:pt x="<<m.lnRay>>" y="0"/>
		                    </a:lnTo>
		                    <a:cubicBezTo>
		                        <a:pt x="0" y="0"/>
		                        <a:pt x="0" y="0"/>
		                        <a:pt x="0" y="<<m.lnRay>>"/>
		                    </a:cubicBezTo>
		                    <a:lnTo>
		                        <a:pt x="0" y="<<m.lnBottom - m.lnRay>>"/>
		                    </a:lnTo>
		                    <a:cubicBezTo>
		                        <a:pt x="0" y="<<m.lnBottom>>"/>
		                        <a:pt x="0" y="<<m.lnBottom>>"/>
		                        <a:pt x="<<m.lnRay>>" y="<<m.lnBottom>>"/>
		                    </a:cubicBezTo>
		                </a:path>
		            </a:pathLst>
		        </a:custGeom>
		        ENDTEXT
		
		    OTHERWISE && Ellipse
		
		        TEXT TO m.lcRectGeom TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <a:prstGeom prst="ellipse">
		            <a:avLst />
		        </a:prstGeom>
		        ENDTEXT
		            
		    ENDCASE
		
		
		    TEXT TO m.loPage.ContentXML ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <w:drawing>
		        <wp:anchor distT="0" distB="0" distL="0" distR="0" simplePos="0" relativeHeight="<<m.loRepObj.ObjID>>" behindDoc="0" locked="0" layoutInCell="0" allowOverlap="1">
		            <wp:simplePos x="0" y="0" />
		            <wp:positionH relativeFrom="margin">
		                <wp:posOffset><<m.lnLeft>></wp:posOffset>
		            </wp:positionH>
		            <wp:positionV relativeFrom="margin">
		                <wp:posOffset><<m.lnTop>></wp:posOffset>
		            </wp:positionV>
		            <wp:extent cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		            <wp:effectExtent l="0" t="0" r="0" b="0"/>
		            <wp:wrapNone />
		            <wp:docPr id="<<m.loRepObj.ObjID>>" name="Rectangle<<m.loRepObj.ObjID>>" />
		            <wp:cNvGraphicFramePr>
		                <a:graphicFrameLocks
		                    xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" 
		                    noDrilldown="1" noSelect="1" noMove="1" noResize="1"/>
		            </wp:cNvGraphicFramePr>
		            <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
		                <a:graphicData uri="http://schemas.microsoft.com/office/word/2010/wordprocessingShape">
		                    <wps:wsp>
		                        <wps:cNvCnPr />
		                        <wps:spPr>
		                            <a:xfrm rot="<<m.lnRotate>>">
		                                <a:off x="0" y="0" />
		                                <a:ext cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		                            </a:xfrm>
		                            <<m.lcRectGeom>>
		                            <<m.lcFill>>
		                            <a:ln w="<<m.lnLineWidth>>">
		                                <<m.lcStroke>>
		                                <a:miter lim="800%" />
		                                <a:headEnd />
		                                <a:tailEnd />
		                            </a:ln>
		                        </wps:spPr>
		                        <wps:bodyPr />
		                    </wps:wsp>
		                </a:graphicData>
		            </a:graphic>
		        </wp:anchor>
		    </w:drawing>
		    ENDTEXT
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE render_text
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		LOCAL loFRXC
		m.loFRXC = This.env.API_FRX.CONST
		
		LOCAL loPage
		m.loPage = This.Pages.Item(This.Pages.Count)
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL lnEmuCoef
		m.lnEmuCoef = 914400 / 96
		
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = INT(m.loRepObj.PosLeft * m.lnEmuCoef)
		m.lnTop = INT(m.loRepObj.PosTop * m.lnEmuCoef)
		m.lnWidth = INT(m.loRepObj.SizeWidth * m.lnEmuCoef)
		m.lnHeight = INT(m.loRepObj.SizeHeight * m.lnEmuCoef)
		
		LOCAL lnWidthAdd
		m.lnWidthAdd = 0
		DO CASE
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		    m.lnWidthAdd = m.loRepObj.Font.FontHeightCeil
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_FIELD()
		    m.lnWidthAdd = 2
		ENDCASE
		
		m.lnWidth = m.lnWidth + INT(m.lnWidthAdd * m.lnEmuCoef)
		
		DO CASE
		CASE m.loRepObj.Align = m.loFRXC.ALIGN_RIGHT()
		    m.lnLeft = m.lnLeft - INT(m.lnWidthAdd * m.lnEmuCoef)
		
		CASE m.loRepObj.Align = m.loFRXC.ALIGN_CENTER()
		    m.lnLeft = m.lnLeft - INT(m.lnWidthAdd * 0.5 * m.lnEmuCoef)
		
		ENDCASE
		
		
		m.lnLeft = m.lnLeft + INT((m.lnWidth * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) - m.lnWidth * 0.5)
		m.lnTop = m.lnTop + INT(-(m.lnWidth * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) - m.lnHeight * 0.5)
		
		LOCAL lnLineSpacing
		m.lnLineSpacing = ROUND(m.loRepObj.Font.LineHeight * ICASE(m.loRepObj.LineSpacing = 1, 1.5, m.loRepObj.LineSpacing = 2, 2, 1) * m.lnDpiCoef,2)
		
		
		LOCAL lnRotate
		m.lnRotate = INT(m.loRepObj.Rotate * 60000)
		
		
		LOCAL loFont
		m.loFont = This.GetFont(m.loRepObj)
		
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		
		    LOCAL lcText
		    m.lcText = ""
		
		    LOCAL laLines(1), lnLinesCount, liLine, loLine
		    m.lnLinesCount = m.loRepObj.Render_Text(@m.laLines)
		
		    FOR m.liLine = 1 TO m.lnLinesCount
		        m.loLine = m.laLines[m.liLine]
		
		        LOCAL lcStyleTextFill
		        m.lcStyleTextFill = ""
		        IF m.loRepObj.PenAlpha < 255
		            TEXT TO m.lcStyleTextFill NOSHOW TEXTMERGE FLAGS 1 PRETEXT 15
		            <w14:textFill>
		                <w14:solidFill>
		                    <w14:srgbClr w14:val="<<STRCONV(CHR(m.loRepObj.PenRed)+CHR(m.loRepObj.PenGreen)+CHR(m.loRepObj.PenBlue),15)>>">
		                        <w14:alpha w14:val="<<100000 - INT(100000 * m.loRepObj.PenAlpha/255)>>"/>
		                    </w14:srgbClr>
		                </w14:solidFill>
		            </w14:textFill>
		            ENDTEXT
		        ENDIF
		
		        TEXT TO m.lcText ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <w:p>
		            <w:pPr>
		                <w:spacing w:line="<<m.lnLineSpacing>>pt" w:lineRule="exact" />
		                <w:jc w:val="<<ICASE(m.loRepObj.Align = m.loFRXC.ALIGN_CENTER(), 'center', m.loRepObj.Align = m.loFRXC.ALIGN_RIGHT(), 'right', 'left')>>"/>
		            </w:pPr>
		            <w:r>
		                <w:rPr>
		                    <w:rFonts 
		                        w:ascii="<<This.XmlEscape(STRCONV(m.loRepObj.FontFace,9))>>" 
		                        w:eastAsia="<<This.XmlEscape(STRCONV(m.loRepObj.FontFace,9))>>" 
		                        w:hAnsi="<<This.XmlEscape(STRCONV(m.loRepObj.FontFace,9))>>" 
		                        w:cs="<<This.XmlEscape(STRCONV(m.loRepObj.FontFace,9))>>"/>
		                    <w:sz w:val="<<m.loRepObj.FontSize * 2>>"/>
		                    <w:szCs w:val="<<m.loRepObj.FontSize * 2>>"/>
		                    <<IIF(m.loRepObj.FontBold, '<w:b/><w:bCs/>', '')>>
		                    <<IIF(m.loRepObj.FontItalic, '<w:i/><w:iCs/>', '')>>
		                    <<IIF(m.loRepObj.FontUnderline, '<w:u w:val="single"/>', '')>>
		                    <<IIF(m.loRepObj.FontStrikeout, '<w:strike/>', '')>>
		                    <w:color w:val="<<STRCONV(CHR(m.loRepObj.PenRed)+CHR(m.loRepObj.PenGreen)+CHR(m.loRepObj.PenBlue),15)>>" />
		                    <<m.lcStyleTextFill>>
		                </w:rPr>
		                <w:t><<This.XmlEscape(RTRIM(STRCONV(m.loLine.Text, 10), 1, CHR(10),CHR(13)))>></w:t>
		            </w:r>
		        </w:p>
		        ENDTEXT
		
		    ENDFOR
		
		    LOCAL lcFill
		    IF m.loRepObj.Transparent=1
		        m.lcFill = "<a:noFill />"
		    ELSE
		        TEXT TO m.lcFill TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <a:solidFill>
		           <a:srgbClr val="<<STRCONV(CHR(m.loRepObj.FillRed)+CHR(m.loRepObj.FillGreen)+CHR(m.loRepObj.FillBlue),15)>>">
		               <a:alpha val="<<INT(100000 * m.loRepObj.FillAlpha/255)>>" />
		           </a:srgbClr>
		         </a:solidFill>
		        ENDTEXT
		    ENDIF
		
		
		    TEXT TO m.loPage.ContentXML ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <w:drawing>
		        <wp:anchor distT="0" distB="0" distL="0" distR="0" simplePos="0" relativeHeight="<<m.loRepObj.ObjID>>" behindDoc="0" locked="0" layoutInCell="0" allowOverlap="1">
		            <wp:simplePos x="0" y="0" />
		            <wp:positionH relativeFrom="margin">
		                <wp:posOffset><<m.lnLeft>></wp:posOffset>
		            </wp:positionH>
		            <wp:positionV relativeFrom="margin">
		                <wp:posOffset><<m.lnTop>></wp:posOffset>
		            </wp:positionV>
		            <wp:extent cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		            <wp:effectExtent l="0" t="0" r="0" b="0"/>
		            <wp:wrapNone />
		            <wp:docPr id="<<m.loRepObj.ObjID>>" name="Field<<m.loRepObj.ObjID>>" />
		            <wp:cNvGraphicFramePr>
		                <a:graphicFrameLocks
		                    xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" 
		                    noDrilldown="1" noSelect="1" noMove="1" noResize="1"/>
		            </wp:cNvGraphicFramePr>
		            <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
		                <a:graphicData uri="http://schemas.microsoft.com/office/word/2010/wordprocessingShape">
		                    <wps:wsp>
		                        <wps:cNvSpPr txBox="1">
		                            <a:spLocks noChangeArrowheads="1" />
		                        </wps:cNvSpPr>
		                        <wps:spPr bwMode="auto">
		                            <a:xfrm rot="<<m.lnRotate>>">
		                                <a:off x="0" y="0" />
		                                <a:ext cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		                            </a:xfrm>
		                            <a:prstGeom prst="rect">
		                                <a:avLst />
		                            </a:prstGeom>
		                            <<m.lcFill>>
		                            <a:ln w="9525">
		                                <a:noFill />
		                                <a:miter lim="800%" />
		                                <a:headEnd />
		                                <a:tailEnd />
		                            </a:ln>
		                        </wps:spPr>
		                        <wps:txbx>
		                            <w:txbxContent>
		                                <<m.lcText>>
		                            </w:txbxContent>
		                        </wps:txbx>
		                        <wps:bodyPr rot="0" vert="horz" wrap="square" lIns="0" tIns="0" rIns="0" bIns="0" anchor="t" anchorCtr="0">
		                            <a:noAutofit />
		                        </wps:bodyPr>
		                    </wps:wsp>
		                </a:graphicData>
		            </a:graphic>
		        </wp:anchor>
		    </w:drawing>
		    ENDTEXT
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_content_types
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		        
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
		        <Default Extension="jpg" ContentType="image/jpeg" />
		        <Default Extension="png" ContentType="image/png" />
		        <Default Extension="odttf"
		            ContentType="application/vnd.openxmlformats-officedocument.obfuscatedFont" />
		        <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
		        <Default Extension="xml" ContentType="application/xml" />
		        <Override PartName="/word/document.xml"
		            ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml" />
		        <Override PartName="/word/styles.xml"
		            ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml" />
		        <Override PartName="/word/settings.xml"
		            ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml" />
		        <Override PartName="/word/webSettings.xml"
		            ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml" />
		        <Override PartName="/word/fontTable.xml"
		            ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml" />
		        <Override PartName="/docProps/core.xml"
		            ContentType="application/vnd.openxmlformats-package.core-properties+xml" />
		        <Override PartName="/docProps/app.xml"
		            ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml" />
		    </Types>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "[Content_Types].xml", m.lcXml, LEN(m.lcXml))
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_docprops
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		        
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties"
		        xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
		        <Template>Normal.dotm</Template>
		        <Application>Microsoft Office Word</Application>
		        <DocSecurity>0</DocSecurity>
		        <ScaleCrop>false</ScaleCrop>
		        <Company></Company>
		        <LinksUpToDate>false</LinksUpToDate>
		        <SharedDoc>false</SharedDoc>
		        <HyperlinksChanged>false</HyperlinksChanged>
		        <AppVersion>16.0000</AppVersion>
		    </Properties>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "docProps/app.xml", m.lcXml, LEN(m.lcXml))
		
		
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <cp:coreProperties
		        xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"
		        xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/"
		        xmlns:dcmitype="http://purl.org/dc/dcmitype/"
		        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		        <dc:creator></dc:creator>
		        <cp:lastModifiedBy></cp:lastModifiedBy>
		        <cp:revision>3</cp:revision>
		        <dcterms:created xsi:type="dcterms:W3CDTF"><<TTOC(DATETIME(),3)>>Z</dcterms:created>
		        <dcterms:modified xsi:type="dcterms:W3CDTF"><<TTOC(DATETIME(),3)>>Z</dcterms:modified>
		    </cp:coreProperties>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "docProps/core.xml", m.lcXml, LEN(m.lcXml))
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_document
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		    
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml ADDITIVE NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <w:document xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas"
		        xmlns:cx="http://schemas.microsoft.com/office/drawing/2014/chartex"
		        xmlns:cx1="http://schemas.microsoft.com/office/drawing/2015/9/8/chartex"
		        xmlns:cx2="http://schemas.microsoft.com/office/drawing/2015/10/21/chartex"
		        xmlns:cx3="http://schemas.microsoft.com/office/drawing/2016/5/9/chartex"
		        xmlns:cx4="http://schemas.microsoft.com/office/drawing/2016/5/10/chartex"
		        xmlns:cx5="http://schemas.microsoft.com/office/drawing/2016/5/11/chartex"
		        xmlns:cx6="http://schemas.microsoft.com/office/drawing/2016/5/12/chartex"
		        xmlns:cx7="http://schemas.microsoft.com/office/drawing/2016/5/13/chartex"
		        xmlns:cx8="http://schemas.microsoft.com/office/drawing/2016/5/14/chartex"
		        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		        xmlns:aink="http://schemas.microsoft.com/office/drawing/2016/ink"
		        xmlns:am3d="http://schemas.microsoft.com/office/drawing/2017/model3d"
		        xmlns:o="urn:schemas-microsoft-com:office:office"
		        xmlns:oel="http://schemas.microsoft.com/office/2019/extlst"
		        xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
		        xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
		        xmlns:v="urn:schemas-microsoft-com:vml"
		        xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing"
		        xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
		        xmlns:w10="urn:schemas-microsoft-com:office:word"
		        xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
		        xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
		        xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml"
		        xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex"
		        xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid"
		        xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml"
		        xmlns:w16du="http://schemas.microsoft.com/office/word/2023/wordml/word16du"
		        xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash"
		        xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex"
		        xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup"
		        xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk"
		        xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml"
		        xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
		        mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du wp14"
		        w:conformance="strict">
		        <w:body>
		    ENDTEXT
		
		    LOCAL loPage, liPage, lcSectPr, lcSectPrDefault
		    m.liPage = 0
		    m.lcSectPr = ""
		    m.lcSectPrDefault = ""
		    FOR EACH m.loPage IN This.Pages FOXOBJECT
		        m.liPage = m.liPage + 1
		        
		        TEXT TO m.lcSectPr TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <w:sectPr>
		            <w:pgSz w:w="<<m.loPage.PageWidth>>pt" w:h="<<m.loPage.PageHeight>>pt" w:orient="<<IIF(m.loPage.PageWidth > m.loPage.PageHeight, 'landscape', 'portrait')>>" />
		            <w:pgMar w:top="18pt" w:right="0pt" w:bottom="0pt" w:left="12.25pt" w:header="0pt" w:footer="0pt" w:gutter="0pt" />
		            <w:cols w:space="36pt" />
		        </w:sectPr>
		        ENDTEXT
		        
		        IF m.liPage = This.Pages.Count
		            m.lcSectPrDefault = m.lcSectPr
		            m.lcSectPr = ""
		        ENDIF
		        
		        TEXT TO m.lcXml ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <<m.loPage.ContentXML>>
		        <w:p>
		            <w:pPr>
		                <w:pStyle w:val="Default" />
		                <<m.lcSectPr>>
		            </w:pPr>
		        </w:p>
		        ENDTEXT
		    ENDFOR
		
		    IF EMPTY(m.lcSectPrDefault) = .T.
		        TEXT TO m.lcSectPrDefault NOSHOW FLAGS 1 PRETEXT 15
		        <w:sectPr>
		            <w:pgSz w:w="595.20pt" w:h="841.80pt" w:orient="portrait" />
		            <w:pgMar w:top="18pt" w:right="0pt" w:bottom="0pt" w:left="12.25pt" w:header="0pt" w:footer="0pt" w:gutter="0pt" />
		            <w:cols w:space="36pt" />
		        </w:sectPr>
		        ENDTEXT
		    ENDIF
		
		    TEXT TO m.lcXml ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		            <<m.lcSectPrDefault>>
		        </w:body>
		    </w:document>
		    ENDTEXT
		
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/document.xml", m.lcXml, LEN(m.lcXml))
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_fonttable
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		    
		    LOCAL lcFontsXml
		    m.lcFontsXml = ""
		
		    LOCAL loFont
		    FOR EACH m.loFont IN This.Fonts FOXOBJECT
		
		        LOCAL lcFontEmbedXML
		        m.lcFontEmbedXML = ""
		        IF VARTYPE(m.loFont.FontFile) = "O" 
		            TEXT TO m.lcFontEmbedXML TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		            <w:embedRegular r:id="<<m.loFont.FontFile.rid>>" w:subsetted="1"/>
		            <w:embedBold r:id="<<m.loFont.FontFile.rid>>" w:subsetted="1"/>    
		            ENDTEXT
		        ENDIF
		
		        TEXT TO m.lcFontsXml ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <w:font w:name="<<This.XmlEscape(STRCONV(m.loFont.name,9))>>">
		            <w:family w:val="auto" />
		            <w:pitch w:val="variable" />
		            <<m.lcFontEmbedXML>>
		        </w:font>
		        ENDTEXT
		    ENDFOR
		
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <w:fonts xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		        xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
		        xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
		        xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
		        xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml"
		        xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex"
		        xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid"
		        xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml"
		        xmlns:w16du="http://schemas.microsoft.com/office/word/2023/wordml/word16du"
		        xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash"
		        xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex"
		        mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du">
		        <<m.lcFontsXml>>
		    </w:fonts>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/fontTable.xml", m.lcXml, LEN(m.lcXml))
		
		    LOCAL lcFontRelsXml
		    m.lcFontRelsXml = ""
		
		    LOCAL loFontFile
		    FOR EACH m.loFontFile IN This.FontFiles FOXOBJECT
		        TEXT TO m.lcFontRelsXml ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <Relationship Id="<<m.loFontFile.rid>>"
		            Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/font"
		            Target="fonts/<<This.XmlEscape(STRCONV(m.loFontFile.FontFileName,9))>>" />
		        ENDTEXT
		    ENDFOR
		
		    IF EMPTY(m.lcFontRelsXml) = .F.
		        LOCAL lcXml
		        m.lcXml = ""
		
		        TEXT TO m.lcXml TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		        <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
		            <<m.lcFontRelsXml>>
		        </Relationships>
		        ENDTEXT
		
		        This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/_rels/fontTable.xml.rels", m.lcXml, LEN(m.lcXml))
		    ENDIF
		    
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_rels
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		    
		    LOCAL lcXml
		    m.lcXml = ""
		    TEXT TO m.lcXml NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
		        <Relationship Id="rId3"
		            Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties"
		            Target="docProps/app.xml" />
		        <Relationship Id="rId2"
		            Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties"
		            Target="docProps/core.xml" />
		        <Relationship Id="rId1"
		            Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument"
		            Target="word/document.xml" />
		    </Relationships>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "_rels/.rels", m.lcXml, LEN(m.lcXml))
		
		    LOCAL lcXml
		    m.lcXml = ""
		    TEXT TO m.lcXml ADDITIVE NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
		    ENDTEXT
		
		    LOCAL loRel
		    FOR EACH m.loRel IN This.DocRels FOXOBJECT
		        TEXT TO m.lcXml ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <Relationship Id="<<This.XmlEscape(m.loRel.Id)>>" 
		            Type="<<This.XmlEscape(m.loRel.Type)>>" 
		            Target="<<This.XmlEscape(m.loRel.Target)>>" />
		        ENDTEXT
		    ENDFOR
		
		    TEXT TO m.lcXml ADDITIVE NOSHOW FLAGS 1 PRETEXT 15
		    </Relationships>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/_rels/document.xml.rels", m.lcXml, LEN(m.lcXml))
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_settings
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		    
		    LOCAL llFontEmbed
		    m.llFontEmbed = (This.FontFiles.Count > 0)
		    
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <w:settings xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		        xmlns:o="urn:schemas-microsoft-com:office:office"
		        xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
		        xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
		        xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w10="urn:schemas-microsoft-com:office:word"
		        xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
		        xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
		        xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml"
		        xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex"
		        xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid"
		        xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml"
		        xmlns:w16du="http://schemas.microsoft.com/office/word/2023/wordml/word16du"
		        xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash"
		        xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex"
		        xmlns:sl="http://schemas.openxmlformats.org/schemaLibrary/2006/main"
		        mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du">
		        <w:zoom w:percent="100" />
		        <w:embedTrueTypeFonts w:val="<<IIF(m.llFontEmbed, 1, 0)>>" />
		        <w:embedSystemFonts w:val="0" />
		        <w:saveSubsetFonts w:val="<<IIF(m.llFontEmbed, 1, 0)>>" />
		        <w:proofState w:grammar="clean" />
		        <w:defaultTabStop w:val="720" />
		        <w:autoHyphenation w:val="0" />
		        <w:characterSpacingControl w:val="doNotCompress" />
		        <w:compat>
		            <w:compatSetting w:name="compatibilityMode" w:uri="http://schemas.microsoft.com/office/word"
		                w:val="15" />
		            <w:compatSetting w:name="overrideTableStyleFontSizeAndJustification"
		                w:uri="http://schemas.microsoft.com/office/word" w:val="1" />
		            <w:compatSetting w:name="enableOpenTypeFeatures"
		                w:uri="http://schemas.microsoft.com/office/word" w:val="1" />
		            <w:compatSetting w:name="doNotFlipMirrorIndents"
		                w:uri="http://schemas.microsoft.com/office/word" w:val="1" />
		            <w:compatSetting w:name="differentiateMultirowTableHeaders"
		                w:uri="http://schemas.microsoft.com/office/word" w:val="1" />
		            <w:compatSetting w:name="useWord2013TrackBottomHyphenation"
		                w:uri="http://schemas.microsoft.com/office/word" w:val="1" />
		        </w:compat>
		    </w:settings>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/settings.xml", m.lcXml, LEN(m.lcXml))
		
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <w:webSettings xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		        xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
		        xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
		        xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
		        xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml"
		        xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex"
		        xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid"
		        xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml"
		        xmlns:w16du="http://schemas.microsoft.com/office/word/2023/wordml/word16du"
		        xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash"
		        xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex"
		        mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du">
		        <w:optimizeForBrowser />
		        <w:allowPNG />
		    </w:webSettings>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/webSettings.xml", m.lcXml, LEN(m.lcXml))
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_styles
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		    
		    LOCAL lcXml
		    m.lcXml = ""
		
		
		    TEXT TO m.lcXml TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <w:styles xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		        xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
		        xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
		        xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
		        xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml"
		        xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex"
		        xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid"
		        xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml"
		        xmlns:w16du="http://schemas.microsoft.com/office/word/2023/wordml/word16du"
		        xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash"
		        xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex"
		        mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du">
		        <w:docDefaults>
		            <w:rPrDefault>
		                <w:rPr>
		                    <w:rFonts w:asciiTheme="minorHAnsi" w:eastAsiaTheme="minorHAnsi" w:hAnsiTheme="minorHAnsi" w:cstheme="minorBidi" />
		                    <w:kern w:val="2" />
		                    <w:sz w:val="16" />
		                    <w:szCs w:val="16" />
		                    <w14:ligatures w14:val="standardContextual" />
		                </w:rPr>
		            </w:rPrDefault>
		            <w:pPrDefault>
		                <w:pPr>
		                    <w:spacing w:after="0" w:line="240" w:lineRule="auto"/>
		                </w:pPr>
		            </w:pPrDefault>
		        </w:docDefaults>
		        <w:latentStyles w:defLockedState="0" w:defUIPriority="99" w:defSemiHidden="0"
		            w:defUnhideWhenUsed="0" w:defQFormat="0" w:count="376">
		            <w:lsdException w:name="Normal" w:uiPriority="0" w:qFormat="1" />
		            <w:lsdException w:name="Default Paragraph Font" w:semiHidden="1" w:uiPriority="1" w:unhideWhenUsed="1" />
		        </w:latentStyles>
		        <w:style w:type="paragraph" w:default="1" w:styleId="a">
		            <w:name w:val="Normal" />
		            <w:qFormat />
		        </w:style>
		        <w:style w:type="character" w:default="1" w:styleId="a0">
		            <w:name w:val="Default Paragraph Font" />
		            <w:uiPriority w:val="1" />
		            <w:semiHidden />
		            <w:unhideWhenUsed />
		        </w:style>
		        <w:style w:type="paragraph" w:customStyle="1" w:styleId="Default">
		            <w:name w:val="_Default" />
		            <w:pPr>
		                <w:suppressAutoHyphens />
		            </w:pPr>
		        </w:style>
		    </w:styles>
		    ENDTEXT
		    
		    
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/styles.xml", m.lcXml, LEN(m.lcXml))
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE xmlescape
		LPARAMETERS lcText
		
		RETURN STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(m.lcText, "<", "&lt;"), ">", "&gt;"), "&", "&amp;"), '"', "&quot;"), "'", "&apos;")
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport_renderer_pdf AS pdfiumreport_renderer_base OF "pdfium-vfp.vcx" 		&& PDF rendering implementation
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: closepdf
		*m: createpdf
		*m: encrypt
		*m: getfontpdf
		*m: hash_md5
		*m: render_frxfield
		*m: render_frxlabel
		*m: render_frxline
		*m: render_frxpicture
		*m: render_frxrectangle
		*m: render_text
		*m: render_textasimage
		*p: fpdf_doc
		*p: fpdf_fonts		&& Font collection for caching purporses
		*p: fpdf_pagecount
		*p: pdftemplateheap
		*p: pdftemplateptr
		*a: fpdf_pages[1,0]
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,fpdf_doc,fpdf_fonts,fpdf_pagecount,fpdf_pages,HelpContextID,NewObject,Objects,pdftemplateheap,pdftemplateptr,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		fpdf_doc = 0
		fpdf_fonts = .F.
		fpdf_pagecount = 0
		Name = "pdfiumreport_renderer_pdf"
		pdftemplateheap = 0
		pdftemplateptr = 0
		_memberdata = <VFPData>
			<memberdata name="closepdf" type="method" display="ClosePDF"/>
			<memberdata name="createpdf" type="method" display="CreatePDF"/>
			<memberdata name="getfontpdf" type="method" display="GetFontPDF"/>
			<memberdata name="render_frxfield" type="method" display="Render_FrxField"/>
			<memberdata name="render_frxlabel" type="method" display="Render_FrxLabel"/>
			<memberdata name="render_frxline" type="method" display="Render_FrxLine"/>
			<memberdata name="render_frxpicture" type="method" display="Render_FrxPicture"/>
			<memberdata name="render_frxrectangle" type="method" display="Render_FrxRectangle"/>
			<memberdata name="render_text" type="method" display="Render_Text"/>
			<memberdata name="render_textasimage" type="method" display="Render_TextAsImage"/>
			<memberdata name="fpdf_doc" type="property" display="fpdf_doc"/>
			<memberdata name="fpdf_fonts" type="property" display="fpdf_fonts"/>
			<memberdata name="fpdf_pagecount" type="property" display="fpdf_pagecount"/>
			<memberdata name="fpdf_pages" type="property" display="fpdf_pages"/>
			<memberdata name="hash_md5" type="method" display="Hash_MD5"/>
			<memberdata name="encrypt" type="method" display="Encrypt"/>
			<memberdata name="pdftemplateheap" type="property" display="PDFTemplateHeap"/>
			<memberdata name="pdftemplateptr" type="property" display="PDFTemplatePtr"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE begin
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
		This.CreatePDF(m.loPDFMeta)
		
	ENDPROC

	HIDDEN PROCEDURE closepdf
		IF EMPTY(This.fpdf_doc)
		    RETURN
		ENDIF
		
		**************************************************
		* Release resources
		**************************************************
		LOCAL liPage, lnPage
		m.liPage = 1 
		FOR m.liPage = 1 TO This.fpdf_pagecount
		    m.lnPage = This.fpdf_pages[m.liPage]
		    IF EMPTY(m.lnPage) = .F.
		        This.env.API_FPDF.FPDF_ClosePage(m.lnPage)
		    ENDIF
		ENDFOR
		
		
		LOCAL lnPDFFont
		FOR EACH m.lnPDFFont IN This.fpdf_fonts FOXOBJECT
		    IF EMPTY(m.lnPDFFont) = .F.
		        This.env.API_FPDF.FPDFFont_Close(m.lnPDFFont)
		    ENDIF
		ENDFOR
		
		
		This.env.API_FPDF.FPDF_CloseDocument(This.fpdf_doc)
		
		
		DIMENSION This.fpdf_pages(1)
		This.fpdf_pages[1] = 0
		
		This.fpdf_pagecount = 0
		This.fpdf_doc = 0
		This.fpdf_fonts = .F.
		
		
		IF EMPTY(This.PDFTemplatePtr)=.F.
		    This.env.API_WIN.HeapFree(This.PDFTemplateHeap, 0, This.PDFTemplatePtr)
		    This.PDFTemplatePtr = 0 
		ENDIF
		
		IF EMPTY(This.PDFTemplateHeap)=.F.
		    This.env.API_WIN.HeapDestroy(This.PDFTemplateHeap)
		    This.PDFTemplateHeap = 0 
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE createpdf
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
		This.ClosePDF()
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		This.fpdf_fonts = NEWOBJECT("Collection")
		
		#define PWD_PAD 0h28BF4E5E4E758A4164004E56FFFA01082E2E00B6D0683E802F0CA9FE6453697A
		#define PWD_LEN 32
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		    
		    IF VARTYPE(m.loPDFMeta) != "O"
		        This.fpdf_doc = m.loFPDF.FPDF_CreateNewDocument()
		
		        IF EMPTY(This.fpdf_doc)
		            ERROR "FPDF_CreateNewDocument returned empty value"
		        ENDIF
		
		        EXIT
		    ENDIF
		
		    *******************************************************
		    LOCAL lcFileID
		    m.lcFileID = ""
		    This.Hash_MD5(;
		        BINTOC(DATETIME() - DATETIME(1970,1,1,0,0,0), "4RS") + ;
		        TRANSFORM(NVL(m.loPDFMeta.Author,"")) + ;
		        TRANSFORM(NVL(m.loPDFMeta.Creator,"")) + ;
		        TRANSFORM(NVL(m.loPDFMeta.Producer,"")) + ;
		        TRANSFORM(NVL(m.loPDFMeta.Title,"")) + ;
		        TRANSFORM(NVL(m.loPDFMeta.Subject,"")) + ;
		        TRANSFORM(NVL(m.loPDFMeta.Keywords,"")) ;
		        , @m.lcFileID)
		        
		
		
		    *******************************************************    
		
		    LOCAL lcOwnerPassword, lcUserPassword
		    m.lcUserPassword = NVL(m.loPDFMeta.UserPassword,"")
		    m.lcOwnerPassword = EVL(NVL(m.loPDFMeta.OwnerPassword,""), m.lcUserPassword)
		
		    IF LEN(m.lcUserPassword) > PWD_LEN
		        ERROR TEXTMERGE("User password cannot be more than <<PWD_LEN>> characters")
		    ENDIF
		
		    IF LEN(m.lcOwnerPassword) > PWD_LEN
		        ERROR TEXTMERGE("Owner password cannot be more than <<PWD_LEN>> characters")
		    ENDIF
		
		    LOCAL llEncrypt
		    m.llEncrypt = (LEN(m.lcOwnerPassword) = 0 AND LEN(m.lcUserPassword) = 0) = .F.
		
		
		    IF m.llEncrypt
		        LOCAL lnPermit as Integer
		        m.lnPermit = BITCLEAR(BITCLEAR(0xFFFFFFFF,0),1)
		        m.lnPermit = IIF(m.loPDFMeta.Permit_Print, m.lnPermit, BITCLEAR(m.lnPermit,2))
		        m.lnPermit = IIF(m.loPDFMeta.Permit_Edit_All, m.lnPermit, BITCLEAR(m.lnPermit,3))
		        m.lnPermit = IIF(m.loPDFMeta.Permit_Copy, m.lnPermit, BITCLEAR(m.lnPermit,4))
		        m.lnPermit = IIF(m.loPDFMeta.Permit_Edit, m.lnPermit, BITCLEAR(m.lnPermit,5)) 
		
		        m.lcUserPassword = LEFT(m.lcUserPassword + PWD_PAD, PWD_LEN)
		        m.lcOwnerPassword = LEFT(m.lcOwnerPassword + PWD_PAD, PWD_LEN)
		
		
		        LOCAL lcOwnerPasswordHash, lcOwnerKey
		        STORE "" TO m.lcOwnerPasswordHash, m.lcOwnerKey
		        This.Hash_MD5(m.lcOwnerPassword, @m.lcOwnerPasswordHash)
		        
		        LOCAL liRepeat
		        FOR m.liRepeat = 1 TO 50
		            This.Hash_MD5(m.lcOwnerPasswordHash, @m.lcOwnerPasswordHash)
		        ENDFOR
		        
		        
		        m.lcOwnerKey = LEFT(m.lcOwnerPasswordHash, PWD_LEN)
		        This.Encrypt("RC4", m.lcUserPassword, m.lcOwnerKey,  @m.lcOwnerKey)
		        
		        LOCAL i
		        FOR m.i = 1 TO 19
		            LOCAL j, lcTempKey
		            m.lcTempKey = ""
		            FOR m.j = 1 TO LEN(m.lcOwnerPasswordHash)
		                m.lcTempKey = m.lcTempKey + BINTOC(BITXOR(CTOBIN(SUBSTR(m.lcOwnerPasswordHash, m.j, 1), "1"), m.i), "1")
		            ENDFOR
		            
		            This.Encrypt("RC4", m.lcOwnerKey, m.lcTempKey,  @m.lcOwnerKey)
		        ENDFOR
		        
		
		        LOCAL lcEncryptionKey
		        STORE "" TO m.lcEncryptionKey
		        This.Hash_MD5(;
		            m.lcUserPassword +;
		            m.lcOwnerKey + ;
		            BINTOC(m.lnPermit,"4RS") +;
		            m.lcFileID, ;
		            @m.lcEncryptionKey)
		            
		        LOCAL liRepeat
		        FOR m.liRepeat = 1 TO 50
		            This.Hash_MD5(LEFT(m.lcEncryptionKey, 16), @m.lcEncryptionKey)
		        ENDFOR
		        
		        
		        LOCAL lcUserHash, lcUserKey
		        STORE "" TO m.lcUserHash, m.lcUserKey
		        This.Hash_MD5(;
		            PWD_PAD + ;
		            m.lcFileID, ;
		            @m.lcUserHash)
		
		        This.Encrypt("RC4", m.lcUserHash, m.lcEncryptionKey,  @m.lcUserKey)
		        
		        LOCAL i
		        FOR m.i = 1 TO 19
		            LOCAL j, lcTempKey
		            m.lcTempKey = ""
		            FOR m.j = 1 TO LEN(m.lcEncryptionKey)
		                m.lcTempKey = m.lcTempKey + BINTOC(BITXOR(CTOBIN(SUBSTR(m.lcEncryptionKey, m.j, 1), "1"), m.i), "1")
		            ENDFOR
		            
		            This.Encrypt("RC4", m.lcUserKey, m.lcTempKey,  @m.lcUserKey)
		        ENDFOR
		        
		        m.lcUserKey = PADR(m.lcUserKey, PWD_LEN, CHR(0))
		
		
		        LOCAL lnInfoObjId, lnInfoObjGen, lcInfoObjEncryptionKey
		        m.lnInfoObjId = 4
		        m.lnInfoObjGen = 0
		        m.lcInfoObjEncryptionKey = m.lcEncryptionKey
		        m.lcInfoObjEncryptionKey = m.lcInfoObjEncryptionKey + CHR(BITAND(m.lnInfoObjId, 0xFF))
		        m.lcInfoObjEncryptionKey = m.lcInfoObjEncryptionKey + CHR(BITAND(BITRSHIFT(m.lnInfoObjId, 8), 0xFF))
		        m.lcInfoObjEncryptionKey = m.lcInfoObjEncryptionKey + CHR(BITAND(BITRSHIFT(m.lnInfoObjId, 16), 0xFF))
		        m.lcInfoObjEncryptionKey = m.lcInfoObjEncryptionKey + CHR(BITAND(m.lnInfoObjGen, 0xFF))
		        m.lcInfoObjEncryptionKey = m.lcInfoObjEncryptionKey + CHR(BITAND(BITRSHIFT(m.lnInfoObjGen, 8), 0xFF))
		        
		        This.Hash_MD5(m.lcInfoObjEncryptionKey, @m.lcInfoObjEncryptionKey)
		
		    ENDIF
		
		    LOCAL lcPDFInfo, laPDFInfoTags(6), lcPDFInfoTag, liPDFInfoTag, lcPDFInfoTagValue, lcPDFInfoTagValueUTF16
		    m.lcPDFInfo = ""
		    m.laPDFInfoTags[1] = "Title"
		    m.laPDFInfoTags[2] = "Author"
		    m.laPDFInfoTags[3] = "Subject"
		    m.laPDFInfoTags[4] = "Keywords"
		    m.laPDFInfoTags[5] = "Creator"
		    m.laPDFInfoTags[6] = "Producer"
		
		    m.liPDFInfoTag = 1
		    FOR m.liPDFInfoTag = 1 TO ALEN(m.laPDFInfoTags,1)
		        m.lcPDFInfoTag = m.laPDFInfoTags[m.liPDFInfoTag]
		        IF PEMSTATUS(m.loPDFMeta, m.lcPDFInfoTag, 5) = .F.
		            LOOP
		        ENDIF
		        
		        m.lcPDFInfoTagValue = m.loPDFMeta.&lcPDFInfoTag
		        
		        IF EMPTY(m.lcPDFInfoTagValue) = .T.
		            LOOP
		        ENDIF
		        
		        
		        m.lcPDFInfoTagValueUTF16 = ""
		        LOCAL i
		        FOR m.i = 1 TO LEN(m.lcPDFInfoTagValue)
		            m.lcPDFInfoTagValueUTF16 = m.lcPDFInfoTagValueUTF16 + BINTOC(CTOBIN(STRCONV(SUBSTR(m.lcPDFInfoTagValue,m.i,1),5), "2RS"), "2S")
		        ENDFOR
		        
		        m.lcPDFInfoTagValueUTF16 = 0hFEFF + m.lcPDFInfoTagValueUTF16
		        
		        IF m.llEncrypt
		            This.Encrypt("RC4", m.lcPDFInfoTagValueUTF16, m.lcInfoObjEncryptionKey,  @m.lcPDFInfoTagValueUTF16)
		        ENDIF
		        
		        m.lcPDFInfo = m.lcPDFInfo + TEXTMERGE("/{m.lcPDFInfoTag} <{STRCONV(m.lcPDFInfoTagValueUTF16, 15)}>", .F., "{", "}")
		        
		    ENDFOR
		
		    LOCAL ldtNow, lcCreationDate
		    m.ldtNow = DATETIME()
		    m.lcCreationDate = TEXTMERGE("D:<<TTOC(m.ldtNow,1)>>")
		
		    IF m.llEncrypt
		        This.Encrypt("RC4", m.lcCreationDate, m.lcInfoObjEncryptionKey,  @m.lcCreationDate)
		    ENDIF
		    m.lcCreationDate = "<" + STRCONV(m.lcCreationDate,15) + ">"    
		
		
		    *******************************************************    
		    LOCAL loPDFTemplate
		    m.loPDFTemplate = NEWOBJECT("Collection")
		    m.loPDFTemplate.Add("%PDF-1.7")
		    m.loPDFTemplate.Add("1 0 obj<</Pages 2 0 R>>endobj")
		    m.loPDFTemplate.Add("2 0 obj<</Kids[3 0 R]/Count 1>>endobj")
		    m.loPDFTemplate.Add("3 0 obj<</Parent 2 0 R>>endobj")
		    m.loPDFTemplate.Add(TEXTMERGE("4 0 obj<<{ m.lcPDFInfo }/CreationDate { m.lcCreationDate }/ModDate { m.lcCreationDate }>>endobj", .F., "{", "}"))
		
		    IF m.llEncrypt        
		        LOCAL lcPDFEncrypt
		        TEXT TO m.lcPDFEncrypt ADDITIVE NOSHOW FLAGS 1 PRETEXT 3
		        5 0 obj
		        <<
		        /Filter /Standard
		        /V 2
		        /Length 128
		        /R 3
		        /O { "<" + STRCONV(m.lcOwnerKey,15) + ">" }
		        /U { "<" + STRCONV(m.lcUserKey,15) + ">" }
		        /P {m.lnPermit}
		        >> endobj
		        ENDTEXT
		        
		        m.loPDFTemplate.Add(TEXTMERGE(m.lcPDFEncrypt, .F., "{", "}"))
		    ENDIF
		
		    LOCAL lcPDFTemplate
		    m.lcPDFTemplate = ""
		
		    LOCAL lcXRef, m.lnXRefCount
		    m.lcXRef = "0000000000 65535 f"
		    m.lnXRefCount = 1
		
		    LOCAL lcPDFLine
		    FOR EACH m.lcPDFLine IN m.loPDFTemplate FOXOBJECT
		        IF LEFT(m.lcPDFLine,1) != '%'
		            m.lnXRefCount = m.lnXRefCount + 1
		            m.lcXRef = m.lcXRef + CHR(13)+CHR(10) + PADL(TRANSFORM(LEN(m.lcPDFTemplate)), 10, '0') + " 00000 n"
		        ENDIF
		        m.lcPDFTemplate = m.lcPDFTemplate + m.lcPDFLine + CHR(13)+CHR(10)
		    ENDFOR
		
		    LOCAL lnStartXRef
		    m.lnStartXRef = LEN(m.lcPDFTemplate)
		
		    TEXT TO m.lcPDFTemplate ADDITIVE NOSHOW FLAGS 1 PRETEXT 3
		    xref
		    0 { m.lnXRefCount }
		    { m.lcXREF }
		    trailer
		    <<
		    /Root 1 0 R
		    /Info 4 0 R
		    { IIF(m.llEncrypt, "/Encrypt 5 0 R", "") }
		    /Size { m.lnXRefCount }
		    /ID { "[<" + STRCONV(m.lcFileID, 15) + "> <" + STRCONV(m.lcFileID, 15) + ">]" }
		    >>
		    startxref
		    { m.lnStartXRef }
		    %%EOF
		    ENDTEXT
		     
		    m.lcPDFTemplate = TEXTMERGE(m.lcPDFTemplate, .F., "{", "}")
		
		    LOCAL lnPDFTemplateSize
		    m.lnPDFTemplateSize = LEN(m.lcPDFTemplate)
		    
		
		    This.PDFTemplateHeap = This.env.API_WIN.HeapCreate(0, m.lnPDFTemplateSize, 0)
		    IF EMPTY(This.PDFTemplateHeap)
		        EXIT
		    ENDIF
		
		    This.PDFTemplatePtr = This.env.API_WIN.HeapAlloc(This.PDFTemplateHeap, 0, m.lnPDFTemplateSize)
		    IF EMPTY(This.PDFTemplatePtr)
		        EXIT
		    ENDIF
		
		    SYS(2600, This.PDFTemplatePtr, m.lnPDFTemplateSize, m.lcPDFTemplate)
		
		
		    This.fpdf_doc = m.loFPDF.FPDF_LoadMemDocument(This.PDFTemplatePtr, m.lnPDFTemplateSize, NVL(m.loPDFMeta.UserPassword,"")) 
		
		    IF EMPTY(This.fpdf_doc)
		        ERROR "FPDF_LoadMemDocument returned empty value"
		    ENDIF
		
		    m.loFPDF.FPDFPage_Delete(This.fpdf_doc,0)
		    
		    
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		
		    IF EMPTY(This.PDFTemplatePtr)=.F. AND EMPTY(This.fpdf_doc)
		        This.env.API_WIN.HeapFree(This.PDFTemplateHeap, 0, This.PDFTemplatePtr)
		        This.PDFTemplatePtr = 0 
		    ENDIF
		
		    IF EMPTY(This.PDFTemplateHeap)=.F. AND EMPTY(This.fpdf_doc)
		        This.env.API_WIN.HeapDestroy(This.PDFTemplateHeap)
		        This.PDFTemplateHeap = 0 
		    ENDIF
		
		ENDTRY
		
		
	ENDPROC

	PROCEDURE Destroy
		DODEFAULT()
		
		This.ClosePDF()
		
		This.env = .F.
		
	ENDPROC

	HIDDEN PROCEDURE encrypt
		LPARAMETERS tcAlgorithm, tcData, tcKey, lcDataEncrypted
		
		lcDataEncrypted = ""
		
		LOCAL loWin
		m.loWin = This.env.API_WIN
		
		
		#define BCRYPT_BLOCK_PADDING  0x00000001
		
		LOCAL lnAlg, lnKey
		STORE 0 TO m.lnAlg, m.lnKey
		
		LOCAL llRes
		llRes = .F.
		
		TRY
		    IF m.loWin.BCryptOpenAlgorithmProvider(@m.lnAlg, STRCONV(m.tcAlgorithm+CHR(0),5), NULL, 0) != 0
		        EXIT
		    ENDIF
		
		    IF m.loWin.BCryptGenerateSymmetricKey(m.lnAlg, @m.lnKey, NULL, 0, @m.tcKey, LEN(m.tcKey), 0) != 0
		        EXIT
		    ENDIF
		
		    LOCAL lnSize
		    m.lnSize = 0
		    IF m.loWin.BCryptEncrypt(m.lnKey, m.tcData, LEN(m.tcData), NULL, NULL, 0, NULL, 0, @m.lnSize, BCRYPT_BLOCK_PADDING) != 0
		        EXIT
		    ENDIF
		
		
		    m.lcDataEncrypted = REPLICATE(CHR(0), m.lnSize)
		    
		    IF m.loWin.BCryptEncrypt(m.lnKey, m.tcData, LEN(m.tcData), NULL, NULL, 0, @m.lcDataEncrypted, LEN(m.lcDataEncrypted), @m.lnSize, BCRYPT_BLOCK_PADDING) != 0
		       EXIT
		    ENDIF
		    
		    m.llRes = .T.
		
		FINALLY
		    IF EMPTY(m.lnKey) = .F.
		        m.loWin.BCryptDestroyKey(m.lnKey)
		        m.lnKey = 0
		    ENDIF
		
		    IF EMPTY(m.lnAlg) = .F.
		        m.loWin.BCryptCloseAlgorithmProvider(m.lnAlg, 0)
		        m.lnAlg = 0
		    ENDIF
		ENDTRY
		
		IF m.llRes = .F.
		    m.lcDataEncrypted = ""
		ENDIF
		
		RETURN m.llRes
		
		
	ENDPROC

	PROCEDURE finalize
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
		IF EMPTY(This.fpdf_doc)
		    RETURN
		ENDIF
		
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		LOCAL lcTempFileName
		m.lcTempFileName = ""
		
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    LOCAL liPage, lnPage
		    m.liPage = 1 
		    FOR m.liPage = 1 TO This.fpdf_pagecount
		        m.lnPage = This.fpdf_pages[m.liPage]
		        IF EMPTY(m.lnPage) = .F.
		            m.loFPDF.FPDFPage_GenerateContent(m.lnPage)
		        ENDIF
		    ENDFOR
		    *******************************************************
		
		    m.lcTempFileName = This.env.GetUniqueTempFileName("pdf")
		
		    LOCAL lcSaveErrMsg
		    m.lcSaveErrMsg = REPLICATE(CHR(0), 500)
		    
		    IF m.loFPDF.VFPDF_SaveDocument(This.fpdf_doc, m.lcTempFileName, @m.lcSaveErrMsg, LEN(m.lcSaveErrMsg)) <> 1
		        m.lcTempFileName = ""
		        ERROR (RTRIM(m.lcSaveErrMsg, 1, CHR(0)))
		        EXIT
		    ENDIF
		
		FINALLY
		    This.ClosePDF()
		ENDTRY
		
		RETURN m.lcTempFileName
		
	ENDPROC

	PROCEDURE getfileextension
		RETURN "pdf"
		
	ENDPROC

	HIDDEN PROCEDURE getfontpdf
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		IF EMPTY(This.fpdf_doc)
		    RETURN 0
		ENDIF
		
		IF FILE(m.loRepObj.Font.FontFileName,1) = .F.
		    * Font file doesn't exist OR FILENAME HAS UNICODE SYMBOLS
		    RETURN 0
		ENDIF
		
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		
		LOCAL lcFontID
		m.lcFontID = m.loRepObj.Font.FontFileName
		
		***********************************************************
		* Font has been found
		***********************************************************
		LOCAL lnFontIndex
		m.lnFontIndex = This.fpdf_fonts.GetKey(m.lcFontID)
		IF m.lnFontIndex > 0
		    RETURN This.fpdf_fonts[m.lnFontIndex]
		ENDIF
		***********************************************************
		
		***********************************************************
		* Font hasn't been found, load it from file
		***********************************************************
		LOCAL lnFPDF_Font
		m.lnFPDF_Font = 0
		
		LOCAL lhHeap, lnFontDataPtr, lnSubsetData, lnSubsetDataSize
		STORE 0 TO m.lhHeap, m.lnFontDataPtr, m.lnSubsetData, m.lnSubsetDataSize
		
		TRY
		
		    IF m.loRepObj.Font.FontSymbol
		        EXIT
		    ENDIF
		
		
		    LOCAL lcFontData, lnFontDataSize
		    m.lcFontData = FILETOSTR(m.loRepObj.Font.FontFileName)
		    m.lnFontDataSize = LEN(m.lcFontData)
		
		    m.lhHeap = This.env.API_WIN.HeapCreate(0, m.lnFontDataSize, 0)
		    IF EMPTY(m.lhHeap)
		        EXIT
		    ENDIF
		
		    m.lnFontDataPtr = This.env.API_WIN.HeapAlloc(m.lhHeap, 0, m.lnFontDataSize)
		    IF EMPTY(m.lnFontDataPtr)
		        EXIT
		    ENDIF
		    
		    SYS(2600, m.lnFontDataPtr, m.lnFontDataSize, m.lcFontData)
		    
		    IF m.loFPDF.VFPDF_CreateFontSubset(m.lnFontDataPtr, m.lnFontDataSize, m.loRepObj.FontSubset.CharSubset + CHR(0), @m.lnSubsetData, @m.lnSubsetDataSize) = 1
		        m.lnFPDF_Font = m.loFPDF.FPDFText_LoadFont(This.fpdf_doc, m.lnSubsetData, m.lnSubsetDataSize, m.loFPDFC.FPDF_FONT_TRUETYPE(), 1)
		    ELSE            
		        m.lnFPDF_Font = m.loFPDF.FPDFText_LoadFont(This.fpdf_doc, m.lnFontDataPtr, m.lnFontDataSize, m.loFPDFC.FPDF_FONT_TRUETYPE(), 1)
		    ENDIF
		
		
		FINALLY
		
		    IF EMPTY(m.lnSubsetData)=.F.
		        m.loFPDF.VFPDF_DestroyFontSubset(m.lnSubsetData)
		        m.lnSubsetData = 0
		        m.lnSubsetDataSize = 0
		    ENDIF
		    
		    IF EMPTY(m.lnFontDataPtr)=.F.
		        This.env.API_WIN.HeapFree(m.lhHeap, 0, m.lnFontDataPtr)
		        m.lnFontDataPtr = 0 
		    ENDIF
		    
		    IF EMPTY(m.lhHeap)=.F.
		        This.env.API_WIN.HeapDestroy(m.lhHeap)
		        m.lhHeap = 0 
		    ENDIF
		    
		ENDTRY
		
		
		
		IF EMPTY(m.lnFPDF_Font)=.T. AND m.loRepObj.Font.FontSymbol=.F. && Get a fallback font
		
		    m.lnFPDF_Font = m.loFPDF.FPDFText_LoadStandardFont( ;
		        This.fpdf_doc, ;
		        ICASE( ;
		            m.loRepObj.FontBold and m.loRepObj.FontItalic, "Helvetica-BoldItalic", ;
		            m.loRepObj.FontBold, "Helvetica-Bold", ;
		            m.loRepObj.FontItalic, "Helvetica-Italic", ;
		            "Helvetica"))
		ENDIF
		
		This.fpdf_fonts.Add(m.lnFPDF_Font, m.lcFontID)
		
		RETURN m.lnFPDF_Font
		
	ENDPROC

	HIDDEN PROCEDURE hash_md5
		LPARAMETERS tcData, tcDataHash
		
		m.tcDataHash = ""
		
		LOCAL loWin
		m.loWin = This.env.API_WIN
		
		LOCAL lcAlgorithm
		m.lcAlgorithm = "MD5"
		
		LOCAL lnAlg, lnHash, lhHashHeap, lnHashObjPtr
		STORE 0 TO m.lnAlg, m.lnHash, m.lhHashHeap, m.lnHashObjPtr
		
		LOCAL llRes
		m.llRes = .F.
		
		TRY
		
		    IF m.loWin.BCryptOpenAlgorithmProvider(@m.lnAlg, STRCONV(m.lcAlgorithm+CHR(0),5), NULL, 0) != 0
		        EXIT
		    ENDIF
		
		    LOCAL lnSizeObj, lnData
		    m.lnSizeObj = 0
		    m.lnData = 0
		    IF m.loWin.BCryptGetProperty(m.lnAlg, STRCONV("ObjectLength"+CHR(0),5), @m.lnSizeObj, 4, @m.lnData, 0 ) != 0
		        EXIT
		    ENDIF
		
		    LOCAL lnSizeHash
		    m.lnSizeHash = 0
		    IF m.loWin.BCryptGetProperty( m.lnAlg, STRCONV("HashDigestLength"+CHR(0),5), @m.lnSizeHash, 4, @m.lnData, 0 ) != 0
		        EXIT
		    ENDIF
		
		
		    m.lhHashHeap = m.loWin.HeapCreate(0, m.lnSizeObj, 0)
		    IF EMPTY(m.lhHashHeap)
		        EXIT
		    ENDIF
		
		    m.lnHashObjPtr = m.loWin.HeapAlloc(m.lhHashHeap, 0, m.lnSizeObj)
		    IF EMPTY(m.lnHashObjPtr)
		        EXIT
		    ENDIF
		
		    IF m.loWin.BCryptCreateHash(m.lnAlg, @m.lnHash, m.lnHashObjPtr, m.lnSizeObj, NULL, 0, 0 ) != 0
		        EXIT
		    ENDIF
		
		    IF m.loWin.BCryptHashData(m.lnHash, m.tcData, LEN(m.tcData), 0) != 0
		        EXIT
		    ENDIF 
		
		    m.tcDataHash = REPLICATE(CHR(0), m.lnSizeHash)
		    IF m.loWin.BCryptFinishHash(m.lnHash, @m.tcDataHash, m.lnSizeHash, 0) != 0
		        EXIT
		    ENDIF
		    
		    m.llRes = .T.
		
		FINALLY
		
		    IF EMPTY(m.lnHash) = .F.
		        m.loWin.BCryptDestroyHash(m.lnHash)
		        m.lnHash = 0
		    ENDIF
		
		    IF EMPTY(m.lnAlg) = .F.
		        m.loWin.BCryptCloseAlgorithmProvider(m.lnAlg, 0)
		        m.lnAlg = 0
		    ENDIF
		
		
		    IF EMPTY(m.lnHashObjPtr)=.F.
		        m.loWin.HeapFree(m.lhHashHeap, 0, m.lnHashObjPtr)
		        m.lnHashObjPtr = 0 
		    ENDIF
		    
		    IF EMPTY(m.lhHashHeap)=.F.
		        This.env.API_WIN.HeapDestroy(m.lhHashHeap)
		        m.lhHashHeap = 0 
		    ENDIF
		
		ENDTRY
		
		IF m.llRes = .F.
		    m.tcDataHash = ""
		ENDIF
		
		RETURN m.llRes
		
	ENDPROC

	PROCEDURE render
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		IF EMPTY(This.fpdf_doc)
		    RETURN
		ENDIF
		
		
		LOCAL loFRXC
		m.loFRXC = This.env.API_FRX.CONST
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		*************************************************
		* Create new page
		*************************************************
		IF m.loRepObj.Batch_PageNo > This.fpdf_pagecount
		
		    This.fpdf_pagecount = This.fpdf_pagecount + 1
		
		    DIMENSION This.fpdf_pages(This.fpdf_pagecount)
		
		    LOCAL lnFPDF_Page
		    m.lnFPDF_Page = m.loFPDF.FPDFPage_New(This.fpdf_doc, This.fpdf_pagecount - 1, m.loRepObj.Rep_PageWidth * m.lnDpiCoef, m.loRepObj.Rep_PageHeight * m.lnDpiCoef)
		
		    This.fpdf_pages[This.fpdf_pagecount] = m.lnFPDF_Page
		    
		ENDIF
		
		IF EMPTY(This.fpdf_pages[This.fpdf_pagecount])
		    RETURN
		ENDIF
		
		
		*************************************************
		
		DO CASE
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_FIELD()
		    This.Render_FrxField(m.loRepObj)
		   
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		    This.Render_FrxLabel(m.loRepObj)
		
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_LINE()
		    This.Render_FrxLine(m.loRepObj)
		
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_RECTANGLE()
		    This.Render_FrxRectangle(m.loRepObj)
		
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_PICTURE()
		    This.Render_FrxPicture(m.loRepObj)
		
		ENDCASE
		*************************************************
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxfield
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		This.Render_Text(m.loRepObj)
		
	ENDPROC

	HIDDEN PROCEDURE render_frxlabel
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		This.Render_Text(m.loRepObj)
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxline
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		
		LOCAL lnFPDF_Page
		m.lnFPDF_Page = This.fpdf_pages[This.fpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL lnLineWidth
		IF m.loRepObj.PenPat >= 1
		    m.lnLineWidth = MAX(m.loRepObj.PenSize, 0.5) * m.lnDpiCoef
		ELSE
		    m.lnLineWidth = 0
		ENDIF
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = m.loRepObj.PosLeft
		m.lnTop = m.loRepObj.PosTopRev
		m.lnWidth = m.loRepObj.SizeWidth
		m.lnHeight = m.loRepObj.SizeHeight
		
		
		LOCAL lnRad
		m.lnRad = -m.loRepObj.Rotate * PI() / 180
		
		LOCAL lcTrMatrix
		m.lcTrMatrix = ;
		    BINTOC(COS(m.lnRad), "F") + ;
		    BINTOC(SIN(m.lnRad), "F") + ;
		    BINTOC(-SIN(m.lnRad), "F") + ;
		    BINTOC(COS(m.lnRad), "F") + ;
		    BINTOC(m.lnDpiCoef * m.lnLeft, "F") + ;
		    BINTOC(m.lnDpiCoef * m.lnTop, "F")
		
		
		LOCAL lnLineObj
		m.lnLineObj = m.loFPDF.FPDFPageObj_CreateNewPath(0, 0)
		
		m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnLineObj)
		
		
		IF m.loRepObj.LineType = 1
		    * Horizontal line
		    m.loFPDF.FPDFPath_LineTo(m.lnLineObj, m.lnDpiCoef * m.lnWidth, 0)
		ELSE
		    * Vertical line
		    m.loFPDF.FPDFPath_LineTo(m.lnLineObj, 0, m.lnDpiCoef * -m.lnHeight)
		ENDIF
		
		
		m.loFPDF.FPDFPageObj_TransformF(m.lnLineObj, m.lcTrMatrix)
		
		
		m.loFPDF.FPDFPageObj_SetStrokeColor(m.lnLineObj, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue, m.loRepObj.PenAlpha)
		m.loFPDF.FPDFPageObj_SetStrokeWidth(m.lnLineObj, m.lnLineWidth)
		
		m.loFPDF.FPDFPath_SetDrawMode(m.lnLineObj, m.loFPDFC.FPDF_FILLMODE_NONE(), 1)
		
		
		LOCAL lcDash
		
		DO CASE
		CASE m.loRepObj.PenPat = 8 && Normal
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnLineObj, NULL, 0, 0)
		
		CASE m.loRepObj.PenPat = 1 && Dot
		    m.lcDash = BINTOC(1, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnLineObj, m.lcDash, 1, 1)
		    
		CASE m.loRepObj.PenPat = 2 && Dash
		    m.lcDash = BINTOC(6, "F") + BINTOC(6, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnLineObj, m.lcDash, 2, 2)
		    
		CASE m.loRepObj.PenPat = 3 && Dash-dot
		    m.lcDash = BINTOC(6, "F") + BINTOC(6, "F") + BINTOC(1, "F") + BINTOC(6, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnLineObj, m.lcDash, 4, 0)
		    
		CASE m.loRepObj.PenPat = 4 && Dash-dot-dot
		    m.lcDash = BINTOC(6, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnLineObj, m.lcDash, 6, 0)
		
		OTHERWISE && Normal
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnLineObj, NULL, 0, 0)
		
		ENDCASE
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxpicture
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		LOCAL loGDIP, loGDIPC
		m.loGDIP = This.env.API_GDIP
		m.loGDIPC = m.loGDIP.CONST
		
		
		LOCAL lnFPDF_Page
		m.lnFPDF_Page = This.fpdf_pages[This.fpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL lcTempFileName
		m.lcTempFileName = This.env.GetUniqueTempFileName("png")
		
		LOCAL lSaveSafety
		m.lSaveSafety = SET("Safety")
		SET SAFETY OFF
		
		LOCAL lhGdipImage, lcImageBitmapData
		m.lhGdipImage = 0
		m.lcImageBitmapData = ""
		
		LOCAL lnFPDF_Bitmap
		m.lnFPDF_Bitmap = 0
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    LOCAL lnLeft, lnTop, lnWidth, lnHeight
		    m.lnLeft = m.loRepObj.PosLeft
		    m.lnTop = m.loRepObj.PosTopRev
		    m.lnWidth = m.loRepObj.SizeWidth
		    m.lnHeight = m.loRepObj.SizeHeight
		
		
		    **************************************************
		    * Draw image
		    **************************************************
		
		    IF EMPTY(m.loRepObj.PictureVal) = .T.
		        EXIT
		    ENDIF
		
		    STRTOFILE(m.loRepObj.PictureVal, m.lcTempFileName, 0)
		    
		    m.loGDIP.CheckError(m.loGDIP.GdipCreateBitmapFromFile(STRCONV(m.lcTempFileName,5) + CHR(0), @m.lhGdipImage))
		
		    LOCAL lnImgWidth, lnImgHeight
		    STORE 0 TO m.lnImgWidth, m.lnImgHeight
		    
		    m.loGDIP.CheckError(m.loGDIP.GdipGetImageWidth(m.lhGdipImage, @m.lnImgWidth))
		    m.loGDIP.CheckError(m.loGDIP.GdipGetImageHeight(m.lhGdipImage, @m.lnImgHeight))
		    
		    LOCAL lcImageRect
		    m.lcImageRect = BINTOC(0, "4RS") + BINTOC(0, "4RS") + BINTOC(m.lnImgWidth, "4RS") + BINTOC(m.lnImgHeight, "4RS")
		
		    m.lcImageBitmapData = REPLICATE(CHR(0), 24)
		    m.loGDIP.CheckError(m.loGDIP.GdipBitmapLockBits(m.lhGdipImage, m.lcImageRect, m.loGDIPC.Gdip_ImageLockModeRead(), m.loGDIPC.Gdip_PixelFormat32bppARGB(), @m.lcImageBitmapData))
		    
		    ************************************
		    LOCAL lnImageStride, lnImageScan0
		    m.lnImageStride = CTOBIN(SUBSTR(m.lcImageBitmapData, 9, 4), "4RS")
		    m.lnImageScan0 = CTOBIN(SUBSTR(m.lcImageBitmapData, 17, 4), "4RS")
		    
		    m.lnFPDF_Bitmap = m.loFPDF.FPDFBitmap_CreateEx(m.lnImgWidth, m.lnImgHeight, m.loFPDFC.FPDFBitmap_BGRA(), m.lnImageScan0, m.lnImageStride)
		
		    IF EMPTY(m.lnFPDF_Bitmap)
		        EXIT
		    ENDIF
		    
		    LOCAL lnImageObj
		    m.lnImageObj = m.loFPDF.FPDFPageObj_NewImageObj(This.fpdf_doc)
		    
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnImageObj)
		    
		    m.loFPDF.FPDFImageObj_SetBitmap(0, 0, m.lnImageObj, m.lnFPDF_Bitmap)
		
		
		    LOCAL lnRad
		    m.lnRad = -m.loRepObj.Rotate * PI() / 180
		
		    LOCAL lcTrMatrix
		    m.lcTrMatrix = ;
		        BINTOC(COS(m.lnRad), "F") + ;
		        BINTOC(SIN(m.lnRad), "F") + ;
		        BINTOC(-SIN(m.lnRad), "F") + ;
		        BINTOC(COS(m.lnRad), "F") + ;
		        BINTOC(m.lnDpiCoef * m.lnLeft, "F") + ;
		        BINTOC(m.lnDpiCoef * m.lnTop, "F")
		
		    
		    m.loFPDF.FPDFPageObj_Transform(m.lnImageObj, m.lnDpiCoef * MAX(m.lnWidth,1), 0, 0, m.lnDpiCoef * MAX(m.lnHeight,1), 0, m.lnDpiCoef * (-m.lnHeight))
		    m.loFPDF.FPDFPageObj_TransformF(m.lnImageObj, m.lcTrMatrix)
		    
		    
		    
		FINALLY
		    
		    SET SAFETY &lSaveSafety
		
		    IF EMPTY(m.lnFPDF_Bitmap) = .F.
		        m.loFPDF.FPDFBitmap_Destroy(m.lnFPDF_Bitmap)
		        m.lnFPDF_Bitmap = 0
		    ENDIF
		
		    IF EMPTY(m.lhGdipImage) = .F. AND EMPTY(RTRIM(m.lcImageBitmapData,1, CHR(0))) = .F.
		        m.loGDIP.GdipBitmapUnlockBits(m.lhGdipImage, m.lcImageBitmapData)
		        m.lcImageBitmapData = ""
		    ENDIF
		
		    IF EMPTY(m.lhGdipImage) = .F.
		        m.loGDIP.GdipDisposeImage(m.lhGdipImage)
		        m.lhGdipImage = 0
		    ENDIF
		        
		    IF FILE(m.lcTempFileName,1)
		        DELETE FILE (m.lcTempFileName)
		    ENDIF
		    
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE render_frxrectangle
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		
		LOCAL lnFPDF_Page
		m.lnFPDF_Page = This.fpdf_pages[This.fpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		LOCAL lnLineWidth
		IF m.loRepObj.PenPat >= 1
		    m.lnLineWidth = MAX(m.loRepObj.PenSize, 0.5) * m.lnDpiCoef
		ELSE
		    m.lnLineWidth = 0
		ENDIF
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = m.loRepObj.PosLeft
		m.lnTop = m.loRepObj.PosTopRev
		m.lnWidth = m.loRepObj.SizeWidth
		m.lnHeight = m.loRepObj.SizeHeight
		
		LOCAL lnRad
		m.lnRad = -m.loRepObj.Rotate * PI() / 180
		
		LOCAL lcTrMatrix
		m.lcTrMatrix = ;
		    BINTOC(COS(m.lnRad), "F") + ;
		    BINTOC(SIN(m.lnRad), "F") + ;
		    BINTOC(-SIN(m.lnRad), "F") + ;
		    BINTOC(COS(m.lnRad), "F") + ;
		    BINTOC(m.lnDpiCoef * m.lnLeft, "F") + ;
		    BINTOC(m.lnDpiCoef * m.lnTop, "F")
		
		
		LOCAL lnRectObj
		m.lnRectObj = 0
		
		DO CASE
		CASE m.loRepObj.RectCurvature = 0 && Normal rectangle
		    
		    m.lnRectObj = m.loFPDF.FPDFPageObj_CreateNewRect(;
		        0, ;
		        m.lnDpiCoef * -m.lnHeight, ;
		        m.lnDpiCoef * m.lnWidth, ;
		        m.lnDpiCoef * m.lnHeight)
		    
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnRectObj)
		
		
		CASE BETWEEN(m.loRepObj.RectCurvature, 1, 98) AND m.loRepObj.RectCurvature <= MAX(m.lnWidth, m.lnHeight)/2  && Rounded rectangle
		
		    m.lnRectObj = m.loFPDF.FPDFPageObj_CreateNewPath(0, 0)
		    
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnRectObj)
		    
		    LOCAL lnRay
		    m.lnRay = m.lnDpiCoef * ROUND(IIF(m.lnWidth > m.lnHeight, MIN(m.loRepObj.RectCurvature, INT(m.lnHeight / 2)), MIN(m.loRepObj.RectCurvature, INT(m.lnWidth / 2))), 0)
		    
		    LOCAL lnRight, lnBottom
		    m.lnRight = m.lnDpiCoef * m.lnWidth
		    m.lnBottom = m.lnDpiCoef * -m.lnHeight
		    
		    m.loFPDF.FPDFPath_MoveTo(m.lnRectObj, m.lnRay, m.lnBottom)
		    m.loFPDF.FPDFPath_LineTo(m.lnRectObj, m.lnRight - m.lnRay, m.lnBottom)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, m.lnRight, m.lnBottom, m.lnRight, m.lnBottom, m.lnRight, m.lnBottom + m.lnRay) 
		    m.loFPDF.FPDFPath_LineTo(m.lnRectObj, m.lnRight, -m.lnRay)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, m.lnRight, 0, m.lnRight, 0, m.lnRight - m.lnRay, 0)
		    m.loFPDF.FPDFPath_LineTo(m.lnRectObj, m.lnRay, 0)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, 0, 0, 0, 0, 0, -m.lnRay)
		    m.loFPDF.FPDFPath_LineTo(m.lnRectObj, 0 , m.lnBottom + m.lnRay)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, 0, m.lnBottom, 0, m.lnBottom, m.lnRay, m.lnBottom)
		
		
		OTHERWISE && Ellipse
		
		    LOCAL lnKappa
		    m.lnKappa = 0.552
		    
		    LOCAL lnCenterX, lnCenterY, lnRayX, lnRayY
		    m.lnCenterX = m.lnDpiCoef * m.lnWidth / 2
		    m.lnCenterY = m.lnDpiCoef * -m.lnHeight / 2
		    m.lnRayX = m.lnDpiCoef * (m.lnWidth / 2)
		    m.lnRayY = m.lnDpiCoef * (m.lnHeight / 2)
		    
		    m.lnRectObj = m.loFPDF.FPDFPageObj_CreateNewPath(0, 0)
		    
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnRectObj)
		
		    m.loFPDF.FPDFPath_MoveTo(m.lnRectObj, m.lnCenterX - m.lnRayX, m.lnCenterY)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, m.lnCenterX - m.lnRayX, m.lnCenterY + m.lnRayY * m.lnKappa, m.lnCenterX - m.lnRayX * m.lnKappa, m.lnCenterY + m.lnRayY, m.lnCenterX, m.lnCenterY + m.lnRayY)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, m.lnCenterX + m.lnRayX * m.lnKappa, m.lnCenterY + m.lnRayY, m.lnCenterX + m.lnRayX, m.lnCenterY + m.lnRayY * m.lnKappa, m.lnCenterX + m.lnRayX, m.lnCenterY)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, m.lnCenterX + m.lnRayX, m.lnCenterY - m.lnRayY * m.lnKappa, m.lnCenterX + m.lnRayX * m.lnKappa, m.lnCenterY - m.lnRayY, m.lnCenterX, m.lnCenterY - m.lnRayY)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, m.lnCenterX - m.lnRayX * m.lnKappa, m.lnCenterY - m.lnRayY, m.lnCenterX - m.lnRayX, m.lnCenterY - m.lnRayY * m.lnKappa, m.lnCenterX - m.lnRayX, m.lnCenterY)
		        
		ENDCASE
		
		IF EMPTY(m.lnRectObj)
		    RETURN
		ENDIF
		
		
		m.loFPDF.FPDFPageObj_TransformF(m.lnRectObj, m.lcTrMatrix)
		
		
		m.loFPDF.FPDFPageObj_SetFillColor(m.lnRectObj, m.loRepObj.FillRed, m.loRepObj.FillGreen, m.loRepObj.FillBlue, m.loRepObj.FillAlpha)
		m.loFPDF.FPDFPageObj_SetStrokeColor(m.lnRectObj, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue, m.loRepObj.PenAlpha)
		m.loFPDF.FPDFPageObj_SetStrokeWidth(m.lnRectObj, m.lnLineWidth)
		
		DO CASE
		CASE m.loRepObj.Transparent = 0 AND m.loRepObj.FillPat > 0 AND m.loRepObj.PenPat = 0
		    m.loFPDF.FPDFPath_SetDrawMode(m.lnRectObj, m.loFPDFC.FPDF_FILLMODE_ALTERNATE(), 0)
		    
		CASE m.loRepObj.Transparent = 0 AND m.loRepObj.FillPat > 0
		    m.loFPDF.FPDFPath_SetDrawMode(m.lnRectObj, m.loFPDFC.FPDF_FILLMODE_ALTERNATE(), 1)
		
		OTHERWISE 
		    m.loFPDF.FPDFPath_SetDrawMode(m.lnRectObj, m.loFPDFC.FPDF_FILLMODE_NONE(), 1)
		
		ENDCASE
		
		
		*******************************************************
		LOCAL lcDash
		
		DO CASE
		CASE m.loRepObj.PenPat = 8 && Normal
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnRectObj, NULL, 0, 0)
		
		CASE m.loRepObj.PenPat = 1 && Dot
		    m.lcDash = BINTOC(1, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnRectObj, m.lcDash, 1, 1)
		    
		CASE m.loRepObj.PenPat = 2 && Dash
		    m.lcDash = BINTOC(6, "F") + BINTOC(6, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnRectObj, m.lcDash, 2, 2)
		    
		CASE m.loRepObj.PenPat = 3 && Dash-dot
		    m.lcDash = BINTOC(6, "F") + BINTOC(6, "F") + BINTOC(1, "F") + BINTOC(6, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnRectObj, m.lcDash, 4, 0)
		    
		CASE m.loRepObj.PenPat = 4 && Dash-dot-dot
		    m.lcDash = BINTOC(6, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnRectObj, m.lcDash, 6, 0)
		
		OTHERWISE && Normal
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnRectObj, NULL, 0, 0)
		
		ENDCASE
		*******************************************************
		
		
		
	ENDPROC

	HIDDEN PROCEDURE render_text
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		
		LOCAL loFRXC
		m.loFRXC = This.env.API_FRX.CONST
		
		
		LOCAL lnFPDF_Page
		m.lnFPDF_Page = This.fpdf_pages[This.fpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		LOCAL loFont
		m.loFont = m.loRepObj.Font
		
		LOCAL lnPDFFont
		m.lnPDFFont = This.GetFontPDF(m.loRepObj)
		
		IF EMPTY(m.lnPDFFont)
		    This.Render_TextAsImage(m.loRepObj)
		    RETURN
		ENDIF
		
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = m.loRepObj.PosLeft
		m.lnTop = m.loRepObj.PosTopRev
		m.lnWidth = m.loRepObj.SizeWidth
		m.lnHeight = m.loRepObj.SizeHeight
		
		
		LOCAL lnRad
		m.lnRad = -m.loRepObj.Rotate * PI() / 180
		
		LOCAL lcTrMatrix
		m.lcTrMatrix = ;
		    BINTOC(COS(m.lnRad), "F") + ;
		    BINTOC(SIN(m.lnRad), "F") + ;
		    BINTOC(-SIN(m.lnRad), "F") + ;
		    BINTOC(COS(m.lnRad), "F") + ;
		    BINTOC(m.lnDpiCoef * m.lnLeft, "F") + ;
		    BINTOC(m.lnDpiCoef * m.lnTop, "F")
		
		
		*******************************************************
		* Background mode 0 - Opaque, 1 - Transparent
		IF m.loRepObj.Transparent = 0 
		
		    LOCAL lnTextBgRect
		    m.lnTextBgRect = m.loFPDF.FPDFPageObj_CreateNewRect(;
		        0, ;
		        m.lnDpiCoef * -m.lnHeight, ;
		        m.lnDpiCoef * m.lnWidth, ;
		        m.lnDpiCoef * m.lnHeight)
		
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnTextBgRect)
		    
		    m.loFPDF.FPDFPageObj_TransformF(m.lnTextBgRect, m.lcTrMatrix)
		        
		    m.loFPDF.FPDFPageObj_SetFillColor(m.lnTextBgRect, m.loRepObj.FillRed, m.loRepObj.FillGreen, m.loRepObj.FillBlue, m.loRepObj.FillAlpha)
		    
		    m.loFPDF.FPDFPath_SetDrawMode(m.lnTextBgRect, m.loFPDFC.FPDF_FILLMODE_ALTERNATE(), 0)
		
		ENDIF
		*******************************************************
		
		
		
		*******************************************************
		LOCAL laLines(1), lnLinesCount, liLine, loLine
		m.lnLinesCount = m.loRepObj.Render_Text(@m.laLines)
		m.liLine = 1
		FOR m.liLine = 1 TO m.lnLinesCount
		
		    m.loLine = m.laLines[m.liLine]
		
		
		    LOCAL lnTextObj
		    m.lnTextObj = m.loFPDF.FPDFPageObj_CreateTextObj(This.fpdf_doc, m.lnPDFFont, m.loRepObj.FontSize)
		    
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnTextObj)
		    
		    
		    m.loFPDF.FPDFText_SetText(m.lnTextObj, m.loLine.Text + CHR(0))
		    
		    
		    m.loFPDF.FPDFPageObj_SetFillColor(m.lnTextObj, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue, m.loRepObj.PenAlpha)
		    m.loFPDF.FPDFPageObj_SetStrokeColor(m.lnTextObj, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue, m.loRepObj.PenAlpha)
		    
		    m.loFPDF.FPDFPath_SetDrawMode(m.lnTextObj, m.loFPDFC.FPDF_FILLMODE_ALTERNATE(), 0)
		    
		    m.loFPDF.FPDFTextObj_SetTextRenderMode(m.lnTextObj, m.loFPDFC.FPDF_TEXTRENDERMODE_FILL())
		    
		    IF m.loRepObj.FontBold AND m.loRepObj.Font.FontBold = .F.
		        m.loFPDF.FPDFTextObj_SetTextRenderMode(m.lnTextObj, m.loFPDFC.FPDF_TEXTRENDERMODE_FILL_STROKE()) && Bold imitation
		        m.loFPDF.FPDFPageObj_SetStrokeWidth(m.lnTextObj, 0.5)
		    ENDIF
		    
		    LOCAL llFakeItalic
		    m.llFakeItalic = m.loRepObj.FontItalic AND m.loRepObj.Font.FontItalic = .F.
		    IF m.llFakeItalic
		        m.loFPDF.FPDFPageObj_Transform(m.lnTextObj, 1, 0, 0.3333, 1, 0, 0) && Italic imitation
		    ENDIF
		
		
		    LOCAL lnAlignOffsetX
		    m.lnAlignOffsetX = ICASE(m.loRepObj.Align = m.loFRXC.ALIGN_RIGHT(), m.loLine.Width - m.loLine.TextWidth, m.loRepObj.Align = m.loFRXC.ALIGN_CENTER(), (m.loLine.Width - m.loLine.TextWidth) * 0.5, 0)
		
		    m.loFPDF.FPDFPageObj_Transform(m.lnTextObj, ;
		        1, ;
		        0, ;
		        0, ;
		        1, ;
		        m.lnDpiCoef * (m.loLine.Left + m.lnAlignOffsetX) + IIF(m.llFakeItalic, m.loRepObj.FontSize * 0.5, 0),;
		        m.lnDpiCoef * (-m.loLine.Top - m.loLine.Height + m.loFont.FontDescent + 2) )
		
		
		    m.loFPDF.FPDFPageObj_TransformF(m.lnTextObj, m.lcTrMatrix)
		    
		    
		    IF m.loRepObj.FontUnderline
		        LOCAL lnTextUnderline
		        m.lnTextUnderline = m.loFPDF.FPDFPageObj_CreateNewPath(;
		            m.lnDpiCoef * (m.loLine.Left + m.lnAlignOffsetX),;
		            m.lnDpiCoef * (-m.loLine.Top - m.loLine.Height + m.loFont.FontDescent))
		        
		        m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnTextUnderline)
		        
		        m.loFPDF.FPDFPath_LineTo(m.lnTextUnderline, ;
		            m.lnDpiCoef * (m.loLine.Left + m.lnAlignOffsetX + m.loLine.TextWidth),;
		            m.lnDpiCoef * (-m.loLine.Top - m.loLine.Height + m.loFont.FontDescent))
		            
		        m.loFPDF.FPDFPageObj_TransformF(m.lnTextUnderline, m.lcTrMatrix)
		
		        m.loFPDF.FPDFPageObj_SetStrokeColor(m.lnTextUnderline, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue, m.loRepObj.PenAlpha)
		        m.loFPDF.FPDFPageObj_SetStrokeWidth(m.lnTextUnderline, 0.5)
		        
		        m.loFPDF.FPDFPath_SetDrawMode(m.lnTextUnderline, m.loFPDFC.FPDF_FILLMODE_NONE(), 1)
		
		    ENDIF
		
		
		    IF m.loRepObj.FontStrikeout
		        LOCAL lnTextStrikeout
		        m.lnTextStrikeout = m.loFPDF.FPDFPageObj_CreateNewPath(;
		            m.lnDpiCoef * (m.loLine.Left + m.lnAlignOffsetX),;
		            m.lnDpiCoef * (-m.loLine.Top - m.loLine.Height + (m.loFont.FontDescent + m.loFont.FontAscent) * 0.5))
		        
		        m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnTextStrikeout)
		        
		        m.loFPDF.FPDFPath_LineTo(m.lnTextStrikeout, ;
		            m.lnDpiCoef * (m.loLine.Left + m.lnAlignOffsetX + m.loLine.TextWidth),;
		            m.lnDpiCoef * (-m.loLine.Top - m.loLine.Height + (m.loFont.FontDescent + m.loFont.FontAscent) * 0.5))
		            
		        m.loFPDF.FPDFPageObj_TransformF(m.lnTextStrikeout, m.lcTrMatrix)
		
		        m.loFPDF.FPDFPageObj_SetStrokeColor(m.lnTextStrikeout, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue, m.loRepObj.PenAlpha)
		        m.loFPDF.FPDFPageObj_SetStrokeWidth(m.lnTextStrikeout, 0.5)
		        
		        m.loFPDF.FPDFPath_SetDrawMode(m.lnTextStrikeout, m.loFPDFC.FPDF_FILLMODE_NONE(), 1)
		
		    ENDIF
		   
		    
		ENDFOR
		
		
		
	ENDPROC

	HIDDEN PROCEDURE render_textasimage
		LPARAMETERS loRepObj as pdfiumreport_repobj of pdfium-vfp.vcx
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		LOCAL loGDIP, loGDIPC
		m.loGDIP = This.env.API_GDIP
		m.loGDIPC = m.loGDIP.CONST
		
		
		LOCAL lnFPDF_Page
		m.lnFPDF_Page = This.fpdf_pages[This.fpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		LOCAL lcTempFileName
		m.lcTempFileName = This.env.GetUniqueTempFileName("png")
		
		LOCAL lSaveSafety
		m.lSaveSafety = SET("Safety")
		SET SAFETY OFF
		
		LOCAL lhGdipImage, lcImageBitmapData
		m.lhGdipImage = 0
		m.lcImageBitmapData = ""
		
		LOCAL lnFPDF_Bitmap
		m.lnFPDF_Bitmap = 0
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    LOCAL lnLeft, lnTop, lnWidth, lnHeight, lcPictureVal
		    m.lnLeft = m.loRepObj.PosLeft
		    m.lnTop = m.loRepObj.PosTopRev
		    m.lnWidth = m.loRepObj.SizeWidth
		    m.lnHeight = m.loRepObj.SizeHeight
		    m.lcPictureVal = ""
		
		    ************************************
		    m.loRepObj.Render_TextAsImage(@m.lcPictureVal, @m.lnWidth, @m.lnHeight)
		    
		    STRTOFILE(m.lcPictureVal, m.lcTempFileName, 0)
		    m.lcPictureVal = ""
		    
		    m.loGDIP.CheckError(m.loGDIP.GdipCreateBitmapFromFile(STRCONV(m.lcTempFileName,5) + CHR(0), @m.lhGdipImage))
		
		    LOCAL lnImgWidth, lnImgHeight
		    STORE 0 TO m.lnImgWidth, m.lnImgHeight
		    
		    m.loGDIP.CheckError(m.loGDIP.GdipGetImageWidth(m.lhGdipImage, @m.lnImgWidth))
		    m.loGDIP.CheckError(m.loGDIP.GdipGetImageHeight(m.lhGdipImage, @m.lnImgHeight))
		    
		    LOCAL lcImageRect
		    m.lcImageRect = BINTOC(0, "4RS") + BINTOC(0, "4RS") + BINTOC(m.lnImgWidth, "4RS") + BINTOC(m.lnImgHeight, "4RS")
		
		    m.lcImageBitmapData = REPLICATE(CHR(0), 24)
		    m.loGDIP.CheckError(m.loGDIP.GdipBitmapLockBits(m.lhGdipImage, m.lcImageRect, m.loGDIPC.Gdip_ImageLockModeRead(), m.loGDIPC.Gdip_PixelFormat32bppARGB(), @m.lcImageBitmapData))
		    
		    ************************************
		    LOCAL lnImageStride, lnImageScan0
		    m.lnImageStride = CTOBIN(SUBSTR(m.lcImageBitmapData, 9, 4), "4RS")
		    m.lnImageScan0 = CTOBIN(SUBSTR(m.lcImageBitmapData, 17, 4), "4RS")
		
		
		    m.lnFPDF_Bitmap = m.loFPDF.FPDFBitmap_CreateEx(m.lnImgWidth, m.lnImgHeight, m.loFPDFC.FPDFBitmap_BGRA(), m.lnImageScan0, m.lnImageStride)
		
		    IF EMPTY(m.lnFPDF_Bitmap)
		        EXIT
		    ENDIF
		    
		    LOCAL lnImageObj
		    m.lnImageObj = m.loFPDF.FPDFPageObj_NewImageObj(This.fpdf_doc)
		    
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnImageObj)
		    
		    m.loFPDF.FPDFImageObj_SetBitmap(0, 0, m.lnImageObj, m.lnFPDF_Bitmap)
		
		
		    LOCAL lnRad
		    m.lnRad = -m.loRepObj.Rotate * PI() / 180
		
		    LOCAL lcTrMatrix
		    m.lcTrMatrix = ;
		        BINTOC(COS(m.lnRad), "F") + ;
		        BINTOC(SIN(m.lnRad), "F") + ;
		        BINTOC(-SIN(m.lnRad), "F") + ;
		        BINTOC(COS(m.lnRad), "F") + ;
		        BINTOC(m.lnDpiCoef * m.lnLeft, "F") + ;
		        BINTOC(m.lnDpiCoef * m.lnTop, "F")
		
		    
		    m.loFPDF.FPDFPageObj_Transform(m.lnImageObj, m.lnDpiCoef * MAX(m.lnWidth,1), 0, 0, m.lnDpiCoef * MAX(m.lnHeight,1), 0, m.lnDpiCoef * (-m.lnHeight))
		    m.loFPDF.FPDFPageObj_TransformF(m.lnImageObj, m.lcTrMatrix)
		    
		FINALLY
		
		    SET SAFETY &lSaveSafety
		
		    IF EMPTY(m.lnFPDF_Bitmap) = .F.
		        m.loFPDF.FPDFBitmap_Destroy(m.lnFPDF_Bitmap)
		        m.lnFPDF_Bitmap = 0
		    ENDIF
		
		    IF EMPTY(m.lhGdipImage) = .F. AND EMPTY(RTRIM(m.lcImageBitmapData,1, CHR(0))) = .F.
		        m.loGDIP.GdipBitmapUnlockBits(m.lhGdipImage, m.lcImageBitmapData)
		        m.lcImageBitmapData = ""
		    ENDIF
		
		    IF EMPTY(m.lhGdipImage) = .F.
		        m.loGDIP.GdipDisposeImage(m.lhGdipImage)
		        m.lhGdipImage = 0
		    ENDIF
		
		    IF FILE(m.lcTempFileName,1)
		        DELETE FILE (m.lcTempFileName)
		    ENDIF
		ENDTRY
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport_repfont AS custom 		&& Frx font representation; Referenced in PdfiumReport.Fonts collection and PdfiumReport_repobj.Font
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: fontascent
		*p: fontbold		&& Specifies if the text is bold.
		*p: fontdescent
		*p: fontface
		*p: fontfilename
		*p: fontheight
		*p: fontheightceil
		*p: fontitalic		&& Specifies if the text is italic.
		*p: fontprivate
		*p: fontsize
		*p: fontsymbol
		*p: gdipfont
		*p: gdipfontfamily
		*p: lineheight
		*p: linespacing
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,Height,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		fontascent = 0
		fontbold = .F.
		fontdescent = 0
		fontface = ("")
		fontfilename = ("")
		fontheight = 0
		fontheightceil = 0
		fontitalic = .F.
		fontprivate = .F.
		fontsize = 0
		fontsymbol = .F.
		gdipfont = .F.
		gdipfontfamily = 0
		Height = 27
		lineheight = 0
		linespacing = 0
		Name = "pdfiumreport_repfont"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="fontbold" type="property" display="FontBold"/>
			<memberdata name="fontface" type="property" display="FontFace"/>
			<memberdata name="fontfilename" type="property" display="FontFileName"/>
			<memberdata name="fontheight" type="property" display="FontHeight"/>
			<memberdata name="fontheightceil" type="property" display="FontHeightCeil"/>
			<memberdata name="fontitalic" type="property" display="FontItalic"/>
			<memberdata name="fontsymbol" type="property" display="FontSymbol"/>
			<memberdata name="lineheight" type="property" display="LineHeight"/>
			<memberdata name="fontascent" type="property" display="FontAscent"/>
			<memberdata name="fontdescent" type="property" display="FontDescent"/>
			<memberdata name="fontprivate" type="property" display="FontPrivate"/>
			<memberdata name="gdipfont" type="property" display="GdipFont"/>
			<memberdata name="gdipfontfamily" type="property" display="GdipFontFamily"/>
			<memberdata name="fontsize" type="property" display="FontSize"/>
			<memberdata name="linespacing" type="property" display="LineSpacing"/>
		</VFPData>
	*</PropValue>

ENDDEFINE

DEFINE CLASS pdfiumreport_repobj AS custom 		&& Input object for Render  method of PdfiumReport_renderer_base  class; Produced by PdfiumReport Render method
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: measurestring
		*m: render_text
		*m: render_textasimage		&& Render text as an image; Returns character representation in PNG format
		*p: align		&& Alignment: 0 - left, 1 - right, 2 - center
		*p: batch_pageno
		*p: continuationtype		&& Object ContinuationType Indicates the current continuation state for the rendered element. When layout elements span pages, they are rendered in multiple sections
		*p: env		&& Pdfium_env object
		*p: fillalpha		&& Object background color alpha transparency of RGBA (0 - 255)
		*p: fillblue		&& Object background color blue component of RGBA (0 - 255)
		*p: fillgreen		&& Object background color green component of RGBA (0 - 255)
		*p: fillpat
		*p: fillred		&& Object background color red component of RGBA (0 - 255)
		*p: font		&& Font representation (PdfiumReport_repfont)
		*p: fontbold		&& Specifies if the text is bold.
		*p: fontcharset		&& Specifies the script for the font used to display text.
		*p: fontface
		*p: fontitalic		&& Specifies if the text is italic.
		*p: fontsize		&& Specifies the font size for text displayed with an object.
		*p: fontstrikeout
		*p: fontsubset
		*p: fontunderline		&& Specifies if the text is underlined.
		*p: linespacing		&& Spacing between lines of text: 0 - normal, 1 - normal * 1.5, 2 - double spacing
		*p: linetype		&& Line object type: 1 - horizontal, 2 - vertical
		*p: objid
		*p: objtype		&& Frx control type id: 5 - Label, 6 - Line, 7 - Rectangle, 8 - Field, 17 - Picture
		*p: penalpha
		*p: penblue
		*p: pengreen
		*p: penpat
		*p: penred
		*p: pensize
		*p: picturefilename		&& Filename for Picture report control
		*p: picturescale		&& Picture scale mode: 0 = Clip , 1 = Scale Retain Shape, 2 = Scale and fill frame
		*p: pictureval		&& Character represetation of Picture object in PNG
		*p: posleft		&& Object position: Left (pixels)
		*p: postop		&& Object position: Top (pixels)
		*p: postoprev		&& Object position: Reverse Top (from page bottom, pixels)
		*p: rectcurvature		&& Rectange Curvature; specifies % curvature:
		*p: rep_pageheight		&& Page height (pixels)
		*p: rep_pageno		&& Number of page where object were rendered
		*p: rep_pagetotal		&& Total number of pages in report (may be 0 if ReportListener.TwoPassProcess was  equal to.F.)
		*p: rep_pagewidth		&& Page width (pixels)
		*p: rotate		&& Rotation (degrees)
		*p: screengfx
		*p: sizeheight		&& Object height (pixels)
		*p: sizewidth		&& Object width (pixels)
		*p: text		&& Text in UTF-16 LE for Field and Label
		*p: transparent		&& Transparency: 0 - Opague, 1 - Transparent
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,env,Error,Height,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,screengfx,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		align = 0
		batch_pageno = 0
		continuationtype = 0
		env = .F.
		fillalpha = 0
		fillblue = 0
		fillgreen = 0
		fillpat = 0
		fillred = 0
		font = .F.
		fontbold = .F.
		fontcharset = 0
		fontface = ("")
		fontitalic = .F.
		fontsize = 0
		fontstrikeout = .F.
		fontsubset = .F.
		fontunderline = .F.
		Height = 27
		linespacing = 0
		linetype = 0
		Name = "pdfiumreport_repobj"
		objid = 0
		objtype = 0
		penalpha = 0
		penblue = 0
		pengreen = 0
		penpat = 0
		penred = 0
		pensize = 0
		picturefilename = ("")
		picturescale = 0
		pictureval = ("")
		posleft = 0
		postop = 0
		postoprev = 0
		rectcurvature = 0
		rep_pageheight = 0
		rep_pageno = 0
		rep_pagetotal = 0
		rep_pagewidth = 0
		rotate = 0
		screengfx = .F.
		sizeheight = 0
		sizewidth = 0
		text = ("")
		transparent = 0
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="align" type="property" display="Align"/>
			<memberdata name="continuationtype" type="property" display="ContinuationType"/>
			<memberdata name="fillalpha" type="property" display="FillAlpha"/>
			<memberdata name="fillblue" type="property" display="FillBlue"/>
			<memberdata name="fillgreen" type="property" display="FillGreen"/>
			<memberdata name="fillpat" type="property" display="FillPat"/>
			<memberdata name="fillred" type="property" display="FillRed"/>
			<memberdata name="fontbold" type="property" display="FontBold"/>
			<memberdata name="fontcharset" type="property" display="FontCharset"/>
			<memberdata name="fontface" type="property" display="FontFace"/>
			<memberdata name="fontitalic" type="property" display="FontItalic"/>
			<memberdata name="fontsize" type="property" display="FontSize"/>
			<memberdata name="fontstrikeout" type="property" display="FontStrikeout"/>
			<memberdata name="fontunderline" type="property" display="FontUnderline"/>
			<memberdata name="linespacing" type="property" display="LineSpacing"/>
			<memberdata name="objtype" type="property" display="ObjType"/>
			<memberdata name="penalpha" type="property" display="PenAlpha"/>
			<memberdata name="penblue" type="property" display="PenBlue"/>
			<memberdata name="pengreen" type="property" display="PenGreen"/>
			<memberdata name="penpat" type="property" display="PenPat"/>
			<memberdata name="penred" type="property" display="PenRed"/>
			<memberdata name="pensize" type="property" display="PenSize"/>
			<memberdata name="posleft" type="property" display="PosLeft"/>
			<memberdata name="postop" type="property" display="PosTop"/>
			<memberdata name="rep_pageheight" type="property" display="Rep_PageHeight"/>
			<memberdata name="rep_pageno" type="property" display="Rep_PageNo"/>
			<memberdata name="rep_pagetotal" type="property" display="Rep_PageTotal"/>
			<memberdata name="rep_pagewidth" type="property" display="Rep_PageWidth"/>
			<memberdata name="rotate" type="property" display="Rotate"/>
			<memberdata name="sizeheight" type="property" display="SizeHeight"/>
			<memberdata name="sizewidth" type="property" display="SizeWidth"/>
			<memberdata name="text" type="property" display="Text"/>
			<memberdata name="postoprev" type="property" display="PosTopRev"/>
			<memberdata name="linetype" type="property" display="LineType"/>
			<memberdata name="rectcurvature" type="property" display="RectCurvature"/>
			<memberdata name="transparent" type="property" display="Transparent"/>
			<memberdata name="font" type="property" display="Font"/>
			<memberdata name="picturescale" type="property" display="PictureScale"/>
			<memberdata name="picturefilename" type="property" display="PictureFilename"/>
			<memberdata name="env" type="property" display="env"/>
			<memberdata name="pictureval" type="property" display="PictureVal"/>
			<memberdata name="render_textasimage" type="method" display="Render_TextAsImage"/>
			<memberdata name="measurestring" type="method" display="MeasureString"/>
			<memberdata name="screengfx" type="property" display="ScreenGfx"/>
			<memberdata name="render_text" type="method" display="Render_Text"/>
			<memberdata name="batch_pageno" type="property" display="Batch_PageNo"/>
			<memberdata name="fontsubset" type="property" display="FontSubset"/>
			<memberdata name="objid" type="property" display="ObjID"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE Destroy
		This.env = .F.
		This.ScreenGfx = 0
		
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv, tnScreenGfx
		
		This.env = m.toEnv
		This.ScreenGfx = m.tnScreenGfx
		
		IF VARTYPE(This.env) != "O"
		    RETURN .F.
		ENDIF
		
		IF EMPTY(NVL(This.ScreenGfx,0))
		    RETURN .F.
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE measurestring
		LPARAMETERS m.tcTextUnicode, toLayoutRectF, thStringFormat, toObjRectF, tnCharsFitted, tnLinesFitted
		
		STORE 0 TO m.tnCharsFitted, m.tnLinesFitted
		
		m.toObjRectF = NEWOBJECT("empty")
		ADDPROPERTY(m.toObjRectF, "x", 0.0)
		ADDPROPERTY(m.toObjRectF, "y", 0.0)
		ADDPROPERTY(m.toObjRectF, "width", 0.0)
		ADDPROPERTY(m.toObjRectF, "height", 0.0)
		
		LOCAL lcLayoutRectF
		m.lcLayoutRectF = 0h + BINTOC(m.toLayoutRectF.x, "F") + BINTOC(m.toLayoutRectF.y, "F") + BINTOC(m.toLayoutRectF.width, "F") + BINTOC(m.toLayoutRectF.height, "F")
		
		LOCAL lcObjBBox
		m.lcObjBBox = 0h + BINTOC(0.0, "F") + BINTOC(0.0, "F") + BINTOC(0.0, "F") + BINTOC(0.0, "F")
		
		
		This.env.API_GDIP.GdipMeasureString (;
		    This.ScreenGfx, ;
		    m.tcTextUnicode + CHR(0), ;
		    LEN(m.tcTextUnicode) / 2, ;
		    This.Font.GdipFont, ;
		    m.lcLayoutRectF, ;
		    m.thStringFormat, ;
		    @m.lcObjBBox, ;
		    @m.tnCharsFitted, ;
		    @m.tnLinesFitted)
		
		
		m.toObjRectF.x = CTOBIN(SUBSTR(m.lcObjBBox,1,4), "N")
		m.toObjRectF.y = CTOBIN(SUBSTR(m.lcObjBBox,5,4), "N")
		m.toObjRectF.width = CTOBIN(SUBSTR(m.lcObjBBox,9,4), "N")
		m.toObjRectF.height = CTOBIN(SUBSTR(m.lcObjBBox,13,4), "N")
		
	ENDPROC

	PROCEDURE render_text
		LPARAMETERS laTextLines
		
		DIMENSION m.laTextLines(1)
		
		LOCAL lnTextLinesCount
		m.lnTextLinesCount = 0
		
		
		LOCAL loFRXC
		m.loFRXC = This.env.API_FRX.CONST
		
		LOCAL loFont
		m.loFont = This.Font
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = This.PosLeft
		m.lnTop = This.PosTop
		m.lnWidth = This.SizeWidth
		m.lnHeight = This.SizeHeight
		
		
		*******************************************************
		IF This.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		    m.lnWidth = m.lnWidth + This.Font.FontHeightCeil * 2
		ENDIF
		
		LOCAL lnTextOffsetX, lnTextOffsetY
		m.lnTextOffsetX = 2
		m.lnTextOffsetY = 2
		
		DO CASE
		CASE This.Align = m.loFRXC.ALIGN_RIGHT()
		    m.lnTextOffsetX = -2 + IIF(This.ObjType = m.loFRXC.FRX_OBJ_LABEL(), -This.Font.FontHeightCeil * 2, 0)
		
		CASE This.Align = m.loFRXC.ALIGN_CENTER()
		    m.lnTextOffsetX = IIF(This.ObjType = m.loFRXC.FRX_OBJ_LABEL(), -This.Font.FontHeightCeil, 0)
		
		ENDCASE
		
		
		*******************************************************
		LOCAL loLineRect
		m.loLineRect = NEWOBJECT("empty")
		ADDPROPERTY(m.loLineRect, "x", 0.0)
		ADDPROPERTY(m.loLineRect, "y", 0.0)
		ADDPROPERTY(m.loLineRect, "width", CEILING(m.lnWidth) + 0.0)
		ADDPROPERTY(m.loLineRect, "height", m.loFont.FontHeightCeil + 0.0)
		
		
		LOCAL lnLineHeight
		m.lnLineHeight = m.loFont.LineHeight
		
		IF m.lnLineHeight <= 0
		    ERROR 2005, (This.Class + ".Font.LineHeight <= 0")
		ENDIF
		
		LOCAL lhStringFormat
		m.lhStringFormat = 0
		
		TRY
		    IF This.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		        This.env.API_GDIP.GdipStringFormatGetGenericTypographic(@m.lhStringFormat)
		    ELSE
		        IF m.loFont.FontPrivate
		            * VFP is unable to use private gdi+ fonts, thus it renders field with fallback font, this font can be smaller than actual report font
		            * thus GenerericTypographic is used to make resulting text lines more condensed 
		            This.env.API_GDIP.GdipStringFormatGetGenericTypographic(@m.lhStringFormat)
		        ELSE
		            This.env.API_GDIP.GdipStringFormatGetGenericDefault(@m.lhStringFormat)
		            This.env.API_GDIP.GdipSetStringFormatFlags(m.lhStringFormat, This.env.API_GDIP.CONST.Gdip_StringFormatFlagsLineLimit())
		        ENDIF
		
		        This.env.API_GDIP.GdipSetStringFormatTrimming(m.lhStringFormat, ;
		            IIF(FLOOR(m.lnHeight / EVL(m.lnLineHeight,1)) <= 1, ;
		                This.env.API_GDIP.CONST.Gdip_StringTrimmingCharacter(), ;
		                This.env.API_GDIP.CONST.Gdip_StringTrimmingNone()) ;
		            )
		    ENDIF
		
		    This.env.API_GDIP.GdipSetStringFormatAlign(m.lhStringFormat, ;
		        ICASE(;
		            This.Align = m.loFRXC.ALIGN_LEFT(), This.env.API_GDIP.CONST.Gdip_StringAlignmentNear(), ;
		            This.Align = m.loFRXC.ALIGN_RIGHT(), This.env.API_GDIP.CONST.Gdip_StringAlignmentFar(), ;
		            This.Align = m.loFRXC.ALIGN_CENTER(), This.env.API_GDIP.CONST.Gdip_StringAlignmentCenter(), ;
		            This.env.API_GDIP.CONST.Gdip_StringAlignmentNear() ;
		            ))
		
		
		    *******************************************************
		    LOCAL liLine, lnCharIndex, lnLineCharsFitted, lcLineText
		    m.liLine = 0
		    m.lnCharIndex = 1
		    DO WHILE .T.
		
		        m.liLine = m.liLine + 1
		
		        IF m.liLine > 1
		            m.liLine = m.liLine + ICASE(This.LineSpacing = 1, 0.5, This.LineSpacing = 2, 1, 0)
		
		            IF FLOOR(m.liLine * m.lnLineHeight) > m.lnHeight
		                EXIT
		            ENDIF
		        ENDIF
		        
		        m.lcLineText = SUBSTR(This.Text, m.lnCharIndex * 2 - 1)
		
		        m.lnLineCharsFitted = 0
		
		        LOCAL loLineTextRect
		        This.MeasureString(m.lcLineText, m.loLineRect, m.lhStringFormat, @m.loLineTextRect, @m.lnLineCharsFitted)
		
		        m.lcLineText = RTRIM(SUBSTR(m.lcLineText, 1, m.lnLineCharsFitted * 2), 1, CHR(13)+CHR(0), CHR(10)+CHR(0))
		        
		        m.lnCharIndex = m.lnCharIndex + m.lnLineCharsFitted
		
		        IF EMPTY(m.lcLineText) = .F.
		            LOCAL loTextLine
		            m.loTextLine = NEWOBJECT("Empty")
		            ADDPROPERTY(m.loTextLine, "Text", m.lcLineText)
		            ADDPROPERTY(m.loTextLine, "Left", m.lnTextOffsetX)
		            ADDPROPERTY(m.loTextLine, "Top", (m.liLine-1) * m.lnLineHeight + m.lnTextOffsetY)
		            ADDPROPERTY(m.loTextLine, "Width", m.lnWidth)
		            ADDPROPERTY(m.loTextLine, "Height", m.lnLineHeight)
		            ADDPROPERTY(m.loTextLine, "TextWidth", m.loLineTextRect.Width)
		            ADDPROPERTY(m.loTextLine, "TextHeight", m.loLineTextRect.Height)
		            
		
		            m.lnTextLinesCount = m.lnTextLinesCount + 1
		            
		            DIMENSION m.laTextLines(m.lnTextLinesCount)    
		            m.laTextLines[m.lnTextLinesCount] = m.loTextLine
		        ENDIF
		                        
		    ENDDO
		    *******************************************************
		
		FINALLY
		    
		    IF EMPTY(m.lhStringFormat) = .F.
		        This.env.API_GDIP.GdipDeleteStringFormat(m.lhStringFormat)
		        m.lhStringFormat = 0
		    ENDIF
		    
		ENDTRY
		
		RETURN m.lnTextLinesCount
		
	ENDPROC

	PROCEDURE render_textasimage		&& Render text as an image; Returns character representation in PNG format
		LPARAMETERS ResPictureVal as String, ResImgWidth as Long, ResImgHeight as Long
		
		LOCAL loFont
		m.loFont = This.Font
		
		LOCAL lcTempFileName
		m.lcTempFileName = This.env.GetUniqueTempFileName("png")
		
		
		LOCAL loFRXC
		m.loFRXC = This.env.API_FRX.CONST
		
		m.ResPictureVal = ""
		m.ResImgWidth = This.SizeWidth
		m.ResImgHeight = This.SizeHeight
		
		LOCAL lhStringFormat
		m.lhStringFormat = 0
		
		LOCAL lhImage, lhGfx, lhBrush
		STORE 0 TO m.lhImage, m.lhGfx, m.lhBrush
		
		TRY
		
		    LOCAL lnWidth, lnHeight
		    m.lnWidth = m.ResImgWidth
		    m.lnHeight = m.ResImgHeight
		    
		    IF This.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		        m.lnWidth = m.lnWidth + This.Font.FontHeightCeil * 2
		        m.ResImgWidth = m.lnWidth
		    ENDIF
		      
		    LOCAL lnTextOffsetX, lnTextOffsetY
		    m.lnTextOffsetX = 1
		    m.lnTextOffsetY = 1
		
		    DO CASE
		    CASE This.Align = m.loFRXC.ALIGN_RIGHT()
		        m.lnTextOffsetX = -1 + IIF(This.ObjType = m.loFRXC.FRX_OBJ_LABEL(), -This.Font.FontHeightCeil * 2, 0)
		
		    CASE This.Align = m.loFRXC.ALIGN_CENTER()
		        m.lnTextOffsetX = IIF(This.ObjType = m.loFRXC.FRX_OBJ_LABEL(), -This.Font.FontHeightCeil, 0)
		
		    ENDCASE
		
		    LOCAL lnLineHeight
		    m.lnLineHeight = m.loFont.LineHeight
		    
		    
		    LOCAL lnImgScale, lnImgWidth, lnImgHeight, lnImgPixelFormat
		    m.lnImgScale = 2
		    m.lnImgWidth = m.lnWidth * m.lnImgScale
		    m.lnImgHeight = m.lnHeight * m.lnImgScale
		    m.lnImgPixelFormat = This.env.API_GDIP.CONST.Gdip_PixelFormat32bppARGB()
		
		    
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateBitmapFromScan0(m.lnImgWidth, m.lnImgHeight, 0, m.lnImgPixelFormat, NULL, @m.lhImage))
		    
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetImageGraphicsContext(m.lhImage, @m.lhGfx))
		
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSetCompositingMode(m.lhGfx, 0))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSetCompositingQuality(m.lhGfx, 2))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSetPixelOffsetMode(m.lhGfx, 2))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSetTextRenderingHint(m.lhGfx, 4))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSetTextContrast(m.lhGfx, 0))
		
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipScaleWorldTransform(m.lhGfx, m.lnImgScale, m.lnImgScale))
		    
		    
		    *******************************************************
		    * Background mode 0 - Opaque, 1 - Transparent
		    IF This.Transparent = 0
		        LOCAL lnColor
		        m.lnColor = This.env.API_GDIP.ARGB(This.FillAlpha, This.FillRed, This.FillGreen, This.FillBlue)
		        This.env.API_GDIP.GdipCreateSolidFill(m.lnColor, @m.lhBrush)
		        This.env.API_GDIP.GdipFillRectangleI(m.lhGfx, m.lhBrush, 0, 0, m.lnImgWidth, m.lnImgHeight)
		        This.env.API_GDIP.GdipDeleteBrush(m.lhBrush)
		        m.lhBrush = 0
		    ENDIF
		    *******************************************************
		    
		    LOCAL lnColor
		    m.lnColor = This.env.API_GDIP.ARGB(This.PenAlpha, This.PenRed, This.PenGreen, This.PenBlue)
		    This.env.API_GDIP.GdipCreateSolidFill(m.lnColor, @m.lhBrush)
		    
		    
		    IF This.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		
		        This.env.API_GDIP.GdipStringFormatGetGenericTypographic(@m.lhStringFormat)
		        
		        This.env.API_GDIP.GdipSetStringFormatAlign(m.lhStringFormat, ;
		            ICASE(;
		                This.Align = m.loFRXC.ALIGN_LEFT(), This.env.API_GDIP.CONST.Gdip_StringAlignmentNear(), ;
		                This.Align = m.loFRXC.ALIGN_RIGHT(), This.env.API_GDIP.CONST.Gdip_StringAlignmentFar(), ;
		                This.Align = m.loFRXC.ALIGN_CENTER(), This.env.API_GDIP.CONST.Gdip_StringAlignmentCenter(), ;
		                This.env.API_GDIP.CONST.Gdip_StringAlignmentNear() ;
		                ))
		        
		        
		        LOCAL laLines(1), lnLineCnt, lnLine, lcLineText, lnLineTop
		        m.lnLineCnt = ALINES(m.laLines, STRTRAN(This.Text, CHR(10)+CHR(0), CHR(10)), 0, CHR(10))
		        
		        m.lnLineTop = 0
		        
		        FOR m.lnLine = 1 TO m.lnLineCnt
		            
		            m.lcLineText = m.laLines[m.lnLine]
		            
		            m.lnLineTop = m.lnLineTop + 1
		            IF m.lnLine > 1
		                m.lnLineTop = m.lnLineTop + ICASE(This.LineSpacing = 1, 0.5, This.LineSpacing = 2, 1, 0)
		            ENDIF
		            
		            LOCAL lqLayoutRect
		            m.lqLayoutRect = ;
		                BINTOC(m.lnTextOffsetX + ICASE(This.Align = m.loFRXC.ALIGN_RIGHT(), m.lnWidth, This.Align = m.loFRXC.ALIGN_CENTER(), m.lnWidth * 0.5, 0), "F") +;
		                BINTOC(m.lnTextOffsetY + (m.lnLineTop - 1) * m.lnLineHeight, "F") + ;
		                BINTOC(0, "F") + ;
		                BINTOC(0, "F")
		            
		
		            This.env.API_GDIP.GdipDrawString(;
		                m.lhGfx, ;
		                m.lcLineText + CHR(0), ;
		                LEN(m.lcLineText) / 2, ;
		                m.loFont.GdipFont, ;
		                @m.lqLayoutRect, ;
		                m.lhStringFormat, ;
		                m.lhBrush)
		                
		        ENDFOR    
		
		    ELSE
		
		        IF m.loFont.FontPrivate 
		            * VFP is unable to use private gdi+ fonts, thus it renders field with fallback font, this font can be smaller than actual report font
		            * thus GenerericTypographic is used to make resulting text lines more condensed 
		            This.env.API_GDIP.GdipStringFormatGetGenericTypographic(@m.lhStringFormat)
		        ELSE
		            This.env.API_GDIP.GdipStringFormatGetGenericDefault(@m.lhStringFormat)
		            This.env.API_GDIP.GdipSetStringFormatFlags(m.lhStringFormat, This.env.API_GDIP.CONST.Gdip_StringFormatFlagsLineLimit())
		        ENDIF
		
		        This.env.API_GDIP.GdipSetStringFormatTrimming(m.lhStringFormat, ;
		            IIF(FLOOR(m.lnHeight / EVL(m.lnLineHeight,1)) <= 1, ;
		                This.env.API_GDIP.CONST.Gdip_StringTrimmingCharacter(), ;
		                This.env.API_GDIP.CONST.Gdip_StringTrimmingNone()) ;
		            )
		
		        This.env.API_GDIP.GdipSetStringFormatAlign(m.lhStringFormat, ;
		            ICASE(;
		                This.Align = m.loFRXC.ALIGN_LEFT(), This.env.API_GDIP.CONST.Gdip_StringAlignmentNear(), ;
		                This.Align = m.loFRXC.ALIGN_RIGHT(), This.env.API_GDIP.CONST.Gdip_StringAlignmentFar(), ;
		                This.Align = m.loFRXC.ALIGN_CENTER(), This.env.API_GDIP.CONST.Gdip_StringAlignmentCenter(), ;
		                This.env.API_GDIP.CONST.Gdip_StringAlignmentNear() ;
		                ))
		
		
		        LOCAL lqLayoutRect
		        m.lqLayoutRect = ;
		            BINTOC(m.lnTextOffsetX, "F") +;
		            BINTOC(m.lnTextOffsetY, "F") + ;
		            BINTOC(CEILING(m.lnWidth), "F") + ;
		            BINTOC(CEILING(m.lnHeight), "F")
		        
		
		        This.env.API_GDIP.GdipDrawString(;
		            m.lhGfx, ;
		            This.Text + CHR(0), ;
		            LEN(This.Text) / 2, ;
		            m.loFont.GdipFont, ;
		            @m.lqLayoutRect, ;
		            m.lhStringFormat, ;
		            m.lhBrush)
		    
		    ENDIF
		
		    LOCAL lcImgEncoder
		    m.lcImgEncoder = This.env.API_GDIP.GdipGetImageEncoder("image/png")
		    
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSaveImageToFile(m.lhImage, STRCONV(m.lcTempFileName,5)+CHR(0), m.lcImgEncoder, 0))
		    
		    m.ResPictureVal = FILETOSTR(m.lcTempFileName)
		
		
		FINALLY
		
		    IF EMPTY(m.lhStringFormat) = .F.
		        This.env.API_GDIP.GdipDeleteStringFormat(m.lhStringFormat)
		        m.lhStringFormat = 0
		    ENDIF
		    
		    IF EMPTY(m.lhGfx) = .F.
		        This.env.API_GDIP.GdipDeleteGraphics(m.lhGfx)
		    ENDIF
		    
		    IF EMPTY(m.lhImage) = .F.
		        This.env.API_GDIP.GdipDisposeImage(m.lhImage)
		        m.lhImage = 0
		    ENDIF
		    
		    IF EMPTY(m.lhBrush) = .F.
		        This.env.API_GDIP.GdipDeleteBrush(m.lhBrush)
		        m.lhBrush = 0
		    ENDIF
		
		
		    IF FILE(m.lcTempFileName,1)
		        DELETE FILE (m.lcTempFileName)
		    ENDIF
		ENDTRY
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreportviewer AS form 		&& Report preview for PdfiumReport. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="PdfiumViewer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSaveAs" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFitWidth" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFitPage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmbScale" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPageInfo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExportDocx" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="env" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: close		&& Close preview window
		*m: exportdocument
		*m: openpdf		&& Open pdf file
		*m: printreport		&& Print report
		*m: savedocument
		*m: scalechanged		&& Scale change handling
		*m: setreport		&& ReportPreviewer interface requirement (reead docs on ReportPreviewer, ReportListener)
		*p: listenerref
		*p: saveas_filename		&& Filename suggestion for "save as" dialog
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN listenerref
	*<PropValue>
		Caption = "Pdfium report preview"
		Desktop = .F.
		DoCreate = .T.
		Height = 741
		Icon = ("images\wwrite.ico")
		KeyPreview = .T.
		Left = 0
		listenerref = .F.
		MaxButton = .T.
		MinButton = .F.
		Name = "pdfiumreportviewer"
		saveas_filename = ("")
		ScrollBars = 0
		ShowWindow = 1
		Top = 0
		Visible = .T.
		Width = 792
		WindowState = 0
		WindowType = 0
		_memberdata = <VFPData>
			<memberdata name="openpdf" type="method" display="OpenPDF"/>
			<memberdata name="setreport" type="method" display="SetReport"/>
			<memberdata name="listenerref" type="property" display="ListenerRef"/>
			<memberdata name="printreport" type="method" display="PrintReport"/>
			<memberdata name="close" type="method" display="Close"/>
			<memberdata name="scalechanged" type="method" display="ScaleChanged"/>
			<memberdata name="saveas_filename" type="property" display="SaveAs_Filename"/>
			<memberdata name="savedocument" type="method" display="SaveDocument"/>
			<memberdata name="exportdocument" type="method" display="ExportDocument"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cmbScale' AS combobox WITH ;
		BoundColumn = 1, ;
		BoundTo = .F., ;
		ColumnCount = 1, ;
		ColumnLines = .F., ;
		ColumnWidths = "80,0", ;
		ControlSource = "", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 27, ;
		Left = 579, ;
		Name = "cmbScale", ;
		Style = 2, ;
		TabIndex = 9, ;
		TabStop = .F., ;
		Top = 11, ;
		Width = 65
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdClose' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 736, ;
		Name = "cmdClose", ;
		Picture = images\close.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 10, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdExportDocx' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 431, ;
		Name = "cmdExportDocx", ;
		Picture = images\docx.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 6, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFitPage' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 528, ;
		Name = "cmdFitPage", ;
		Picture = images\fitpage.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 8, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFitWidth' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 482, ;
		Name = "cmdFitWidth", ;
		Picture = images\fitwidth.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 7, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrint' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "  Print", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 237, ;
		Name = "cmdPrint", ;
		Picture = images\print.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 4, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 135
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSaveAs' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 384, ;
		Name = "cmdSaveAs", ;
		Picture = images\saveas.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 5, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSearch' AS commandbutton WITH ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 189, ;
		Name = "cmdSearch", ;
		Picture = images\search.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 14, ;
		PictureSpacing = 0, ;
		TabIndex = 3, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'env' AS pdfium_env WITH ;
		Left = 456, ;
		Name = "env", ;
		Top = 60, ;
		API_FPDF.CONST.Name = "CONST", ;
		API_FPDF.Name = "API_FPDF", ;
		API_WIN.Name = "API_WIN", ;
		API_FRX.CONST.Name = "CONST", ;
		API_FRX.Name = "API_FRX", ;
		API_GDIP.CONST.Name = "CONST", ;
		API_GDIP.Name = "API_GDIP"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 192, ;
		Name = "i18n", ;
		Top = 72, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'lblPageInfo' AS label WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "1234 / 1234", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 648, ;
		Name = "lblPageInfo", ;
		TabIndex = 11, ;
		Top = 15, ;
		Width = 76
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'PdfiumViewer' AS pdfiumviewer WITH ;
		Anchor = 15, ;
		Enabled = .T., ;
		Height = 681, ;
		Left = 12, ;
		Name = "PdfiumViewer", ;
		scrollbars = 3, ;
		TabIndex = 1, ;
		TabStop = .T., ;
		Top = 48, ;
		Visible = .T., ;
		Width = 768, ;
		cmdFocus.Name = "cmdFocus", ;
		env.API_FPDF.CONST.Name = "CONST", ;
		env.API_FPDF.Name = "API_FPDF", ;
		env.API_FRX.CONST.Name = "CONST", ;
		env.API_FRX.Name = "API_FRX", ;
		env.API_GDIP.CONST.Name = "CONST", ;
		env.API_GDIP.Name = "API_GDIP", ;
		env.API_WIN.Name = "API_WIN", ;
		env.Name = "env", ;
		i18n.API_WIN.Name = "API_WIN", ;
		i18n.Name = "i18n", ;
		UIState.Name = "UIState"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="control" />

	ADD OBJECT 'txtSearch' AS pdfium_textbox WITH ;
		Anchor = 0, ;
		InputMask = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", ;
		Left = 12, ;
		Name = "txtSearch", ;
		TabIndex = 2, ;
		TabStop = .F., ;
		Top = 11
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />
	
	PROCEDURE close		&& Close preview window
		IF VARTYPE(This.ListenerRef)="O"
		    This.ListenerRef.OnPreviewClose()
		    This.ListenerRef = .F.
		ENDIF
		
		This.Hide()
		
	ENDPROC

	PROCEDURE Destroy
		This.Pdfiumviewer.Destroy()
		
	ENDPROC

	PROCEDURE exportdocument
		LPARAMETERS tcExt
		
		LOCAL lcExt
		m.lcExt = LOWER(EVL(m.tcExt, "docx"))
		
		LOCAL lcTempFileName
		m.lcTempFileName = ""
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    LOCAL loRenderer
		    m.loRenderer = .F.
		    DO CASE
		    CASE m.lcExt == "docx"
		        m.loRenderer = NEWOBJECT("pdfiumreport_renderer_docx", Thisform.ClassLibrary, "", This.env)
		    ENDCASE
		
		    IF VARTYPE(m.loRenderer) <> "O"
		        EXIT
		    ENDIF
		
		    LOCAL lcOutputFileName
		    m.lcOutputFileName = This.env.GetSaveFileName(Thisform.SaveAs_Filename, m.lcExt)
		
		    IF EMPTY(m.lcOutputFileName)
		        EXIT
		    ENDIF
		
		    m.lcTempFileName = This.ListenerRef.RunRenderer(m.loRenderer)
		    IF FILE(m.lcTempFileName,1)
		        COPY FILE (m.lcTempFileName) TO (m.lcOutputFileName)
		        This.env.API_Win.ShellExecute(0, "Open", FULLPATH(m.lcOutputFileName), NULL, SYS(2023), 1)
		    ENDIF
		    
		CATCH TO m.loErr
		    MESSAGEBOX(This.env.ErrFmt(m.loErr), 0+48, This.Class + " ("+This.ClassLibrary+")")
		    
		FINALLY
		    TRY
		        IF FILE(m.lcTempFileName,1)
		            DELETE FILE (m.lcTempFileName)
		        ENDIF
		    CATCH
		    ENDTRY
		
		ENDTRY    
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp, toPrintEnv as Pdfium_print_env of pdfium-vfp.vcx
		
		This.env.Setup(m.toEnv)
		
		This.Pdfiumviewer.Init(m.toEnv)
		
		This.Pdfiumviewer.PrintEnv.Setup(m.toPrintEnv)
		
		
		BINDEVENT(This.PdfiumViewer, "scale", This, "scalechanged", 1)
		
		This.Caption = This.i18n.text("REPORTVIEWER_TITLE")
		
		This.MinWidth = This.Width
		This.MinHeight = 300
		
		
		LOCAL loTopLevelForm
		IF TYPE("Application.ActiveForm") = "O"
		    m.loTopLevelForm = Application.ActiveForm
		ELSE
		    m.loTopLevelForm = _SCREEN    
		ENDIF
		
		IF m.loTopLevelForm.ShowWindow <> 2
		    m.loTopLevelForm = _SCREEN
		ENDIF
		
		
		IF m.loTopLevelForm = _SCREEN
		    LOCAL lnTop, lnBottom
		    m.lnTop = 0
		    m.lnBottom = m.loTopLevelForm.Height
		
		
		    LOCAL i, loForm
		    FOR m.i = 1 TO m.loTopLevelForm.FormCount
		        m.loForm = m.loTopLevelForm.Forms[m.i]
		        
		        IF m.loForm = Thisform
		            LOOP
		        ENDIF
		
		        IF m.loForm.DockPosition = 0
		            m.lnTop = MAX(m.lnTop, m.loForm.Top + m.loForm.Height)
		        ENDIF
		
		        IF m.loForm.DockPosition = 3
		            m.lnBottom = MIN(m.lnBottom, m.loForm.Height - laDockState[m.i,6].Top)
		        ENDIF
		        
		    ENDFOR
		
		    This.Width = MAX(MIN(m.loTopLevelForm.Height, m.loTopLevelForm.Width) - SYSMETRIC(3) , This.MinWidth) 
		    This.Height = MAX(MAX(m.lnBottom - m.lnTop, This.Height) - SYSMETRIC(4), This.MinHeight)
		
		ENDIF
		
		This.WindowState = 2
		This.TitleBar = 0
		This.BorderStyle = 0
		
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		DO CASE
		CASE m.nKeyCode = 6 AND m.nShiftAltCtrl = 2 && Ctrl + F
		    NODEFAULT
		    This.txtSearch.SetFocus()
		
		CASE m.nKeyCode = -2 AND m.nShiftAltCtrl = 0 && F3
		    NODEFAULT
		    Thisform.cmdSearch.Click()
		
		ENDCASE
		
	ENDPROC

	PROCEDURE openpdf		&& Open pdf file
		LPARAMETERS tcFilename, tcPassword
		
		RETURN This.pdfiumviewer.OpenPDF(m.tcFilename, m.tcPassword)
		
	ENDPROC

	PROCEDURE printreport		&& Print report
		This.PdfiumViewer.PrintDocument()
		
	ENDPROC

	PROCEDURE QueryUnload
		
		This.Close()
		
		
	ENDPROC

	PROCEDURE Resize
		IF This.ScrollBars > 0 AND Thisform.WindowState = 2
		    This.Cls()
		ENDIF
		This.Refresh()
		
	ENDPROC

	PROCEDURE savedocument
		LOCAL lcFilename
		m.lcFilename = This.env.GetSaveFileName(Thisform.SaveAs_Filename, "pdf")
		
		IF EMPTY(m.lcFilename)
		    RETURN
		ENDIF
		
		Thisform.pdfiumviewer.SaveDocument(m.lcFileName)
		
	ENDPROC

	PROCEDURE scalechanged		&& Scale change handling
		LOCAL lnScale, lcScale
		m.lnScale = This.PdfiumViewer.Scale
		m.lcScale = TRANSFORM(INT(m.lnScale*100)) + "%"
		
		IF INLIST(m.lnScale,1,2,3,4)=.F.
		    This.cmbScale.List[1] = m.lcScale
		ELSE
		    This.cmbScale.List[1] = ""
		ENDIF
		
		This.cmbScale.Value = m.lcScale
		
	ENDPROC

	PROCEDURE setreport		&& ReportPreviewer interface requirement (reead docs on ReportPreviewer, ReportListener)
		LPARAMETERS toListenerRef 
		
		This.ListenerRef = m.toListenerRef 
		
	ENDPROC

	PROCEDURE cmbScale.Init
		This.AddItem("")
		This.AddItem("100%")
		This.AddItem("200%")
		This.AddItem("300%")
		This.AddItem("400%")
		
	ENDPROC

	PROCEDURE cmbScale.InteractiveChange
		Thisform.pdfiumviewer.Scale = MIN(MAX(INT(VAL(EVL(This.Value,"100")))/100,0.25),4)
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdClose.Click
		Thisform.Close()
		
		
	ENDPROC

	PROCEDURE cmdExportDocx.Click
		Thisform.ExportDocument("docx")
		
	ENDPROC

	PROCEDURE cmdFitPage.Click
		Thisform.pdfiumviewer.FitWidth = .F.
		Thisform.pdfiumviewer.Scale = 1
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdFitPage.Refresh
		IF Thisform.pdfiumviewer.FitWidth = .T. and This.Enabled = .F.
		    This.Enabled = .T.
		ENDIF
		
		IF Thisform.pdfiumviewer.FitWidth = .F. and This.Enabled = .T.
		    This.Enabled = .F.
		ENDIF
		
		
	ENDPROC

	PROCEDURE cmdFitWidth.Click
		Thisform.pdfiumviewer.FitWidth = .T.
		Thisform.pdfiumviewer.Scale = 1
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdFitWidth.Refresh
		IF Thisform.pdfiumviewer.FitWidth = .T. and This.Enabled = .T.
		    This.Enabled = .F.
		ENDIF
		
		IF Thisform.pdfiumviewer.FitWidth = .F. and This.Enabled = .F.
		    This.Enabled = .T.
		ENDIF
		
		
	ENDPROC

	PROCEDURE cmdPrint.Click
		Thisform.PrintReport()
		
	ENDPROC

	PROCEDURE cmdPrint.Refresh
		This.Caption = SPACE(2) + Thisform.i18n.text("BTN_PRINT")
		
	ENDPROC

	PROCEDURE cmdSaveAs.Click
		Thisform.SaveDocument()
		
	ENDPROC

	PROCEDURE cmdSearch.Click
		CLEAR TYPEAHEAD 
		
		IF EMPTY(Thisform.txtSearch.Value)
		    Thisform.pdfiumviewer.SearchClose()
		ELSE
		    LOCAL lnRes
		    m.lnRes = Thisform.Pdfiumviewer.SearchText(Thisform.txtSearch.Value)
		    DO CASE
		    CASE m.lnRes = 0
		        WAIT WINDOW Thisform.i18n.text("SEARCH_NOT_FOUND") NOWAIT
		    CASE m.lnRes = 2
		        WAIT WINDOW Thisform.i18n.text("SEARCH_ENDED") NOWAIT
		    ENDCASE
		    
		ENDIF
		
	ENDPROC

	PROCEDURE lblPageInfo.Refresh
		This.Caption = TRANSFORM(Thisform.PdfiumViewer.GetCurrentPage()) + " / " + TRANSFORM(Thisform.PdfiumViewer.GetPageCount())
		
	ENDPROC

	PROCEDURE PdfiumViewer.afterviewportupdate
		Thisform.lblPageInfo.Refresh()
		
	ENDPROC

	PROCEDURE txtSearch.GotFocus
		Thisform.pdfiumviewer.SearchClose()
		
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE txtSearch.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 13 AND EMPTY(m.nShiftAltCtrl) AND EMPTY(This.Value)=.F.
		    NODEFAULT
		    Thisform.cmdSearch.Click()
		ENDIF    
		
		DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumviewer AS control 		&& PDF viewer control.
 	*< CLASSDATA: Baseclass="control" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdFocus" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="env" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="UIState" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: afterviewportupdate		&& Event. Triggered after ViewPortUpdate call
		*m: backcolor_assign
		*m: closepdf		&& Close pdf file, previously opened by PdfiumViewer.openpdf
		*m: contextmenu
		*m: drawbufcreate
		*m: drawbufrelease
		*m: errmsg
		*m: fitwidth_assign
		*m: getcurrentpage		&& Current page number. First page has number = 1
		*m: getpagecount		&& Returns page count
		*m: getpagesize		&& Returns page dimensions (see comment in source code)
		*m: keypress		&& Occurs when the user presses and releases a key.
		*m: openpdf		&& Open pdf file. Returns: .T. on success, .F. if file was not loaded
		*m: pagepick
		*m: printdocument		&& Send document to printer with preceding setup dialog
		*m: printenv_access
		*m: printenv_assign
		*m: redraw
		*m: renderpages
		*m: rendersearch
		*m: renderselection
		*m: savedocument		&& Save document to file
		*m: scale_assign
		*m: scrollbars_assign
		*m: scrollhorz
		*m: scrollvert
		*m: searchclose		&& Stop search
		*m: searchtext		&& Text for searching. SearchClose must be called to stop search results rendering
		*m: selectioncopy		&& Copy selected text to clipboard
		*m: selecttext
		*m: selecttextall		&& Select all text in the document
		*m: viewportupdate
		*m: wndcreate
		*m: wndproc		&& Events handler of PdfiumViewer internal window. Developer must not use or redefine this method
		*m: wndredraw
		*m: wndrelease
		*m: wndresize
		*m: wndshow		&& Show child window (for internal use, public for bindevent)
		*p: backcolorbrush
		*p: dblclickbegin
		*p: drawbufdc
		*p: drawbufdib
		*p: drawbufgfx
		*p: fitwidth
		*p: fpdf_doc
		*p: fpdf_opened
		*p: fpdf_pagecount
		*p: fpdf_page_first_visible		&& Index of the page that appears first after rendering
		*p: fpdf_page_last_visible
		*p: isfocused		&& .T. if control has input focus
		*p: pagefillbrush
		*p: printenv		&& Print configuration state (pdfium_print_env object); Read-Only
		*p: scale
		*p: scrollbars		&& Specifies the type of scroll bars that an EditBox control, Form object, or Grid control has. 0 - None (Default); 1 - Horizontal; 2 - Vertical; 3 - Both vertical and horizontal
		*p: searchbrush
		*p: searchstate_dir
		*p: searchstate_findwhat
		*p: searchstate_rescount
		*p: searchstate_resindex
		*p: searchstate_respage
		*p: searchstate_resrect
		*p: selectionbrush
		*p: selectioncharindexprev
		*p: selectioncharindexstart
		*p: tplclickbegin
		*p: viewportmaxx
		*p: viewportmaxy
		*p: viewportsizex
		*p: viewportsizey
		*p: viewportx
		*p: viewporty
		*p: wndclassname
		*p: wnddc
		*p: wndhandle		&& Specifies the Window handle of the Window.
		*a: fpdf_pages[1,0]
		*a: fpdf_pages_pos[1,4]
		*a: fpdf_pages_selection[1,3]
		*a: fpdf_pages_size[1,4]
		*a: fpdf_text_pages[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _printenv
	*</DefinedPropArrayMethod>

	HIDDEN ActiveControl,AddProperty,backcolorbrush,BackStyle,BorderColor,BorderWidth,Click,CloneObject,ColorSource,ControlCount,Controls,dblclickbegin,DblClick,DragDrop,DragIcon,DragMode,DragOver,Drag,drawbufdc,drawbufdib,drawbufgfx,Draw,Error,ForeColor,fpdf_doc,fpdf_opened,fpdf_pagecount,fpdf_pages,fpdf_pages_pos,fpdf_pages_selection,fpdf_pages_size,fpdf_page_first_visible,fpdf_page_last_visible,fpdf_text_pages,GotFocus,HelpContextID,isfocused,LostFocus,MiddleClick,MouseDown,MouseEnter,MouseIcon,MouseLeave,MouseMove,MousePointer,MouseUp,MouseWheel,Moved,Objects,OLECompleteDrag,OLEDragDrop,OLEDragMode,OLEDragOver,OLEDragPicture,OLEDrag,OLEDropEffects,OLEDropHasData,OLEDropMode,OLEGiveFeedback,OLESetData,OLEStartDrag,pagefillbrush,ParentClass,Picture,ReadExpression,ReadMethod,Refresh,ResetToDefault,Resize,RightClick,SaveAsClass,searchbrush,searchstate_dir,searchstate_findwhat,searchstate_rescount,searchstate_resindex,searchstate_respage,searchstate_resrect,selectionbrush,selectioncharindexprev,selectioncharindexstart,ShowWhatsThis,SpecialEffect,Style,Tag,tplclickbegin,UIEnable,viewportmaxx,viewportmaxy,viewportsizex,viewportsizey,viewportx,viewporty,WhatsThisHelpID,wndclassname,wnddc,wndhandle,WriteExpression,WriteMethod,ZOrder,_printenv
	*<PropValue>
		backcolorbrush = .F.
		BackStyle = 1
		dblclickbegin = 0
		drawbufdc = 0
		drawbufdib = 0
		drawbufgfx = 0
		fitwidth = .F.
		fpdf_doc = 0
		fpdf_opened = .F.
		fpdf_pagecount = 0
		fpdf_page_first_visible = 0
		fpdf_page_last_visible = 0
		Height = 622
		isfocused = .F.
		Name = "pdfiumviewer"
		pagefillbrush = 0
		printenv = .F.
		scale = 1
		scrollbars = 0
		searchbrush = .F.
		searchstate_dir = 0
		searchstate_findwhat = ("")
		searchstate_rescount = 0
		searchstate_resindex = 0
		searchstate_respage = 0
		searchstate_resrect = ("")
		selectionbrush = .F.
		selectioncharindexprev = -1
		selectioncharindexstart = 0
		tplclickbegin = 0
		viewportmaxx = 0
		viewportmaxy = 0
		viewportsizex = 0
		viewportsizey = 0
		viewportx = 0
		viewporty = 0
		Visible = .T.
		Width = 445
		wndclassname = ("PDFIUM-VFP-VIEWER")
		wnddc = 0
		wndhandle = 0
		_memberdata = <VFPData>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="drawbufgfx" type="property" display="DrawBufGFX"/>
			<memberdata name="drawbufrelease" type="method" display="DrawBufRelease"/>
			<memberdata name="errmsg" type="method" display="ErrMsg"/>
			<memberdata name="fpdf_doc" type="property" display="fpdf_doc"/>
			<memberdata name="fpdf_opened" type="property" display="fpdf_opened"/>
			<memberdata name="fpdf_pagecount" type="property" display="fpdf_pagecount"/>
			<memberdata name="fpdf_pages" type="property" display="fpdf_pages"/>
			<memberdata name="fpdf_pages_pos" type="property" display="fpdf_pages_pos"/>
			<memberdata name="fpdf_pages_selection" type="property" display="fpdf_pages_selection"/>
			<memberdata name="fpdf_pages_size" type="property" display="fpdf_pages_size"/>
			<memberdata name="fpdf_page_first_visible" type="property" display="fpdf_page_first_visible"/>
			<memberdata name="fpdf_page_last_visible" type="property" display="fpdf_page_last_visible"/>
			<memberdata name="fpdf_text_pages" type="property" display="fpdf_text_pages"/>
			<memberdata name="getcurrentpage" type="method" display="GetCurrentPage"/>
			<memberdata name="getpagecount" type="method" display="GetPageCount"/>
			<memberdata name="getpagesize" type="method" display="GetPageSize"/>
			<memberdata name="keypress" type="method" display="KeyPress"/>
			<memberdata name="openpdf" type="method" display="OpenPDF" favorites="True"/>
			<memberdata name="pagepick" type="method" display="PagePick"/>
			<memberdata name="redraw" type="method" display="Redraw"/>
			<memberdata name="renderpages" type="method" display="RenderPages"/>
			<memberdata name="renderselection" type="method" display="RenderSelection"/>
			<memberdata name="scale" type="property" display="Scale"/>
			<memberdata name="scale_assign" type="method" display="Scale_Assign"/>
			<memberdata name="scrollbars" type="property" display="ScrollBars"/>
			<memberdata name="scrollbars_assign" type="method" display="ScrollBars_Assign"/>
			<memberdata name="scrollhorz" type="method" display="ScrollHorz"/>
			<memberdata name="scrollvert" type="method" display="ScrollVert"/>
			<memberdata name="selectionbrush" type="property" display="SelectionBrush"/>
			<memberdata name="selectioncharindexprev" type="property" display="SelectionCharIndexPrev"/>
			<memberdata name="selectioncharindexstart" type="property" display="SelectionCharIndexStart"/>
			<memberdata name="selectioncopy" type="method" display="SelectionCopy"/>
			<memberdata name="selecttext" type="method" display="SelectText"/>
			<memberdata name="viewportmaxx" type="property" display="ViewPortMaxX"/>
			<memberdata name="viewportmaxy" type="property" display="ViewPortMaxY"/>
			<memberdata name="viewportsizex" type="property" display="ViewPortSizeX"/>
			<memberdata name="viewportsizey" type="property" display="ViewPortSizeY"/>
			<memberdata name="viewportupdate" type="method" display="ViewPortUpdate"/>
			<memberdata name="viewportx" type="property" display="ViewPortX"/>
			<memberdata name="viewporty" type="property" display="ViewPortY"/>
			<memberdata name="wndclassname" type="property" display="WndClassName"/>
			<memberdata name="wndcreate" type="method" display="WndCreate"/>
			<memberdata name="wnddc" type="property" display="WndDC"/>
			<memberdata name="wndhandle" type="property" display="WndHandle"/>
			<memberdata name="wndproc" type="method" display="WndProc"/>
			<memberdata name="wndredraw" type="method" display="WndRedraw"/>
			<memberdata name="wndrelease" type="method" display="WndRelease"/>
			<memberdata name="wndresize" type="method" display="WndResize"/>
			<memberdata name="wndshow" type="method" display="WndShow"/>
			<memberdata name="selecttextall" type="method" display="SelectTextAll"/>
			<memberdata name="dblclickbegin" type="property" display="DblClickBegin"/>
			<memberdata name="tplclickbegin" type="property" display="TplClickBegin"/>
			<memberdata name="rendersearch" type="method" display="RenderSearch"/>
			<memberdata name="searchbrush" type="property" display="SearchBrush"/>
			<memberdata name="searchclose" type="method" display="SearchClose"/>
			<memberdata name="searchstate_findwhat" type="property" display="SearchState_FindWhat"/>
			<memberdata name="searchstate_rescount" type="property" display="SearchState_ResCount"/>
			<memberdata name="searchstate_resindex" type="property" display="SearchState_ResIndex"/>
			<memberdata name="searchstate_respage" type="property" display="SearchState_ResPage"/>
			<memberdata name="searchstate_resrect" type="property" display="SearchState_ResRect"/>
			<memberdata name="searchtext" type="method" display="SearchText"/>
			<memberdata name="searchstate_dir" type="property" display="SearchState_Dir"/>
			<memberdata name="savedocument" type="method" display="SaveDocument"/>
			<memberdata name="fitwidth" type="property" display="FitWidth"/>
			<memberdata name="fitwidth_assign" type="method" display="FitWidth_Assign"/>
			<memberdata name="isfocused" type="property" display="IsFocused"/>
			<memberdata name="printdocument" type="method" display="PrintDocument"/>
			<memberdata name="afterviewportupdate" type="method" display="AfterViewportUpdate"/>
			<memberdata name="printenv" type="property" display="PrintEnv"/>
			<memberdata name="printenv_assign" type="method" display="PrintEnv_Assign"/>
			<memberdata name="printenv_access" type="method" display="PrintEnv_Access"/>
			<memberdata name="_printenv" type="property" display="_PrintEnv"/>
			<memberdata name="pagefillbrush" type="property" display="PageFillBrush"/>
		</VFPData>
		_printenv = .F.
	*</PropValue>

	ADD OBJECT 'cmdFocus' AS pdfiumviewer_cmdfocus WITH ;
		Left = -100, ;
		Name = "cmdFocus", ;
		Top = -100
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'env' AS pdfium_env WITH ;
		Left = 69, ;
		Name = "env", ;
		Top = 24, ;
		API_FPDF.CONST.Name = "CONST", ;
		API_FPDF.Name = "API_FPDF", ;
		API_WIN.Name = "API_WIN", ;
		API_FRX.CONST.Name = "CONST", ;
		API_FRX.Name = "API_FRX", ;
		API_GDIP.CONST.Name = "CONST", ;
		API_GDIP.Name = "API_GDIP"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 108, ;
		Name = "i18n", ;
		Top = 24, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'UIState' AS pdfium_uistate WITH ;
		Left = 24, ;
		Name = "UIState", ;
		Top = 24
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE afterviewportupdate		&& Event. Triggered after ViewPortUpdate call
	ENDPROC

	HIDDEN PROCEDURE backcolor_assign
		LPARAMETERS vNewVal
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.BackColor = m.vNewVal
		
		IF EMPTY(This.BackColorBrush) = .F.
		    This.env.API_GDIP.GdipSetSolidFillColor(This.BackColorBrush, This.env.API_GDIP.ARGB(255, This.BackColor))
		ENDIF
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE closepdf		&& Close pdf file, previously opened by PdfiumViewer.openpdf
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		
		IF This.fpdf_opened
		    This._PrintEnv = .F.
		ENDIF
		
		This.fpdf_opened = .F.
		
		This.SearchClose()
		
		LOCAL lnPage, lnPageCount
		m.lnPageCount = This.fpdf_pagecount
		
		This.fpdf_pagecount = 0
		
		This.fpdf_page_first_visible = 0
		This.fpdf_page_last_visible = 0
		
		This.ViewPortX = 0
		This.ViewPortY = 0
		This.ViewPortSizeX = 0
		This.ViewPortSizeY = 0
		This.ViewPortMaxX = 0
		This.ViewPortMaxY = 0
		
		This.scale = 1
		
		LOCAL lnPage
		FOR m.lnPage = 1 TO m.lnPageCount
		    m.loFPDF.FPDFText_ClosePage(This.fpdf_text_pages[m.lnPage])
		    m.loFPDF.FPDF_ClosePage(This.fpdf_pages[m.lnPage])
		    
		    This.fpdf_pages[m.lnPage] = 0
		    This.fpdf_text_pages[m.lnPage] = 0
		    This.fpdf_pages_selection[m.lnPage,1] = ""
		    This.fpdf_pages_selection[m.lnPage,2] = 0
		    This.fpdf_pages_selection[m.lnPage,3] = 0
		ENDFOR
		
		DIMENSION This.fpdf_pages(1)
		DIMENSION This.fpdf_text_pages(1)
		DIMENSION This.fpdf_pages_selection(1,3)
		DIMENSION This.fpdf_pages_pos(1,4)
		DIMENSION This.fpdf_pages_size(1,2)
		
		STORE 0 TO This.fpdf_pages_pos, This.fpdf_pages_size
		
		IF EMPTY(This.fpdf_doc)=.F.
		    m.loFPDF.FPDF_CloseDocument(This.fpdf_doc)
		    This.fpdf_doc = 0
		ENDIF
		
		This.ViewPortUpdate()
		This.WndRedraw()
		
	ENDPROC

	HIDDEN PROCEDURE contextmenu
		
		LOCAL lcMenuName
		m.lcMenuName = "_context_menu"
		
		DEFINE POPUP (m.lcMenuName) FROM MROW(), MCOL() MARGIN RELATIVE SHORTCUT FONT 'Segoe UI', 10
		
		LOCAL lcSelectCopy, lcSelectAll
		m.lcSelectCopy = "SKIP FOR .T."
		m.lcSelectAll = ""
		
		IF This.fpdf_opened = .T.
		    LOCAL lnPage
		    FOR m.lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		        IF This.fpdf_pages_selection[m.lnPage,3] > 0
		            m.lcSelectCopy = ""
		            EXIT
		        ENDIF
		    ENDFOR
		ELSE
		    m.lcSelectAll = "SKIP FOR .T."
		ENDIF
		
		
		LOCAL i
		m.i=0
		
		m.i=m.i+1
		DEFINE BAR (m.i) OF (m.lcMenuName) PROMPT (This.i18n.text("MNU_COPY")) PICTRES _MED_COPY &lcSelectCopy
		ON SELECTION BAR (m.i) OF (m.lcMenuName) m.poThis.SelectionCopy()
		
		m.i=m.i+1
		DEFINE BAR (m.i) OF (m.lcMenuName) PROMPT (This.i18n.text("MNU_SLCTA")) &lcSelectAll
		ON SELECTION BAR (m.i) OF (m.lcMenuName) m.poThis.SelectTextAll()
		
		
		PRIVATE poThis
		m.poThis = This
		IF CNTBAR(m.lcMenuName)<>0
		    ACTIVATE POPUP &lcMenuName
		ENDIF
		m.poThis = .F.
		
		
	ENDPROC

	PROCEDURE Destroy
		
		IF This.env.ok() 
		    IF EMPTY(This.BackColorBrush) = .F.
		        This.env.API_GDIP.GdipDeleteBrush(This.BackColorBrush)
		        This.BackColorBrush = 0
		    ENDIF
		
		    IF EMPTY(This.SelectionBrush) = .F.
		        This.env.API_GDIP.GdipDeleteBrush(This.SelectionBrush)
		        This.SelectionBrush = 0
		    ENDIF
		
		    IF EMPTY(This.SearchBrush) = .F.
		        This.env.API_GDIP.GdipDeleteBrush(This.SearchBrush)
		        This.SearchBrush = 0
		    ENDIF
		
		    IF EMPTY(This.PageFillBrush) = .F.
		        This.env.API_GDIP.GdipDeleteBrush(This.PageFillBrush)
		        This.PageFillBrush = 0
		    ENDIF
		
		ENDIF
		
		This.ClosePDF()
		
		This.DrawBufRelease()
		
		This.WndRelease()
		
		This._PrintEnv = .F.
		
	ENDPROC

	HIDDEN PROCEDURE drawbufcreate
		
		#DEFINE FF_RGBQUAD_SIZE     4
		#DEFINE FF_DIB_RGB_COLORS   0
		#DEFINE FF_BFHDR_SIZE      14
		#DEFINE FF_BHDR_SIZE       40
		#DEFINE FF_BI_RGB           0
		
		IF EMPTY(This.WndDC)
		    RETURN
		ENDIF
		
		
		This.DrawBufRelease()
		
		
		***********************************************************************************
		IF EMPTY(This.DrawBufDC)
		    This.DrawBufDC = This.env.API_WIN.CreateCompatibleDC(This.WndDC)
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		LOCAL lnWidth, lnHeight, lnBitsPerPixel
		m.lnWidth = This.Width
		m.lnHeight = This.Height
		m.lnBitsPerPixel = 16
		
		LOCAL lcBMI
		m.lcBMI = BINTOC(FF_BHDR_SIZE ,"4RS") + BINTOC(m.lnWidth,"4RS") + BINTOC(m.lnHeight, "4RS") + ;
		        (CHR(MOD(1,256)) + CHR(INT(1/256))) + (CHR(MOD(m.lnBitsPerPixel,256))+ CHR(INT(m.lnBitsPerPixel/256))) +;
		        BINTOC(FF_BI_RGB, "4RS") + REPLICATE(0h00, 20)
		
		
		LOCAL lnDibDataPtr
		m.lnDibDataPtr = 0
		
		This.DrawBufDIB = This.env.API_WIN.CreateDIBSection(This.DrawBufDC, m.lcBMI, FF_DIB_RGB_COLORS, @m.lnDibDataPtr, 0, 0)
		This.env.API_WIN.SelectObject(This.DrawBufDC, This.DrawBufDIB)
		
		LOCAL lhDrawBufGfx
		m.lhDrawBufGfx = 0
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateFromHDC(This.DrawBufDC, @m.lhDrawBufGfx))
		This.DrawBufGfx = m.lhDrawBufGfx
		
	ENDPROC

	HIDDEN PROCEDURE drawbufrelease
		IF EMPTY(This.DrawBufGfx) = .F.
		    This.env.API_GDIP.GdipDeleteGraphics(This.DrawBufGfx)
		    This.DrawBufGfx = 0
		ENDIF
		
		IF EMPTY(This.DrawBufDC) = .F.
		    This.env.API_WIN.DeleteDC(This.DrawBufDC)
		    This.DrawBufDC = 0
		ENDIF
		
		IF EMPTY(This.DrawBufDIB) = .F.
		    This.env.API_WIN.DeleteObject(This.DrawBufDIB)
		    This.DrawBufDIB = 0
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		m.lcMsg = This.env.ErrFmt(m.tvMsg)
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		MESSAGEBOX(m.lcMsg, 0+48, This.Class + " ("+This.ClassLibrary+")")
		
	ENDPROC

	HIDDEN PROCEDURE fitwidth_assign
		LPARAMETERS vNewVal
		
		This.FitWidth = m.vNewVal
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
		
	ENDPROC

	PROCEDURE getcurrentpage		&& Current page number. First page has number = 1
		RETURN This.fpdf_page_first_visible
	ENDPROC

	PROCEDURE getpagecount		&& Returns page count
		RETURN This.fpdf_pagecount
		
	ENDPROC

	PROCEDURE getpagesize		&& Returns page dimensions (see comment in source code)
		LPARAMETERS tnPageIndex, tnPosition
		
		*tnPageIndex: page number from 1 to This.fpdf_pagecount
		*tnPosition: 1 - width in pdf units  (1/72 on inch)
		*tnPosition: 2 - height in pdf units  (1/72 on inch)
		*tnPosition: 3 - width in pixels
		*tnPosition: 4 - height in pixels
		*tnPosition: 5 - width / height relation
		
		IF BETWEEN(m.tnPageIndex, 1, This.fpdf_pagecount)=.F.
		    RETURN 0
		ENDIF
		
		LOCAL lnPdfPageWidth, lnPdfPageHeight
		m.lnPdfPageWidth = This.fpdf_pages_size[m.tnPageIndex,1]
		m.lnPdfPageHeight = This.fpdf_pages_size[m.tnPageIndex,2]
		
		LOCAL lnPageWidth, lnPageHeight
		m.lnPageWidth = INT(m.lnPdfPageWidth * This.env.GetScreenDPIX() / This.env.GetPDFDPI())
		m.lnPageHeight = INT(m.lnPdfPageHeight * This.env.GetScreenDPIY() / This.env.GetPDFDPI())
		
		DO CASE
		
		CASE m.tnPosition = 1
		    RETURN m.lnPdfPageWidth
		
		CASE m.tnPosition = 2
		    RETURN m.lnPdfPageHeight
		
		CASE m.tnPosition = 3
		    RETURN m.lnPageWidth
		    
		CASE m.tnPosition = 4
		    RETURN m.lnPageHeight
		
		CASE m.tnPosition = 5
		    RETURN IIF(EMPTY(m.lnPdfPageHeight), 0, m.lnPdfPageWidth / m.lnPdfPageHeight)
		
		ENDCASE
		
		RETURN 0
		
	ENDPROC

	HIDDEN PROCEDURE GotFocus
		This.IsFocused = .T.
		
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.env.Setup(m.toEnv)
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		*********************************************************
		This.BorderWidth = 0
		
		
		*********************************************************
		IF This.WndCreate() = .F.
		    RETURN
		ENDIF
		
		LOCAL lhBackColorBrush
		m.lhBackColorBrush = 0
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateSolidFill(This.env.API_GDIP.ARGB(255, This.BackColor), @m.lhBackColorBrush))
		This.BackColorBrush = m.lhBackColorBrush
		
		LOCAL lhSelectionBrush
		m.lhSelectionBrush = 0
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateSolidFill(This.env.API_GDIP.ARGB(72, 70, 130, 180), @m.lhSelectionBrush))
		This.SelectionBrush = m.lhSelectionBrush
		
		LOCAL lhSearchBrush
		m.lhSearchBrush = 0
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateSolidFill(This.env.API_GDIP.ARGB(96, 255, 255, 0), @m.lhSearchBrush))
		This.SearchBrush = lhSearchBrush
		
		LOCAL lhPageFillBrush
		m.lhPageFillBrush = 0
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateSolidFill(This.env.API_GDIP.ARGB(255, 255, 255, 255), @m.lhPageFillBrush))
		This.PageFillBrush = lhPageFillBrush
		
		
		
		*********************************************************
		This.Resize()
		This.WndShow()
		
	ENDPROC

	PROCEDURE keypress		&& Occurs when the user presses and releases a key.
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		#define KEY_LEFT_ARROW 19
		#define KEY_RIGHT_ARROW 4
		#define KEY_UP_ARROW 5
		#define KEY_DOWN_ARROW 24
		#define KEY_PAGE_UP 18
		#define KEY_PAGE_DOWN 3
		#define KEY_HOME 1
		#define KEY_END 6
		
		DO CASE
		
		CASE This.fpdf_opened = .F.
		 
		CASE This.UIState.GetEffectivelyVisible() = .F.
		
		CASE This.UIState.GetEffectivelyEnabled() = .F. 
		 
		CASE m.nKeyCode = KEY_LEFT_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollHorz(-0.05 * This.Width, .F., .T.)
		
		CASE m.nKeyCode = KEY_RIGHT_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollHorz(0.05 * This.Width, .F., .T.)
		
		CASE m.nKeyCode = KEY_UP_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(-0.05 * This.Height, .F., .T.)
		
		CASE m.nKeyCode = KEY_DOWN_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(0.05 * This.Height, .F., .T.)
		
		CASE m.nKeyCode = KEY_PAGE_UP AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(-1, .T., .T.)
		
		CASE m.nKeyCode = KEY_PAGE_DOWN AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(1, .T., .T.)
		
		CASE m.nKeyCode = KEY_HOME AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(1, .T., .F.)
		
		CASE m.nKeyCode = KEY_END AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(This.ViewPortMaxY, .T., .F.)
		
		CASE m.nKeyCode = 3 AND m.nShiftAltCtrl = 2
		    NODEFAULT
		    This.SelectionCopy()
		
		CASE m.nKeyCode = 1 AND m.nShiftAltCtrl = 2
		    NODEFAULT
		    This.SelectTextAll()
		    
		ENDCASE
		
		
	ENDPROC

	HIDDEN PROCEDURE LostFocus
		This.IsFocused = .F.
		
		
		
	ENDPROC

	HIDDEN PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		This.SelectionCharIndexStart = 0
		
		IF m.nButton <> 1
		    RETURN 
		ENDIF
		
		
		LOCAL lnMouseX, lnMouseY
		m.lnMouseX = m.nXCoord
		m.lnMouseY = m.nYCoord
		
		LOCAL llDblClick, llTplClick
		m.llDblClick = .F.
		m.llTplClick = .F.
		
		********************************************************************
		LOCAL lnTick
		m.lnTick = This.env.API_WIN.GetTickCount()
		m.lnTick = IIF(m.lnTick < 0, 0x80000000 + BITCLEAR(m.lnTick,31), m.lnTick)
		
		DO CASE 
		
		CASE This.DblClickBegin = 0 AND This.TplClickBegin = 0
		    This.DblClickBegin = -m.lnTick
		    This.TplClickBegin = -m.lnTick
		
		CASE This.DblClickBegin < 0
		    This.DblClickBegin = -This.DblClickBegin
		    
		    IF ABS(m.lnTick - This.DblClickBegin)/1000 <= _DBLCLICK
		        m.llDblClick = .T.
		        This.DblClickBegin = 0
		    ELSE
		        This.DblClickBegin = -m.lnTick
		        This.TplClickBegin = -m.lnTick
		    ENDIF
		
		CASE This.TplClickBegin < 0
		    This.TplClickBegin = -This.TplClickBegin
		    IF ABS(m.lnTick - This.TplClickBegin)/1000 <= _DBLCLICK 
		        m.llTplClick = .T.
		        This.DblClickBegin = 0
		        This.TplClickBegin = 0
		    ELSE
		        This.DblClickBegin = -m.lnTick
		        This.TplClickBegin = -m.lnTick
		    ENDIF
		
		ENDCASE
		
		
		********************************************************************
		LOCAL lnPage, lnFPDF_Page, lnFPDF_Text_Page
		m.lnPage = This.PagePick(m.lnMouseX, m.lnMouseY)
		
		IF EMPTY(m.lnPage) = .T.
		    RETURN
		ENDIF
		
		m.lnFPDF_Page = This.fpdf_pages[m.lnPage]
		m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPage]
		
		LOCAL lnPageX as Double, lnPageY as Double
		STORE 0 TO m.lnPageX, m.lnPageY
		
		IF m.loFPDF.FPDF_DeviceToPage(m.lnFPDF_Page, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnMouseX, m.lnMouseY, @m.lnPageX, @m.lnPageY) <> 1
		    RETURN
		ENDIF
		
		
		********************************************************************
		LOCAL lnCharIndexStart
		m.lnCharIndexStart = m.loFPDF.FPDFText_GetCharIndexAtPos(m.lnFPDF_Text_Page, m.lnPageX, m.lnPageY, 10, 0)
		
		IF m.lnCharIndexStart > 0
		    This.SelectionCharIndexStart = m.lnCharIndexStart
		ENDIF
		
		IF m.lnCharIndexStart < 0
		    * TEXT MISCLICK
		    This.SelectText()
		    RETURN
		ENDIF
		
		
		IF m.llDblClick = .F. AND m.llTplClick = .F.
		    * TEXT SINGLE CLICK
		    This.SelectText()
		    RETURN
		ENDIF
		
		
		********************************************************************
		* TEXT DOUBLE CLICK, TRIPLE CLICK
		********************************************************************
		
		LOCAL lnCharCountMax
		m.lnCharCountMax = m.loFPDF.FPDFText_CountChars(m.lnFPDF_Text_Page)
		IF m.lnCharCountMax < 0
		    RETURN
		ENDIF
		
		LOCAL lnCharCount
		m.lnCharCount = 1
		
		LOCAL lnCharIndexLeft
		m.lnCharIndexLeft = m.lnCharIndexStart
		
		DO WHILE m.lnCharIndexLeft > 0
		    LOCAL lcChar
		    m.lcChar = LEFT(STRCONV(STRCONV(BINTOC(m.loFPDF.FPDFText_GetUnicode(m.lnFPDF_Text_Page, m.lnCharIndexLeft-1), "4RS"),6),2),1)
		    
		    IF INLIST(m.lcChar, CHR(10),CHR(13))
		        EXIT
		    ENDIF
		    
		    IF EMPTY(m.lcChar) AND m.llTplClick = .F.
		        EXIT
		    ENDIF
		    
		    m.lnCharIndexLeft = m.lnCharIndexLeft - 1
		    m.lnCharCount = m.lnCharCount + 1
		ENDDO
		
		
		DO WHILE m.lnCharIndexLeft + m.lnCharCount < m.lnCharCountMax
		    LOCAL lcChar
		    m.lcChar = LEFT(STRCONV(STRCONV(BINTOC(m.loFPDF.FPDFText_GetUnicode(m.lnFPDF_Text_Page, m.lnCharIndexLeft + m.lnCharCount), "4RS"),6),2),1)
		
		    IF INLIST(m.lcChar, CHR(10),CHR(13))
		        EXIT
		    ENDIF
		
		    IF EMPTY(m.lcChar) AND m.llTplClick = .F.
		        EXIT
		    ENDIF
		
		    m.lnCharCount = m.lnCharCount + 1
		ENDDO
		
		
		This.SelectText(m.lnPage, m.lnCharIndexLeft, m.lnCharCount)
		
		
	ENDPROC

	HIDDEN PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL lnMouseX, lnMouseY
		m.lnMouseX = m.nXCoord
		m.lnMouseY = m.nYCoord
		
		LOCAL lnPage, lnFPDF_Page, lnFPDF_Text_Page
		m.lnPage = This.PagePick(m.lnMouseX, m.lnMouseY)
		IF EMPTY(m.lnPage)
		    RETURN
		ENDIF
		
		m.lnFPDF_Page = This.fpdf_pages[m.lnPage]
		m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPage]
		
		LOCAL lnPageX as Double, lnPageY as Double
		STORE 0 TO m.lnPageX, m.lnPageY
		
		IF m.loFPDF.FPDF_DeviceToPage(m.lnFPDF_Page, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnMouseX, m.lnMouseY, @m.lnPageX, @m.lnPageY) <> 1
		    RETURN
		ENDIF
		
		LOCAL lnCharIndex
		m.lnCharIndex = m.loFPDF.FPDFText_GetCharIndexAtPos(m.lnFPDF_Text_Page, m.lnPageX, m.lnPageY, 10, 0)
		
		DO CASE
		CASE m.lnCharIndex >= 0
		    This.MousePointer = 3
		    
		    IF m.nButton = 1 AND m.lnCharIndex <> This.SelectionCharindexPrev
		        This.selecttext(m.lnPage, MIN(This.SelectionCharIndexStart,m.lnCharIndex), ABS(m.lnCharIndex-This.SelectionCharIndexStart)+1)
		    ENDIF
		    
		OTHERWISE
		    This.MousePointer = 0
		ENDCASE
		
		This.SelectionCharindexPrev = m.lnCharIndex
		
	ENDPROC

	HIDDEN PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		IF m.nButton = 2
		    This.contextmenu()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE MouseWheel
		LPARAMETERS nDirection, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		DO CASE
		CASE EVL(m.nShift,0)=2
		     This.scale = This.scale + (SIGN(m.nDirection) * 0.1)
		 
		CASE EVL(m.nShift,0)=0
		    This.ScrollVert(-0.05 * This.Height * m.nDirection/120, .F., .T.)
		
		ENDCASE
		
	ENDPROC

	PROCEDURE openpdf		&& Open pdf file. Returns: .T. on success, .F. if file was not loaded
		LPARAMETERS tcFilename, tcPassword
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.ClosePDF()
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		
		LOCAL lcFilename
		m.lcFilename = ALLTRIM(EVL(NVL(m.tcFilename,""),""))
		
		IF EMPTY(m.lcFilename)
		    RETURN .F.
		ENDIF
		
		IF FILE(m.lcFilename,1)=.F.
		    This.errMsg(TEXTMERGE("File <<FULLPATH(lcFilename)>> not found"))
		    RETURN .F.
		ENDIF    
		
		LOCAL lcPassword
		m.lcPassword = IIF(VARTYPE(m.tcPassword)<>"C", "", m.tcPassword)
		
		
		DO WHILE .T.
		    This.fpdf_doc = m.loFPDF.FPDF_LoadDocument(STRCONV(m.lcFilename,9)+CHR(0), STRCONV(m.lcPassword,9)+CHR(0))
		
		    IF EMPTY(This.fpdf_doc) = .F.
		        EXIT
		    ENDIF
		    
		    LOCAL lnLoadError
		    m.lnLoadError = m.loFPDF.FPDF_GetLastError()
		    
		    IF m.lnLoadError = m.loFPDF.CONST.FPDF_ERR_PASSWORD()
		        LOCAL loPasswordInput
		        m.loPasswordInput = NEWOBJECT("pdfium_password_input", This.ClassLibrary)
		        m.loPasswordInput.out_password = m.lcPassword
		        m.loPasswordInput.in_incorrect = EMPTY(m.lcPassword)=.F.
		        m.loPasswordInput.Show(1)
		        
		        IF VARTYPE(m.loPasswordInput) = "O" AND m.loPasswordInput.out_ok = .T.
		            m.lcPassword = m.loPasswordInput.out_password
		            m.loPasswordInput = .F.
		            LOOP
		        ENDIF
		        m.loPasswordInput = .F.
		    ENDIF
		    
		    RETURN .F.
		ENDDO
		
		
		This.fpdf_pagecount = m.loFPDF.FPDF_GetPageCount(This.fpdf_doc)
		
		IF This.fpdf_pagecount > 0
		    DIMENSION This.fpdf_pages(This.fpdf_pagecount)
		    DIMENSION This.fpdf_text_pages(This.fpdf_pagecount)
		    DIMENSION This.fpdf_pages_selection(This.fpdf_pagecount,3)
		    DIMENSION This.fpdf_pages_pos(This.fpdf_pagecount,4)
		    DIMENSION This.fpdf_pages_size(This.fpdf_pagecount,2)
		    STORE 0 TO This.fpdf_pages, This.fpdf_text_pages, This.fpdf_pages_pos, This.fpdf_pages_size
		ENDIF
		
		LOCAL lnPage
		FOR m.lnPage = 1 TO This.FPDF_PageCount
		    This.fpdf_pages[m.lnPage] = m.loFPDF.FPDF_LoadPage(This.FPDF_Doc, m.lnPage-1)
		    
		    This.fpdf_text_pages[m.lnPage] = m.loFPDF.FPDFText_LoadPage(This.fpdf_pages[m.lnPage])
		    
		    This.fpdf_pages_selection[m.lnPage,1] = ""
		    This.fpdf_pages_selection[m.lnPage,2] = 0
		    This.fpdf_pages_selection[m.lnPage,3] = 0
		    
		    This.fpdf_pages_size[m.lnPage,1] = m.loFPDF.FPDF_GetPageWidth(This.fpdf_pages[m.lnPage])
		    This.fpdf_pages_size[m.lnPage,2] = m.loFPDF.FPDF_GetPageHeight(This.fpdf_pages[m.lnPage])
		ENDFOR
		
		This.ViewPortUpdate()
		
		This.fpdf_opened = .T.
		
		This.WndRedraw()
		
	ENDPROC

	HIDDEN PROCEDURE pagepick
		LPARAMETERS lnCoordX, lnCoordY
		
		* lnCoordX, lnCoordY coordinates in the control space (0,0) is top left corner of the control
		
		IF This.fpdf_opened = .F.
		    RETURN 0
		ENDIF
		
		IF This.fpdf_page_first_visible = 0
		    RETURN 0
		ENDIF
		
		
		LOCAL lnPage, lnPageFound
		m.lnPageFound = 0
		FOR m.lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		    DO CASE
		    CASE BETWEEN(m.lnCoordX, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX + This.fpdf_pages_pos[m.lnPage,3]) = .F.
		         LOOP
		    CASE BETWEEN(m.lnCoordY, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY + This.fpdf_pages_pos[m.lnPage,4]) = .F.
		         LOOP
		    OTHERWISE
		        m.lnPageFound = m.lnPage
		        EXIT
		    ENDCASE
		ENDFOR
		
		RETURN m.lnPageFound
		
	ENDPROC

	PROCEDURE printdocument		&& Send document to printer with preceding setup dialog
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		IF EMPTY(This.fpdf_doc)
		    RETURN
		ENDIF
		
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		*********************************************************************
		IF This.PrintEnv.AllowPrintSetupUI = .T.
		
		    LOCAL loFrmSetup
		    m.loFrmSetup = NEWOBJECT("pdfium_print_settings", This.ClassLibrary, "", This.PrintEnv)
		    m.loFrmSetup.Show(1)
		
		    This.SetFocus()
		
		    IF VARTYPE(m.loFrmSetup)<>"O"
		        RETURN
		    ENDIF
		
		    IF m.loFrmSetup.out_ok = .F.
		        RETURN
		    ENDIF
		
		    m.loFrmSetup = .F.
		
		ENDIF
		
		IF EMPTY(This.PrintEnv.Printer)
		    RETURN
		ENDIF
		*********************************************************************
		
		
		*********************************************************************
		
		#define PHYSICALOFFSETX 112
		#define PHYSICALOFFSETY 113
		
		#define DM_ORIENTATION  1
		#define DM_PAPERSIZE    2
		#define DM_PAPERLENGTH  4
		#define DM_PAPERWIDTH   8
		#define DM_COPIES 0x00000100
		#define DM_DUPLEX 0x00001000
		#define DM_YRESOLUTION 0x00002000
		
		#DEFINE DM_OFFSET_DMFIELDS 41  && DEVMODE dmFields offset
		#define DM_OFFSET_ORIENTATION 45  && DEVMODE dmOrientation offset
		#define DM_OFFSET_PAPERSIZE 47  && DEVMODE dmPaperSize offset
		#define DM_OFFSET_PAPERLENGTH 49  && DEVMODE dmPaperLength offset
		#define DM_OFFSET_PAPERWIDTH 51  && DEVMODE dmPaperWidth offset
		#define DM_OFFSET_COPIES 55  && DEVMODE dmCopies offset
		#define DM_OFFSET_DUPLEX 63 && DEVMODE dmDuplex offset
		#define DM_OFFSET_YRESOLUTION 65 && DEVMODE dmYResolution offset
		#define DMDUP_SIMPLEX    1
		#define DMDUP_VERTICAL   2
		#define DMDUP_HORIZONTAL 3
		#define DMORIENT_PORTRAIT 1
		#define DMORIENT_LANDSCAPE 2
		
		#define DMPAPER_A4 9
		
		#define FORM_BUILTIN 0x00000001
		#define FORM_PRINTER 0x00000002
		*********************************************************************
		* Get printer document properties and printer forms
		*********************************************************************
		
		LOCAL lcPrnDevMode
		m.lcPrnDevMode = This.PrintEnv.GetPrinterDevMode(This.PrintEnv.Printer)
		
		IF EMPTY(m.lcPrnDevMode)
		    This.ErrMsg(TEXTMERGE("PrintEnv.GetPrinterDevMode returned empty value for <<This.PrintEnv.Printer>>"))
		    RETURN
		ENDIF
		
		LOCAL lnPrnFormCnt
		LOCAL laPrnForm(1,9)
		m.lnPrnFormCnt = This.PrintEnv.GetPrinterForms(@m.laPrnForm, This.PrintEnv.Printer)
		IF EMPTY(m.lnPrnFormCnt)
		    This.ErrMsg(TEXTMERGE("PrintEnv.GetPrinterForms returned empty value for <<This.PrintEnv.Printer>>"))
		    RETURN
		ENDIF
		
		LOCAL lnPrnDevModeFlags
		m.lnPrnDevModeFlags = CTOBIN(SUBSTR(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4),"4RS")
		
		
		*********************************************************************
		* Setup page ranges according to PrintEnv.PageMode 
		*********************************************************************
		LOCAL lnPageMode, lcPageList
		m.lnPageMode = 1
		m.lcPageList = ""
		
		m.lnPageMode = This.printEnv.PageMode
		m.lcPageList = This.printEnv.PageList_Parse(This.printEnv.PageList)
		
		
		LOCAL ARRAY laPageRanges(1,2)
		LOCAL lnPageRangeCnt
		m.lnPageRangeCnt = 0
		DO CASE
		CASE m.lnPageMode = 1 && All pages
		    m.lnPageRangeCnt = 1
		    DIMENSION m.laPageRanges(1,2)
		    m.laPageRanges[1,1] = 1
		    m.laPageRanges[1,2] = This.fpdf_pagecount
		
		CASE m.lnPageMode = 2 && Odd pages
		    m.lnPageRangeCnt = INT(This.fpdf_pagecount / 2) + MOD(This.fpdf_pagecount, 2)
		    LOCAL lnRange
		    FOR m.lnRange = 1 TO m.lnPageRangeCnt
		        DIMENSION m.laPageRanges(m.lnRange,2)
		        m.laPageRanges[m.lnRange,1] = m.lnRange*2 - 1
		        m.laPageRanges[m.lnRange,2] = m.lnRange*2 - 1
		    ENDFOR
		
		CASE m.lnPageMode = 3 && Even pages
		    m.lnPageRangeCnt = INT(This.fpdf_pagecount / 2)
		    LOCAL lnRange
		    FOR m.lnRange = 1 TO m.lnPageRangeCnt
		        DIMENSION m.laPageRanges(m.lnRange,2)
		        m.laPageRanges[m.lnRange,1] = m.lnRange*2
		        m.laPageRanges[m.lnRange,2] = m.lnRange*2
		    ENDFOR
		
		CASE m.lnPageMode = 4
		    LOCAL ARRAY laPageList(1)
		    m.lnPageRangeCnt = ALINES(laPageList, m.lcPageList,1+4,",")
		    LOCAL lnRange
		    FOR m.lnRange = 1 TO m.lnPageRangeCnt
		        DIMENSION m.laPageRanges(m.lnRange,2)
		        m.laPageRanges[m.lnRange,1] = INT(VAL(STREXTRACT(m.laPageList[m.lnRange], "", "-",1,2)))
		        m.laPageRanges[m.lnRange,2] = EVL(INT(VAL(STREXTRACT(m.laPageList[m.lnRange], "-", "",1,2))), m.laPageRanges[m.lnRange,1])
		    ENDFOR
		ENDCASE
		*********************************************************************
		
		
		*********************************************************************
		LOCAL lnPrinterDPI
		m.lnPrinterDPI =  EVL(IIF(BITAND(m.lnPrnDevModeFlags, DM_YRESOLUTION)<>0, CTOBIN(SUBSTR(m.lcPrnDevMode,DM_OFFSET_YRESOLUTION,2),"2RS"), 0), 600)
		
		LOCAL llPrinterHasDuplex, lnPrinterDuplex
		m.llPrinterHasDuplex = This.PrintEnv.GetPrinterDuplex(This.PrintEnv.Printer)
		
		* Get default duplex setting of the printer
		m.lnPrinterDuplex = EVL(IIF(BITAND(m.lnPrnDevModeFlags, DM_DUPLEX)<>0, CTOBIN(SUBSTR(m.lcPrnDevMode,DM_OFFSET_DUPLEX,2),"2RS"), 0), DMDUP_SIMPLEX)
		
		DO CASE
		CASE m.llPrinterHasDuplex = .F. OR This.PrintEnv.Duplex  = .F.
		    m.lnPrinterDuplex = DMDUP_SIMPLEX
		OTHERWISE
		    m.lnPrinterDuplex = DMDUP_VERTICAL
		ENDCASE
		
		
		
		LOCAL loErr
		m.loErr = .F.
		
		TRY
		
		    LOCAL lcDocName
		    m.lcDocName = This.Class
		
		    LOCAL lhDocNameHeap, lhDocNameHeapPtr
		    m.lhDocNameHeap = This.env.API_WIN.HeapCreate(0, LEN(m.lcDocName)+1, 0)
		    m.lhDocNameHeapPtr = 0
		    IF EMPTY(m.lhDocNameHeap) = .F.
		        m.lhDocNameHeapPtr = This.env.API_WIN.HeapAlloc(m.lhDocNameHeap, 0, LEN(m.lcDocName)+1)
		        IF EMPTY(m.lhDocNameHeapPtr) = .F.
		            SYS(2600, m.lhDocNameHeapPtr, LEN(m.lcDocName)+1, m.lcDocName+CHR(0))
		        ENDIF
		    ENDIF
		    
		    LOCAL lhPrinterDC
		    m.lhPrinterDC = 0
		
		    LOCAL lcDocInfo
		    m.lcDocInfo = BINTOC(20, "4RS") + BINTOC(m.lhDocNameHeapPtr, "4RS") + BINTOC(0, "4RS") + BINTOC(0, "4RS") + BINTOC(0, "4RS")
		    
		
		    LOCAL llStartDoc
		    m.llStartDoc = .T.
		    
		    LOCAL lnDocPageNum
		    m.lnDocPageNum = 0
		    
		    LOCAL lnOrientation
		    m.lnOrientation = 0
		    
		    LOCAL lnPaperSize, lnPaperSizePrev
		    m.lnPaperSize = 0
		    m.lnPaperSizePrev = 0
		
		    LOCAL lnPageRange
		    m.lnPageRange = 1
		    FOR m.lnPageRange = 1 TO m.lnPageRangeCnt
		        
		        LOCAL lnPageFrom, lnPageTo
		        m.lnPageFrom = MAX(m.laPageRanges[m.lnPageRange,1], 1)
		        m.lnPageTo = MIN(m.laPageRanges[m.lnPageRange,2], This.fpdf_pagecount)
		        
		        LOCAL lnPageIndex
		        m.lnPageIndex = m.lnPageFrom
		
		        
		        FOR m.lnPageIndex = m.lnPageFrom TO m.lnPageTo
		
		            LOCAL lnPageWidth, lnPageHeight
		            m.lnPageWidth = This.GetPageSize(m.lnPageIndex,1)  / This.env.GetPDFDPI()
		            m.lnPageHeight = This.GetPageSize(m.lnPageIndex,2) / This.env.GetPDFDPI()
		
		
		            * Find paper size 
		            m.lnPaperSize = This.PrintEnv.PaperSize
		            
		            IF BETWEEN(m.lnPaperSize, 1, m.lnPrnFormCnt)
		               m.lnPaperSize = IIF(m.laPrnForm[m.lnPaperSize,9], m.lnPaperSize, -1) && check form is supported by printer
		            ELSE
		                m.lnPaperSize = -1 
		            ENDIF
		            
		            IF m.lnPaperSize = -1 && Find fittest paper form
		                LOCAL liPrnForm, lnFitFormWidth, lnFitFormHeight
		                m.liPrnForm = 1
		                STORE 0 TO m.lnFitFormWidth, m.lnFitFormHeight 
		                FOR m.liPrnForm = 1 TO m.lnPrnFormCnt
		                    DO CASE
		                    CASE BITAND(m.laPrnForm[m.liPrnForm,1], FORM_BUILTIN) = 0
		                    CASE m.laPrnForm[m.liPrnForm,9] = .F.
		                    CASE ROUND(m.laPrnForm[m.liPrnForm,3]/1000,0) < ROUND(IIF(m.lnPageWidth < m.lnPageHeight, m.lnPageWidth, m.lnPageHeight) * 25.4, 0)
		                    CASE ROUND(m.laPrnForm[m.liPrnForm,4]/1000,0) < ROUND(IIF(m.lnPageWidth < m.lnPageHeight, m.lnPageHeight, m.lnPageWidth) * 25.4, 0)
		                    CASE m.lnFitFormWidth > 0 AND m.lnFitFormWidth < m.laPrnForm[m.liPrnForm,3]
		                    CASE m.lnFitFormHeight > 0 AND m.lnFitFormHeight < m.laPrnForm[m.liPrnForm,4]
		                    OTHERWISE
		                        m.lnPaperSize = m.liPrnForm
		                        m.lnFitFormWidth = m.laPrnForm[m.liPrnForm,3]
		                        m.lnFitFormHeight = m.laPrnForm[m.liPrnForm,4]
		                    ENDCASE
		                ENDFOR
		                m.lnPaperSize = EVL(MAX(m.lnPaperSize,0), EVL(MAX(PRTINFO(2, This.PrintEnv.Printer), 0), DMPAPER_A4 ))
		            ENDIF
		            
		            *********************************************************
		            IF BETWEEN(m.lnPaperSize, 1, m.lnPrnFormCnt) = .F.
		                ERROR TEXTMERGE("Not Found Paper Form For Page number <<lnPageIndex>>, page size <<ROUND(lnPageWidth * 25.4,0)>> mm, <<ROUND(lnPageHeight * 25.4,0)>> mm ")
		            ENDIF
		            *********************************************************
		
		            IF m.lnPaperSizePrev <> m.lnPaperSize
		                m.lnPaperSizePrev = m.lnPaperSize
		                m.llStartDoc = .T.
		            ENDIF
		
		            IF m.llStartDoc
		
		                IF EMPTY(m.lhPrinterDC) = .F.
		                    This.env.API_WIN.EndDoc(m.lhPrinterDC)
		                    This.env.API_WIN.DeleteDC(m.lhPrinterDC)
		                ENDIF
		
		                m.lnDocPageNum = 0
		                
		                m.lnOrientation = IIF(m.lnPageWidth > m.lnPageHeight, DMORIENT_LANDSCAPE, DMORIENT_PORTRAIT)
		                
		                * Set paper size
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(m.lnPrnDevModeFlags, DM_PAPERSIZE), "4RS"))
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_PAPERSIZE, 2, BINTOC(m.lnPaperSize, "2RS"))
		
		                * Set duplex
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(m.lnPrnDevModeFlags, DM_DUPLEX), "4RS"))
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DUPLEX, 2, BINTOC(m.lnPrinterDuplex, "2RS"))
		                
		                * Set page orientation
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(m.lnPrnDevModeFlags, DM_ORIENTATION), "4RS"))
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_ORIENTATION, 2, BINTOC(m.lnOrientation, "2RS"))
		
		                * Set copies
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(m.lnPrnDevModeFlags, DM_COPIES), "4RS"))
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_COPIES, 2, BINTOC(EVL(This.PrintEnv.copies,1), "2RS"))
		                
		                m.lhPrinterDC = This.env.API_WIN.CreateDC(NULL, This.printenv.Printer + CHR(0), NULL, @m.lcPrnDevMode)
		
		                IF EMPTY(m.lhPrinterDC)
		                    ERROR TEXTMERGE("WinApi CreateDC error on page <<lnPageIndex>>, printer <<This.PrintEnv.Printer>>")
		                ENDIF
		            
		                This.env.API_WIN.StartDoc(m.lhPrinterDC, m.lcDocInfo)
		                
		                m.llStartDoc = .F.
		            ENDIF
		
		            m.lnDocPageNum = m.lnDocPageNum + 1
		
		
		            ***********************************
		            * Render page 
		            ***********************************
		            This.env.API_WIN.StartPage(m.lhPrinterDC)
		            
		            LOCAL lnPrintX, lnPrintY, lnPrintWidth, lnPrintHeight
		            m.lnPrintX = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETY), This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETX))
		            m.lnPrintY = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETX), This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETY))
		
		            m.lnPrintWidth = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, m.laPrnForm[m.lnPaperSize,4], m.laPrnForm[m.lnPaperSize,3])
		            m.lnPrintHeight = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, m.laPrnForm[m.lnPaperSize,3], m.laPrnForm[m.lnPaperSize,4])
		            m.lnPrintWidth = (m.lnPrintWidth / (25.4 * 1000)) * m.lnPrinterDPI
		            m.lnPrintHeight = (m.lnPrintHeight / (25.4 * 1000)) * m.lnPrinterDPI
		
		            #if .F. && pdfium style scaling "fill printable area" (not implemented). Only print without scaling is implemented
		            m.lnPrintWidth = m.lnPrintWidth - m.lnPrintX * 2
		            m.lnPrintHeight = m.lnPrintHeight - m.lnPrintY * 2
		            #endif
		            
		            m.lnPrintX = 0
		            m.lnPrintY = 0
		            
		            LOCAL lnPrintRotate
		            m.lnPrintRotate = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, IIF(m.lnPageWidth > m.lnPageHeight, 0, 1), IIF(m.lnPageWidth > m.lnPageHeight, 1, 0))
		            IF m.lnPrinterDuplex = DMDUP_VERTICAL AND MOD(m.lnDocPageNum,2) = 0
		                m.lnPrintRotate = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, IIF(m.lnPageWidth > m.lnPageHeight, 2, 1), IIF(m.lnPageWidth > m.lnPageHeight, 3, 0)) 
		            ENDIF
		            
		            LOCAL lnFPDF_Page 
		            m.lnFPDF_Page = This.fpdf_pages[m.lnPageIndex]
		            
		            IF EMPTY(m.lnFPDF_Page) = .F.
		                
		                m.loFPDF.FPDF_RenderPage(m.lhPrinterDC, ;
		                    m.lnFPDF_Page, ;
		                    m.lnPrintX, ;
		                    m.lnPrintY, ;
		                    m.lnPrintWidth, ;
		                    m.lnPrintHeight, ;
		                    m.lnPrintRotate, ;
		                    m.loFPDF.CONST.FPDF_PRINTING())
		
		            ENDIF
		            
		            This.env.API_WIN.EndPage(m.lhPrinterDC)
		            ***********************************
		            * / Render page 
		            ***********************************
		
		
		        ENDFOR
		
		    ENDFOR
		    
		
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		
		FINALLY
		    IF EMPTY(m.lhPrinterDC) = .F.
		        IF m.llStartDoc = .F.
		            This.env.API_WIN.EndDoc(m.lhPrinterDC)
		        ENDIF
		        This.env.API_WIN.DeleteDC(m.lhPrinterDC)
		    ENDIF
		    
		    IF EMPTY(m.lhDocNameHeap) = .F.
		        This.env.API_WIN.HeapDestroy(m.lhDocNameHeap)
		    ENDIF
		    
		ENDTRY
		
		
		
	ENDPROC

	PROCEDURE printenv_access
		
		IF VARTYPE(This._PrintEnv) <> "O"
		    This._PrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		ENDIF
		
		RETURN This._PrintEnv
		
	ENDPROC

	PROCEDURE printenv_assign
		LPARAMETERS vNewVal
		
		ERROR 1740, TEXTMERGE("<<This.Class>>.PrintEnv")
		
	ENDPROC

	HIDDEN PROCEDURE redraw
		LPARAMETERS tnWndDC
		
		LOCAL lnWndDC
		m.lnWndDC = EVL(m.tnWndDC, This.WndDC)
		
		IF EMPTY(m.lnWndDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDIB)
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufGfx)
		    RETURN
		ENDIF
		
		IF This.UIState.GetEffectivelyVisible() = .F.
		    RETURN
		ENDIF
		
		
		
		LOCAL lnWidth, lnHeight
		m.lnWidth = This.Width
		m.lnHeight = This.Height
		
		******************************************************************************
		This.env.API_GDIP.GdipFillRectangleI(This.DrawBufGfx, This.BackColorBrush, 0, 0, m.lnWidth, m.lnHeight)
		
		This.renderpages()
		
		This.env.API_GDIP.GdipFlush(This.DrawBufGfx)
		
		******************************************************************************
		#define FF_SRCCOPY 0x00CC0020
		
		This.env.API_WIN.BitBlt(m.lnWndDC, 0,0, m.lnWidth, m.lnHeight, This.DrawBufDC, 0, 0, FF_SRCCOPY)
		
	ENDPROC

	HIDDEN PROCEDURE renderpages
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.fpdf_page_first_visible)
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		
		LOCAL lnFPDF_Page, lnPageX, lnPageY, lnPageWidth, lnPageHeight
		
		LOCAL lnPage
		FOR m.lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		    
		    m.lnFPDF_Page = This.fpdf_pages[m.lnPage]
		    m.lnPageX = This.fpdf_pages_pos[m.lnPage,1] - This.ViewPortX
		    m.lnPageY = This.fpdf_pages_pos[m.lnPage,2] - This.ViewPortY
		    m.lnPageWidth = This.fpdf_pages_pos[m.lnPage,3]
		    m.lnPageHeight = This.fpdf_pages_pos[m.lnPage,4]
		
		    This.env.API_GDIP.GdipFillRectangleI(This.DrawBufGfx, This.PageFillBrush, m.lnPageX, m.lnPageY, m.lnPageWidth, m.lnPageHeight)
		    
		    m.loFPDF.FPDF_RenderPage(This.DrawBufDC, m.lnFPDF_Page, m.lnPageX, m.lnPageY, m.lnPageWidth, m.lnPageHeight, 0, 0)
		
		    This.RenderSearch(m.lnPage)
		    This.RenderSelection(m.lnPage)
		    
		ENDFOR
		
	ENDPROC

	HIDDEN PROCEDURE rendersearch
		LPARAMETERS lnPage
		
		IF m.lnPage <> This.SearchState_ResPage
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		
		LOCAL lnRectCount
		m.lnRectCount = LEN(This.SearchState_ResRect)/32
		
		LOCAL lnRect, lcRect
		FOR m.lnRect = 1 TO m.lnRectCount
		    
		    m.lcRect = SUBSTR(This.SearchState_ResRect, 32*(m.lnRect-1) + 1, 32)
		    
		    LOCAL lnPageLeft,lnPageTop,lnPageRight,lnPageBottom
		    m.lnPageLeft = CTOBIN(SUBSTR(m.lcRect,1,8),"B")
		    m.lnPageTop = CTOBIN(SUBSTR(m.lcRect,9,8),"B")
		    m.lnPageRight = CTOBIN(SUBSTR(m.lcRect,17,8),"B")
		    m.lnPageBottom = CTOBIN(SUBSTR(m.lcRect,25,8),"B")
		    
		       
		    LOCAL lnLeft, lnTop, lnRight, lnBottom
		    STORE 0 TO m.lnLeft, m.lnTop, m.lnRight, m.lnBottom
		    
		    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPage], This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnPageLeft, m.lnPageTop, @m.lnLeft, @m.lnTop) = 0
		        LOOP
		    ENDIF
		    
		    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPage], This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnPageRight, m.lnPageBottom, @m.lnRight, @m.lnBottom) = 0
		        LOOP
		    ENDIF
		    
		    This.env.API_GDIP.GdipFillRectangleI(This.DrawBufGfx, This.SearchBrush, m.lnLeft, m.lnTop, m.lnRight - m.lnLeft, m.lnBottom - m.lnTop)
		    
		ENDFOR
		
		
	ENDPROC

	HIDDEN PROCEDURE renderselection
		LPARAMETERS lnPage
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL lnRectCount
		m.lnRectCount = LEN(This.fpdf_pages_selection[m.lnPage,1])/32
		
		LOCAL lnRect, lcRect
		FOR m.lnRect = 1 TO m.lnRectCount
		    
		    m.lcRect = SUBSTR(This.fpdf_pages_selection[m.lnPage,1], 32*(m.lnRect-1) + 1, 32)
		    
		    LOCAL lnPageLeft,lnPageTop,lnPageRight,lnPageBottom
		    m.lnPageLeft = CTOBIN(SUBSTR(m.lcRect,1,8),"B")
		    m.lnPageTop = CTOBIN(SUBSTR(m.lcRect,9,8),"B")
		    m.lnPageRight = CTOBIN(SUBSTR(m.lcRect,17,8),"B")
		    m.lnPageBottom = CTOBIN(SUBSTR(m.lcRect,25,8),"B")
		    
		    
		    LOCAL lnLeft, lnTop, lnRight, lnBottom
		    STORE 0 TO m.lnLeft, m.lnTop, m.lnRight, m.lnBottom
		    
		    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPage], This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnPageLeft, m.lnPageTop, @m.lnLeft, @m.lnTop) = 0
		        LOOP
		    ENDIF
		    
		    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPage], This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnPageRight, m.lnPageBottom, @m.lnRight, @m.lnBottom) = 0
		        LOOP
		    ENDIF
		        
		    This.env.API_GDIP.GdipFillRectangleI(This.DrawBufGfx, This.SelectionBrush, m.lnLeft, m.lnTop, m.lnRight - m.lnLeft, m.lnBottom - m.lnTop)
		ENDFOR
		
	ENDPROC

	HIDDEN PROCEDURE Resize
		This.WndResize()
		
	ENDPROC

	PROCEDURE savedocument		&& Save document to file
		LPARAMETERS tcFileName
		
		IF EMPTY(This.fpdf_doc)
		    RETURN .F.
		ENDIF
		
		IF VARTYPE(m.tcFileName) <> "C"
		    RETURN .F.
		ENDIF
		
		
		LOCAL lcFileName
		m.lcFileName = ALLTRIM(EVL(NVL(m.tcFileName,""), ""))
		
		IF EMPTY(m.lcFileName)
		    RETURN .F.
		ENDIF
		
		LOCAL lcErrMsg
		m.lcErrMsg = SPACE(500)
		This.env.API_FPDF.VFPDF_SaveDocument(This.fpdf_doc, m.lcFilename, @m.lcErrMsg, LEN(m.lcErrMsg))
		
		IF EMPTY(m.lcErrMsg)=.F.
		    This.ErrMsg(ALLTRIM(m.lcErrMsg))
		    RETURN .F.
		ENDIF
		
		
	ENDPROC

	HIDDEN PROCEDURE scale_assign
		LPARAMETERS vNewVal
		
		
		This.Scale = MIN(MAX(EVL(NVL(m.vNewVal,0),0),0.2),4)
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE scrollbars_assign
		LPARAMETERS vNewVal
		
		This.ScrollBars = IIF(INLIST(m.vNewVal, 0,1,2,3), m.vNewVal, This.ScrollBars)
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE scrollhorz
		LPARAMETERS tnScroll, tlPage, tlRelative
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL lnScroll
		m.lnScroll = EVL(NVL(m.tnScroll,0),0)
		
		DO CASE
		CASE m.tlPage=.F. AND m.tlRelative = .T.
		    This.ViewPortX = This.ViewPortX + m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .T.
		    This.ViewPortX = This.ViewPortX + m.lnScroll * This.ViewPortSizeX
		    
		CASE m.tlPage=.F. AND m.tlRelative = .F.
		    This.ViewPortX = m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .F.
		    This.ViewPortX = (m.lnScroll - 1) * This.ViewPortSizeX
		
		ENDCASE
		
		This.ViewPortUpdate()
		
		This.WndRedraw()
		
	ENDPROC

	HIDDEN PROCEDURE scrollvert
		LPARAMETERS tnScroll, tlPage, tlRelative
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL lnScroll
		m.lnScroll = EVL(NVL(m.tnScroll,0),0)
		
		DO CASE
		CASE m.tlPage=.F. AND m.tlRelative = .T.
		    This.ViewPortY = This.ViewPortY + m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .T.
		    This.ViewPortY = This.ViewPortY + m.lnScroll * This.ViewPortSizeY
		    
		CASE  m.tlPage=.F. AND m.tlRelative = .F.
		    This.ViewPortY = m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .F.
		    This.ViewPortY = (m.lnScroll - 1) * This.ViewPortSizeY
		
		ENDCASE
		
		This.ViewPortUpdate()
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE searchclose		&& Stop search
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.SearchState_FindWhat = ""
		This.SearchState_Dir = 0
		
		This.SearchState_ResPage = 0
		This.SearchState_ResIndex = 0
		This.SearchState_ResCount = 0
		This.SearchState_ResRect = ""
		
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE searchtext		&& Text for searching. SearchClose must be called to stop search results rendering
		LPARAMETERS tcFindWhat, tnDirection, tlMatchCase, tlMatchWholeWord
		
		* tcFindWhat - text to find
		* tnDirection - search direction: 1 - forward (default), 2 - backward
		* tlMatchCase - .T. - case sensitive, .F. - case insensitive (default)
		* tlMatchWholeWord - .T. match whole word, .F. - not match whole word (default)
		
		* return value: -1 - error, 0 - not found, 1 - found, 2 - search ended
		
		#define SCH_ERROR -1
		#define SCH_NOT_FOUND 0
		#define SCH_FOUND 1
		#define SCH_ENDED 2
		
		#define SCH_FWD 1
		#define SCH_BCK 2
		
		#define SCH_WHITESPACE CHR(0x00)+CHR(0x09) + CHR(0x00)+CHR(0x0A) + CHR(0x00)+CHR(0x0B) + CHR(0x00)+CHR(0x0C) + CHR(0x00)+CHR(0x0D) + CHR(0x00)+CHR(0x20) + CHR(0x00)+CHR(0x85) + CHR(0x00)+CHR(0xA0) + CHR(0x16)+CHR(0x80) + CHR(0x20)+CHR(0x00) + CHR(0x20)+CHR(0x01) + CHR(0x20)+CHR(0x02) + CHR(0x20)+CHR(0x03) + CHR(0x20)+CHR(0x04) + CHR(0x20)+CHR(0x05) + CHR(0x20)+CHR(0x06) + CHR(0x20)+CHR(0x07) + CHR(0x20)+CHR(0x08) + CHR(0x20)+CHR(0x09) + CHR(0x20)+CHR(0x0A) + CHR(0x20)+CHR(0x28) + CHR(0x20)+CHR(0x29) + CHR(0x20)+CHR(0x2F) + CHR(0x20)+CHR(0x5F) + CHR(0x30)+CHR(0x00)
		#define SCH_PUNCTIATION CHR(0x00)+CHR(0x21) + CHR(0x00)+CHR(0x22) + CHR(0x00)+CHR(0x23) + CHR(0x00)+CHR(0x25) + CHR(0x00)+CHR(0x26) + CHR(0x00)+CHR(0x27) + CHR(0x00)+CHR(0x2A) + CHR(0x00)+CHR(0x2C) + CHR(0x00)+CHR(0x2D) + CHR(0x00)+CHR(0x2E) + CHR(0x00)+CHR(0x2F) + CHR(0x00)+CHR(0x3A) + CHR(0x00)+CHR(0x3B) + CHR(0x00)+CHR(0x3D) + CHR(0x00)+CHR(0x3F) + CHR(0x20)+CHR(0x10) + CHR(0x20)+CHR(0x11) + CHR(0x20)+CHR(0x12) + CHR(0x20)+CHR(0x13) + CHR(0x20)+CHR(0x14) + CHR(0x20)+CHR(0x15) + CHR(0x00)+CHR(0xAB) + CHR(0x00)+CHR(0xBB) + CHR(0x20)+CHR(0x18) + CHR(0x20)+CHR(0x19) + CHR(0x20)+CHR(0x1B) + CHR(0x20)+CHR(0x1C) + CHR(0x20)+CHR(0x1D) + CHR(0x00)+CHR(0x28) + CHR(0x00)+CHR(0x29) + CHR(0x00)+CHR(0x5B) + CHR(0x00)+CHR(0x5C) + CHR(0x00)+CHR(0x5D) + CHR(0x00)+CHR(0x7B) + CHR(0x00)+CHR(0x7D) + CHR(0x20)+CHR(0x1A) + CHR(0x20)+CHR(0x1E)
		
		IF This.fpdf_opened = .F.
		    RETURN SCH_ERROR
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL lcFindWhat, lnDirection, llMatchCase, llMatchWholeWord
		
		m.lcFindWhat = CHRTRAN(ALLTRIM(EVL(NVL(m.tcFindWhat,""),"")), CHR(10)+CHR(13)+CHR(9),"")
		m.lnDirection = EVL(NVL(m.tnDirection,0), SCH_FWD)
		m.llMatchCase = EMPTY(NVL(m.tlMatchCase,.F.))=.F.
		m.llMatchWholeWord = EMPTY(NVL(m.tlMatchWholeWord,.F.))=.F.
		
		#define LOCALE_USER_DEFAULT       0x0400
		
		#define FIND_FROMSTART            0x00400000  && look for value in source, starting at the beginning
		#define FIND_FROMEND              0x00800000  && look for value in source, starting at the end
		
		#define NORM_IGNORECASE           0x00000001  && ignore case
		#define NORM_IGNORENONSPACE       0x00000002  && ignore nonspacing chars
		#define NORM_IGNORESYMBOLS        0x00000004  && ignore symbols
		
		
		LOCAL lnSearchFlags
		m.lnSearchFlags = 0
		m.lnSearchFlags = m.lnSearchFlags + IIF(m.lnDirection = SCH_BCK, FIND_FROMEND, FIND_FROMSTART)
		m.lnSearchFlags = m.lnSearchFlags + IIF(m.llMatchCase=.T., 0, NORM_IGNORECASE)
		
		LOCAL llNewSearch
		m.llNewSearch = .F.
		DO CASE
		CASE m.lnDirection <> This.SearchState_Dir
		    m.llNewSearch = .T.
		CASE NOT m.lcFindWhat == This.SearchState_FindWhat
		    m.llNewSearch = .T.
		ENDCASE
		
		
		LOCAL lnSearchStartPage, lnSearchStartIndex
		m.lnSearchStartPage = EVL(This.SearchState_ResPage, EVL(This.fpdf_page_first_visible,1))
		m.lnSearchStartIndex = This.SearchState_ResIndex + IIF(m.lnDirection = SCH_BCK, 0, This.SearchState_ResCount)
		
		IF m.llNewSearch = .T.    
		    IF NOT (m.lcFindWhat == This.SearchState_FindWhat)
		        m.lnSearchStartPage = EVL(This.fpdf_page_first_visible,1)
		        m.lnSearchStartIndex = IIF(m.lnDirection = SCH_BCK, -1, 0)
		    ENDIF
		    
		    This.SearchClose()
		ENDIF
		
		This.SearchState_FindWhat = m.lcFindWhat
		This.SearchState_Dir = m.lnDirection
		
		
		IF EMPTY(m.lcFindWhat)
		    RETURN SCH_NOT_FOUND
		ENDIF
		
		
		
		LOCAL lnLocaleId
		m.lnLocaleId = This.i18n.GetLocaleID()
		
		LOCAL lcFindWhatUnicode
		m.lcFindWhatUnicode = ""
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    m.lcFindWhatUnicode = STRCONV(m.lcFindWhat, 5, m.lnLocaleId)
		
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		ENDTRY
		
		IF LEN(m.lcFindWhatUnicode) = 0
		    RETURN SCH_ERROR
		ENDIF
		
		
		LOCAL lnPageIndex
		m.lnPageIndex = m.lnSearchStartPage
		
		DO WHILE m.lnPageIndex > 0 AND m.lnPageIndex <= This.fpdf_pagecount
		
		    LOCAL lnFPDF_Text_Page
		    m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPageIndex]
		
		    LOCAL lnFindResIndex, lnFindResCount
		    m.lnFindResIndex = -1
		    m.lnFindResCount = 0
		
		    LOCAL lnPageTextLen, lcPageText
		    m.lnPageTextLen = MAX(m.loFPDF.FPDFText_CountChars(m.lnFPDF_Text_Page), 0)
		    
		    DO CASE
		    CASE EMPTY(m.lnPageTextLen)
		    
		    CASE m.lnDirection = SCH_FWD
		        m.lnPageTextLen = MAX(m.lnPageTextLen - m.lnSearchStartIndex, 0)
		        m.lcPageText = REPLICATE(CHR(0), m.lnPageTextLen * 2)
		        m.lnPageTextLen = m.loFPDF.FPDFText_GetText(m.lnFPDF_TEXT_PAGE, m.lnSearchStartIndex, m.lnPageTextLen, @m.lcPageText)
		
		        IF m.lnPageTextLen > 0
		            m.lnFindResIndex = This.env.API_WIN.FindNLSString(LOCALE_USER_DEFAULT, m.lnSearchFlags, m.lcPageText + CHR(0), -1, m.lcFindWhatUnicode + CHR(0), -1, @m.lnFindResCount)
		            
		            IF m.lnFindResIndex >= 0
		                m.lnFindResIndex = m.lnSearchStartIndex + m.lnFindResIndex
		            ENDIF
		        ENDIF
		    
		    CASE m.lnDirection = SCH_BCK
		        m.lnPageTextLen = MAX(IIF(m.lnSearchStartIndex < 0,  m.lnPageTextLen, m.lnSearchStartIndex), 0)
		        m.lcPageText = REPLICATE(CHR(0), m.lnPageTextLen * 2)
		        m.lnPageTextLen = m.loFPDF.FPDFText_GetText(m.lnFPDF_TEXT_PAGE, 0, m.lnPageTextLen, @m.lcPageText)
		        
		        IF m.lnPageTextLen > 0
		            m.lnFindResIndex = This.env.API_WIN.FindNLSString(LOCALE_USER_DEFAULT, m.lnSearchFlags, m.lcPageText + CHR(0), -1, m.lcFindWhatUnicode + CHR(0), -1, @m.lnFindResCount)
		        ENDIF
		    
		    ENDCASE
		
		
		    IF m.llMatchWholeWord = .T. AND m.lnFindResIndex >= 0 AND m.lnFindResCount > 0
		        LOCAL lcNextChar
		        m.lcNextChar = BINTOC(m.loFPDF.FPDFText_GetUnicode(m.lnFPDF_Text_Page, m.lnFindResIndex + m.lnFindResCount), "2RS")
		
		        DO CASE
		        CASE m.lcNextChar == CHR(0)+CHR(0)
		        CASE AT(m.lcNextChar, SCH_WHITESPACE) <> 0 
		        CASE AT(m.lcNextChar, SCH_PUNCTIATION) <> 0
		        OTHERWISE
		            m.lnSearchStartIndex = IIF(m.lnDirection = SCH_BCK, m.lnFindResIndex, m.lnFindResIndex + m.lnFindResCount)
		            LOOP
		        ENDCASE
		    ENDIF
		
		
		    IF m.lnFindResIndex >= 0 AND m.lnFindResCount > 0
		        This.SearchState_ResPage = m.lnPageIndex
		        This.SearchState_ResIndex = m.lnFindResIndex
		        This.SearchState_ResCount = m.lnFindResCount
		
		        LOCAL lnRectCount
		        m.lnRectCount = m.loFPDF.FPDFText_CountRects(m.lnFPDF_Text_Page, m.lnFindResIndex, m.lnFindResCount)
		
		        This.SearchState_ResRect = ""
		        
		        LOCAL lnPageLeft as Double, lnPageRight as Double, lnPageBottom as Double, lnPageTop as Double
		        STORE 0 TO m.lnPageLeft, m.lnPageRight, m.lnPageBottom, m.lnPageTop
		
		        LOCAL lnRect
		        FOR m.lnRect=1 TO m.lnRectCount
		            IF m.loFPDF.FPDFText_GetRect(m.lnFPDF_Text_Page, m.lnRect-1, @m.lnPageLeft, @m.lnPageTop, @m.lnPageRight, @m.lnPageBottom) > 0
		                This.SearchState_ResRect = This.SearchState_ResRect + BINTOC(m.lnPageLeft,"8")+BINTOC(m.lnPageTop,"8")+BINTOC(m.lnPageRight,"8")+BINTOC(m.lnPageBottom,"8")
		                
		                IF m.lnRect = 1
		                    LOCAL lnLeft, lnTop
		                    STORE 0 TO m.lnLeft, m.lnTop
		                    
		                    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPageIndex], 0, 0, This.fpdf_pages_pos[m.lnPageIndex,3], This.fpdf_pages_pos[m.lnPageIndex,4], 0, m.lnPageLeft, m.lnPageTop, @m.lnLeft, @m.lnTop) > 0
		                        LOCAL lnScrollVert
		                        m.lnScrollVert = This.fpdf_pages_pos[m.lnPageIndex,2] + m.lnTop
		                        m.lnScrollVert = m.lnScrollVert - This.ViewPortSizeY * 0.5
		                        This.ScrollVert(m.lnScrollVert)
		
		                        LOCAL lnScrollHorz
		                        m.lnScrollHorz = This.fpdf_pages_pos[m.lnPageIndex,1] + m.lnLeft
		                        m.lnScrollHorz = m.lnScrollHorz - This.ViewPortSizeX * 0.5
		                        This.ScrollHorz(m.lnScrollHorz)
		                    ENDIF
		                ENDIF
		            ENDIF
		        ENDFOR
		
		        This.WndRedraw()
		        
		        RETURN SCH_FOUND
		    ENDIF
		
		
		    IF m.lnDirection = SCH_BCK
		        m.lnPageIndex = m.lnPageIndex - 1
		        m.lnSearchStartIndex = -1
		    ELSE
		        m.lnPageIndex = m.lnPageIndex + 1
		        m.lnSearchStartIndex = 0
		    ENDIF
		    
		    
		    
		ENDDO
		
		IF EMPTY(This.SearchState_ResCount)=.F.
		    RETURN SCH_ENDED
		ELSE
		    RETURN SCH_NOT_FOUND
		ENDIF
		
	ENDPROC

	PROCEDURE selectioncopy		&& Copy selected text to clipboard
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		#define CF_TEXT       1
		#define CF_UNICODETEXT 13
		#DEFINE CF_LOCALE     16
		#define GMEM_MOVEABLE 0x0002
		#define GMEM_ZEROINIT 0x0040
		
		
		LOCAL lcCopyText
		m.lcCopyText = ""
		
		LOCAL lnPage, lnFPDF_TEXT_PAGE, lnSelStart, lnSelCount
		FOR m.lnPage = 1 TO This.fpdf_pagecount
		
		    m.lnFPDF_TEXT_PAGE = This.FPDF_TEXT_PAGES[m.lnPage]
		    m.lnSelStart = EVL(This.fpdf_pages_selection[m.lnPage,2],0)
		    m.lnSelCount = EVL(This.fpdf_pages_selection[m.lnPage,3],0)
		    
		    IF m.lnSelCount = 0
		        LOOP
		    ENDIF
		    
		    LOCAL lcBuffer, lnBufLen
		    m.lcBuffer = REPLICATE(CHR(0), m.lnSelCount * 2)
		    m.lnBufLen = m.loFPDF.FPDFText_GetText(m.lnFPDF_TEXT_PAGE, m.lnSelStart, m.lnSelCount, @m.lcBuffer)
		    
		    IF m.lnBufLen > 0
		        m.lcCopyText = m.lcCopyText + m.lcBuffer
		    ENDIF
		
		ENDFOR
		
		IF EMPTY(m.lcCopyText)=.F.
		    
		    LOCAL lnCopyTextLen
		    m.lnCopyTextLen = LEN(m.lcCopyText)
		
		    LOCAL lnDefaultLocaleID
		    m.lnDefaultLocaleID = EVL(This.env.API_WIN.GetSystemDefaultLCID(), 1033) &&English LocaleID = 1033
		
		    IF This.env.API_WIN.OpenClipboard(0) = 0
		        RETURN
		    ENDIF
		    
		    This.env.API_WIN.EmptyClipboard()
		
		    LOCAL lnMemHandle
		    m.lnMemHandle = This.env.API_WIN.GlobalAlloc(GMEM_MOVEABLE + GMEM_ZEROINIT, m.lnCopyTextLen+2)
		    
		    IF m.lnMemHandle <> 0
		        LOCAL lnMemPtr
		        m.lnMemPtr = This.env.API_WIN.GlobalLock(m.lnMemHandle)
		        IF m.lnMemPtr <> 0
		            SYS(2600, m.lnMemPtr, m.lnCopyTextLen, m.lcCopyText)
		        ENDIF
		        This.env.API_WIN.GlobalUnlock(m.lnMemHandle)
		        
		        This.env.API_WIN.SetClipboardData(CF_UNICODETEXT, m.lnMemHandle)
		        
		        This.env.API_WIN.GlobalFree(m.lnMemHandle)
		    ENDIF
		
		
		    LOCAL lnMemHandle
		    m.lnMemHandle = This.env.API_WIN.GlobalAlloc(GMEM_MOVEABLE + GMEM_ZEROINIT, 4)
		    IF m.lnMemHandle <> 0
		        LOCAL lnMemPtr
		        m.lnMemPtr = This.env.API_WIN.GlobalLock(m.lnMemHandle)
		        IF m.lnMemPtr <> 0
		            SYS(2600, m.lnMemPtr, 4, BINTOC(m.lnDefaultLocaleID, "4RS"))
		        ENDIF
		        This.env.API_WIN.GlobalUnlock(m.lnMemHandle)
		        
		        This.env.API_WIN.SetClipboardData(CF_LOCALE, m.lnMemHandle)
		        
		        This.env.API_WIN.GlobalFree(m.lnMemHandle)
		    ENDIF
		
		    This.env.API_WIN.CloseClipboard()
		
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE selecttext
		LPARAMETERS tnPage, tnStartIndex, tnCount
		
		* tnPage - page index, from 1 to This.fpdf_pagecount, 0 for all pages
		* tnStartIndex - Index for the start character (zero-based)
		* tnCount - Number of characters, or -1 for all remaining.
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		
		LOCAL lnPage, lnStartIndex, lnCount
		m.lnPage = EVL(m.tnPage,0)
		m.lnStartIndex = EVL(m.tnStartIndex,0)
		m.lnCount = EVL(m.tnCount, 0)
		
		IF m.lnStartIndex < 0
		    RETURN
		ENDIF
		IF m.lnCount < -1
		    RETURN
		ENDIF
		
		
		LOCAL lnPageStart, lnPageEnd
		m.lnPageStart = EVL(m.lnPage,1)
		m.lnPageEnd = EVL(m.lnPage,This.fpdf_pagecount)
		
		FOR m.lnPage = m.lnPageStart TO m.lnPageEnd
		    LOCAL lnFPDF_Text_Page
		    m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPage]
		
		    LOCAL lnCountChars
		    DO CASE
		    CASE m.lnCount = 0
		        m.lnCountChars = 0
		         
		    CASE m.lnCount = -1
		        m.lnCountChars = MAX(m.loFPDF.FPDFText_CountChars(m.lnFPDF_Text_Page) - m.lnStartIndex,0)
		
		    CASE m.loFPDF.FPDFText_CountChars(m.lnFPDF_Text_Page) >= m.lnStartIndex + m.lnCount
		        m.lnCountChars = m.lnCount
		
		    OTHERWISE
		        m.lnCountChars = 0
		
		    ENDCASE
		    
		    LOCAL lnRectCount
		    IF m.lnCountChars > 0
		        m.lnRectCount = m.loFPDF.FPDFText_CountRects(m.lnFPDF_Text_Page, m.lnStartIndex, m.lnCountChars)
		    ELSE
		        m.lnRectCount = 0
		    ENDIF
		
		    IF m.lnRectCount > 0 
		        This.fpdf_pages_selection[m.lnPage,1] = ""
		        This.fpdf_pages_selection[m.lnPage,2] = m.lnStartIndex
		        This.fpdf_pages_selection[m.lnPage,3] = m.lnCountChars
		
		        LOCAL lnPageLeft as Double, lnPageRight as Double, lnPageBottom as Double, lnPageTop as Double
		        STORE 0 TO m.lnPageLeft, m.lnPageRight, m.lnPageBottom, m.lnPageTop
		
		        LOCAL lnRect
		        FOR m.lnRect=1 TO m.lnRectCount
		            IF m.loFPDF.FPDFText_GetRect(m.lnFPDF_Text_Page, m.lnRect-1, @m.lnPageLeft, @m.lnPageTop, @m.lnPageRight, @m.lnPageBottom) > 0
		                This.fpdf_pages_selection[m.lnPage,1] = This.fpdf_pages_selection[m.lnPage,1] + BINTOC(m.lnPageLeft,"8")+BINTOC(m.lnPageTop,"8")+BINTOC(m.lnPageRight,"8")+BINTOC(m.lnPageBottom,"8")
		            ENDIF
		        ENDFOR
		    ELSE
		        This.fpdf_pages_selection[m.lnPage,1] = ""
		        This.fpdf_pages_selection[m.lnPage,2] = 0
		        This.fpdf_pages_selection[m.lnPage,3] = 0
		    ENDIF
		    
		ENDFOR
		
		This.Redraw()
		
	ENDPROC

	PROCEDURE selecttextall		&& Select all text in the document
		This.SelectText(0,0,-1)
		
	ENDPROC

	HIDDEN PROCEDURE viewportupdate
		LOCAL lnVewPortUpdateStep
		m.lnVewPortUpdateStep = 1
		
		FOR m.lnVewPortUpdateStep = 1 TO 2
		
		    This.fpdf_page_first_visible = 0
		    This.fpdf_page_last_visible = 0
		
		    *********************************************************************
		
		    This.ViewPortSizeX = MAX(This.Width - IIF(INLIST(This.ScrollBars,2,3), SYSMETRIC(5),0), 0)
		    This.ViewPortSizeY = MAX(This.Height - IIF(INLIST(This.ScrollBars,1,3), SYSMETRIC(8),0), 0)
		
		
		    *********************************************************************
		
		    IF This.ViewPortMaxX > This.ViewPortSizeX
		        This.ViewPortX = MIN(MAX(-0.5 * (This.ViewPortMaxX - This.ViewPortSizeX), This.ViewPortX), MAX(0.5 * (This.ViewPortMaxX - This.ViewPortSizeX),0))
		    ELSE
		        This.ViewPortX = 0
		    ENDIF    
		
		    This.ViewPortY = MIN(MAX(This.ViewPortY,0), MAX(This.ViewPortMaxY - This.Height,0))
		
		
		
		
		    LOCAL lnViewPortMaxXNew
		    m.lnViewPortMaxXNew = 0
		
		    *********************************************************************
		    LOCAL lnPageX, lnPageY
		    STORE 0 TO m.lnPageX, m.lnPageY
		
		    LOCAL lnPageWidthUnscaled, lnPageHeightUnscaled
		    LOCAL lnPageWidthUnscaledFirst
		    LOCAL lnPageWidth, lnPageHeight
		
		
		    LOCAL lnPageCount, lnPage
		    m.lnPageCount = This.FPDF_PageCount
		
		    FOR m.lnPage = 1 TO m.lnPageCount
		        
		        m.lnPageWidthUnscaled = This.GetPageSize(m.lnPage,3)
		        m.lnPageHeightUnscaled = This.GetPageSize(m.lnPage,4)
		        
		        IF m.lnPage = 1
		            m.lnPageWidthUnscaledFirst = m.lnPageWidthUnscaled
		        ENDIF
		
		        m.lnPageWidth = m.lnPageWidthUnscaled
		        m.lnPageHeight = m.lnPageHeightUnscaled
		
		        IF This.FitWidth
		            m.lnPageWidth = This.ViewPortSizeX * m.lnPageWidthUnscaled / EVL(m.lnPageWidthUnscaledFirst, EVL(m.lnPageWidthUnscaled, 1))
		            m.lnPageHeight = INT(m.lnPageHeight * m.lnPageWidth / EVL(m.lnPageWidthUnscaled, EVL(m.lnPageWidth, 1)))
		        ENDIF
		        
		        m.lnPageWidth = m.lnPageWidth * This.scale
		        m.lnPageHeight = m.lnPageHeight * This.scale    
		        
		        m.lnPageX = (This.ViewPortSizeX - m.lnPageWidth) * 0.5
		        
		        IF m.lnPage > 1
		            m.lnPageY = m.lnPageY +  MIN(MAX(INT(m.lnPageWidth * 0.02),5),40) &&page separator
		        ENDIF
		        
		        This.fpdf_pages_pos[m.lnPage,1] = m.lnPageX
		        This.fpdf_pages_pos[m.lnPage,2] = m.lnPageY
		
		        This.fpdf_pages_pos[m.lnPage,3] = m.lnPageWidth
		        This.fpdf_pages_pos[m.lnPage,4] = m.lnPageHeight
		       
		        DO CASE
		        CASE This.Width < 30
		        CASE m.lnPageY + m.lnPageHeight < This.ViewPortY
		        CASE m.lnPageY > This.ViewPortY + This.ViewPortSizeY
		        OTHERWISE
		
		            IF This.fpdf_page_first_visible = 0
		                This.fpdf_page_first_visible = m.lnPage
		            ENDIF
		            
		            This.fpdf_page_last_visible = m.lnPage
		            
		        ENDCASE
		        
		      
		        m.lnPageY = m.lnPageY + m.lnPageHeight
		        
		        m.lnViewPortMaxXNew = MAX(m.lnViewPortMaxXNew, m.lnPageWidth)
		        
		    ENDFOR
		
		
		    *********************************************************************
		    IF This.ViewPortMaxX > 0 && Adjust ViewPortX after scaling
		        This.ViewPortX = INT(This.ViewPortX * m.lnViewPortMaxXNew * 10000 / This.ViewPortMaxX) / 10000
		    ENDIF
		
		    This.ViewPortMaxX = m.lnViewPortMaxXNew
		
		    *********************************************************************
		    LOCAL lnViewPortYPrev
		    m.lnViewPortYPrev = This.ViewPortY
		
		    LOCAL lnViewPortMaxYNew
		    m.lnViewPortMaxYNew = m.lnPageY
		    
		    IF This.ViewPortMaxY > 0 && Adjust ViewPortY after scaling
		        This.ViewPortY = INT(This.ViewPortY * m.lnViewPortMaxYNew * 10000 / This.ViewPortMaxY) / 10000
		    ENDIF
		    
		    This.ViewPortMaxY = m.lnViewPortMaxYNew
		    
		    
		    IF m.lnViewPortYPrev <> This.ViewPortY
		        * ViewPortY changed, need to recalculate page visibility
		        * Go to the second step
		        LOOP 
		    ENDIF
		    
		    EXIT 
		
		ENDFOR
		
		
		*********************************************************************
		* Scrollbars update
		*********************************************************************
		IF EMPTY(This.WndHandle)=.T.
		    RETURN
		ENDIF
		
		#define SIF_RANGE 0x0001
		#define SIF_PAGE 0x0002
		#define SIF_POS 0x0004
		#define SIF_DISABLENOSCROLL 0x0008
		
		*********************************************************************
		* Vertical scrollbar update
		
		LOCAL lnScrollMin, lnScrollMax, lnScrollPageSize, lnScrollPos
		IF INLIST(This.ScrollBars,2,3) AND This.ViewPortSizeY > 0
		    m.lnScrollMin = 0
		    m.lnScrollMax = This.ViewPortMaxY
		    m.lnScrollPageSize = This.ViewPortSizeY
		    m.lnScrollPos = This.ViewPortY
		ELSE
		    m.lnScrollMin = 0
		    m.lnScrollMax = 0
		    m.lnScrollPageSize = 0
		    m.lnScrollPos = 0
		ENDIF
		
		LOCAL lcScrollInfo
		m.lcScrollInfo = ;
		    BINTOC(28, "4RS")+;
		    BINTOC(SIF_RANGE+SIF_PAGE+SIF_POS, "4RS")+;
		    BINTOC(m.lnScrollMin, "4RS")+;
		    BINTOC(m.lnScrollMax, "4RS")+;
		    BINTOC(m.lnScrollPageSize, "4RS")+;
		    BINTOC(m.lnScrollPos, "4RS")+;
		    BINTOC(0, "4RS")
		
		This.env.API_WIN.SetScrollInfo(This.WndHandle, 1, m.lcScrollInfo, 1)
		
		
		*********************************************************************
		* Horizontal scrollbar update
		
		LOCAL lnScrollMin, lnScrollMax, lnScrollPageSize, lnScrollPos
		IF INLIST(This.ScrollBars,1,3) AND This.ViewPortMaxX > This.ViewPortSizeX AND This.ViewPortSizeX > 0
		    m.lnScrollMin = -0.5 * (This.ViewPortMaxX - This.ViewPortSizeX)
		    m.lnScrollMax = 0.5 * (This.ViewPortMaxX - This.ViewPortSizeX)
		    m.lnScrollPageSize = This.ViewPortSizeX
		    m.lnScrollMax = m.lnScrollMax + m.lnScrollPageSize
		    m.lnScrollPos = MIN(MAX(m.lnScrollMin, This.ViewPortX), m.lnScrollMax)
		ELSE
		    m.lnScrollMin = 0
		    m.lnScrollMax = 0
		    m.lnScrollPageSize = 0
		    m.lnScrollPos = 0
		ENDIF
		
		LOCAL lcScrollInfo
		m.lcScrollInfo = ;
		    BINTOC(28, "4RS")+;
		    BINTOC(SIF_RANGE+SIF_PAGE+SIF_POS, "4RS")+;
		    BINTOC(m.lnScrollMin, "4RS")+;
		    BINTOC(m.lnScrollMax, "4RS")+;
		    BINTOC(m.lnScrollPageSize, "4RS")+;
		    BINTOC(m.lnScrollPos, "4RS")+;
		    BINTOC(0, "4RS")
		
		This.env.API_WIN.SetScrollInfo(This.WndHandle, 0, m.lcScrollInfo, 1)
		
		
		*********************************************************************
		* Events triggering
		This.AfterViewportUpdate()
		*********************************************************************
		
		
	ENDPROC

	HIDDEN PROCEDURE wndcreate
		
		#DEFINE WNDCLASSEX_SIZE 48
		#DEFINE GW_CHILD 5
		#DEFINE GWL_WNDPROC -4
		#DEFINE GWL_HINSTANCE -6
		#DEFINE GWL_STYLE -16
		#define CS_OWNDC            0x0020
		#define CS_PARENTDC         0x0080
		#define WS_CHILD            0x40000000
		#define WS_DISABLED         0x08000000
		#define WS_VISIBLE          0x10000000
		#define WS_CLIPSIBLINGS     0x04000000
		#define WS_CLIPCHILDREN     0x02000000
		#define WS_VSCROLL          0x00200000
		#define WS_HSCROLL          0x00100000
		#define GMEM_FIXED 0x0
		#define GMEM_ZEROINIT 0x0040
		
		
		LOCAL lhWndParent
		m.lhWndParent = This.env.API_WIN.GetWindow(Thisform.HWnd, GW_CHILD) && VFP window with ScrollBars != 0 or with ShowWindow = 2 - As Top-Level Form creates his own child window
		IF EMPTY(m.lhWndParent) = .F. AND Thisform.ShowWindow = 2 AND Thisform.ScrollBars <> 0
		    m.lhWndParent = EVL(This.env.API_WIN.GetWindow(m.lhWndParent, GW_CHILD), m.lhWndParent)
		ENDIF
		IF EMPTY(m.lhWndParent)=.T. OR (Thisform.ScrollBars = 0 AND Thisform.ShowWindow <> 2)
		    m.lhWndParent = Thisform.HWnd
		ENDIF
		
		LOCAL lhInstance
		m.lhInstance = This.env.API_WIN.GetModuleHandle(NULL)
		
		
		LOCAL lcWndClassEx
		m.lcWndClassEx = REPLICATE(CHR(0), WNDCLASSEX_SIZE)
		
		IF EMPTY( This.env.API_WIN.GetClassInfoEx(m.lhInstance, This.WndClassName, @m.lcWndClassEx) )
		
		    LOCAL lnWndClassNamePtr
		    m.lnWndClassNamePtr = This.env.API_WIN.GlobalAlloc(GMEM_FIXED + GMEM_ZEROINIT, LEN(This.WndClassName)+1)
		
		    SYS(2600, m.lnWndClassNamePtr, LEN(This.WndClassName), This.WndClassName)
		
		    m.lcWndClassEx = ;
		        BINTOC(WNDCLASSEX_SIZE, "4RS")+; &&cbSize
		        BINTOC(CS_PARENTDC,"4RS")+; &&style
		        BINTOC(This.env.API_WIN.GetWindowLong(Application.HWnd, GWL_WNDPROC),"4RS")+; &&lpfnWndProc
		        BINTOC(0,"4RS")+; &&cbClsExtra
		        BINTOC(0,"4RS")+; &&cbWndExtra
		        BINTOC(m.lhInstance,"4RS")+; &&hInstance
		        BINTOC(0,"4RS")+; &&hIcon
		        BINTOC(0,"4RS")+; &&hCursor
		        BINTOC(0,"4RS")+; &&hbrBackground
		        BINTOC(0,"4RS")+; &&lpszMenuName
		        BINTOC(m.lnWndClassNamePtr,"4RS")+; &&lpszClassName
		        BINTOC(0,"4RS") &&hIconSm
		
		    This.env.API_WIN.RegisterClassEx(m.lcWndClassEx)
		
		    This.env.API_WIN.GlobalFree(m.lnWndClassNamePtr)
		    
		ENDIF
		
		
		This.WndHandle = This.env.API_WIN.CreateWindowEx( ;
		    0, ;
		    This.WndClassName, ;
		    "", ;
		    WS_CHILD + WS_CLIPCHILDREN + WS_CLIPSIBLINGS + WS_HSCROLL + WS_VSCROLL, ;
		    0,0,1,1, ;
		    m.lhWndParent, ;
		    0, ;
		    m.lhInstance, ;
		    0)
		
		
		IF EMPTY(This.WndHandle)=.T.
		    This.errMsg("CreateWindowEx returned 0")
		    RETURN
		ENDIF
		
		******************************************************
		This.WndDC = This.env.API_WIN.GetDC(This.WndHandle)
		
		
		******************************************************
		#define WM_PAINT 0x000F
		BINDEVENT(This.WndHandle, WM_PAINT, This, "WndProc")
		
		#define WM_MOUSEACTIVATE 0x0021
		BINDEVENT(This.WndHandle, WM_MOUSEACTIVATE, This, "WndProc")
		
		#define WM_MOUSEMOVE 0x0200
		#define WM_LBUTTONDOWN 0x0201
		#define WM_RBUTTONUP 0x0205
		#define WM_MOUSEWHEEL 0x020A
		BINDEVENT(This.WndHandle, WM_MOUSEMOVE, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_LBUTTONDOWN, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_RBUTTONUP, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_MOUSEWHEEL, This, "WndProc")
		
		#define WM_VSCROLL 0x0115
		BINDEVENT(This.WndHandle, WM_VSCROLL, This, "WndProc")
		
		#define WM_HSCROLL 0x0114
		BINDEVENT(This.WndHandle, WM_HSCROLL, This, "WndProc")
		
		
		
	ENDPROC

	PROCEDURE wndproc		&& Events handler of PdfiumViewer internal window. Developer must not use or redefine this method
		LPARAMETERS thWnd, tnMsg, tnWParam, tnLParam
		
		#define GWL_WNDPROC -4
		#define WM_PAINT  0x000F
		#define WM_MOUSEACTIVATE 0x0021
		#define WM_VSCROLL 0x0115
		#define WM_HSCROLL 0x0114
		#define WM_MOUSEMOVE 0x0200
		#define WM_LBUTTONDOWN 0x0201
		#define WM_RBUTTONUP 0x0205
		#define WM_MOUSEWHEEL 0x020A
		#define MK_LBUTTON 0x0001
		#define MK_RBUTTON 0x0002
		#define MK_SHIFT 0x0004
		#define MK_CONTROL 0x0008
		
		
		#define SB_LINEUP           0
		#define SB_LINELEFT         0
		#define SB_LINEDOWN         1
		#define SB_LINERIGHT        1
		#define SB_PAGEUP           2
		#define SB_PAGELEFT         2
		#define SB_PAGEDOWN         3
		#define SB_PAGERIGHT        3
		#define SB_THUMBPOSITION    4
		#define SB_THUMBTRACK       5
		#define SB_TOP              6
		#define SB_LEFT             6
		#define SB_BOTTOM           7
		#define SB_RIGHT            7
		#define SB_ENDSCROLL        8
		#define SIF_TRACKPOS 0x0010
		#define SB_SCROLLINFO_TRACKPOS BINTOC(28, "4RS")+BINTOC(SIF_TRACKPOS, "4RS")+REPLICATE(CHR(0),20)
		
		
		LOCAL lnRetVal
		m.lnRetVal = 0
		
		DO CASE
		
		CASE This.UIState.GetEffectivelyVisible() = .F.
		 
		CASE m.tnMsg = WM_PAINT
		
		    LOCAL lcPaint
		    m.lcPaint = REPLICATE(CHR(0), 256)
		
		    LOCAL lnWndDC
		    m.lnWndDC = This.env.API_WIN.BeginPaint(m.thWnd, @m.lcPaint)
		
		    This.Redraw(m.lnWndDC)
		
		    This.env.API_WIN.EndPaint(m.thWnd, m.lcPaint)
		
		
		CASE This.UIState.GetEffectivelyEnabled() = .F.
		 
		
		CASE m.tnMsg = WM_MOUSEACTIVATE
		    IF This.IsFocused = .F.
		        LOCAL lSaveMousePointer
		        m.lSaveMousePointer = This.MousePointer
		        IF TYPE("Application.ActiveForm.HWnd") = "N"
		            IF Application.ActiveForm.WindowType <> 1 OR Application.ActiveForm.HWnd = Thisform.HWnd
		                This.SetFocus()
		            ENDIF
		        ENDIF
		        This.MousePointer = m.lSaveMousePointer
		    ENDIF
		    
		CASE INLIST(m.tnMsg, WM_MOUSEMOVE, WM_MOUSEWHEEL, WM_LBUTTONDOWN, WM_RBUTTONUP) 
		    LOCAL lnMBtn, lnMShift, lnMouseX, lnMouseY
		    m.lnMBtn = BITAND(m.tnWParam, MK_LBUTTON + MK_RBUTTON)
		    m.lnMShift = BITRSHIFT(BITAND(m.tnWParam, MK_SHIFT + MK_CONTROL),2)
		    m.lnMouseX = BITAND(m.tnLParam, 0xffff)
		    m.lnMouseY = BITAND(BITRSHIFT(m.tnLParam,16), 0xffff)
		    
		    DO CASE
		    
		    CASE INLIST(m.tnMsg, WM_MOUSEMOVE) AND This.IsFocused
		        This.MouseMove(m.lnMBtn, m.lnMShift, m.lnMouseX, m.lnMouseY)
		 
		    CASE INLIST(m.tnMsg, WM_MOUSEWHEEL)
		        LOCAL lnMWDir 
		        m.lnMWDir = BITAND(BITRSHIFT(m.tnWParam,16), 0xffff)
		        m.lnMWDir = IIF(BITTEST(m.lnMWDir,15), m.lnMWDir - 0xffff, m.lnMWDir)
		        
		        This.MouseWheel(m.lnMWDir, m.lnMShift, m.lnMouseX, m.lnMouseY)
		
		    CASE INLIST(m.tnMsg, WM_LBUTTONDOWN) AND This.IsFocused
		        This.MouseDown(1, m.lnMShift, m.lnMouseX, m.lnMouseY)
		        
		    CASE INLIST(m.tnMsg, WM_RBUTTONUP) AND This.IsFocused
		        This.MouseUp(2, m.lnMShift, m.lnMouseX, m.lnMouseY)
		
		    ENDCASE
		    
		    
		CASE m.tnMsg = WM_VSCROLL
		
		    LOCAL lnSbReq
		    m.lnSbReq = BITAND(m.tnWParam, 0xffff)
		     
		    DO CASE
		    CASE m.lnSbReq = SB_LINEUP
		       This.ScrollVert(-0.05 * This.Height, .F., .T.)
		
		    CASE m.lnSbReq = SB_LINEDOWN
		       This.ScrollVert(0.05 * This.Height, .F., .T.)
		
		    CASE m.lnSbReq = SB_PAGEUP
		       This.ScrollVert(-1, .T., .T.)
		
		    CASE m.lnSbReq = SB_PAGEDOWN
		       This.ScrollVert(1, .T., .T.)
		
		    CASE m.lnSbReq = SB_TOP
		       This.ScrollVert(0, .F., .F.)
		
		    CASE m.lnSbReq = SB_BOTTOM
		       This.ScrollVert(This.ViewPortMaxY, .F., .F.)
		
		    CASE m.lnSbReq = SB_THUMBTRACK
		       LOCAL lcScrollInfo
		       m.lcScrollInfo = SB_SCROLLINFO_TRACKPOS
		
		       IF This.env.API_WIN.GetScrollInfo(m.thWnd, 1, @m.lcScrollInfo) = 1
		           LOCAL lnSbPos
		           m.lnSbPos = CTOBIN(SUBSTR(m.lcScrollInfo,25,4),"4RS")
		           This.ScrollVert(m.lnSbPos)
		       ENDIF
		    ENDCASE
		
		
		CASE m.tnMsg = WM_HSCROLL
		
		    LOCAL lnSbReq
		    m.lnSbReq = BITAND(m.tnWParam, 0xffff)
		     
		    DO CASE
		    CASE m.lnSbReq = SB_LINELEFT
		       This.ScrollHorz(-0.05 * This.Width, .F., .T.)
		
		    CASE m.lnSbReq = SB_LINERIGHT
		       This.ScrollHorz(0.05 * This.Width, .F., .T.)
		
		    CASE m.lnSbReq = SB_PAGELEFT
		       This.ScrollHorz(-1, .T., .T.)
		
		    CASE m.lnSbReq = SB_PAGERIGHT
		       This.ScrollHorz(1, .T., .T.)
		
		    CASE m.lnSbReq = SB_LEFT
		       This.ScrollHorz(-This.ViewPortMaxY, .F., .F.)
		
		    CASE m.lnSbReq = SB_RIGHT
		       This.ScrollHorz(This.ViewPortMaxY, .F., .F.)
		
		    CASE m.lnSbReq = SB_THUMBTRACK
		       LOCAL lcScrollInfo
		       m.lcScrollInfo = SB_SCROLLINFO_TRACKPOS
		
		       IF This.env.API_WIN.GetScrollInfo(m.thWnd, 0, @m.lcScrollInfo) = 1
		           LOCAL lnSbPos
		           m.lnSbPos = CTOBIN(SUBSTR(m.lcScrollInfo,25,4),"4RS")
		           This.ScrollHorz(m.lnSbPos)
		       ENDIF
		    ENDCASE
		
		
		OTHERWISE
		    LOCAL lnWndProcDefault
		    m.lnWndProcDefault = This.env.API_WIN.GetWindowLong(m.thWnd, GWL_WNDPROC)
		    m.lnRetVal = This.env.API_WIN.CallWindowProc(m.lnWndProcDefault, m.thWnd, m.tnMsg, m.tnWParam, m.tnLParam)
		
		ENDCASE
		
		
		RETURN m.lnRetVal
		
	ENDPROC

	HIDDEN PROCEDURE wndredraw
		IF EMPTY(This.WndHandle)
		    RETURN
		ENDIF
		
		This.env.API_WIN.InvalidateRect(This.WndHandle, NULL, 1)
		
	ENDPROC

	HIDDEN PROCEDURE wndrelease
		IF EMPTY(This.WndDC) = .F.
		    This.env.API_WIN.ReleaseDC(This.WndHandle, This.WndDC)
		    This.WndDC = 0
		ENDIF
		
		IF EMPTY(This.WndHandle) = .F.
		    UNBINDEVENTS(This.WndHandle)
		    This.env.API_WIN.DestroyWindow(This.WndHandle)
		    This.WndHandle = 0
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE wndresize
		IF EMPTY(This.WndHandle)
		    RETURN
		ENDIF
		
		This.ViewPortUpdate()
		This.DrawBufCreate()
		
		This.env.API_WIN.MoveWindow(This.WndHandle, This.UIState.ObjToClient(2), This.UIState.ObjToClient(1), This.Width, This.Height, 1)
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE wndshow		&& Show child window (for internal use, public for bindevent)
		
		#define SW_HIDE 0
		#define SW_SHOWNA 8
		IF EMPTY(This.WndHandle)=.F.
		    This.env.API_WIN.ShowWindow(This.WndHandle, IIF(This.UIState.GetEffectivelyVisible(), SW_SHOWNA, SW_HIDE))
		ENDIF
		
	ENDPROC

	PROCEDURE UIState.onvisible
		This.Parent.WndShow()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumviewer_cmdfocus AS commandbutton 		&& PdfiumViewer input focus holder. Library consumer must not use this class directly
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: this_access
	*</DefinedPropArrayMethod>

	*<PropValue>
		Caption = ""
		Enabled = .T.
		Height = 27
		Name = "pdfiumviewer_cmdfocus"
		Style = 0
		Visible = .T.
		Width = 27
	*</PropValue>
	
	HIDDEN PROCEDURE this_access
		LPARAMETERS cMember
		
		RETURN This.Parent
		
	ENDPROC

ENDDEFINE
