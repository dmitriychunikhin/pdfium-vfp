*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="pdfium-vfp.vcx" CPID="1251" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS pdfiumviewer AS control 
 	*< CLASSDATA: Baseclass="control" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdFocus" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="UIState" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: backcolor_assign
		*m: closepdf		&& Close pdf file, previously opened by PdfiumViewer.openpdf
		*m: configure
		*m: contextmenu
		*m: declaredll
		*m: drawbufcreate
		*m: drawbufrelease
		*m: errmsg
		*m: getcurrentpage		&& Current page number. First page has number = 1
		*m: getpagecount
		*m: getpagesize
		*m: keypress		&& Occurs when the user presses and releases a key.
		*m: openpdf		&& Open pdf file. Returns: .T. on success, .F. if file was not loaded
		*m: pagepick
		*m: redraw
		*m: renderpagefromcache
		*m: renderpages
		*m: renderselection
		*m: scale_assign
		*m: scrollbars_assign
		*m: scrollhorz
		*m: scrollvert
		*m: selectioncopy		&& Copy selected text to clipboard
		*m: selecttext
		*m: selecttextall
		*m: viewportupdate
		*m: wndcreate
		*m: wndproc		&& Events handler of PdfiumViewer internal window. Developer must not use or redefine this method
		*m: wndredraw
		*m: wndrelease
		*m: wndresize
		*m: wndshow
		*p: backcolorbrush
		*p: dblclickbegin
		*p: declaredll_ok
		*p: drawbufdc
		*p: drawbufdib
		*p: drawbufgfx
		*p: fpdf_doc
		*p: fpdf_opened
		*p: fpdf_pagecount
		*p: fpdf_page_first_visible		&& Index of the page that appears first after rendering
		*p: fpdf_page_last_visible
		*p: pdfdpi
		*p: pdfium_dll_path
		*p: scale
		*p: screendpix
		*p: screendpiy
		*p: scrollbars		&& Specifies the type of scroll bars that an EditBox control, Form object, or Grid control has. 0 - None (Default); 1 - Horizontal; 2 - Vertical; 3 - Both vertical and horizontal
		*p: selectionbrush
		*p: selectioncharindexprev
		*p: selectioncharindexstart
		*p: system		&& GDIPlusX System object
		*p: tplclickbegin
		*p: viewportmaxx
		*p: viewportmaxy
		*p: viewportsizex
		*p: viewportsizey
		*p: viewportx
		*p: viewporty
		*p: wndclassname
		*p: wnddc
		*p: wndhandle		&& Specifies the Window handle of the Window.
		*a: fpdf_pages[1,0]
		*a: fpdf_pages_pos[1,4]
		*a: fpdf_pages_render_cache[1,4]
		*a: fpdf_pages_selection[3,0]
		*a: fpdf_pages_size[1,4]
		*a: fpdf_text_pages[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN ActiveControl,AddProperty,backcolorbrush,BackStyle,BorderColor,BorderWidth,ClassLibrary,Click,CloneObject,ColorSource,ControlCount,Controls,dblclickbegin,DblClick,declaredll_ok,DragDrop,DragIcon,DragMode,DragOver,Drag,drawbufdc,drawbufdib,drawbufgfx,Draw,Error,ForeColor,fpdf_doc,fpdf_opened,fpdf_pagecount,fpdf_pages,fpdf_pages_pos,fpdf_pages_render_cache,fpdf_pages_selection,fpdf_pages_size,fpdf_page_first_visible,fpdf_page_last_visible,fpdf_text_pages,GotFocus,HelpContextID,LostFocus,MiddleClick,MouseDown,MouseEnter,MouseIcon,MouseLeave,MouseMove,MousePointer,MouseUp,MouseWheel,Moved,Objects,OLECompleteDrag,OLEDragDrop,OLEDragMode,OLEDragOver,OLEDragPicture,OLEDrag,OLEDropEffects,OLEDropHasData,OLEDropMode,OLEGiveFeedback,OLESetData,OLEStartDrag,ParentClass,pdfdpi,pdfium_dll_path,Picture,ReadExpression,ReadMethod,Refresh,ResetToDefault,Resize,RightClick,SaveAsClass,screendpix,screendpiy,selectionbrush,selectioncharindexprev,selectioncharindexstart,SetFocus,ShowWhatsThis,SpecialEffect,Style,system,Tag,tplclickbegin,UIEnable,viewportmaxx,viewportmaxy,viewportsizex,viewportsizey,viewportx,viewporty,WhatsThisHelpID,wndclassname,wnddc,wndhandle,WriteExpression,WriteMethod,ZOrder
	*<PropValue>
		backcolorbrush = .F.
		BackStyle = 1
		dblclickbegin = 0
		declaredll_ok = .F.
		drawbufdc = 0
		drawbufdib = 0
		drawbufgfx = 0
		fpdf_doc = 0
		fpdf_opened = .F.
		fpdf_pagecount = 0
		fpdf_page_first_visible = 0
		fpdf_page_last_visible = 0
		Height = 622
		Name = "pdfiumviewer"
		pdfdpi = 72
		pdfium_dll_path = ("pdfium.dll")
		scale = 1
		screendpix = 96
		screendpiy = 96
		scrollbars = 0
		selectionbrush = .F.
		selectioncharindexprev = -1
		selectioncharindexstart = 0
		system = .F.
		tplclickbegin = 0
		viewportmaxx = 0
		viewportmaxy = 0
		viewportsizex = 0
		viewportsizey = 0
		viewportx = 0
		viewporty = 0
		Visible = .T.
		Width = 445
		wndclassname = ("PDFIUM-VFP-VIEWER")
		wnddc = 0
		wndhandle = 0
		_memberdata = <VFPData>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="configure" type="method" display="Configure"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="declaredll" type="method" display="DeclareDLL"/>
			<memberdata name="declaredll_ok" type="property" display="DeclareDLL_Ok"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="drawbufgfx" type="property" display="DrawBufGFX"/>
			<memberdata name="drawbufrelease" type="method" display="DrawBufRelease"/>
			<memberdata name="errmsg" type="method" display="ErrMsg"/>
			<memberdata name="fpdf_doc" type="property" display="fpdf_doc"/>
			<memberdata name="fpdf_opened" type="property" display="fpdf_opened"/>
			<memberdata name="fpdf_pagecount" type="property" display="fpdf_pagecount"/>
			<memberdata name="fpdf_pages" type="property" display="fpdf_pages"/>
			<memberdata name="fpdf_pages_pos" type="property" display="fpdf_pages_pos"/>
			<memberdata name="fpdf_pages_render_cache" type="property" display="fpdf_pages_render_cache"/>
			<memberdata name="fpdf_pages_selection" type="property" display="fpdf_pages_selection"/>
			<memberdata name="fpdf_pages_size" type="property" display="fpdf_pages_size"/>
			<memberdata name="fpdf_page_first_visible" type="property" display="fpdf_page_first_visible"/>
			<memberdata name="fpdf_page_last_visible" type="property" display="fpdf_page_last_visible"/>
			<memberdata name="fpdf_text_pages" type="property" display="fpdf_text_pages"/>
			<memberdata name="getcurrentpage" type="method" display="GetCurrentPage"/>
			<memberdata name="getpagecount" type="method" display="GetPageCount"/>
			<memberdata name="getpagesize" type="method" display="GetPageSize"/>
			<memberdata name="keypress" type="method" display="KeyPress"/>
			<memberdata name="openpdf" type="method" display="OpenPDF" favorites="True"/>
			<memberdata name="pagepick" type="method" display="PagePick"/>
			<memberdata name="pdfdpi" type="property" display="PdfDPI"/>
			<memberdata name="pdfium_dll_path" type="property" display="Pdfium_Dll_Path"/>
			<memberdata name="redraw" type="method" display="Redraw"/>
			<memberdata name="renderpages" type="method" display="RenderPages"/>
			<memberdata name="renderpagefromcache" type="method" display="RenderPageFromCache"/>
			<memberdata name="renderselection" type="method" display="RenderSelection"/>
			<memberdata name="scale" type="property" display="Scale"/>
			<memberdata name="scale_assign" type="method" display="Scale_Assign"/>
			<memberdata name="screendpix" type="property" display="ScreenDPIX"/>
			<memberdata name="screendpiy" type="property" display="ScreenDPIY"/>
			<memberdata name="scrollbars" type="property" display="ScrollBars"/>
			<memberdata name="scrollbars_assign" type="method" display="ScrollBars_Assign"/>
			<memberdata name="scrollhorz" type="method" display="ScrollHorz"/>
			<memberdata name="scrollvert" type="method" display="ScrollVert"/>
			<memberdata name="selectionbrush" type="property" display="SelectionBrush"/>
			<memberdata name="selectioncharindexprev" type="property" display="SelectionCharIndexPrev"/>
			<memberdata name="selectioncharindexstart" type="property" display="SelectionCharIndexStart"/>
			<memberdata name="selectioncopy" type="method" display="SelectionCopy"/>
			<memberdata name="selecttext" type="method" display="SelectText"/>
			<memberdata name="system" type="property" display="System"/>
			<memberdata name="viewportmaxx" type="property" display="ViewPortMaxX"/>
			<memberdata name="viewportmaxy" type="property" display="ViewPortMaxY"/>
			<memberdata name="viewportsizex" type="property" display="ViewPortSizeX"/>
			<memberdata name="viewportsizey" type="property" display="ViewPortSizeY"/>
			<memberdata name="viewportupdate" type="method" display="ViewPortUpdate"/>
			<memberdata name="viewportx" type="property" display="ViewPortX"/>
			<memberdata name="viewporty" type="property" display="ViewPortY"/>
			<memberdata name="wndclassname" type="property" display="WndClassName"/>
			<memberdata name="wndcreate" type="method" display="WndCreate"/>
			<memberdata name="wnddc" type="property" display="WndDC"/>
			<memberdata name="wndhandle" type="property" display="WndHandle"/>
			<memberdata name="wndproc" type="method" display="WndProc"/>
			<memberdata name="wndredraw" type="method" display="WndRedraw"/>
			<memberdata name="wndrelease" type="method" display="WndRelease"/>
			<memberdata name="wndresize" type="method" display="WndResize"/>
			<memberdata name="wndshow" type="method" display="WndShow"/>
			<memberdata name="selecttextall" type="method" display="SelectTextAll"/>
			<memberdata name="dblclickbegin" type="property" display="DblClickBegin"/>
			<memberdata name="tplclickbegin" type="property" display="TplClickBegin"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cmdFocus' AS pdfiumviewer_cmdfocus WITH ;
		Left = -100, ;
		Name = "cmdFocus", ;
		Top = -100
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfiumviewer_i18n WITH ;
		Left = 72, ;
		Name = "i18n", ;
		Top = 24
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'UIState' AS pdfiumviewer_uistate WITH ;
		Left = 24, ;
		Name = "UIState", ;
		Top = 24
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	HIDDEN PROCEDURE backcolor_assign
		LPARAMETERS vNewVal
		
		IF VARTYPE(This.System)<>"O"
		    RETURN
		ENDIF
		
		This.BackColor = m.vNewVal
		
		LOCAL loBackColor
		loBackColor = This.System.Drawing.Color.FromRgb(This.BackColor)
		This.BackColorBrush.Color = loBackColor
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE closepdf		&& Close pdf file, previously opened by PdfiumViewer.openpdf
		IF This.declaredll_ok = .F.
		    RETURN
		ENDIF
		
		This.fpdf_opened = .F.
		
		LOCAL lnPage, lnPageCount
		lnPageCount = This.fpdf_pagecount
		
		This.fpdf_pagecount = 0
		
		This.fpdf_page_first_visible = 0
		This.fpdf_page_last_visible = 0
		
		This.ViewPortX = 0
		This.ViewPortY = 0
		This.ViewPortSizeX = 0
		This.ViewPortSizeY = 0
		This.ViewPortMaxX = 0
		This.ViewPortMaxY = 0
		
		This.scale = 1
		
		LOCAL lnPage
		FOR lnPage = 1 TO lnPageCount
		    FPDFText_ClosePage(This.fpdf_text_pages[lnPage])
		    FPDF_ClosePage(This.fpdf_pages[lnPage])
		    
		    This.fpdf_pages[lnPage] = 0
		    This.fpdf_text_pages[lnPage] = 0
		    This.fpdf_pages_selection[lnPage,1] = ""
		    This.fpdf_pages_selection[lnPage,2] = 0
		    This.fpdf_pages_selection[lnPage,3] = 0
		    
		    LOCAL j
		    FOR j = 1 TO ALEN(This.fpdf_pages_render_cache,2)
		        This.fpdf_pages_render_cache[lnPage,j] = .F.
		    ENDFOR
		ENDFOR
		
		DIMENSION This.fpdf_pages(1)
		DIMENSION This.fpdf_text_pages(1)
		DIMENSION This.fpdf_pages_selection(1,3)
		DIMENSION This.fpdf_pages_pos(1,4)
		DIMENSION This.fpdf_pages_size(1,2)
		DIMENSION This.fpdf_pages_render_cache(1, ALEN(This.fpdf_pages_render_cache,2))
		
		STORE 0 TO This.fpdf_pages_pos, This.fpdf_pages_size
		
		IF EMPTY(This.fpdf_doc)=.F.
		    FPDF_CloseDocument(This.fpdf_doc)
		    This.fpdf_doc = 0
		ENDIF
		
		This.ViewPortUpdate()
		This.wndredraw()
		
	ENDPROC

	HIDDEN PROCEDURE configure
		LPARAMETERS toConf as pdfiumviewer_conf of pdfium-vfp
		
		IF VARTYPE(toConf)="O"
		    This.System = toConf.System
		    This.pdfium_dll_path = EVL(NVL(toConf.pdfium_dll_path,""), This.pdfium_dll_path)
		ENDIF    
		
		IF VARTYPE(This.System)<>"O" AND TYPE("_SCREEN.System")="O"
		    This.System = _SCREEN.System
		ENDIF
		
		
	ENDPROC

	HIDDEN PROCEDURE contextmenu
		
		LOCAL lcMenuName
		lcMenuName = "_context_menu"
		
		DEFINE POPUP (lcMenuName) FROM MROW(), MCOL() MARGIN RELATIVE SHORTCUT
		
		LOCAL lcSelectCopy, lcSelectAll
		lcSelectCopy = "SKIP FOR .T."
		lcSelectAll = ""
		
		IF This.fpdf_opened = .T.
		    LOCAL lnPage
		    FOR lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		        IF This.fpdf_pages_selection[lnPage,3] > 0
		            lcSelectCopy = ""
		            EXIT
		        ENDIF
		    ENDFOR
		ELSE
		    lcSelectAll = "SKIP FOR .T."
		ENDIF
		
		
		LOCAL i
		i=0
		
		i=i+1
		DEFINE BAR (i) OF (lcMenuName) PROMPT (This.i18n.text("MNU_COPY")) PICTRES _MED_COPY &lcSelectCopy
		ON SELECTION BAR (i) OF (lcMenuName) poThis.SelectionCopy()
		
		i=i+1
		DEFINE BAR (i) OF (lcMenuName) PROMPT (This.i18n.text("MNU_SLCTA")) &lcSelectAll
		ON SELECTION BAR (i) OF (lcMenuName) poThis.SelectTextAll()
		
		
		PRIVATE poThis
		poThis = This
		IF CNTBAR(lcMenuName)<>0
		    ACTIVATE POPUP &lcMenuName
		ENDIF
		poThis = .F.
		
		
	ENDPROC

	HIDDEN PROCEDURE declaredll
		
		************************************************************************
		LOCAL lcPdfiumDll
		lcPdfiumDll = This.pdfium_dll_path
		
		DECLARE FPDF_InitLibraryWithConfig IN (lcPdfiumDll) STRING@ config
		DECLARE FPDF_DestroyLibrary IN (lcPdfiumDll)
		
		DECLARE LONG FPDF_LoadDocument IN (lcPdfiumDll) STRING file_path, STRING password
		DECLARE FPDF_CloseDocument IN (lcPdfiumDll) LONG document
		
		DECLARE INTEGER FPDF_GetPageCount IN (lcPdfiumDll) LONG document
		
		DECLARE LONG FPDF_LoadPage IN (lcPdfiumDll) LONG document, INTEGER page_index
		DECLARE FPDF_ClosePage IN (lcPdfiumDll) LONG page
		
		DECLARE FPDF_RenderPage IN (lcPdfiumDll) LONG dc, LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer flags
		DECLARE FPDF_RenderPageBitmap IN (lcPdfiumDll) LONG bitmap, LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer flags
		
		DECLARE LONG FPDFText_LoadPage IN (lcPdfiumDll) LONG page
		DECLARE FPDFText_ClosePage IN (lcPdfiumDll) LONG text_page
		
		DECLARE INTEGER FPDF_GetPageSizeByIndex IN (lcPdfiumDll) LONG document, integer page_index, double@ width, double@ height
		DECLARE double FPDF_GetPageWidthF IN (lcPdfiumDll) LONG page
		DECLARE double FPDF_GetPageHeightF IN (lcPdfiumDll) LONG page
		
		DECLARE INTEGER FPDFText_CountChars IN (lcPdfiumDll) LONG text_page
		
		DECLARE INTEGER FPDFText_GetCharIndexAtPos IN (lcPdfiumDll) LONG text_page, double x, double y, double xTolerance, double yTolerance
		DECLARE INTEGER FPDFText_GetCharBox IN (lcPdfiumDll) LONG text_page, INTEGER index, double@ left, double@ right, double@ bottom, double@ top
		
		DECLARE INTEGER FPDFText_GetText IN (lcPdfiumDll) LONG text_page, integer start_index, integer count, STRING@ result
		DECLARE LONG FPDFText_GetUnicode IN (lcPdfiumDll) LONG text_page, integer index
		
		DECLARE INTEGER FPDFText_CountRects IN (lcPdfiumDll) LONG text_page, integer start_index, integer count
		DECLARE INTEGER FPDFText_GetRect IN (lcPdfiumDll) LONG text_page, integer rect_index, double@ left, double@ top, double@ right, double@ bottom
		DECLARE INTEGER FPDFText_GetBoundedText IN (lcPdfiumDll) LONG text_page, double left, double top, double right, double bottom, STRING@ buffer, integer buflen
		
		DECLARE INTEGER FPDF_DeviceToPage IN (lcPdfiumDll) LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer device_x, integer device_y, double@ page_x, double@ page_y
		DECLARE INTEGER FPDF_PageToDevice IN (lcPdfiumDll) LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, double page_x, double page_y, integer@ device_x, integer@ device_y
		
		DECLARE LONG FPDFBitmap_Create IN (lcPdfiumDll) integer width, integer height, integer alpha
		DECLARE LONG FPDFBitmap_CreateEx IN (lcPdfiumDll) integer width, integer height, integer format, LONG first_scan, integer stride
		DECLARE FPDFBitmap_Destroy IN (lcPdfiumDll) LONG bitmap
		    
		    
		
		
		************************************************************************
		DECLARE INTEGER GetModuleHandle IN kernel32 AS WinApi_GetModuleHandle LONG lpModuleName
		
		DECLARE LONG GetWindowLong IN user32 AS WinApi_GetWindowLong LONG hWnd, INTEGER nIndex
		DECLARE LONG SetWindowLong IN user32 AS WinApi_SetWindowLong LONG hWnd, INTEGER nIndex, LONG dwNewLong
		
		DECLARE INTEGER GetClassInfoEx IN user32 AS WinApi_GetClassInfoEx LONG hInstance, STRING lpClassName, STRING@ lpWndClassEx
		DECLARE LONG RegisterClassEx IN user32 AS WinApi_RegisterClassEx STRING@ lpWndClassEx
		
		DECLARE LONG CreateWindowEx IN user32 AS WinApi_CreateWindowEx  ;
		    LONG dwExStyle, ;
		    STRING lpClassName,;
		    STRING lpWindowName, LONG dwStyle,;
		    INTEGER x, INTEGER y, INTEGER nWidth, INTEGER nHeight,;
		    LONG hWndParent, LONG hMenu, LONG hInstance,;
		    LONG lpParam  
		
		DECLARE LONG MoveWindow IN user32 AS WinApi_MoveWindow LONG hWnd, INTEGER X, INTEGER Y, INTEGER nWidth, INTEGER nHeight, INTEGER bRepaint
		
		DECLARE LONG SetWindowPos IN user32 AS WinApi_SetWindowPos ;
		    LONG hWnd, ;
		    LONG hWndInsertAfter, ;
		    INTEGER X, INTEGER Y,;
		    INTEGER nWidth, INTEGER nHeight, ;
		    LONG uFlags
		
		DECLARE LONG DestroyWindow IN user32 AS WinApi_DestroyWindow LONG hWnd
		
		DECLARE LONG GetWindow IN user32 AS WinApi_GetWindow LONG hWnd, LONG uCmd
		
		
		DECLARE Integer BitBlt IN WIN32API AS WinApi_BitBlt Integer hdc, Integer nXDest, Integer nYDest, Integer nWidth, Integer nHeight, Long hdcSrc, Integer nXSrc, Integer nYSrc, Integer nRop
		DECLARE INTEGER CreateDIBSection IN WIN32API AS WinApi_CreateDIBSection INTEGER hdc, STRING @pbmi, LONG iUsage, INTEGER @ppvBits, INTEGER hSection, LONG dwOffset
		DECLARE INTEGER CreateCompatibleBitmap IN WIN32API AS WinApi_CreateCompatibleBitmap INTEGER hdc, INTEGER cx, INTEGER cy
		DECLARE Integer SelectObject IN WIN32API AS WinApi_SelectObject Integer hdc, Integer hgdiobj
		DECLARE Integer DeleteObject IN WIN32API AS WinApi_DeleteObject Integer hObject
		DECLARE Integer CreateCompatibleDC IN WIN32API AS WinApi_CreateCompatibleDC Integer hDC
		DECLARE Integer GetDC IN WIN32API AS WinApi_GetDC Integer hWnd
		DECLARE Long ReleaseDC IN WIN32API AS WinApi_ReleaseDC Long hWnd, Long hDC
		DECLARE Long DeleteDC IN WIN32API AS WinApi_DeleteDC Long hdc
		DECLARE integer SaveDC IN WIN32API AS WinApi_SaveDC LONG hdc
		DECLARE integer RestoreDC IN WIN32API AS WinApi_RestoreDC LONG hdc, integer nSavedDC
		DECLARE integer CancelDC IN WIN32API AS WinApi_CancelDC LONG hdc
		
		DECLARE Long GlobalAlloc IN WIN32API AS WinApi_GlobalAlloc Long nFlags, Long nSize
		DECLARE Long GlobalFree IN WIN32API AS WinApi_GlobalFree Long nHandle
		DECLARE INTEGER GdiFlush IN WIN32API AS WinApi_GdiFlush
		DECLARE LONG GlobalLock IN WIN32API AS WinApi_GlobalLock LONG hMem
		DECLARE LONG GlobalUnlock IN WIN32API AS WinApi_GlobalUnlock LONG hMem
		
		
		DECLARE integer FillRect IN WIN32API AS WinApi_FillRect LONG hDC, STRING@ lprc, LONG hbr
		DECLARE integer GetStockObject IN WIN32API AS WinApi_GetStockObject INTEGER index
		
		DECLARE LONG BeginPaint IN WIN32API AS WinApi_BeginPaint LONG hWnd, STRING@ lpPaint
		DECLARE INTEGER EndPaint IN WIN32API AS WinApi_EndPaint LONG hWnd, STRING@ lpPaint
		
		DECLARE LONG InvalidateRect IN WIN32API AS WinApi_InvalidateRect LONG hWnd, LONG lpRect, LONG bErase
		DECLARE LONG UpdateWindow IN WIN32API AS WinApi_UpdateWindow LONG hWnd
		DECLARE LONG GetWindowRect IN WIN32API AS WinApi_GetWindowRect LONG hWnd, STRING@ lpRect
		
		DECLARE LONG CallWindowProc IN WIN32API AS WinApi_CallWindowProc LONG lpPrevWndFunc, LONG hWnd, LONG Msg, LONG wParam, LONG lParam
		
		DECLARE LONG EnableScrollBar IN WIN32API AS WinApi_EnableScrollBar LONG hWnd, LONG wSBflags, LONG wArrows
		DECLARE LONG ShowScrollBar IN WIN32API AS WinApi_ShowScrollBar LONG hWnd, LONG wBar, LONG bShow
		DECLARE INTEGER SetScrollInfo IN WIN32API AS WinApi_SetScrollInfo LONG hwnd, INTEGER nBar, STRING@ lpsi, LONG redraw
		DECLARE LONG GetScrollInfo IN WIN32API AS WinApi_GetScrollInfo LONG hwnd, INTEGER nBar, STRING@ lpsi
		
		DECLARE LONG ShowWindow IN WIN32API AS WinApi_ShowWindow LONG hWnd, INTEGER nCmdShow
		
		DECLARE LONG SetActiveWindow IN WIN32API AS WinApi_SetActiveWindow LONG hWnd
		DECLARE LONG SetFocus IN WIN32API AS WinApi_SetFocus LONG hWnd
		
		DECLARE SHORT GetAsyncKeyState IN WIN32API AS WinApi_GetAsyncKeyState integer vKey
		DECLARE SHORT GetKeyState IN WIN32API AS WinApi_GetKeyState integer vKey
		
		DECLARE INTEGER SetClipboardData IN user32 AS WinApi_SetClipboardData INTEGER uFormat, INTEGER hMem
		DECLARE INTEGER GetClipboardData IN user32 AS WinApi_GetClipboardData INTEGER uFormat
		DECLARE INTEGER OpenClipboard IN user32 AS WinApi_OpenClipboard INTEGER hWndNewOwner
		DECLARE INTEGER CloseClipboard IN user32 AS WinApi_CloseClipboard
		DECLARE INTEGER EmptyClipboard IN user32 AS WinApi_EmptyClipboard
		DECLARE INTEGER GetOpenClipboardWindow IN user32 AS WinApi_GetOpenClipboardWindow
		DECLARE INTEGER IsClipboardFormatAvailable IN user32 AS WinApi_IsClipboardFormatAvailable INTEGER uFormat
		DECLARE INTEGER GetSystemDefaultLCID IN WIN32API AS WinApi_GetSystemDefaultLCID
		
		DECLARE LONG GetTickCount IN WIN32API AS WinApi_GetTickCount
		
	ENDPROC

	PROCEDURE Destroy
		
		This.ClosePdf()
		
		This.SelectionBrush = .F.
		This.BackColorBrush = .F.
		
		This.DrawBufRelease()
		
		This.WndRelease()
		
		
		IF PEMSTATUS(Application, "pdfium_instance_count", 5)=.T.
		    IF Application.pdfium_instance_count = 1
		        FPDF_DestroyLibrary()
		
		        LOCAL ARRAY laDlls(1)
		        LOCAL lnDllsCnt, lnDlls
		        lnDllsCnt = ADLLS(laDlls)
		        
		        FOR lnDlls = 1 TO lnDllsCnt
		            IF ALLTRIM(LOWER(laDlls[lnDlls,3])) == ALLTRIM(LOWER(This.pdfium_dll_path))
		                LOCAL lcDllsAlias
		                lcDllsAlias = laDlls[lnDlls,2]
		                CLEAR DLLS &lcDllsAlias
		            ENDIF
		        ENDFOR
		    ENDIF
		
		    Application.pdfium_instance_count = MAX(Application.pdfium_instance_count - 1, 0)
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE drawbufcreate
		
		#DEFINE FF_RGBQUAD_SIZE     4
		#DEFINE FF_DIB_RGB_COLORS   0
		#DEFINE FF_BFHDR_SIZE      14
		#DEFINE FF_BHDR_SIZE       40
		#DEFINE FF_BI_RGB           0
		
		IF EMPTY(This.WndDC)
		    RETURN
		ENDIF
		
		IF VARTYPE(This.System)<>"O"
		    RETURN
		ENDIF
		
		
		This.DrawBufRelease()
		
		
		***********************************************************************************
		IF EMPTY(This.DrawBufDC)
		    This.DrawBufDC = WinApi_CreateCompatibleDC(This.WndDC)
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		LOCAL lnWidth, lnHeight, lnBitsPerPixel
		lnWidth = This.Width
		lnHeight = This.Height
		lnBitsPerPixel = 16
		
		LOCAL lcBMI
		lcBMI = BINTOC(FF_BHDR_SIZE ,"4RS") + BINTOC(lnWidth,"4RS") + BINTOC(lnHeight, "4RS") + ;
		        (CHR(MOD(1,256)) + CHR(INT(1/256))) + (CHR(MOD(lnBitsPerPixel,256))+ CHR(INT(lnBitsPerPixel/256))) +;
		        BINTOC(FF_BI_RGB, "4RS") + REPLICATE(0h00, 20)
		
		
		LOCAL lnDibDataPtr
		lnDibDataPtr = 0
		
		This.DrawBufDIB = WinApi_CreateDIBSection(This.DrawBufDC, @lcBMI, FF_DIB_RGB_COLORS, @lnDibDataPtr, 0, 0)
		WinApi_SelectObject(This.DrawBufDC, This.DrawBufDIB)
		
		This.DrawBufGfx = This.System.Drawing.Graphics.FromHDC(This.DrawBufDC)
		
		
	ENDPROC

	HIDDEN PROCEDURE drawbufrelease
		This.DrawBufGfx = .F.
		
		IF EMPTY(This.DrawBufDC) = .F.
		    WinApi_DeleteDC(This.DrawBufDC)
		    This.DrawBufDC = 0
		ENDIF
		
		IF EMPTY(This.DrawBufDIB) = .F.
		    WinApi_DeleteObject(This.DrawBufDIB)
		    This.DrawBufDIB = 0
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		lcMsg = ""
		
		DO CASE
		 CASE VARTYPE(m.tvMsg)="O"
		    lcMsg = ;
		        m.tvMsg.Message + ;
		        RTRIM(" " + NVL(m.tvMsg.Details,"")) + ;
		        RTRIM(" " + NVL(m.tvMsg.UserValue,"")) + ;
		        CHR(13) + "Procedure: " + m.tvMsg.Procedure + ;
		        CHR(13) + "LineContents: " + m.tvMsg.LineContents
		
		 CASE VARTYPE(m.tvMsg)="C"
		    lcMsg = ALLTRIM(m.tvMsg)
		
		ENDCASE
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		MESSAGEBOX(m.lcMsg, 0+48, This.Class)
		
		
	ENDPROC

	PROCEDURE getcurrentpage		&& Current page number. First page has number = 1
		RETURN This.fpdf_page_first_visible
	ENDPROC

	PROCEDURE getpagecount
		RETURN This.fpdf_pagecount
		
	ENDPROC

	PROCEDURE getpagesize
		LPARAMETERS tnPageIndex, tnPosition
		
		*tnPageIndex: page number from 1 to This.fpdf_pagecount
		*tnPosition: 1 - width in pdf units  (1/72 on inch)
		*tnPosition: 2 - height in pdf units  (1/72 on inch)
		*tnPosition: 3 - width in pixels
		*tnPosition: 4 - height in pixels
		*tnPosition: 5 - width / height relation
		
		IF BETWEEN(m.tnPageIndex, 1, This.fpdf_pagecount)=.F.
		    RETURN 0
		ENDIF
		
		LOCAL lnPdfPageWidth, lnPdfPageHeight
		lnPdfPageWidth = This.fpdf_pages_size[tnPageIndex,1]
		lnPdfPageHeight = This.fpdf_pages_size[tnPageIndex,2]
		
		LOCAL lnPageWidth, lnPageHeight
		lnPageWidth = INT(lnPdfPageWidth * This.ScreenDpiX / This.PdfDpi)
		lnPageHeight = INT(lnPdfPageHeight * This.ScreenDpiY / This.PdfDpi)
		
		DO CASE
		
		 CASE m.tnPosition = 1
		    RETURN lnPdfPageWidth
		
		 CASE m.tnPosition = 2
		    RETURN lnPdfPageHeight
		
		 CASE m.tnPosition = 3
		    RETURN lnPageWidth
		    
		 CASE m.tnPosition = 4
		    RETURN lnPageHeight
		
		 CASE m.tnPosition = 5
		    RETURN lnPdfPageWidth / EVL(lnPdfPageHeight,1)
		
		ENDCASE
		
		RETURN 0
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toConf as pdfiumviewer_conf of pdfium-vfp
		
		This.configure(m.toConf)
		
		IF VARTYPE(This.System)<>"O"
		    This.errMsg(TEXTMERGE("<<This.Class>>.System: GDIPlusX System object wasn't found. It must be passed through <<This.Class>>.Init toConf parameter or as _SCREEN.System"))
		    RETURN
		ENDIF
		
		IF FILE(This.pdfium_dll_path,1)=.F.
		    This.errMsg(TEXTMERGE("<<This.Class>>.pdfium_dll_path: File <<This.pdfium_dll_path>> does not exist"))
		    RETURN
		ENDIF
		
		*********************************************************
		This.BorderWidth = 0
		
		
		*********************************************************
		This.declaredll_ok = .F.
		LOCAL loErr
		loErr = .F.
		TRY
		    This.declaredll()
		
		    IF PEMSTATUS(Application, "pdfium_instance_count", 5)=.F.
		        ADDPROPERTY(Application, "pdfium_instance_count", 0)
		    ENDIF
		
		    IF Application.pdfium_instance_count = 0
		        LOCAL lcConfig
		        lcConfig = REPLICATE(CHR(0),24)
		        lcConfig = STUFF(lcConfig, 1,4, BINTOC(2, "4RS"))
		
		        FPDF_InitLibraryWithConfig(@lcConfig)
		    ENDIF
		    Application.pdfium_instance_count = Application.pdfium_instance_count + 1
		
		    This.declaredll_ok = .T.
		
		CATCH TO loErr
		    This.errMsg(loErr)
		ENDTRY
		
		IF This.declaredll_ok = .F.
		    RETURN
		ENDIF
		
		
		*********************************************************
		IF This.WndCreate() = .F.
		    RETURN
		ENDIF
		
		LOCAL loSelectionColor
		loSelectionColor = This.System.Drawing.Color.New(This.System.Drawing.Color.SteelBlue.ToArgb())
		loSelectionColor.A = 72
		This.SelectionBrush = This.System.Drawing.SolidBrush.New(loSelectionColor)
		
		LOCAL loBackColor
		loBackColor = This.System.Drawing.Color.FromRgb(This.BackColor)
		This.BackColorBrush = This.System.Drawing.SolidBrush.New(loBackColor)
		
		*********************************************************
		This.Resize()
		This.WndShow()
		
	ENDPROC

	PROCEDURE keypress		&& Occurs when the user presses and releases a key.
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		#define KEY_LEFT_ARROW 19
		#define KEY_RIGHT_ARROW 4
		#define KEY_UP_ARROW 5
		#define KEY_DOWN_ARROW 24
		#define KEY_PAGE_UP 18
		#define KEY_PAGE_DOWN 3
		#define KEY_HOME 1
		#define KEY_END 6
		
		
		DO CASE
		
		 CASE This.fpdf_opened = .F.
		 
		 CASE This.UIState.GetEffectivelyVisible() = .F.
		
		 CASE This.UIState.GetEffectivelyEnabled() = .F. 
		 
		 CASE m.nKeyCode = KEY_LEFT_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollHorz(-0.05 * This.Width, .F., .T.)
		
		 CASE m.nKeyCode = KEY_RIGHT_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollHorz(0.05 * This.Width, .F., .T.)
		
		 CASE m.nKeyCode = KEY_UP_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(-0.05 * This.Height, .F., .T.)
		
		 CASE m.nKeyCode = KEY_DOWN_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(0.05 * This.Height, .F., .T.)
		
		 CASE m.nKeyCode = KEY_PAGE_UP AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(-1, .T., .T.)
		
		 CASE m.nKeyCode = KEY_PAGE_DOWN AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(1, .T., .T.)
		
		 CASE m.nKeyCode = KEY_HOME AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(1, .T., .F.)
		
		 CASE m.nKeyCode = KEY_END AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(This.fpdf_pagecount, .T., .F.)
		
		 CASE m.nKeyCode = 3 AND m.nShiftAltCtrl = 2
		    NODEFAULT
		    This.SelectionCopy()
		    
		ENDCASE
		
		
	ENDPROC

	HIDDEN PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		This.SelectionCharIndexStart = 0
		
		IF m.nButton <> 1
		    RETURN 
		ENDIF
		
		
		LOCAL lnMouseX, lnMouseY
		lnMouseX = m.nXCoord
		lnMouseY = m.nYCoord
		
		LOCAL llDblClick, llTplClick
		llDblClick = .F.
		llTplClick = .F.
		
		********************************************************************
		LOCAL lnTick
		lnTick = WinApi_GetTickCount()
		lnTick = IIF(lnTick < 0, 0x80000000 + BITCLEAR(lnTick,31), lnTick)
		
		DO CASE 
		
		 CASE This.DblClickBegin = 0 AND This.TplClickBegin = 0
		    This.DblClickBegin = -lnTick
		    This.TplClickBegin = -lnTick
		
		 CASE This.DblClickBegin < 0
		    This.DblClickBegin = -This.DblClickBegin
		    
		    IF ABS(lnTick - This.DblClickBegin)/1000 <= _DBLCLICK
		        llDblClick = .T.
		        This.DblClickBegin = 0
		    ELSE
		        This.DblClickBegin = -lnTick
		        This.TplClickBegin = -lnTick
		    ENDIF
		
		 CASE This.TplClickBegin < 0
		    This.TplClickBegin = -This.TplClickBegin
		    IF ABS(lnTick - This.TplClickBegin)/1000 <= _DBLCLICK 
		        llTplClick = .T.
		        This.DblClickBegin = 0
		        This.TplClickBegin = 0
		    ELSE
		        This.DblClickBegin = -lnTick
		        This.TplClickBegin = -lnTick
		    ENDIF
		
		ENDCASE
		
		
		********************************************************************
		LOCAL lnPage, lnFPDF_Page, lnFPDF_Text_Page
		lnPage = This.PagePick(lnMouseX, lnMouseY)
		
		IF EMPTY(lnPage) = .T.
		    RETURN
		ENDIF
		
		lnFPDF_Page = This.fpdf_pages[lnPage]
		lnFPDF_Text_Page = This.fpdf_text_pages[lnPage]
		
		LOCAL lnPageX as Double, lnPageY as Double
		STORE 0 TO lnPageX, lnPageY
		
		IF FPDF_DeviceToPage(lnFPDF_Page, This.fpdf_pages_pos[lnPage,1], This.fpdf_pages_pos[lnPage,2], This.fpdf_pages_pos[lnPage,3], This.fpdf_pages_pos[lnPage,4], 0, lnMouseX, lnMouseY, @lnPageX, @lnPageY) <> 1
		    RETURN
		ENDIF
		
		
		********************************************************************
		LOCAL lnCharIndexStart
		lnCharIndexStart = FPDFText_GetCharIndexAtPos(lnFPDF_Text_Page, lnPageX, lnPageY, 10, 0)
		
		IF lnCharIndexStart > 0
		    This.SelectionCharIndexStart = lnCharIndexStart
		ENDIF
		
		IF lnCharIndexStart < 0
		    * TEXT MISCLICK
		    This.SelectText()
		    RETURN
		ENDIF
		
		
		IF llDblClick = .F. AND llTplClick = .F.
		    * TEXT SINGLE CLICK
		    This.SelectText()
		    RETURN
		ENDIF
		
		
		********************************************************************
		* TEXT DOUBLE CLICK, TRIPLE CLICK
		********************************************************************
		
		LOCAL lnCharCountMax
		lnCharCountMax = FPDFText_CountChars(lnFPDF_Text_Page)
		IF lnCharCountMax < 0
		    RETURN
		ENDIF
		
		LOCAL lnCharCount
		lnCharCount = 1
		
		LOCAL lnCharIndexLeft
		lnCharIndexLeft = lnCharIndexStart
		
		DO WHILE lnCharIndexLeft > 0
		    LOCAL lcChar
		    lcChar = LEFT(STRCONV(STRCONV(BINTOC(FPDFText_GetUnicode(lnFPDF_Text_Page, lnCharIndexLeft-1), "4RS"),6),2),1)
		    
		    IF INLIST(lcChar, CHR(10),CHR(13))
		        EXIT
		    ENDIF
		    
		    IF EMPTY(lcChar) AND llTplClick = .F.
		        EXIT
		    ENDIF
		    
		    lnCharIndexLeft = lnCharIndexLeft - 1
		    lnCharCount = lnCharCount + 1
		ENDDO
		
		
		DO WHILE lnCharIndexLeft + lnCharCount < lnCharCountMax
		    LOCAL lcChar
		    lcChar = LEFT(STRCONV(STRCONV(BINTOC(FPDFText_GetUnicode(lnFPDF_Text_Page, lnCharIndexLeft + lnCharCount), "4RS"),6),2),1)
		
		    IF INLIST(lcChar, CHR(10),CHR(13))
		        EXIT
		    ENDIF
		
		    IF EMPTY(lcChar) AND llTplClick = .F.
		        EXIT
		    ENDIF
		
		    lnCharCount = lnCharCount + 1
		ENDDO
		
		
		This.SelectText(lnPage, lnCharIndexLeft, lnCharCount)
		
		
	ENDPROC

	HIDDEN PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		LOCAL lnMouseX, lnMouseY
		lnMouseX = m.nXCoord
		lnMouseY = m.nYCoord
		
		LOCAL lnPage, lnFPDF_Page, lnFPDF_Text_Page
		lnPage = This.PagePick(lnMouseX, lnMouseY)
		IF EMPTY(lnPage)
		    RETURN
		ENDIF
		
		lnFPDF_Page = This.fpdf_pages[lnPage]
		lnFPDF_Text_Page = This.fpdf_text_pages[lnPage]
		
		LOCAL lnPageX as Double, lnPageY as Double
		STORE 0 TO lnPageX, lnPageY
		
		IF FPDF_DeviceToPage(lnFPDF_Page, This.fpdf_pages_pos[lnPage,1], This.fpdf_pages_pos[lnPage,2], This.fpdf_pages_pos[lnPage,3], This.fpdf_pages_pos[lnPage,4], 0, lnMouseX, lnMouseY, @lnPageX, @lnPageY) <> 1
		    RETURN
		ENDIF
		
		LOCAL lnCharIndex
		lnCharIndex = FPDFText_GetCharIndexAtPos(lnFPDF_Text_Page, lnPageX, lnPageY, 10, 0)
		
		DO CASE
		 CASE lnCharIndex >= 0
		    This.MousePointer = 3
		    
		    IF m.nButton = 1 AND lnCharIndex <> This.SelectionCharindexPrev
		        This.selecttext(lnPage, MIN(This.SelectionCharIndexStart,lnCharIndex), ABS(lnCharIndex-This.SelectionCharIndexStart)+1)
		    ENDIF
		    
		 OTHERWISE
		    This.MousePointer = 0
		ENDCASE
		
		This.SelectionCharindexPrev = lnCharIndex
		
	ENDPROC

	HIDDEN PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		IF m.nButton = 2
		    This.contextmenu()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE MouseWheel
		LPARAMETERS nDirection, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		DO CASE
		 CASE EVL(m.nShift,0)=2
		     This.scale = This.scale + (SIGN(m.nDirection) * 0.1)
		 
		 CASE EVL(m.nShift,0)=0
		    This.ScrollVert(-0.05 * This.Height * m.nDirection/120, .F., .T.)
		
		ENDCASE
		
	ENDPROC

	PROCEDURE openpdf		&& Open pdf file. Returns: .T. on success, .F. if file was not loaded
		LPARAMETERS tcFilename
		
		IF This.declaredll_ok = .F.
		    RETURN
		ENDIF
		
		This.closepdf()
		
		LOCAL lcFilename
		lcFilename = ALLTRIM(EVL(NVL(m.tcFilename,""),""))
		
		IF EMPTY(lcFilename)
		    RETURN .F.
		ENDIF
		
		IF FILE(lcFilename,1)=.F.
		    This.errMsg(TEXTMERGE("File <<FULLPATH(lcFilename)>> not found"))
		    RETURN .F.
		ENDIF    
		
		This.fpdf_doc = FPDF_LoadDocument(lcFilename, "")
		
		IF EMPTY(This.fpdf_doc)
		    RETURN .F.
		ENDIF
		
		This.fpdf_pagecount = FPDF_GetPageCount(This.fpdf_doc)
		
		IF This.fpdf_pagecount > 0
		    DIMENSION This.fpdf_pages(This.fpdf_pagecount)
		    DIMENSION This.fpdf_text_pages(This.fpdf_pagecount)
		    DIMENSION This.fpdf_pages_selection(This.fpdf_pagecount,3)
		    DIMENSION This.fpdf_pages_pos(This.fpdf_pagecount,4)
		    DIMENSION This.fpdf_pages_size(This.fpdf_pagecount,2)
		    STORE 0 TO This.fpdf_pages, This.fpdf_text_pages, This.fpdf_pages_pos, This.fpdf_pages_size
		    
		    DIMENSION This.fpdf_pages_render_cache(This.fpdf_pagecount,4) && Max 4 rendered samples for page
		    STORE .F. TO This.fpdf_pages_render_cache
		ENDIF
		
		LOCAL lnPage
		FOR lnPage = 1 TO This.FPDF_PageCount
		    This.fpdf_pages[lnPage] = FPDF_LoadPage(This.FPDF_Doc, lnPage-1)
		    
		    This.fpdf_text_pages[lnPage] = FPDFText_LoadPage(This.fpdf_pages[lnPage])
		    
		    This.fpdf_pages_selection[lnPage,1] = ""
		    This.fpdf_pages_selection[lnPage,2] = 0
		    This.fpdf_pages_selection[lnPage,3] = 0
		    
		    
		    This.fpdf_pages_size[lnPage,1] = FPDF_GetPageWidthF(This.fpdf_pages[lnPage])
		    This.fpdf_pages_size[lnPage,2] = FPDF_GetPageHeightF(This.fpdf_pages[lnPage])
		ENDFOR
		
		This.ViewPortUpdate()
		
		This.fpdf_opened = .T.
		
		This.WndRedraw()
		
		
	ENDPROC

	HIDDEN PROCEDURE pagepick
		LPARAMETERS lnCoordX, lnCoordY
		
		* lnCoordX, lnCoordY coordinates in the control space (0,0) is top left corner of the control
		
		IF This.fpdf_opened = .F.
		    RETURN 0
		ENDIF
		
		IF This.fpdf_page_first_visible = 0
		    RETURN 0
		ENDIF
		
		
		LOCAL lnPage, lnPageFound
		lnPageFound = 0
		FOR lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		    DO CASE
		     CASE BETWEEN(lnCoordX, This.fpdf_pages_pos[lnPage,1], This.fpdf_pages_pos[lnPage,1] + This.fpdf_pages_pos[lnPage,3]) = .F.
		         LOOP
		     CASE BETWEEN(lnCoordY, This.fpdf_pages_pos[lnPage,2], This.fpdf_pages_pos[lnPage,2] + This.fpdf_pages_pos[lnPage,4]) = .F.
		         LOOP
		     OTHERWISE
		        lnPageFound = lnPage
		        EXIT
		    ENDCASE
		ENDFOR
		
		RETURN lnPageFound
		
	ENDPROC

	HIDDEN PROCEDURE redraw
		LPARAMETERS tnWndDC
		
		LOCAL lnWndDC
		lnWndDC = EVL(m.tnWndDC, This.WndDC)
		
		IF EMPTY(lnWndDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDIB)
		    RETURN
		ENDIF
		
		IF VARTYPE(This.DrawBufGfx)<>"O"
		    RETURN
		ENDIF
		
		IF This.UIState.GetEffectivelyVisible() = .F.
		    RETURN
		ENDIF
		
		
		
		LOCAL lnWidth, lnHeight
		lnWidth = This.Width
		lnHeight = This.Height
		
		******************************************************************************
		LOCAL loGfx
		loGfx = This.DrawBufGfx
		loGfx.FillRectangle(This.BackColorBrush, 0,0, lnWidth, lnHeight)
		
		This.renderpages()
		
		loGfx.Flush()
		
		******************************************************************************
		#define FF_SRCCOPY 0x00CC0020
		
		WinApi_BitBlt(lnWndDC, 0,0, lnWidth, lnHeight, This.DrawBufDC, 0, 0, FF_SRCCOPY)
		
	ENDPROC

	HIDDEN PROCEDURE renderpagefromcache
		LPARAMETERS lnPageIndex, lnPageScale
		
		IF EMPTY(This.WndDC)
		    RETURN .F.
		ENDIF
		
		lnPageScale = EVL(lnPageScale,1)
		lnPageScale = MIN(lnPageScale, ALEN(This.fpdf_pages_render_cache,2))
		
		**********************************************************************
		IF VARTYPE(This.fpdf_pages_render_cache[lnPageIndex,lnPageScale]) = "O"
		    RETURN This.fpdf_pages_render_cache[lnPageIndex, lnPageScale]
		ENDIF
		**********************************************************************
		
		
		#DEFINE FF_RGBQUAD_SIZE     4
		#DEFINE FF_DIB_RGB_COLORS   0
		#DEFINE FF_BFHDR_SIZE      14
		#DEFINE FF_BHDR_SIZE       40
		#DEFINE FF_BI_RGB           0
		
		LOCAL lhPageDC
		lhPageDC = WinApi_CreateCompatibleDC(This.WndDC)
		
		IF EMPTY(lhPageDC)
		    RETURN .F.
		ENDIF
		
		
		LOCAL lnPageWidth, lnPageHeight
		lnPageWidth = lnPageScale * This.GetPageSize(lnPageIndex,3)
		lnPageHeight = lnPageScale * This.GetPageSize(lnPageIndex,4)
		
		
		LOCAL lnBitsPerPixel
		lnBitsPerPixel = 16
		
		LOCAL lcBMI
		lcBMI = BINTOC(FF_BHDR_SIZE ,"4RS") + BINTOC(lnPageWidth,"4RS") + BINTOC(lnPageHeight, "4RS") + ;
		        (CHR(MOD(1,256)) + CHR(INT(1/256))) + (CHR(MOD(lnBitsPerPixel,256))+ CHR(INT(lnBitsPerPixel/256))) +;
		        BINTOC(FF_BI_RGB, "4RS") + REPLICATE(0h00, 20)
		
		
		LOCAL lnDibDataPtr
		lnDibDataPtr = 0
		
		LOCAL lhPageDIB
		lhPageDIB = WinApi_CreateDIBSection(lhPageDC, @lcBMI, FF_DIB_RGB_COLORS, @lnDibDataPtr, 0, 0)
		
		IF EMPTY(lhPageDIB)=.T.
		    WinApi_DeleteDC(lhPageDC)
		    RETURN .F.
		ENDIF
		
		WinApi_SelectObject(lhPageDC, lhPageDIB)
		
		LOCAL loGfx
		loGfx = This.System.Drawing.Graphics.FromHDC(lhPageDC)
		loGfx.FillRectangle(This.System.Drawing.Brushes.White, 0, 0, lnPageWidth, lnPageHeight)
		
		LOCAL lnFPDF_Page 
		lnFPDF_Page = This.fpdf_pages[lnPageIndex]
		
		FPDF_RenderPage(lhPageDC, lnFPDF_Page, 0, 0, lnPageWidth, lnPageHeight, 0, 0)
		
		LOCAL loBmp
		loBmp = This.System.Drawing.Bitmap.FromHbitmap(lhPageDIB)
		
		WinApi_DeleteObject(lhPageDIB)
		WinApi_DeleteDC(lhPageDC)
		
		**********************************************************************
		LOCAL loStream
		loStream = This.System.IO.MemoryStream.New()
		
		loBmp.Save(loStream, This.System.Drawing.Imaging.ImageFormat.Png)
		
		LOCAL loPng
		loPng = This.System.Drawing.Image.FromStream(loStream)
		
		This.fpdf_pages_render_cache[lnPageIndex, lnPageScale] = loPng
		
		RETURN loPng
		
		
	ENDPROC

	HIDDEN PROCEDURE renderpages
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.fpdf_page_first_visible)
		    RETURN
		ENDIF
		
		LOCAL lnPageWidthUnscaled, lnPageHeightUnscaled
		LOCAL lnPageX, lnPageY
		LOCAL lnPageWidth, lnPageHeight
		LOCAL lnPageRenderScale
		
		LOCAL lnPage
		FOR lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		    lnPageWidthUnscaled = This.GetPageSize(lnPage,3)
		    lnPageHeightUnscaled = This.GetPageSize(lnPage,4)
		
		    lnPageX = This.fpdf_pages_pos[lnPage,1]
		    lnPageY = This.fpdf_pages_pos[lnPage,2]
		    lnPageWidth = This.fpdf_pages_pos[lnPage,3]
		    lnPageHeight = This.fpdf_pages_pos[lnPage,4]
		
		
		    lnPageRenderScale = MAX(CEILING(lnPageWidth / EVL(lnPageWidthUnscaled,lnPageWidth)),1)
		    lnPageRenderScale = MIN(lnPageRenderScale, ALEN(This.fpdf_pages_render_cache,2))
		    
		    LOCAL loPng
		    loPng = This.RenderPageFromCache(lnPage, lnPageRenderScale)
		    
		    IF VARTYPE(loPng)="O"
		        This.DrawBufGfx.DrawImage(loPng, lnPageX, lnPageY, lnPageWidth, lnPageHeight)
		        This.RenderSelection(lnPage)
		    ENDIF
		    
		ENDFOR
		
		
	ENDPROC

	HIDDEN PROCEDURE renderselection
		LPARAMETERS lnPage
		
		LOCAL loGfx
		loGfx = This.DrawBufGfx
		
		LOCAL lnRectCount
		lnRectCount = LEN(This.fpdf_pages_selection[lnPage,1])/32
		
		LOCAL lnRect, lcRect
		FOR lnRect = 1 TO lnRectCount
		    
		    lcRect = SUBSTR(This.fpdf_pages_selection[lnPage,1], 32*(lnRect-1) + 1, 32)
		    
		    LOCAL lnPageLeft,lnPageTop,lnPageRight,lnPageBottom
		    lnPageLeft = CTOBIN(SUBSTR(lcRect,1,8),"B")
		    lnPageTop = CTOBIN(SUBSTR(lcRect,9,8),"B")
		    lnPageRight = CTOBIN(SUBSTR(lcRect,17,8),"B")
		    lnPageBottom = CTOBIN(SUBSTR(lcRect,25,8),"B")
		    
		       
		    LOCAL lnLeft, lnTop, lnRight, lnBottom
		    STORE 0 TO lnLeft, lnTop, lnRight, lnBottom
		    
		    IF FPDF_PageToDevice(This.FPDF_PAGES[lnPage], This.fpdf_pages_pos[lnPage,1], This.fpdf_pages_pos[lnPage,2], This.fpdf_pages_pos[lnPage,3], This.fpdf_pages_pos[lnPage,4], 0, lnPageLeft, lnPageTop, @lnLeft, @lnTop) = 0
		        LOOP
		    ENDIF
		    
		    IF FPDF_PageToDevice(This.FPDF_PAGES[lnPage], This.fpdf_pages_pos[lnPage,1], This.fpdf_pages_pos[lnPage,2], This.fpdf_pages_pos[lnPage,3], This.fpdf_pages_pos[lnPage,4], 0, lnPageRight, lnPageBottom, @lnRight, @lnBottom) = 0
		        LOOP
		    ENDIF
		    
		    loGfx.FillRectangle(This.SelectionBrush, lnLeft, lnTop, lnRight - lnLeft, lnBottom - lnTop)
		ENDFOR
		
	ENDPROC

	HIDDEN PROCEDURE Resize
		This.WndResize()
		
	ENDPROC

	HIDDEN PROCEDURE scale_assign
		LPARAMETERS vNewVal
		
		This.scale = MIN(MAX(EVL(NVL(m.vNewVal,0),0),0.2),4)
		
		IF This.scale <= 1
		    This.ViewPortX = 0
		ENDIF    
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.wndredraw()
		ENDIF    
		
	ENDPROC

	HIDDEN PROCEDURE scrollbars_assign
		LPARAMETERS vNewVal
		
		This.ScrollBars = IIF(INLIST(m.vNewVal, 0,1,2,3), m.vNewVal, This.ScrollBars)
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
	ENDPROC

	HIDDEN PROCEDURE scrollhorz
		LPARAMETERS tnScroll, tlPage, tlRelative
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		DO CASE
		 CASE m.tlPage=.F. AND m.tlRelative = .T.
		    This.ViewPortX = This.ViewPortX + m.tnScroll
		
		 CASE m.tlPage=.T. AND m.tlRelative = .T.
		    This.ViewPortX = This.ViewPortX + m.tnScroll * This.ViewPortSizeX
		    
		 CASE m.tlPage=.F. AND m.tlRelative = .F.
		    This.ViewPortX = m.tnScroll
		
		ENDCASE
		
		IF This.ViewPortMaxX > This.ViewPortSizeX
		    This.ViewPortX = MIN(MAX(-0.5 * (This.ViewPortMaxX - This.ViewPortSizeX), This.ViewPortX), MAX(0.5 * (This.ViewPortMaxX - This.ViewPortSizeX),0))
		ELSE
		    This.ViewPortX = 0
		ENDIF        
		
		This.ViewPortUpdate()
		
		This.WndRedraw()
		
	ENDPROC

	HIDDEN PROCEDURE scrollvert
		LPARAMETERS tnScroll, tlPage, tlRelative
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		DO CASE
		 CASE m.tlPage=.F. AND m.tlRelative = .T.
		    This.ViewPortY = This.ViewPortY + m.tnScroll
		
		 CASE m.tlPage=.T. AND m.tlRelative = .T.
		    This.ViewPortY = This.ViewPortY + This.fpdf_pages_pos[MIN(MAX(This.fpdf_page_first_visible + m.tnScroll,1), This.fpdf_pagecount), 2]
		    
		 CASE  m.tlPage=.F. AND m.tlRelative = .F.
		    This.ViewPortY = m.tnScroll
		
		 CASE m.tlPage=.T. AND m.tlRelative = .F.
		    This.ViewPortY = This.ViewPortY + This.fpdf_pages_pos[MIN(MAX(m.tnScroll,1), This.fpdf_pagecount), 2]
		
		ENDCASE
		
		This.ViewPortY = MIN(MAX(This.ViewPortY,0), MAX(This.ViewPortMaxY - This.Height,0))
		
		This.ViewPortUpdate()
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE selectioncopy		&& Copy selected text to clipboard
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		#define CF_TEXT       1
		#define CF_UNICODETEXT 13
		#DEFINE CF_LOCALE     16
		#define GMEM_MOVEABLE 0x0002
		#define GMEM_ZEROINIT 0x0040
		
		
		LOCAL lcCopyText
		lcCopyText = ""
		
		LOCAL lnPage, lnFPDF_TEXT_PAGE, lnSelStart, lnSelCount
		FOR lnPage = 1 TO This.fpdf_pagecount
		
		    lnFPDF_TEXT_PAGE = This.FPDF_TEXT_PAGES[lnPage]
		    lnSelStart = EVL(This.fpdf_pages_selection[lnPage,2],0)
		    lnSelCount = EVL(This.fpdf_pages_selection[lnPage,3],0)
		    
		    IF lnSelCount = 0
		        LOOP
		    ENDIF
		    
		    LOCAL lcBuffer, lnBufLen
		    lcBuffer = REPLICATE(CHR(0), lnSelCount * 2)
		    lnBufLen = FPDFText_GetText(lnFPDF_TEXT_PAGE, lnSelStart, lnSelCount, @lcBuffer)
		    
		    IF lnBufLen > 0
		        lcCopyText = lcCopyText + lcBuffer
		    ENDIF
		
		ENDFOR
		
		IF EMPTY(lcCopyText)=.F.
		    
		    LOCAL lnCopyTextLen
		    lnCopyTextLen = LEN(lcCopyText)
		
		    LOCAL lnDefaultLocaleID
		    lnDefaultLocaleID = EVL(WinApi_GetSystemDefaultLCID(), 1033) &&English LocaleID = 1033
		
		    IF WinApi_OpenClipboard(0) = 0
		        RETURN
		    ENDIF
		    
		    WinApi_EmptyClipboard()
		
		    LOCAL lnMemHandle
		    lnMemHandle = WinApi_GlobalAlloc(GMEM_MOVEABLE + GMEM_ZEROINIT, lnCopyTextLen+2)
		    
		    IF lnMemHandle <> 0
		        LOCAL lnMemPtr
		        lnMemPtr = WinApi_GlobalLock(lnMemHandle)
		        IF lnMemPtr <> 0
		            SYS(2600, lnMemPtr, lnCopyTextLen, lcCopyText)
		        ENDIF
		        WinApi_GlobalUnlock(lnMemHandle)
		        
		        WinApi_SetClipboardData(CF_UNICODETEXT, lnMemHandle)
		        
		        WinAPI_GlobalFree(lnMemHandle)
		    ENDIF
		
		
		    LOCAL lnMemHandle
		    lnMemHandle = WinApi_GlobalAlloc(GMEM_MOVEABLE + GMEM_ZEROINIT, 4)
		    IF lnMemHandle <> 0
		        LOCAL lnMemPtr
		        lnMemPtr = WinApi_GlobalLock(lnMemHandle)
		        IF lnMemPtr <> 0
		            SYS(2600, lnMemPtr, 4, BINTOC(lnDefaultLocaleID, "4RS"))
		        ENDIF
		        WinApi_GlobalUnlock(lnMemHandle)
		        
		        WinApi_SetClipboardData(CF_LOCALE, lnMemHandle)
		        
		        WinAPI_GlobalFree(lnMemHandle)
		    ENDIF
		
		    WinApi_CloseClipboard()
		
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE selecttext
		LPARAMETERS tnPage, tnStartIndex, tnCount
		
		* tnPage - page index, from 1 to This.fpdf_pagecount, 0 for all pages
		* tnStartIndex - Index for the start character (zero-based)
		* tnCount - Number of characters, or -1 for all remaining.
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL lnPage, lnStartIndex, lnCount
		lnPage = EVL(m.tnPage,0)
		lnStartIndex = EVL(m.tnStartIndex,0)
		lnCount = EVL(m.tnCount, 0)
		
		IF lnStartIndex < 0
		    RETURN
		ENDIF
		IF lnCount < -1
		    RETURN
		ENDIF
		
		
		LOCAL lnPageStart, lnPageEnd
		lnPageStart = EVL(lnPage,1)
		lnPageEnd = EVL(lnPage,This.fpdf_pagecount)
		
		FOR lnPage = lnPageStart TO lnPageEnd
		    LOCAL lnFPDF_Text_Page
		    lnFPDF_Text_Page = This.fpdf_text_pages[lnPage]
		
		    LOCAL lnCountChars
		    DO CASE
		     CASE lnCount = 0
		        lnCountChars = 0
		         
		     CASE lnCount = -1
		        lnCountChars = MAX(FPDFText_CountChars(lnFPDF_Text_Page) - lnStartIndex,0)
		
		     CASE FPDFText_CountChars(lnFPDF_Text_Page) >= lnStartIndex + lnCount
		        lnCountChars = lnCount
		
		     OTHERWISE
		        lnCountChars = 0
		
		    ENDCASE
		    
		    LOCAL lnRectCount
		    IF lnCountChars > 0
		        lnRectCount = FPDFText_CountRects(lnFPDF_Text_Page, lnStartIndex, lnCountChars)
		    ELSE
		        lnRectCount = 0
		    ENDIF
		
		    IF lnRectCount > 0 
		        This.fpdf_pages_selection[lnPage,1] = ""
		        This.fpdf_pages_selection[lnPage,2] = lnStartIndex
		        This.fpdf_pages_selection[lnPage,3] = lnCountChars
		
		        LOCAL lnPageLeft as Double, lnPageRight as Double, lnPageBottom as Double, lnPageTop as Double
		        STORE 0 TO lnPageLeft, lnPageRight, lnPageBottom, lnPageTop
		
		        LOCAL lnRect
		        FOR lnRect=1 TO lnRectCount
		            IF FPDFText_GetRect(lnFPDF_Text_Page, lnRect-1, @lnPageLeft, @lnPageTop, @lnPageRight, @lnPageBottom) > 0
		                This.fpdf_pages_selection[lnPage,1] = This.fpdf_pages_selection[lnPage,1] + BINTOC(lnPageLeft,"8")+BINTOC(lnPageTop,"8")+BINTOC(lnPageRight,"8")+BINTOC(lnPageBottom,"8")
		            ENDIF
		        ENDFOR
		    ELSE
		        This.fpdf_pages_selection[lnPage,1] = ""
		        This.fpdf_pages_selection[lnPage,2] = 0
		        This.fpdf_pages_selection[lnPage,3] = 0
		    ENDIF
		    
		ENDFOR
		
		This.Redraw()
		
	ENDPROC

	PROCEDURE selecttextall
		This.SelectText(0,0,-1)
		
	ENDPROC

	HIDDEN PROCEDURE viewportupdate
		This.fpdf_page_first_visible = 0
		This.fpdf_page_last_visible = 0
		
		This.ViewPortSizeX = MAX(This.Width - IIF(INLIST(This.ScrollBars,1,3), SYSMETRIC(8),0), 0)
		This.ViewPortSizeY = MAX(This.Height - IIF(INLIST(This.ScrollBars,2,3), SYSMETRIC(5),0), 0)
		
		LOCAL lnViewPortMaxXNew
		lnViewPortMaxXNew = 0
		
		
		*********************************************************************
		LOCAL lnPageX, lnPageY
		STORE 0 TO lnPageX, lnPageY
		
		LOCAL lnPageWidthUnscaled, lnPageHeightUnscaled
		LOCAL lnPageWidth, lnPageHeight
		LOCAL lnPageRenderScale
		
		LOCAL lnPageCount, lnPage
		lnPageCount = This.FPDF_PageCount
		
		FOR lnPage = 1 TO lnPageCount
		    
		    lnPageWidthUnscaled = This.GetPageSize(lnPage,3)
		    lnPageHeightUnscaled = This.GetPageSize(lnPage,4)
		
		    lnPageWidth = lnPageWidthUnscaled
		    lnPageHeight = lnPageHeightUnscaled
		
		    lnPageWidth = This.ViewPortSizeX
		    lnPageHeight = INT(lnPageHeight * lnPageWidth / EVL(lnPageWidthUnscaled,1))
		    
		    lnPageWidth = lnPageWidth * This.scale
		    lnPageHeight = lnPageHeight * This.scale    
		    
		    lnPageX = (This.ViewPortSizeX - lnPageWidth) * 0.5
		    
		    IF lnPage > 1
		        lnPageY = lnPageY +  MIN(MAX(INT(lnPageWidth * 0.02),5),40) &&page separator
		    ENDIF
		    
		    This.fpdf_pages_pos[lnPage,1] = lnPageX - This.ViewPortX
		    This.fpdf_pages_pos[lnPage,2] = lnPageY - This.ViewPortY
		
		    This.fpdf_pages_pos[lnPage,3] = lnPageWidth
		    This.fpdf_pages_pos[lnPage,4] = lnPageHeight
		   
		    DO CASE
		     CASE This.Width < 30
		     CASE lnPageY + lnPageHeight < This.ViewPortY
		     CASE lnPageY > This.ViewPortY + This.ViewPortSizeY
		     OTHERWISE
		
		        IF This.fpdf_page_first_visible = 0
		            This.fpdf_page_first_visible = lnPage
		        ENDIF
		        
		        This.fpdf_page_last_visible = lnPage
		        
		    ENDCASE
		    
		  
		    lnPageY = lnPageY + lnPageHeight
		    
		    lnViewPortMaxXNew = MAX(lnViewPortMaxXNew, lnPageWidth)
		    
		ENDFOR
		
		
		*********************************************************************
		LOCAL lnViewPortMaxYNew
		lnViewPortMaxYNew = lnPageY
		
		IF This.ViewPortMaxY > 0
		    This.ViewPortY = INT(This.ViewPortY * lnViewPortMaxYNew * 10000 / This.ViewPortMaxY) / 10000
		ENDIF
		
		This.ViewPortMaxY = lnViewPortMaxYNew
		
		
		*********************************************************************
		IF This.ViewPortMaxX > 0
		    This.ViewPortX = INT(This.ViewPortX * lnViewPortMaxXNew * 10000 / This.ViewPortMaxX) / 10000
		ENDIF
		
		This.ViewPortMaxX = lnViewPortMaxXNew
		
		
		
		
		*********************************************************************
		IF EMPTY(This.WndHandle)=.T.
		    RETURN
		ENDIF
		
		#define SIF_RANGE 0x0001
		#define SIF_PAGE 0x0002
		#define SIF_POS 0x0004
		#define SIF_DISABLENOSCROLL 0x0008
		
		*********************************************************************
		* Vertical scrolling setup
		
		LOCAL lnScrollMin, lnScrollMax, lnScrollPageSize, lnScrollPos
		IF INLIST(This.ScrollBars,2,3) AND This.ViewPortSizeY > 0
		    lnScrollMin = 0
		    lnScrollMax = This.ViewPortMaxY - This.ViewPortSizeY + EVL(This.fpdf_pages_pos[EVL(This.fpdf_pagecount,1),4],0)
		    lnScrollPageSize = This.ViewPortMaxY / EVL(This.fpdf_pagecount,1)
		    lnScrollPos = This.ViewPortY
		ELSE
		    lnScrollMin = 0
		    lnScrollMax = 0
		    lnScrollPageSize = 0
		    lnScrollPos = 0
		ENDIF
		
		LOCAL lcScrollInfo
		lcScrollInfo = ;
		    BINTOC(28, "4RS")+;
		    BINTOC(SIF_RANGE+SIF_PAGE+SIF_POS, "4RS")+;
		    BINTOC(lnScrollMin, "4RS")+;
		    BINTOC(lnScrollMax, "4RS")+;
		    BINTOC(lnScrollPageSize, "4RS")+;
		    BINTOC(lnScrollPos, "4RS")+;
		    BINTOC(0, "4RS")
		
		WinApi_SetScrollInfo(This.WndHandle, 1, @lcScrollInfo, 1)
		*********************************************************************
		
		*********************************************************************
		* Horizontal scrolling setup
		
		LOCAL lnScrollMin, lnScrollMax, lnScrollPageSize, lnScrollPos
		IF INLIST(This.ScrollBars,1,3) AND This.ViewPortMaxX > This.ViewPortSizeX AND This.ViewPortSizeX > 0
		    lnScrollMin = -0.5 * (This.ViewPortMaxX - This.ViewPortSizeX)
		    lnScrollMax = 0.5 * (This.ViewPortMaxX - This.ViewPortSizeX)
		    lnScrollPageSize = This.ViewPortSizeX
		    lnScrollMax = lnScrollMax + lnScrollPageSize
		    lnScrollPos = MIN(MAX(lnScrollMin, This.ViewPortX), lnScrollMax)
		ELSE
		    lnScrollMin = 0
		    lnScrollMax = 0
		    lnScrollPageSize = 0
		    lnScrollPos = 0
		ENDIF
		
		LOCAL lcScrollInfo
		lcScrollInfo = ;
		    BINTOC(28, "4RS")+;
		    BINTOC(SIF_RANGE+SIF_PAGE+SIF_POS, "4RS")+;
		    BINTOC(lnScrollMin, "4RS")+;
		    BINTOC(lnScrollMax, "4RS")+;
		    BINTOC(lnScrollPageSize, "4RS")+;
		    BINTOC(lnScrollPos, "4RS")+;
		    BINTOC(0, "4RS")
		
		WinApi_SetScrollInfo(This.WndHandle, 0, @lcScrollInfo, 1)
		*********************************************************************
		
	ENDPROC

	HIDDEN PROCEDURE wndcreate
		
		#DEFINE WNDCLASSEX_SIZE 48
		#DEFINE GW_CHILD 5
		#DEFINE GWL_WNDPROC -4
		#DEFINE GWL_HINSTANCE -6
		#DEFINE GWL_STYLE -16
		#define CS_OWNDC            0x0020
		#define CS_PARENTDC         0x0080
		#define WS_CHILD            0x40000000
		#define WS_DISABLED         0x08000000
		#define WS_VISIBLE          0x10000000
		#define WS_CLIPSIBLINGS     0x04000000
		#define WS_CLIPCHILDREN     0x02000000
		#define WS_VSCROLL          0x00200000
		#define WS_HSCROLL          0x00100000
		#define GMEM_FIXED 0x0
		#define GMEM_ZEROINIT 0x0040
		
		
		LOCAL lhWndParent
		lhWndParent = WinApi_GetWindow(Thisform.HWnd, GW_CHILD) && VFP window with scroll bars creates his own child window
		IF EMPTY(lhWndParent)=.T.
		    lhWndParent = Thisform.HWnd
		ENDIF
		
		LOCAL lhInstance
		lhInstance = WinApi_GetModuleHandle(0)
		
		
		LOCAL lcWndClassEx
		lcWndClassEx = REPLICATE(CHR(0), WNDCLASSEX_SIZE)
		
		IF EMPTY( WinApi_GetClassInfoEx(lhInstance, This.WndClassName, @lcWndClassEx) )
		
		    LOCAL lnWndClassNamePtr
		    lnWndClassNamePtr = WinApi_GlobalAlloc(GMEM_FIXED + GMEM_ZEROINIT, LEN(This.WndClassName)+1)
		
		    SYS(2600, lnWndClassNamePtr, LEN(This.WndClassName), This.WndClassName)
		
		    lcWndClassEx = ;
		        BINTOC(WNDCLASSEX_SIZE, "4RS")+; &&cbSize
		        BINTOC(CS_PARENTDC,"4RS")+; &&style
		        BINTOC(WinApi_GetWindowLong(Application.HWnd, GWL_WNDPROC),"4RS")+; &&lpfnWndProc
		        BINTOC(0,"4RS")+; &&cbClsExtra
		        BINTOC(0,"4RS")+; &&cbWndExtra
		        BINTOC(lhInstance,"4RS")+; &&hInstance
		        BINTOC(0,"4RS")+; &&hIcon
		        BINTOC(0,"4RS")+; &&hCursor
		        BINTOC(0,"4RS")+; &&hbrBackground
		        BINTOC(0,"4RS")+; &&lpszMenuName
		        BINTOC(lnWndClassNamePtr,"4RS")+; &&lpszClassName
		        BINTOC(0,"4RS") &&hIconSm
		
		    WinApi_RegisterClassEx(@lcWndClassEx)
		
		    WinApi_GlobalFree(lnWndClassNamePtr)
		    
		ENDIF
		
		
		This.WndHandle = WinApi_CreateWindowEx( ;
		    0, ;
		    This.WndClassName, ;
		    "", ;
		    WS_CHILD + WS_CLIPCHILDREN + WS_CLIPSIBLINGS + WS_HSCROLL + WS_VSCROLL, ;
		    0,0,1,1, ;
		    lhWndParent, ;
		    0, ;
		    lhInstance, ;
		    0)
		
		
		IF EMPTY(This.WndHandle)=.T.
		    This.errMsg("WinApi_CreateWindowEx returned 0")
		    RETURN
		ENDIF
		
		******************************************************
		This.WndDC = WinApi_GetDC(This.WndHandle)
		
		
		******************************************************
		#define WM_PAINT 0x000F
		BINDEVENT(This.WndHandle, WM_PAINT, This, "WndProc")
		
		#define WM_MOUSEACTIVATE 0x0021
		BINDEVENT(This.WndHandle, WM_MOUSEACTIVATE, This, "WndProc")
		
		#define WM_MOUSEMOVE 0x0200
		#define WM_LBUTTONDOWN 0x0201
		#define WM_RBUTTONUP 0x0205
		#define WM_MOUSEWHEEL 0x020A
		BINDEVENT(This.WndHandle, WM_MOUSEMOVE, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_LBUTTONDOWN, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_RBUTTONUP, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_MOUSEWHEEL, This, "WndProc")
		
		#define WM_VSCROLL 0x0115
		BINDEVENT(This.WndHandle, WM_VSCROLL, This, "WndProc")
		
		#define WM_HSCROLL 0x0114
		BINDEVENT(This.WndHandle, WM_HSCROLL, This, "WndProc")
		
		
		
	ENDPROC

	PROCEDURE wndproc		&& Events handler of PdfiumViewer internal window. Developer must not use or redefine this method
		LPARAMETERS thWnd, tnMsg, tnWParam, tnLParam
		
		#define GWL_WNDPROC -4
		#define WM_PAINT  0x000F
		#define WM_MOUSEACTIVATE 0x0021
		#define WM_VSCROLL 0x0115
		#define WM_HSCROLL 0x0114
		#define WM_MOUSEMOVE 0x0200
		#define WM_LBUTTONDOWN 0x0201
		#define WM_RBUTTONUP 0x0205
		#define WM_MOUSEWHEEL 0x020A
		#define MK_LBUTTON 0x0001
		#define MK_RBUTTON 0x0002
		#define MK_SHIFT 0x0004
		#define MK_CONTROL 0x0008
		
		
		#define SB_LINEUP           0
		#define SB_LINELEFT         0
		#define SB_LINEDOWN         1
		#define SB_LINERIGHT        1
		#define SB_PAGEUP           2
		#define SB_PAGELEFT         2
		#define SB_PAGEDOWN         3
		#define SB_PAGERIGHT        3
		#define SB_THUMBPOSITION    4
		#define SB_THUMBTRACK       5
		#define SB_TOP              6
		#define SB_LEFT             6
		#define SB_BOTTOM           7
		#define SB_RIGHT            7
		#define SB_ENDSCROLL        8
		#define SIF_TRACKPOS 0x0010
		#define SB_SCROLLINFO_TRACKPOS BINTOC(28, "4RS")+BINTOC(SIF_TRACKPOS, "4RS")+REPLICATE(CHR(0),20)
		
		
		LOCAL lnRetVal
		lnRetVal = 0
		
		DO CASE
		
		 CASE This.UIState.GetEffectivelyVisible() = .F.
		 
		 CASE m.tnMsg = WM_PAINT
		
		    LOCAL lcPaint
		    lcPaint = REPLICATE(CHR(0), 256)
		
		    LOCAL lnWndDC
		    lnWndDC = WinApi_BeginPaint(m.thWnd, @lcPaint)
		
		    This.Redraw(lnWndDC)
		
		    WinApi_EndPaint(m.thWnd, @lcPaint)
		    
		
		 CASE This.UIState.GetEffectivelyEnabled() = .F.
		 
		
		 CASE m.tnMsg = WM_MOUSEACTIVATE
		    This.SetFocus()
		
		    
		 CASE INLIST(m.tnMsg, WM_MOUSEMOVE, WM_MOUSEWHEEL, WM_LBUTTONDOWN, WM_RBUTTONUP)
		    LOCAL lnMBtn, lnMShift, lnMouseX, lnMouseY
		    lnMBtn = BITAND(m.tnWParam, MK_LBUTTON + MK_RBUTTON)
		    lnMShift = BITRSHIFT(BITAND(m.tnWParam, MK_SHIFT + MK_CONTROL),2)
		    lnMouseX = BITAND(m.tnLParam, 0xffff)
		    lnMouseY = BITAND(BITRSHIFT(m.tnLParam,16), 0xffff)
		    
		    DO CASE
		     CASE INLIST(m.tnMsg, WM_MOUSEMOVE)
		        This.MouseMove(lnMBtn, lnMShift, lnMouseX, lnMouseY)
		 
		     CASE INLIST(m.tnMsg, WM_MOUSEWHEEL)
		        LOCAL lnMWDir 
		        lnMWDir = BITAND(BITRSHIFT(m.tnWParam,16), 0xffff)
		        lnMWDir = IIF(BITTEST(lnMWDir,15), lnMWDir - 0xffff, lnMWDir)
		        
		        This.MouseWheel(lnMWDir, lnMShift, lnMouseX, lnMouseY)
		
		     CASE INLIST(m.tnMsg, WM_LBUTTONDOWN)
		        This.MouseDown(1, lnMShift, lnMouseX, lnMouseY)
		        
		     CASE INLIST(m.tnMsg, WM_RBUTTONUP)
		        This.MouseUp(2, lnMShift, lnMouseX, lnMouseY)
		
		    ENDCASE
		    
		    
		 CASE m.tnMsg = WM_VSCROLL
		
		    LOCAL lnSbReq
		    lnSbReq = BITAND(m.tnWParam, 0xffff)
		     
		    DO CASE
		     CASE lnSbReq = SB_LINEUP
		       This.ScrollVert(-0.05 * This.Height, .F., .T.)
		
		     CASE lnSbReq = SB_LINEDOWN
		       This.ScrollVert(0.05 * This.Height, .F., .T.)
		
		     CASE lnSbReq = SB_PAGEUP
		       This.ScrollVert(-1, .T., .T.)
		
		     CASE lnSbReq = SB_PAGEDOWN
		       This.ScrollVert(1, .T., .T.)
		
		     CASE lnSbReq = SB_TOP
		       This.ScrollVert(0, .F., .F.)
		
		     CASE lnSbReq = SB_BOTTOM
		       This.ScrollVert(This.ViewPortMaxY, .F., .F.)
		
		     CASE lnSbReq = SB_THUMBTRACK
		       LOCAL lcScrollInfo
		       lcScrollInfo = SB_SCROLLINFO_TRACKPOS
		
		       IF WinApi_GetScrollInfo(m.thWnd, 1, @lcScrollInfo) = 1
		           LOCAL lnSbPos
		           lnSbPos = CTOBIN(SUBSTR(lcScrollInfo,25,4),"4RS")
		           This.ScrollVert(lnSbPos)
		       ENDIF
		    ENDCASE
		
		
		 CASE m.tnMsg = WM_HSCROLL
		
		    LOCAL lnSbReq
		    lnSbReq = BITAND(m.tnWParam, 0xffff)
		     
		    DO CASE
		     CASE lnSbReq = SB_LINELEFT
		       This.ScrollHorz(-0.05 * This.Width, .F., .T.)
		
		     CASE lnSbReq = SB_LINERIGHT
		       This.ScrollHorz(0.05 * This.Width, .F., .T.)
		
		     CASE lnSbReq = SB_PAGELEFT
		       This.ScrollHorz(-1, .T., .T.)
		
		     CASE lnSbReq = SB_PAGERIGHT
		       This.ScrollHorz(1, .T., .T.)
		
		     CASE lnSbReq = SB_LEFT
		       This.ScrollHorz(-This.ViewPortMaxY, .F., .F.)
		
		     CASE lnSbReq = SB_RIGHT
		       This.ScrollHorz(This.ViewPortMaxY, .F., .F.)
		
		     CASE lnSbReq = SB_THUMBTRACK
		       LOCAL lcScrollInfo
		       lcScrollInfo = SB_SCROLLINFO_TRACKPOS
		
		       IF WinApi_GetScrollInfo(m.thWnd, 0, @lcScrollInfo) = 1
		           LOCAL lnSbPos
		           lnSbPos = CTOBIN(SUBSTR(lcScrollInfo,25,4),"4RS")
		           This.ScrollHorz(lnSbPos)
		       ENDIF
		    ENDCASE
		
		
		 OTHERWISE
		    LOCAL lnWndProcDefault
		    lnWndProcDefault = WinApi_GetWindowLong(m.thWnd, GWL_WNDPROC)
		    lnRetVal = WinApi_CallWindowProc(lnWndProcDefault, m.thWnd, m.tnMsg, m.tnWParam, m.tnLParam)
		
		ENDCASE
		
		
		RETURN lnRetVal
		
	ENDPROC

	HIDDEN PROCEDURE wndredraw
		IF EMPTY(This.WndHandle)
		    RETURN
		ENDIF
		
		WinApi_InvalidateRect(This.WndHandle, 0, 1)
		
	ENDPROC

	HIDDEN PROCEDURE wndrelease
		IF EMPTY(This.WndDC) = .F.
		    WinApi_ReleaseDC(This.WndHandle, This.WndDC)
		    This.WndDC = 0
		ENDIF
		
		IF EMPTY(This.WndHandle) = .F.
		    UNBINDEVENTS(This.WndHandle)
		    WinApi_DestroyWindow(This.WndHandle)
		    This.WndHandle = 0
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE wndresize
		IF EMPTY(This.WndHandle)
		    RETURN
		ENDIF
		
		This.ViewPortUpdate()
		
		This.DrawBufCreate()
		
		WinApi_MoveWindow(This.WndHandle, This.UIState.ObjToClient(2), This.UIState.ObjToClient(1), This.Width, This.Height, 1)
		
		This.ViewPortUpdate()
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE wndshow
		
		#define SW_HIDE 0
		#define SW_SHOWNA 8
		IF EMPTY(This.WndHandle)=.F.
		    WinApi_ShowWindow(This.WndHandle, IIF(This.UIState.GetEffectivelyVisible(), SW_SHOWNA, SW_HIDE))
		ENDIF
		
	ENDPROC

	PROCEDURE UIState.onvisible
		This.Parent.WndShow()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumviewer_cmdfocus AS commandbutton 		&& PdfiumViewer can input focus holder. Developer must not use this class directly
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: this_access
	*</DefinedPropArrayMethod>

	*<PropValue>
		Caption = ""
		Enabled = .T.
		Height = 27
		Name = "pdfiumview_cmdfocus"
		Style = 0
		Visible = .T.
		Width = 27
	*</PropValue>
	
	HIDDEN PROCEDURE this_access
		LPARAMETERS cMember
		
		RETURN This.Parent
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumviewer_conf AS custom 		&& PdfiumViewer Configuration Object. Usage: create, setup and pass as first parameter of PdfiumViewer.Init
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: pdfium_dll_path		&& Path to file pdfium.dll. Filename without path also accepted
		*p: system		&& GDIPlusX System object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,ClassLibrary,Class,CloneObject,Comment,ControlCount,Controls,Error,Height,HelpContextID,Name,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfiumviewer_conf"
		pdfium_dll_path = ("pdfium.dll")
		system = .F.
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="pdfium_dll_path" type="property" display="Pdfium_Dll_Path"/>
			<memberdata name="system" type="property" display="System"/>
		</VFPData>
	*</PropValue>

ENDDEFINE

DEFINE CLASS pdfiumviewer_i18n AS custom 		&& PdfiumViewer Internationalization Helper
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: text		&& Returns all of the text in a text-entry area of a control.
		*m: text_de
		*m: text_en
		*m: text_es
		*m: text_fr
		*m: text_ru
		*p: localeid
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,ClassLibrary,Class,CloneObject,Comment,ControlCount,Controls,Error,Height,HelpContextID,localeid,Name,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		localeid = 1033
		Name = "pdfiumviewer_i18n"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="localeid" type="property" display="LocaleID"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE Init
		DECLARE INTEGER GetSystemDefaultLCID IN WIN32API AS WinApi_GetSystemDefaultLCID
		This.LocaleID = WinApi_GetSystemDefaultLCID()
		
		
	ENDPROC

	PROCEDURE text		&& Returns all of the text in a text-entry area of a control.
		LPARAMETERS tcTxtID
		
		LOCAL lcTxtID
		lcTxtID = UPPER(ALLTRIM(EVL(NVL(m.tcTxtID,""),"")))
		
		IF EMPTY(lcTxtID)
		    RETURN ""
		ENDIF
		
		
		DO CASE 
		 CASE This.LocaleID = 1031
		    RETURN This.text_de(lcTxtID)
		
		 CASE This.LocaleID = 1033
		    RETURN This.text_en(lcTxtID)
		
		 CASE This.LocaleID = 1034
		    RETURN This.text_es(lcTxtID)
		
		 CASE This.LocaleID = 1036
		    RETURN This.text_fr(lcTxtID)
		
		 CASE This.LocaleID = 1049
		    RETURN This.text_ru(lcTxtID)
		
		 OTHERWISE
		    RETURN This.text_en(lcTxtID)
		
		ENDCASE
		
	ENDPROC

	HIDDEN PROCEDURE text_de
		LPARAMETERS tcTxtID
		
		DO CASE
		 CASE m.tcTxtID == "MNU_COPY"
		    RETURN "Kopieren"
		 
		 CASE m.tcTxtID == "MNU_SLCTA"
		    RETURN "Alles markieren"
		 
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_en
		LPARAMETERS tcTxtID
		
		DO CASE
		 CASE m.tcTxtID == "MNU_COPY"
		    RETURN "Copy"
		 
		 CASE m.tcTxtID == "MNU_SLCTA"
		    RETURN "Select all"
		 
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_es
		LPARAMETERS tcTxtID
		
		DO CASE
		 CASE m.tcTxtID == "MNU_COPY"
		    RETURN "Copiar"
		 
		 CASE m.tcTxtID == "MNU_SLCTA"
		    RETURN "Seleccionar todo"
		 
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_fr
		LPARAMETERS tcTxtID
		
		DO CASE
		 CASE m.tcTxtID == "MNU_COPY"
		    RETURN "Copier"
		 
		 CASE m.tcTxtID == "MNU_SLCTA"
		    RETURN "Slectionner tout"
		 
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_ru
		LPARAMETERS tcTxtID
		
		DO CASE
		 CASE m.tcTxtID == "MNU_COPY"
		    RETURN ""
		 
		 CASE m.tcTxtID == "MNU_SLCTA"
		    RETURN " "
		 
		ENDCASE
		
		RETURN m.tcTxtID
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumviewer_uistate AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: geteffectivelyenabled
		*m: geteffectivelyvisible
		*m: getispageframe
		*m: objtoclient
		*m: onenabled
		*m: onvisible
		*m: setstate
		*m: _onactivate
		*m: _ondeactivate
		*m: _onenabled
		*m: _onvisible
		*p: effectivelyenabled
		*p: effectivelyvisible
		*p: ispageframe
		*p: _ispagedeactivated
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,effectivelyenabled,effectivelyvisible,Error,HelpContextID,ispageframe,NewObject,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod,_ispagedeactivated
	*<PropValue>
		effectivelyenabled = .F.
		effectivelyvisible = .F.
		Height = 24
		ispageframe = .F.
		Name = "pdfiumviewer_uistate"
		Tag = ""
		Width = 37
		_ispagedeactivated = .F.
		_memberdata = <VFPData>
			<memberdata name="objtoclient" display="ObjToClient"/>
			<memberdata name="addobject" display="AddObject"/>
			<memberdata name="writemethod" display="WriteMethod"/>
			<memberdata name="writeexpression" display="WriteExpression"/>
			<memberdata name="whatsthishelpid" display="WhatsThisHelpID"/>
			<memberdata name="tag" display="Tag"/>
			<memberdata name="showwhatsthis" display="ShowWhatsThis"/>
			<memberdata name="saveasclass" display="SaveAsClass"/>
			<memberdata name="resettodefault" display="ResetToDefault"/>
			<memberdata name="removeobject" display="RemoveObject"/>
			<memberdata name="readmethod" display="ReadMethod"/>
			<memberdata name="readexpression" display="ReadExpression"/>
			<memberdata name="picture" display="Picture"/>
			<memberdata name="parentclass" display="ParentClass"/>
			<memberdata name="parent" display="Parent"/>
			<memberdata name="objects" display="Objects"/>
			<memberdata name="newobject" display="Newobject"/>
			<memberdata name="helpcontextid" display="HelpContextID"/>
			<memberdata name="error" display="Error"/>
			<memberdata name="controls" display="Controls"/>
			<memberdata name="classlibrary" display="ClassLibrary"/>
			<memberdata name="addproperty" display="AddProperty"/>
			<memberdata name="setstate" display="SetState"/>
			<memberdata name="effectivelyenabled" display="EffectivelyEnabled"/>
			<memberdata name="effectivelyvisible" display="EffectivelyVisible"/>
			<memberdata name="geteffectivelyenabled" display="GetEffectivelyEnabled"/>
			<memberdata name="geteffectivelyvisible" display="GetEffectivelyVisible"/>
			<memberdata name="ispageframe" display="IsPageFrame"/>
			<memberdata name="getispageframe" display="GetIsPageFrame"/>
			<memberdata name="onenabled" display="OnEnabled"/>
			<memberdata name="onvisible" display="OnVisible"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE Destroy
		UNBINDEVENTS(This)
		
	ENDPROC

	PROCEDURE geteffectivelyenabled
		RETURN This.EffectivelyEnabled
		
	ENDPROC

	PROCEDURE geteffectivelyvisible
		RETURN This.EffectivelyVisible
		
	ENDPROC

	PROCEDURE getispageframe
		RETURN This.IsPageFrame
		
	ENDPROC

	PROCEDURE Init
		LOCAL loControl
		loControl = This.Parent
		
		This.IsPageFrame = .F.
		
		BINDEVENT(m.loControl, "Visible", This, "_OnVisible",1)
		BINDEVENT(m.loControl, "Enabled", This, "_OnEnabled",1)
		
		DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		    IF UPPER(m.loControl.BASECLASS) == [PAGE] THEN
		        This.IsPageFrame = .T.
		
		        BINDEVENT(m.loControl, "Activate", This, "_OnActivate",1)
		        BINDEVENT(m.loControl, "Deactivate", This, "_OnDeactivate",1)
		        BINDEVENT(m.loControl, "Enabled", This, "_OnEnabled",1)
		        BINDEVENT(m.loControl.Parent, "Visible", This, "_OnVisible",1)
		        BINDEVENT(m.loControl.Parent, "Enabled", This, "_OnEnabled",1)
		    ENDIF
		    m.loControl = m.loControl.PARENT
		ENDDO
		
		This.SetState()
		
	ENDPROC

	PROCEDURE objtoclient
		*********************************************************************
		** opied from GDPIPlusX xfcBitmap.ObjToClientEx
		**
		** This replaces OBJTOCLIENT that has bugs with pageframes and SP2
		*********************************************************************
		PARAMETERS tnType && 1 = Top  2 = Left
		
		IF This.GetIsPageframe() = .F.
		    RETURN OBJTOCLIENT(This.Parent, m.tnType)
		ENDIF
		
		LOCAL loControl
		loControl = This.Parent
		
		
		*!* TabOrientation parameters
		#DEFINE CON_TABOR_TOP    0
		#DEFINE CON_TABOR_BOTTOM 1
		#DEFINE CON_TABOR_LEFT   2
		#DEFINE CON_TABOR_RIGHT  3
		
		LOCAL lnPosition AS INTEGER
		m.lnPosition = 0
		
		DO CASE
		
		CASE m.tnType = 1 && Top
		    DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		        IF PEMSTATUS(m.loControl, [Top],5) THEN && Defined Property
		            m.lnPosition = m.lnPosition + m.loControl.TOP
		        ENDIF
		        IF UPPER(m.loControl.BASECLASS) == [PAGE] THEN
		            IF m.loControl.PARENT.TABORIENTATION = CON_TABOR_TOP THEN    && Top
		                m.lnPosition = m.lnPosition + ;
		                    m.loControl.PARENT.HEIGHT - ;
		                    m.loControl.PARENT.PAGEHEIGHT - ;
		                    m.loControl.PARENT.BORDERWIDTH * 2
		            ELSE
		                m.lnPosition = m.lnPosition + 1
		            ENDIF
		        ENDIF
		        m.loControl = m.loControl.PARENT
		    ENDDO
		
		CASE m.tnType = 2 && Left
		    DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		        IF PEMSTATUS(m.loControl, [Left], 5) THEN && Defined Property
		            m.lnPosition = m.lnPosition + m.loControl.LEFT
		        ENDIF
		        IF UPPER(m.loControl.BASECLASS) == [PAGE]
		            IF m.loControl.PARENT.TABORIENTATION = CON_TABOR_LEFT THEN    && Left
		                m.lnPosition = m.lnPosition + ;
		                    m.loControl.PARENT.WIDTH - ;
		                    m.loControl.PARENT.PAGEWIDTH - ;
		                    m.loControl.PARENT.BORDERWIDTH * 2
		            ELSE
		                m.lnPosition = m.lnPosition + 1
		            ENDIF
		        ENDIF
		        m.loControl = m.loControl.PARENT
		    ENDDO
		
		ENDCASE
		
		RETURN m.lnPosition
		
	ENDPROC

	PROCEDURE onenabled
	ENDPROC

	PROCEDURE onvisible
	ENDPROC

	HIDDEN PROCEDURE setstate
		LOCAL loControl
		loControl = This.Parent
		
		
		LOCAL llPrevVisible, llPrevEnabled
		llPrevVisible = This.EffectivelyVisible
		llPrevEnabled = This.EffectivelyEnabled
		
		This.EffectivelyVisible = loControl.Visible
		This.EffectivelyEnabled = loControl.Enabled
		
		
		IF This._IsPageDeactivated
		    This.EffectivelyVisible = .F.
		ENDIF
		
		DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		    IF UPPER(m.loControl.BASECLASS) == [PAGE] THEN
		        IF m.loControl.Enabled = .F.
		            This.EffectivelyEnabled = .F.
		        ENDIF
		       IF m.loControl.Parent.Enabled = .F.
		            This.EffectivelyEnabled = .F.
		        ENDIF
		
		        IF m.loControl.Parent.Visible = .F.
		            This.EffectivelyVisible = .F.
		        ENDIF
		        
		        IF BETWEEN(m.loControl.Parent.ActivePage, 1, m.loControl.Parent.PageCount)
		            IF m.loControl.Parent.Pages(m.loControl.Parent.ActivePage) != m.loControl
		                This.EffectivelyVisible = .F.
		            ENDIF
		        ENDIF
		    ENDIF
		    m.loControl = m.loControl.PARENT
		ENDDO
		
		DO CASE
		 CASE llPrevVisible <> This.EffectivelyVisible
		    This.OnVisible()
		 CASE llPrevEnabled <> This.EffectivelyEnabled
		    This.OnEnabled()
		ENDCASE
		
	ENDPROC

	PROCEDURE _onactivate
		This.SetState()
		
	ENDPROC

	PROCEDURE _ondeactivate
		This._IsPageDeactivated = .T.
		This.SetState()
		This._IsPageDeactivated = .F.
		
		
	ENDPROC

	PROCEDURE _onenabled
		LPARAMETERS tlEnabled
		This.SetState()
		
	ENDPROC

	PROCEDURE _onvisible
		LPARAMETERS tlVisible
		This.SetState()
		
	ENDPROC

ENDDEFINE
