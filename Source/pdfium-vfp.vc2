*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="pdfium-vfp.vcx" CPID="1251" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS pdfium_api_fpdf AS pdfium_api_fpdf_base OF "pdfium-vfp.vcx" 		&& Pdfium API wrapper
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: fpdfbitmap_create
		*m: fpdfbitmap_createex
		*m: fpdfbitmap_destroy
		*m: fpdfbitmap_fillrect
		*m: fpdfbitmap_getbuffer
		*m: fpdfbitmap_getformat
		*m: fpdfbitmap_getheight
		*m: fpdfbitmap_getstride
		*m: fpdfbitmap_getwidth
		*m: fpdffont_close
		*m: fpdffont_getfamilyname
		*m: fpdffont_getflags
		*m: fpdffont_getweight
		*m: fpdfimageobj_setbitmap
		*m: fpdfpageobj_createnewpath
		*m: fpdfpageobj_createnewrect
		*m: fpdfpageobj_createtextobj
		*m: fpdfpageobj_destroy
		*m: fpdfpageobj_getbounds
		*m: fpdfpageobj_getmatrix
		*m: fpdfpageobj_gettype
		*m: fpdfpageobj_newimageobj
		*m: fpdfpageobj_setdasharray
		*m: fpdfpageobj_setfillcolor
		*m: fpdfpageobj_setstrokecolor
		*m: fpdfpageobj_setstrokewidth
		*m: fpdfpageobj_transform
		*m: fpdfpageobj_transformf
		*m: fpdfpage_countobjects
		*m: fpdfpage_delete
		*m: fpdfpage_generatecontent
		*m: fpdfpage_getobject
		*m: fpdfpage_insertobject
		*m: fpdfpage_new
		*m: fpdfpage_removeobject
		*m: fpdfpath_bezierto
		*m: fpdfpath_lineto
		*m: fpdfpath_moveto
		*m: fpdfpath_setdrawmode
		*m: fpdftextobj_getfont
		*m: fpdftextobj_getfontsize
		*m: fpdftextobj_gettext
		*m: fpdftextobj_settextrendermode
		*m: fpdftext_closepage
		*m: fpdftext_countchars
		*m: fpdftext_countrects
		*m: fpdftext_getcharindexatpos
		*m: fpdftext_getrect
		*m: fpdftext_gettext
		*m: fpdftext_getunicode
		*m: fpdftext_loadfont
		*m: fpdftext_loadpage
		*m: fpdftext_loadstandardfont
		*m: fpdftext_settext
		*m: fpdf_closedocument
		*m: fpdf_closepage
		*m: fpdf_createnewdocument
		*m: fpdf_destroylibrary
		*m: fpdf_devicetopage
		*m: fpdf_getlasterror
		*m: fpdf_getpagecount
		*m: fpdf_getpageheight
		*m: fpdf_getpagesizebyindex
		*m: fpdf_getpagewidth
		*m: fpdf_importpages
		*m: fpdf_initlibrarywithconfig
		*m: fpdf_loaddocument
		*m: fpdf_loadmemdocument
		*m: fpdf_loadpage
		*m: fpdf_pagetodevice
		*m: fpdf_renderpage
		*m: fpdf_renderpagebitmap
		*m: vfpdf_addfiletozipinput
		*m: vfpdf_createfontsubset
		*m: vfpdf_createzip
		*m: vfpdf_createzipinput
		*m: vfpdf_destroyfontsubset
		*m: vfpdf_destroyzip
		*m: vfpdf_destroyzipinput
		*m: vfpdf_getfontfilename		&& pdfium-vfp.dll function; Gets font face name and returns font filename and simulations
		*m: vfpdf_savedocument		&& pdfium-vfp.dll function; Save pdf to the file
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_fpdf"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="fpdf_initlibrarywithconfig" type="method" display="FPDF_InitLibraryWithConfig"/>
			<memberdata name="fpdf_destroylibrary" type="method" display="FPDF_DestroyLibrary"/>
			<memberdata name="fpdf_loaddocument" type="method" display="FPDF_LoadDocument"/>
			<memberdata name="fpdf_loadmemdocument" type="method" display="FPDF_LoadMemDocument"/>
			<memberdata name="fpdf_closedocument" type="method" display="FPDF_CloseDocument"/>
			<memberdata name="fpdf_getlasterror" type="method" display="FPDF_GetLastError"/>
			<memberdata name="fpdf_getpagecount" type="method" display="FPDF_GetPageCount"/>
			<memberdata name="fpdf_loadpage" type="method" display="FPDF_LoadPage"/>
			<memberdata name="fpdf_closepage" type="method" display="FPDF_ClosePage"/>
			<memberdata name="fpdf_renderpage" type="method" display="FPDF_RenderPage"/>
			<memberdata name="fpdftext_loadpage" type="method" display="FPDFText_LoadPage"/>
			<memberdata name="fpdftext_closepage" type="method" display="FPDFText_ClosePage"/>
			<memberdata name="fpdf_getpagesizebyindex" type="method" display="FPDF_GetPageSizeByIndex"/>
			<memberdata name="fpdf_getpagewidth" type="method" display="FPDF_GetPageWidth"/>
			<memberdata name="fpdf_getpageheight" type="method" display="FPDF_GetPageHeight"/>
			<memberdata name="fpdftext_countchars" type="method" display="FPDFText_CountChars"/>
			<memberdata name="fpdftext_getcharindexatpos" type="method" display="FPDFText_GetCharIndexAtPos"/>
			<memberdata name="fpdftext_gettext" type="method" display="FPDFText_GetText"/>
			<memberdata name="fpdftext_getunicode" type="method" display="FPDFText_GetUnicode"/>
			<memberdata name="fpdftext_countrects" type="method" display="FPDFText_CountRects"/>
			<memberdata name="fpdftext_getrect" type="method" display="FPDFText_GetRect"/>
			<memberdata name="fpdf_devicetopage" type="method" display="FPDF_DeviceToPage"/>
			<memberdata name="fpdf_pagetodevice" type="method" display="FPDF_PageToDevice"/>
			<memberdata name="vfpdf_getfontfilename" type="method" display="VFPDF_GetFontFilename"/>
			<memberdata name="vfpdf_savedocument" type="method" display="VFPDF_SaveDocument"/>
			<memberdata name="fpdfpage_countobjects" type="method" display="FPDFPage_CountObjects"/>
			<memberdata name="fpdfpage_getobject" type="method" display="FPDFPage_GetObject"/>
			<memberdata name="fpdfpageobj_gettype" type="method" display="FPDFPageObj_GetType"/>
			<memberdata name="fpdftextobj_gettext" type="method" display="FPDFTextObj_GetText"/>
			<memberdata name="fpdfpageobj_getbounds" type="method" display="FPDFPageObj_GetBounds"/>
			<memberdata name="fpdfpage_removeobject" type="method" display="FPDFPage_RemoveObject"/>
			<memberdata name="fpdfpage_insertobject" type="method" display="FPDFPage_InsertObject"/>
			<memberdata name="fpdf_createnewdocument" type="method" display="FPDF_CreateNewDocument"/>
			<memberdata name="fpdfpage_new" type="method" display="FPDFPage_New"/>
			<memberdata name="fpdfpage_delete" type="method" display="FPDFPage_Delete"/>
			<memberdata name="fpdfpageobj_getmatrix" type="method" display="FPDFPageObj_GetMatrix"/>
			<memberdata name="fpdffont_close" type="method" display="FPDFFont_Close"/>
			<memberdata name="fpdftextobj_getfontsize" type="method" display="FPDFTextObj_GetFontSize"/>
			<memberdata name="fpdftextobj_getfont" type="method" display="FPDFTextObj_GetFont"/>
			<memberdata name="fpdffont_getfamilyname" type="method" display="FPDFFont_GetFamilyName"/>
			<memberdata name="fpdffont_getflags" type="method" display="FPDFFont_GetFlags"/>
			<memberdata name="fpdffont_getweight" type="method" display="FPDFFont_GetWeight"/>
			<memberdata name="fpdftext_loadfont" type="method" display="FPDFText_LoadFont"/>
			<memberdata name="fpdftext_loadstandardfont" type="method" display="FPDFText_LoadStandardFont"/>
			<memberdata name="fpdfpageobj_createnewrect" type="method" display="FPDFPageObj_CreateNewRect"/>
			<memberdata name="fpdfpageobj_destroy" type="method" display="FPDFPageObj_Destroy"/>
			<memberdata name="fpdfpageobj_setfillcolor" type="method" display="FPDFPageObj_SetFillColor"/>
			<memberdata name="fpdfpageobj_setstrokecolor" type="method" display="FPDFPageObj_SetStrokeColor"/>
			<memberdata name="fpdfpageobj_setstrokewidth" type="method" display="FPDFPageObj_SetStrokeWidth"/>
			<memberdata name="fpdfpageobj_createtextobj" type="method" display="FPDFPageObj_CreateTextObj"/>
			<memberdata name="fpdfpath_setdrawmode" type="method" display="FPDFPath_SetDrawMode"/>
			<memberdata name="fpdfpage_generatecontent" type="method" display="FPDFPage_GenerateContent"/>
			<memberdata name="fpdfpageobj_transform" type="method" display="FPDFPageObj_Transform"/>
			<memberdata name="fpdfpageobj_transformf" type="method" display="FPDFPageObj_TransformF"/>
			<memberdata name="fpdftextobj_settextrendermode" type="method" display="FPDFTextObj_SetTextRenderMode"/>
			<memberdata name="fpdftext_settext" type="method" display="FPDFText_SetText"/>
			<memberdata name="fpdfpageobj_createnewpath" type="method" display="FPDFPageObj_CreateNewPath"/>
			<memberdata name="fpdfpath_lineto" type="method" display="FPDFPath_LineTo"/>
			<memberdata name="fpdfpath_moveto" type="method" display="FPDFPath_MoveTo"/>
			<memberdata name="fpdfbitmap_create" type="method" display="FPDFBitmap_Create"/>
			<memberdata name="fpdfbitmap_destroy" type="method" display="FPDFBitmap_Destroy"/>
			<memberdata name="fpdfbitmap_createex" type="method" display="FPDFBitmap_CreateEx"/>
			<memberdata name="fpdfbitmap_getformat" type="method" display="FPDFBitmap_GetFormat"/>
			<memberdata name="fpdfbitmap_getbuffer" type="method" display="FPDFBitmap_GetBuffer"/>
			<memberdata name="fpdfbitmap_getwidth" type="method" display="FPDFBitmap_GetWidth"/>
			<memberdata name="fpdfbitmap_getheight" type="method" display="FPDFBitmap_GetHeight"/>
			<memberdata name="fpdfbitmap_getstride" type="method" display="FPDFBitmap_GetStride"/>
			<memberdata name="fpdfbitmap_fillrect" type="method" display="FPDFBitmap_FillRect"/>
			<memberdata name="fpdfpageobj_newimageobj" type="method" display="FPDFPageObj_NewImageObj"/>
			<memberdata name="fpdfimageobj_setbitmap" type="method" display="FPDFImageObj_SetBitmap"/>
			<memberdata name="fpdfpageobj_setdasharray" type="method" display="FPDFPageObj_SetDashArray"/>
			<memberdata name="fpdfpath_bezierto" type="method" display="FPDFPath_BezierTo"/>
			<memberdata name="vfpdf_createfontsubset" type="method" display="VFPDF_CreateFontSubset"/>
			<memberdata name="vfpdf_destroyfontsubset" type="method" display="VFPDF_DestroyFontSubset"/>
			<memberdata name="fpdf_importpages" type="method" display="FPDF_ImportPages"/>
			<memberdata name="vfpdf_addfiletozipinput" type="method" display="VFPDF_AddFileToZipInput"/>
			<memberdata name="vfpdf_createzip" type="method" display="VFPDF_CreateZip"/>
			<memberdata name="vfpdf_createzipinput" type="method" display="VFPDF_CreateZipInput"/>
			<memberdata name="vfpdf_destroyzip" type="method" display="VFPDF_DestroyZip"/>
			<memberdata name="vfpdf_destroyzipinput" type="method" display="VFPDF_DestroyZipInput"/>
			<memberdata name="fpdf_renderpagebitmap" type="method" display="FPDF_RenderPageBitmap"/>
		</VFPData>
		CONST.Name = "CONST"
	*</PropValue>
	
	PROCEDURE fpdfbitmap_create
		LPARAMETERS width as Long, height as Long, alpha as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_Create(m.width, m.height, m.alpha)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFBitmap_Create IN (This.pdfium_dll_path) AS FPDFBitmap_Create LONG width, LONG height, LONG alpha
		    m.lvRes = FPDFBitmap_Create(m.width, m.height, m.alpha)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_createex
		LPARAMETERS width as Long, height as Long, format as Long, first_scan as Long, stride as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_CreateEx(m.width, m.height, m.format, m.first_scan, m.stride)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFBitmap_CreateEx IN (This.pdfium_dll_path) AS FPDFBitmap_CreateEx LONG width, LONG height, LONG format, LONG first_scan, LONG stride
		    m.lvRes = FPDFBitmap_CreateEx(m.width, m.height, m.format, m.first_scan, m.stride)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_destroy
		LPARAMETERS bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_Destroy(m.bitmap)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDFBitmap_Destroy IN (This.pdfium_dll_path) AS FPDFBitmap_Destroy LONG bitmap
		    m.lvRes = FPDFBitmap_Destroy(m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_fillrect
		LPARAMETERS bitmap as Long, left as Integer, top as Integer, width as Integer, height as Integer, color as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_FillRect(m.bitmap, m.left, m.top, m.width, m.height, m.color)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDFBitmap_FillRect IN (This.pdfium_dll_path) AS FPDFBitmap_FillRect LONG bitmap, INTEGER left, INTEGER top, INTEGER width, INTEGER height, LONG color
		    m.lvRes = FPDFBitmap_FillRect(m.bitmap, m.left, m.top, m.width, m.height, m.color)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_getbuffer
		LPARAMETERS bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_GetBuffer(m.bitmap)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFBitmap_GetBuffer IN (This.pdfium_dll_path) AS FPDFBitmap_GetBuffer LONG bitmap
		    m.lvRes = FPDFBitmap_GetBuffer(m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_getformat
		LPARAMETERS bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_GetFormat(m.bitmap)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFBitmap_GetFormat IN (This.pdfium_dll_path) AS FPDFBitmap_GetFormat LONG bitmap
		    m.lvRes = FPDFBitmap_GetFormat(m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_getheight
		LPARAMETERS bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_GetHeight(m.bitmap)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFBitmap_GetHeight IN (This.pdfium_dll_path) AS FPDFBitmap_GetHeight LONG bitmap
		    m.lvRes = FPDFBitmap_GetHeight(m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_getstride
		LPARAMETERS bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_GetStride(m.bitmap)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFBitmap_GetStride IN (This.pdfium_dll_path) AS FPDFBitmap_GetStride LONG bitmap
		    m.lvRes = FPDFBitmap_GetStride(m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfbitmap_getwidth
		LPARAMETERS bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFBitmap_GetWidth(m.bitmap)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFBitmap_GetWidth IN (This.pdfium_dll_path) AS FPDFBitmap_GetWidth LONG bitmap
		    m.lvRes = FPDFBitmap_GetWidth(m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdffont_close
		LPARAMETERS font as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFFont_Close(m.font)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDFFont_Close IN (This.pdfium_dll_path) AS FPDFFont_Close LONG font
		    m.lvRes = FPDFFont_Close(m.font)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdffont_getfamilyname
		LPARAMETERS font as Long, buffer as String, length as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFFont_GetFamilyName(m.font, @m.buffer, m.length)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFFont_GetFamilyName IN (This.pdfium_dll_path) AS FPDFFont_GetFamilyName LONG font, STRING @buffer, LONG length
		    m.lvRes = FPDFFont_GetFamilyName(m.font, @m.buffer, m.length)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdffont_getflags
		LPARAMETERS font as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFFont_GetFlags(m.font)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFFont_GetFlags IN (This.pdfium_dll_path) AS FPDFFont_GetFlags LONG font
		    m.lvRes = FPDFFont_GetFlags(m.font)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdffont_getweight
		LPARAMETERS font as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFFont_GetWeight(m.font)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFFont_GetWeight IN (This.pdfium_dll_path) AS FPDFFont_GetWeight LONG font
		    m.lvRes = FPDFFont_GetWeight(m.font)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfimageobj_setbitmap
		LPARAMETERS pages as Long, count as Integer, image_object as Long, bitmap as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFImageObj_SetBitmap(m.pages, m.count, m.image_object, m.bitmap)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFImageObj_SetBitmap IN (This.pdfium_dll_path) AS FPDFImageObj_SetBitmap LONG pages, INTEGER count, LONG image_object, LONG bitmap
		    m.lvRes = FPDFImageObj_SetBitmap(m.pages, m.count, m.image_object, m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_createnewpath
		LPARAMETERS x as Single, y as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_CreateNewPath(m.x, m.y)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPageObj_CreateNewPath IN (This.pdfium_dll_path) AS FPDFPageObj_CreateNewPath SINGLE x, SINGLE y
		    m.lvRes = FPDFPageObj_CreateNewPath(m.x, m.y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_createnewrect
		LPARAMETERS x as Single, y as Single, w as Single, h as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_CreateNewRect(m.x, m.y, m.w, m.h)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPageObj_CreateNewRect IN (This.pdfium_dll_path) AS FPDFPageObj_CreateNewRect SINGLE x, SINGLE y, SINGLE w, SINGLE h
		    m.lvRes = FPDFPageObj_CreateNewRect(m.x, m.y, m.w, m.h)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_createtextobj
		LPARAMETERS page_object as Long, font as Long, font_size as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_CreateTextObj(m.page_object, m.font, m.font_size)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPageObj_CreateTextObj IN (This.pdfium_dll_path) AS FPDFPageObj_CreateTextObj LONG page_object, LONG font, SINGLE font_size
		    m.lvRes = FPDFPageObj_CreateTextObj(m.page_object, m.font, m.font_size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_destroy
		LPARAMETERS page_object as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_Destroy(m.page_object)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDFPageObj_Destroy IN (This.pdfium_dll_path) AS FPDFPageObj_Destroy LONG page_object
		    m.lvRes = FPDFPageObj_Destroy(m.page_object)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_getbounds
		LPARAMETERS page_object as Long, left as Single, bottom as Single, right as Single, top as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_GetBounds(m.page_object, @m.left, @m.bottom, @m.right, @m.top)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPageObj_GetBounds IN (This.pdfium_dll_path) AS FPDFPageObj_GetBounds LONG page_object, SINGLE @left, SINGLE @bottom, SINGLE @right, SINGLE @top
		    m.lvRes = FPDFPageObj_GetBounds(m.page_object, @m.left, @m.bottom, @m.right, @m.top)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_getmatrix
		LPARAMETERS page_object as Long, matrix as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_GetMatrix(m.page_object , @matrix)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPageObj_GetMatrix IN (This.pdfium_dll_path) AS FPDFPageObj_GetMatrix LONG page_object, STRING @matrix
		    m.lvRes = FPDFPageObj_GetMatrix(m.page_object , @matrix)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_gettype
		LPARAMETERS page_object as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_GetType(m.page_object)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFPageObj_GetType IN (This.pdfium_dll_path) AS FPDFPageObj_GetType LONG page_object
		    m.lvRes = FPDFPageObj_GetType(m.page_object)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_newimageobj
		LPARAMETERS document as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_NewImageObj(m.document)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPageObj_NewImageObj IN (This.pdfium_dll_path) AS FPDFPageObj_NewImageObj LONG document
		    m.lvRes = FPDFPageObj_NewImageObj(m.document)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_setdasharray
		LPARAMETERS page_object as Long, dash_array as String, dash_count as Long, phase as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_SetDashArray(m.page_object, m.dash_array, m.dash_count, m.phase)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPageObj_SetDashArray IN (This.pdfium_dll_path) AS FPDFPageObj_SetDashArray LONG page_object, STRING dash_array, LONG dash_count, SINGLE phase
		    m.lvRes = FPDFPageObj_SetDashArray(m.page_object, m.dash_array, m.dash_count, m.phase)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_setfillcolor
		LPARAMETERS page_object as Long, R as Long, G as Long, B as Long, A as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_SetFillColor(m.page_object, m.R, m.G, m.B, m.A)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPageObj_SetFillColor IN (This.pdfium_dll_path) AS FPDFPageObj_SetFillColor LONG page_object, LONG R, LONG G, LONG B, LONG A
		    m.lvRes = FPDFPageObj_SetFillColor(m.page_object, m.R, m.G, m.B, m.A)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_setstrokecolor
		LPARAMETERS page_object as Long, R as Long, G as Long, B as Long, A as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_SetStrokeColor(m.page_object, m.R, m.G, m.B, m.A)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPageObj_SetStrokeColor IN (This.pdfium_dll_path) AS FPDFPageObj_SetStrokeColor LONG page_object, LONG R, LONG G, LONG B, LONG A
		    m.lvRes = FPDFPageObj_SetStrokeColor(m.page_object, m.R, m.G, m.B, m.A)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_setstrokewidth
		LPARAMETERS page_object as Long, width as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_SetStrokeWidth(m.page_object, m.width)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPageObj_SetStrokeWidth IN (This.pdfium_dll_path) AS FPDFPageObj_SetStrokeWidth LONG page_object, SINGLE width
		    m.lvRes = FPDFPageObj_SetStrokeWidth(m.page_object, m.width)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_transform
		LPARAMETERS page_object as Long, a as Double, b as Double, c as Double, d as Double, e as Double, f as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_Transform(m.page_object, m.a, m.b, m.c, m.d, m.e, m.f)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDFPageObj_Transform IN (This.pdfium_dll_path) AS FPDFPageObj_Transform LONG page_object, DOUBLE a, DOUBLE b, DOUBLE c, DOUBLE d, DOUBLE e, DOUBLE f
		    m.lvRes = FPDFPageObj_Transform(m.page_object, m.a, m.b, m.c, m.d, m.e, m.f)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpageobj_transformf
		LPARAMETERS page_object as Long, matrix as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPageObj_TransformF(m.page_object, m.matrix)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPageObj_TransformF IN (This.pdfium_dll_path) AS FPDFPageObj_TransformF LONG page_object, STRING matrix
		    m.lvRes = FPDFPageObj_TransformF(m.page_object, m.matrix)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_countobjects
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_CountObjects(m.page)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFPage_CountObjects IN (This.pdfium_dll_path) AS FPDFPage_CountObjects LONG page
		    m.lvRes = FPDFPage_CountObjects(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_delete
		LPARAMETERS document as Long, page_index as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_Delete(m.document, m.page_index)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDFPage_Delete IN (This.pdfium_dll_path) AS FPDFPage_Delete LONG document, INTEGER page_index
		    m.lvRes = FPDFPage_Delete(m.document, m.page_index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_generatecontent
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_GenerateContent(m.page)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPage_GenerateContent IN (This.pdfium_dll_path) AS FPDFPage_GenerateContent LONG page
		    m.lvRes = FPDFPage_GenerateContent(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_getobject
		LPARAMETERS page as Long, index as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_GetObject(m.page, m.index)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPage_GetObject IN (This.pdfium_dll_path) AS FPDFPage_GetObject LONG page, INTEGER index
		    m.lvRes = FPDFPage_GetObject(m.page, m.index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_insertobject
		LPARAMETERS page as Long, page_object as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_InsertObject(m.page, m.page_object)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDFPage_InsertObject IN (This.pdfium_dll_path) AS FPDFPage_InsertObject LONG page, LONG page_object
		    m.lvRes = FPDFPage_InsertObject(m.page, m.page_object)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_new
		LPARAMETERS document as Long, page_index as Integer, width as Double, height as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_New(m.document, m.page_index, m.width, m.height)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPage_New IN (This.pdfium_dll_path) AS FPDFPage_New LONG document, INTEGER page_index, DOUBLE width, DOUBLE height
		    m.lvRes = FPDFPage_New(m.document, m.page_index, m.width, m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_removeobject
		LPARAMETERS page as Long, page_object as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_RemoveObject(m.page, m.page_object)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPage_RemoveObject IN (This.pdfium_dll_path) AS FPDFPage_RemoveObject LONG page, LONG page_object
		    m.lvRes = FPDFPage_RemoveObject(m.page, m.page_object)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpath_bezierto
		LPARAMETERS path as Long, x1 as Single, y1 as Single, x2 as Single, y2 as Single, x3 as Single, y3 as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPath_BezierTo(m.path, m.x1, m.y1, m.x2, m.y2, m.x3, m.y3)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPath_BezierTo IN (This.pdfium_dll_path) AS FPDFPath_BezierTo LONG path, SINGLE x1, SINGLE y1, SINGLE x2, SINGLE y2, SINGLE x3, SINGLE y3
		    m.lvRes = FPDFPath_BezierTo(m.path, m.x1, m.y1, m.x2, m.y2, m.x3, m.y3)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpath_lineto
		LPARAMETERS path as Long, x as Single, y as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPath_LineTo(m.path, m.x, m.y)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPath_LineTo IN (This.pdfium_dll_path) AS FPDFPath_LineTo LONG path, SINGLE x, SINGLE y
		    m.lvRes = FPDFPath_LineTo(m.path, m.x, m.y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpath_moveto
		LPARAMETERS path as Long, x as Single, y as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPath_MoveTo(m.path, m.x, m.y)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPath_MoveTo IN (This.pdfium_dll_path) AS FPDFPath_MoveTo LONG path, SINGLE x, SINGLE y
		    m.lvRes = FPDFPath_MoveTo(m.path, m.x, m.y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpath_setdrawmode
		LPARAMETERS page_object as Long, fillmode as Integer, stoke as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPath_SetDrawMode(m.page_object, m.fillmode, m.stoke)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPath_SetDrawMode IN (This.pdfium_dll_path) AS FPDFPath_SetDrawMode LONG page_object, INTEGER fillmode, LONG stroke
		    m.lvRes = FPDFPath_SetDrawMode(m.page_object, m.fillmode, m.stoke)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftextobj_getfont
		LPARAMETERS text as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFTextObj_GetFont(m.text)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFTextObj_GetFont IN (This.pdfium_dll_path) AS FPDFTextObj_GetFont LONG text
		    m.lvRes = FPDFTextObj_GetFont(m.text)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftextobj_getfontsize
		LPARAMETERS text as Long, size as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFTextObj_GetFontSize(m.text, @m.size)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFTextObj_GetFontSize IN (This.pdfium_dll_path) AS FPDFTextObj_GetFontSize LONG text, SINGLE @size
		    m.lvRes = FPDFTextObj_GetFontSize(m.text, @m.size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftextobj_gettext
		LPARAMETERS text_object as Long, text_page as Long, buffer as String, length as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFTextObj_GetText(m.text_object, m.text_page, @m.buffer, m.length)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFTextObj_GetText IN (This.pdfium_dll_path) AS FPDFTextObj_GetText LONG text_object, LONG text_page, STRING @buffer, LONG length
		    m.lvRes = FPDFTextObj_GetText(m.text_object, m.text_page, @m.buffer, m.length)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftextobj_settextrendermode
		LPARAMETERS text as Long, render_mode as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFTextObj_SetTextRenderMode(m.text, m.render_mode)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFTextObj_SetTextRenderMode IN (This.pdfium_dll_path) AS FPDFTextObj_SetTextRenderMode LONG text, INTEGER render_mode
		    m.lvRes = FPDFTextObj_SetTextRenderMode(m.text, m.render_mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_closepage
		LPARAMETERS text_page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_ClosePage(m.text_page)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDFText_ClosePage IN (This.pdfium_dll_path) AS FPDFText_ClosePage LONG text_page
		    m.lvRes = FPDFText_ClosePage(m.text_page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_countchars
		LPARAMETERS text_page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_CountChars(m.text_page)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFText_CountChars IN (This.pdfium_dll_path) AS FPDFText_CountChars LONG text_page
		    m.lvRes = FPDFText_CountChars(m.text_page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_countrects
		LPARAMETERS text_page as Long, start_index as Integer, count as Intege
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_CountRects(m.text_page, m.start_index, m.count)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFText_CountRects IN (This.pdfium_dll_path) AS FPDFText_CountRects LONG text_page, integer start_index, integer count
		    m.lvRes = FPDFText_CountRects(m.text_page, m.start_index, m.count)
		ENDTRY
		
		RETURN m.lvRes
		
		
	ENDPROC

	PROCEDURE fpdftext_getcharindexatpos
		LPARAMETERS text_page as Long, x as Double, y as Double, xTolerance as Double, yTolerance as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_GetCharIndexAtPos(m.text_page, m.x, m.y, m.xTolerance, m.yTolerance)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFText_GetCharIndexAtPos IN (This.pdfium_dll_path) AS FPDFText_GetCharIndexAtPos LONG text_page, double x, double y, double xTolerance, double yTolerance
		    m.lvRes = FPDFText_GetCharIndexAtPos(m.text_page, m.x, m.y, m.xTolerance, m.yTolerance)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_getrect
		LPARAMETERS text_page as Long, rect_index as Integer, left as Double, top as Double, right as Double, bottom as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_GetRect(m.text_page, m.rect_index, @m.left, @m.top, @m.right, @m.bottom)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFText_GetRect IN (This.pdfium_dll_path) AS FPDFText_GetRect LONG text_page, integer rect_index, double @left, double @top, double @right, double @bottom
		    m.lvRes = FPDFText_GetRect(m.text_page, m.rect_index, @m.left, @m.top, @m.right, @m.bottom)
		ENDTRY
		
		RETURN m.lvRes
		
		
	ENDPROC

	PROCEDURE fpdftext_gettext
		LPARAMETERS text_page as Long, start_index as Integer, count as Integer, result as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_GetText(m.text_page, m.start_index, m.count, @m.result)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFText_GetText IN (This.pdfium_dll_path) AS FPDFText_GetText LONG text_page, integer start_index, integer count, STRING @result
		    m.lvRes = FPDFText_GetText(m.text_page, m.start_index, m.count, @m.result)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_getunicode
		LPARAMETERS text_page as Long, index as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_GetUnicode(m.text_page, m.index)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFText_GetUnicode IN (This.pdfium_dll_path) AS FPDFText_GetUnicode LONG text_page, integer index
		    m.lvRes = FPDFText_GetUnicode(m.text_page, m.index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_loadfont
		LPARAMETERS document as Long, data as Long, size as Long, font_type as Integer, cid as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_LoadFont(m.document, m.data, m.size, m.font_type, m.cid)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFText_LoadFont IN (This.pdfium_dll_path) AS FPDFText_LoadFont LONG document, LONG data, LONG size, INTEGER font_type, LONG cid
		    m.lvRes = FPDFText_LoadFont(m.document, m.data, m.size, m.font_type, m.cid)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_loadpage
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_LoadPage(m.page)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFText_LoadPage IN (This.pdfium_dll_path) AS FPDFText_LoadPage LONG page
		    m.lvRes = FPDFText_LoadPage(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_loadstandardfont
		LPARAMETERS document as Long, font as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_LoadStandardFont(m.document, m.font)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFText_LoadStandardFont IN (This.pdfium_dll_path) AS FPDFText_LoadStandardFont LONG document, STRING font
		    m.lvRes = FPDFText_LoadStandardFont(m.document, m.font)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdftext_settext
		LPARAMETERS text_object as Long, text as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFText_SetText(m.text_object, m.text)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFText_SetText IN (This.pdfium_dll_path) AS FPDFText_SetText LONG text_object, STRING text
		    m.lvRes = FPDFText_SetText(m.text_object, m.text)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_closedocument
		LPARAMETERS document as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_CloseDocument(m.document)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDF_CloseDocument IN (This.pdfium_dll_path) AS FPDF_CloseDocument LONG document
		    m.lvRes = FPDF_CloseDocument(m.document)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_closepage
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_ClosePage(m.page)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDF_ClosePage IN (This.pdfium_dll_path) AS FPDF_ClosePage LONG page
		    m.lvRes = FPDF_ClosePage(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_createnewdocument
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_CreateNewDocument()
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDF_CreateNewDocument IN (This.pdfium_dll_path) AS FPDF_CreateNewDocument
		    m.lvRes = FPDF_CreateNewDocument()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_destroylibrary
		
		DECLARE FPDF_DestroyLibrary IN (This.pdfium_dll_path) AS FPDF_DestroyLibrary
		
		IF PEMSTATUS(Application, "pdfium_instance_count", 5)=.T.
		
		    IF Application.pdfium_instance_count = 1
		        FPDF_DestroyLibrary()
		    ENDIF
		
		    Application.pdfium_instance_count = MAX(Application.pdfium_instance_count - 1, 0)
		
		ENDIF
		
	ENDPROC

	PROCEDURE fpdf_devicetopage
		LPARAMETERS page as Long, start_x as Integer, start_y as Integer, size_x as Integer, size_y as Integer, rotate as Integer, device_x as Integer, device_y as Integer, page_x as Double, page_y as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = m.FPDF_DeviceToPage(m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.device_x, m.device_y, @m.page_x, @m.page_y)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDF_DeviceToPage IN (This.pdfium_dll_path) AS FPDF_DeviceToPage LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer device_x, integer device_y, double @page_x, double @page_y
		    m.lvRes = m.FPDF_DeviceToPage(m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.device_x, m.device_y, @m.page_x, @m.page_y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getlasterror
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetLastError()
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDF_GetLastError IN (This.pdfium_dll_path) AS FPDF_GetLastError
		    m.lvRes = FPDF_GetLastError()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getpagecount
		LPARAMETERS document as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetPageCount(m.document)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDF_GetPageCount IN (This.pdfium_dll_path) AS FPDF_GetPageCount LONG document
		    m.lvRes = FPDF_GetPageCount(m.document)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getpageheight
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetPageHeight(m.page)
		CATCH
		    SET CONSOLE OFF
		    DECLARE double FPDF_GetPageHeight IN (This.pdfium_dll_path) AS FPDF_GetPageHeight LONG page
		    m.lvRes = FPDF_GetPageHeight(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getpagesizebyindex
		LPARAMETERS document as Long, page_index as Integer, width as Double, height as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetPageSizeByIndex(m.document, m.page_index, @m.width, @m.height)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDF_GetPageSizeByIndex IN (This.pdfium_dll_path) AS FPDF_GetPageSizeByIndex LONG document, integer page_index, double @width, double @height
		    m.lvRes = FPDF_GetPageSizeByIndex(m.document, m.page_index, @m.width, @m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_getpagewidth
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_GetPageWidth(m.page)
		CATCH
		    SET CONSOLE OFF
		    DECLARE double FPDF_GetPageWidth IN (This.pdfium_dll_path) AS FPDF_GetPageWidth LONG page
		    m.lvRes = FPDF_GetPageWidth(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_importpages
		LPARAMETERS dest_doc as Long, src_doc as Long, pagerange as String, index as Integer
		
		LOCAL m.lvRes
		TRY
		   m.lvRes = FPDF_ImportPages(m.dest_doc, m.src_doc, m.pagerange, m.index)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDF_ImportPages IN (This.pdfium_dll_path) AS FPDF_ImportPages LONG dest_doc, LONG src_doc, STRING pagerange, INTEGER index
		    m.lvRes = FPDF_ImportPages(m.dest_doc, m.src_doc, m.pagerange, m.index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_initlibrarywithconfig
		LPARAMETERS config as String
		
		DECLARE FPDF_InitLibraryWithConfig IN (This.pdfium_dll_path) AS FPDF_InitLibraryWithConfig STRING config
		
		LOCAL lcConfig
		m.lcConfig = EVL(NVL(m.config,""),"")
		IF EMPTY(m.lcConfig)
		    m.lcConfig = REPLICATE(CHR(0),24)
		    m.lcConfig = STUFF(m.lcConfig, 1,4, BINTOC(2, "4RS"))
		ELSE
		    m.lcConfig = PADR(m.lcConfig, 24, CHR(0))    
		ENDIF
		
		
		IF PEMSTATUS(Application, "pdfium_instance_count", 5)=.F.
		    ADDPROPERTY(Application, "pdfium_instance_count", 0)
		ENDIF
		
		IF Application.pdfium_instance_count = 0
		    FPDF_InitLibraryWithConfig(m.lcConfig)
		    This.FPDF_GetLastError() && Last error initialization, first call of FPDF_GetLastError() always returns 0 even if error has occured
		ENDIF
		
		Application.pdfium_instance_count = Application.pdfium_instance_count + 1
		
	ENDPROC

	PROCEDURE fpdf_loaddocument
		LPARAMETERS file_path as String, password as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_LoadDocument(m.file_path, m.password)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDF_LoadDocument IN (This.pdfium_dll_path) AS FPDF_LoadDocument STRING file_path, STRING password
		    m.lvRes = FPDF_LoadDocument(m.file_path, m.password)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_loadmemdocument
		LPARAMETERS data_buf as Long, size as Integer, password as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_LoadMemDocument(m.data_buf, m.size, m.password)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDF_LoadMemDocument IN (This.pdfium_dll_path) AS FPDF_LoadMemDocument LONG data_buf, INTEGER size, STRING password
		    m.lvRes = FPDF_LoadMemDocument(m.data_buf, m.size, m.password)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_loadpage
		LPARAMETERS document as Long, page_index as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_LoadPage(m.document, m.page_index)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDF_LoadPage IN (This.pdfium_dll_path) AS FPDF_LoadPage LONG document, INTEGER page_index
		    m.lvRes = FPDF_LoadPage(m.document, m.page_index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_pagetodevice
		LPARAMETERS page as Long, start_x as Integer, start_y as Integer, size_x as Integer, size_y as Integer, rotate as Integer, page_x as Double, page_y as Double, device_x as Integer, device_y as Integer
		
		LOCAL lcDevX, lcDevY
		STORE 0h00000000 TO m.lcDevX, m.lcDevY
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_PageToDevice(m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.page_x, m.page_y, @m.lcDevX, @m.lcDevY)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDF_PageToDevice IN (This.pdfium_dll_path) AS FPDF_PageToDevice LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, double page_x, double page_y, string @device_x, string @device_y
		    m.lvRes = FPDF_PageToDevice(m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.page_x, m.page_y, @m.lcDevX, @m.lcDevY)
		ENDTRY
		
		m.device_x = CTOBIN(m.lcDevX, "4RS")
		m.device_y = CTOBIN(m.lcDevY, "4RS")
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_renderpage
		LPARAMETERS dc as Long, page as Long, start_x as Integer, start_y as Integer, size_x as Integer, size_y as Integer, rotate as Integer, flags as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_RenderPage(m.dc, m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.flags)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDF_RenderPage IN (This.pdfium_dll_path) AS FPDF_RenderPage LONG dc, LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer flags
		    m.lvRes = FPDF_RenderPage(m.dc, m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.flags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_renderpagebitmap
		LPARAMETERS bitmap as Long, page as Long, start_x as Integer, start_y as Integer, size_x as Integer, size_y as Integer, rotate as Integer, flags as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_RenderPageBitmap(m.bitmap, m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.flags)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDF_RenderPageBitmap IN (This.pdfium_dll_path) AS FPDF_RenderPageBitmap LONG bitmap, LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer flags
		    m.lvRes = FPDF_RenderPageBitmap(m.bitmap, m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.flags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_addfiletozipinput
		LPARAMETERS zip_input as Long, filename as String, filedata as String, filedata_size as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_AddFileToZipInput(m.zip_input, m.filename, m.filedata, m.filedata_size)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG VFPDF_AddFileToZipInput IN (This.pdfium_vfp_dll_path) AS VFPDF_AddFileToZipInput LONG zip_input, STRING filename, STRING filedata, LONG filedata_size
		    m.lvRes = VFPDF_AddFileToZipInput(m.zip_input, m.filename, m.filedata, m.filedata_size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_createfontsubset
		LPARAMETERS font_data as Long, font_data_size as Long, char_list as String, font_subset_data as Long, font_subset_data_size as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_CreateFontSubset(m.font_data, m.font_data_size, m.char_list, @m.font_subset_data, @m.font_subset_data_size)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG VFPDF_CreateFontSubset IN (This.pdfium_vfp_dll_path) AS VFPDF_CreateFontSubset LONG font_data, LONG font_data_size, STRING char_list, LONG @font_subset_data, LONG @font_subset_data_size
		    m.lvRes = VFPDF_CreateFontSubset(m.font_data, m.font_data_size, m.char_list, @m.font_subset_data, @m.font_subset_data_size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_createzip
		LPARAMETERS zip_input as Long, zipfile_data as Long, zipfile_data_size as Long
		
		m.zipfile_data = 0
		m.zipfile_data_size = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_CreateZip(m.zip_input, @m.zipfile_data, @m.zipfile_data_size)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG VFPDF_CreateZip IN (This.pdfium_vfp_dll_path) AS VFPDF_CreateZip LONG zip_input, LONG @zipfile_data, LONG @zipfile_data_size
		    m.lvRes = VFPDF_CreateZip(m.zip_input, @m.zipfile_data, @m.zipfile_data_size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_createzipinput
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_CreateZipInput()
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG VFPDF_CreateZipInput IN (This.pdfium_vfp_dll_path) AS VFPDF_CreateZipInput
		    m.lvRes = VFPDF_CreateZipInput()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_destroyfontsubset
		LPARAMETERS font_subset_data as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_DestroyFontSubset(m.font_subset_data)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG VFPDF_DestroyFontSubset IN (This.pdfium_vfp_dll_path) AS VFPDF_DestroyFontSubset LONG font_subset_data
		    m.lvRes = VFPDF_DestroyFontSubset(m.font_subset_data)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_destroyzip
		LPARAMETERS zipfile_data as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_DestroyZip(m.zipfile_data)
		CATCH
		    SET CONSOLE OFF
		    DECLARE VFPDF_DestroyZip IN (This.pdfium_vfp_dll_path) AS VFPDF_DestroyZip LONG zipfile_data
		    m.lvRes = VFPDF_DestroyZip(m.zipfile_data)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_destroyzipinput
		LPARAMETERS zip_input as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_DestroyZipInput(m.zip_input)
		CATCH
		    SET CONSOLE OFF
		    DECLARE VFPDF_DestroyZipInput IN (This.pdfium_vfp_dll_path) AS VFPDF_DestroyZipInput LONG zip_input
		    m.lvRes = VFPDF_DestroyZipInput(m.zip_input)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_getfontfilename		&& pdfium-vfp.dll function; Gets font face name and returns font filename and simulations
		LPARAMETERS family_name as String, is_bold as Long, is_italic as Long, nCharset as Long, buffer as String, buflen as Long, bBoldSimulation as Long, bItalicSimulation as Long, bSymbolFont as Long
		
		* Algorithmic emboldening is performed.
		#define DWRITE_FONT_SIMULATIONS_BOLD 0x0001
		* Algorithmic italicization is performed.
		#define DWRITE_FONT_SIMULATIONS_OBLIQUE 0x0002
		
		LOCAL m.lnFontSimulations, m.lnSymbolFont
		STORE 0 TO m.lnFontSimulations, m.lnSymbolFont
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_GetFontFileName(@m.family_name, m.is_bold, m.is_italic, m.nCharset, @m.buffer, m.buflen, @m.lnFontSimulations, @m.lnSymbolFont)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG VFPDF_GetFontFileName IN (This.pdfium_vfp_dll_path) AS VFPDF_GetFontFileName STRING @family_name, LONG is_bold, LONG is_italic, LONG nCharset, STRING @buffer, LONG buflen, LONG @nFontSimulations, LONG @bSymbolFont
		    m.lvRes = VFPDF_GetFontFileName(@m.family_name, m.is_bold, m.is_italic, m.nCharset, @m.buffer, m.buflen, @m.lnFontSimulations, @m.lnSymbolFont)
		ENDTRY
		
		IF m.lvRes <> 0
		    m.bBoldSimulation = IIF(BITAND(m.lnFontSimulations, DWRITE_FONT_SIMULATIONS_BOLD) <> 0, 1, 0)
		    m.bItalicSimulation = IIF(BITAND(m.lnFontSimulations, DWRITE_FONT_SIMULATIONS_OBLIQUE) <> 0, 1, 0)
		    m.bSymbolFont = m.lnSymbolFont
		ENDIF
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdf_savedocument		&& pdfium-vfp.dll function; Save pdf to the file
		LPARAMETERS document as Long, filepath as String, errMsg as String, errMsgSize as Long
		
		IF NVL(m.errMsgSize, 0) > 0
		    m.errMsg = SPACE(m.errMsgSize)
		ELSE
		    m.errMsg = ""
		    m.errMsgSize = 0
		ENDIF
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDF_SaveDocument(m.document, m.filepath, @m.errMsg, m.errMsgSize)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG VFPDF_SaveDocument IN (This.pdfium_vfp_dll_path) AS VFPDF_SaveDocument LONG document, STRING filepath, STRING @errMsg, LONG errMsgSize &&errMsgSize: errMsg buffer size in chars, not in bytes
		    m.lvRes = VFPDF_SaveDocument(m.document, m.filepath, @m.errMsg, m.errMsgSize)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_fpdf_annot AS pdfium_api_fpdf_base OF "pdfium-vfp.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: fpdfannot_getformcontrolcount
		*m: fpdfannot_getformfieldalternatename
		*m: fpdfannot_getformfieldexportvalue
		*m: fpdfannot_getformfieldflags
		*m: fpdfannot_getformfieldname
		*m: fpdfannot_getformfieldtype
		*m: fpdfannot_getformfieldvalue
		*m: fpdfannot_getnumbervalue
		*m: fpdfannot_getoptioncount
		*m: fpdfannot_getoptionlabel
		*m: fpdfannot_getstringvalue
		*m: fpdfannot_ischecked
		*m: fpdfannot_isoptionselected
		*m: fpdfannot_setstringvalue
		*m: fpdfpage_closeannot
		*m: fpdfpage_getannot
		*m: fpdfpage_getannotcount
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Name = "pdfium_api_fpdf_annot"
		_memberdata = <VFPData>
			<memberdata name="fpdfpage_getannotcount" type="method" display="FPDFPage_GetAnnotCount"/>
			<memberdata name="fpdfpage_getannot" type="method" display="FPDFPage_GetAnnot"/>
			<memberdata name="fpdfpage_closeannot" type="method" display="FPDFPage_CloseAnnot"/>
			<memberdata name="fpdfannot_getformfieldname" type="method" display="FPDFAnnot_GetFormFieldName"/>
			<memberdata name="fpdfannot_getformfieldtype" type="method" display="FPDFAnnot_GetFormFieldType"/>
			<memberdata name="fpdfannot_getformfieldvalue" type="method" display="FPDFAnnot_GetFormFieldValue"/>
			<memberdata name="fpdfannot_getnumbervalue" type="method" display="FPDFAnnot_GetNumberValue"/>
			<memberdata name="fpdfannot_getstringvalue" type="method" display="FPDFAnnot_GetStringValue"/>
			<memberdata name="fpdfannot_getformfieldalternatename" type="method" display="FPDFAnnot_GetFormFieldAlternateName"/>
			<memberdata name="fpdfannot_getoptioncount" type="method" display="FPDFAnnot_GetOptionCount"/>
			<memberdata name="fpdfannot_getoptionlabel" type="method" display="FPDFAnnot_GetOptionLabel"/>
			<memberdata name="fpdfannot_isoptionselected" type="method" display="FPDFAnnot_IsOptionSelected"/>
			<memberdata name="fpdfannot_setstringvalue" type="method" display="FPDFAnnot_SetStringValue"/>
			<memberdata name="fpdfannot_ischecked" type="method" display="FPDFAnnot_IsChecked"/>
			<memberdata name="fpdfannot_getformcontrolcount" type="method" display="FPDFAnnot_GetFormControlCount"/>
			<memberdata name="fpdfannot_getformfieldexportvalue" type="method" display="FPDFAnnot_GetFormFieldExportValue"/>
			<memberdata name="fpdfannot_getformfieldflags" type="method" display="FPDFAnnot_GetFormFieldFlags"/>
		</VFPData>
		CONST.Name = "CONST"
	*</PropValue>
	
	PROCEDURE fpdfannot_getformcontrolcount
		LPARAMETERS hHandle as Long, annot as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_GetFormControlCount(m.hHandle, m.annot)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFAnnot_GetFormControlCount IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_GetFormControlCount LONG hHandle, LONG annot
		    m.lvRes = FPDF_FPDFAnnot_GetFormControlCount(m.hHandle, m.annot)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_getformfieldalternatename
		LPARAMETERS hHandle as Long, annot as Long, buffer as String, buflen as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_GetFormFieldAlternateName(m.hHandle, m.annot, @m.buffer, m.buflen)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFAnnot_GetFormFieldAlternateName IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_GetFormFieldAlternateName LONG hHandle, LONG annot, STRING @buffer, LONG buflen
		    m.lvRes = FPDF_FPDFAnnot_GetFormFieldAlternateName(m.hHandle, m.annot, @m.buffer, m.buflen)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_getformfieldexportvalue
		LPARAMETERS hHandle as Long, annot as Long, buffer as String, buflen as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_GetFormFieldExportValue(m.hHandle, m.annot, @m.buffer, m.buflen)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFAnnot_GetFormFieldExportValue IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_GetFormFieldExportValue LONG hHandle, LONG annot, STRING @buffer, LONG buflen
		    m.lvRes = FPDF_FPDFAnnot_GetFormFieldExportValue(m.hHandle, m.annot, @m.buffer, m.buflen)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_getformfieldflags
		LPARAMETERS hHandle as Long, annot as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_GetFormFieldFlags(m.hHandle, m.annot)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFAnnot_GetFormFieldFlags IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_GetFormFieldFlags LONG hHandle, LONG annot
		    m.lvRes = FPDF_FPDFAnnot_GetFormFieldFlags(m.hHandle, m.annot)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_getformfieldname
		LPARAMETERS hHandle as Long, annot as Long, buffer as String, buflen as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_GetFormFieldName(m.hHandle, m.annot, @m.buffer, m.buflen)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFAnnot_GetFormFieldName IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_GetFormFieldName LONG hHandle, LONG annot, STRING @buffer, LONG buflen
		    m.lvRes = FPDF_FPDFAnnot_GetFormFieldName(m.hHandle, m.annot, @m.buffer, m.buflen)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_getformfieldtype
		LPARAMETERS hHandle as Long, annot as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_GetFormFieldType(m.hHandle, m.annot)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFAnnot_GetFormFieldType IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_GetFormFieldType LONG hHandle, LONG annot
		    m.lvRes = FPDF_FPDFAnnot_GetFormFieldType(m.hHandle, m.annot)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_getformfieldvalue
		LPARAMETERS hHandle as Long, annot as Long, buffer as String, buflen as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_GetFormFieldValue(m.hHandle, m.annot, @m.buffer, m.buflen)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFAnnot_GetFormFieldValue IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_GetFormFieldValue LONG hHandle, LONG annot, STRING @buffer, LONG buflen
		    m.lvRes = FPDF_FPDFAnnot_GetFormFieldValue(m.hHandle, m.annot, @m.buffer, m.buflen)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_getnumbervalue
		LPARAMETERS annot as Long, key as String, value as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_GetNumberValue(m.annot, m.key, @m.value)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFAnnot_GetNumberValue IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_GetNumberValue LONG annot, STRING key, DOUBLE @value
		    m.lvRes = FPDF_FPDFAnnot_GetNumberValue(m.annot, m.key, @m.value)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_getoptioncount
		LPARAMETERS hHandle as Long, annot as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_GetOptionCount(m.hHandle, m.annot)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFAnnot_GetOptionCount IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_GetOptionCount LONG hHandle, LONG annot
		    m.lvRes = FPDF_FPDFAnnot_GetOptionCount(m.hHandle, m.annot)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_getoptionlabel
		LPARAMETERS hHandle as Long, annot as Long, index as Integer, buffer as String, buflen as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_GetOptionLabel(m.hHandle, m.annot, m.index, @m.buffer, m.buflen)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFAnnot_GetOptionLabel IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_GetOptionLabel LONG hHandle, LONG annot, INTEGER index, STRING @buffer, LONG buflen
		    m.lvRes = FPDF_FPDFAnnot_GetOptionLabel(m.hHandle, m.annot, m.index, @m.buffer, m.buflen)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_getstringvalue
		LPARAMETERS annot as Long, key as String, buffer as String, buflen as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_GetStringValue(m.annot, m.key, @m.buffer, m.buflen)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFAnnot_GetStringValue IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_GetStringValue LONG annot, STRING key, STRING @buffer, LONG buflen
		    m.lvRes = FPDF_FPDFAnnot_GetStringValue(m.annot, m.key, @m.buffer, m.buflen)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_ischecked
		LPARAMETERS hHandle as Long, annot as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_IsChecked(m.hHandle, m.annot)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFAnnot_IsChecked IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_IsChecked LONG hHandle, LONG annot
		    m.lvRes = FPDF_FPDFAnnot_IsChecked(m.hHandle, m.annot)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_isoptionselected
		LPARAMETERS hHandle as Long, annot as Long, index as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_IsOptionSelected(m.hHandle, m.annot, m.index)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFAnnot_IsOptionSelected IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_IsOptionSelected LONG hHandle, LONG annot, INTEGER index
		    m.lvRes = FPDF_FPDFAnnot_IsOptionSelected(m.hHandle, m.annot, m.index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfannot_setstringvalue
		LPARAMETERS annot as Long, key as String, value as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFAnnot_SetStringValue(m.annot, m.key, m.value)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFAnnot_SetStringValue IN (This.pdfium_dll_path) AS FPDF_FPDFAnnot_SetStringValue LONG annot, STRING key, STRING value
		    m.lvRes = FPDF_FPDFAnnot_SetStringValue(m.annot, m.key, m.value)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_closeannot
		LPARAMETERS annot as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFPage_CloseAnnot(m.annot)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDFPage_CloseAnnot IN (This.pdfium_dll_path) AS FPDF_FPDFPage_CloseAnnot LONG annot
		    m.lvRes = FPDF_FPDFPage_CloseAnnot(m.annot)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_getannot
		LPARAMETERS page as Long, index as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFPage_GetAnnot(m.page, m.index)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FPDFPage_GetAnnot IN (This.pdfium_dll_path) AS FPDF_FPDFPage_GetAnnot LONG page, INTEGER index
		    m.lvRes = FPDF_FPDFPage_GetAnnot(m.page, m.index)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_getannotcount
		LPARAMETERS page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FPDFPage_GetAnnotCount(m.page)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFPage_GetAnnotCount IN (This.pdfium_dll_path) AS FPDF_FPDFPage_GetAnnotCount LONG page
		    m.lvRes = FPDF_FPDFPage_GetAnnotCount(m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_fpdf_base AS custom 		&& Pdfium API wrapper
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="CONST" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: pdfium_vfp_dll_path_access
		*p: pdfium_dll_path		&& Path to file pdfium.dll
		*p: pdfium_vfp_dll_path
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,pdfium_vfp_dll_path,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_fpdf_base"
		pdfium_dll_path = ("")
		pdfium_vfp_dll_path = ("")
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="pdfium_dll_path" type="property" display="pdfium_dll_path"/>
			<memberdata name="pdfium_vfp_dll_path" type="property" display="pdfium_vfp_dll_path"/>
			<memberdata name="pdfium_vfp_dll_path_access" type="method" display="pdfium_vfp_dll_path_access"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'CONST' AS pdfium_api_fpdf_const WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "CONST", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	HIDDEN PROCEDURE pdfium_vfp_dll_path_access
		RETURN ADDBS(JUSTPATH(This.pdfium_dll_path)) + IIF(ATC("x64", SYS(17))<>0, "pdfium-vfp64.dll", "pdfium-vfp.dll")
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_fpdf_const AS custom 		&& Pdfium API constants
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: fpdfbitmap_bgr
		*m: fpdfbitmap_bgra
		*m: fpdfbitmap_bgrx
		*m: fpdfbitmap_gray
		*m: fpdfbitmap_unknown
		*m: fpdf_err_file
		*m: fpdf_err_format
		*m: fpdf_err_page
		*m: fpdf_err_password
		*m: fpdf_err_security
		*m: fpdf_err_unknown
		*m: fpdf_fillmode_alternate
		*m: fpdf_fillmode_none
		*m: fpdf_fillmode_winding
		*m: fpdf_font_truetype
		*m: fpdf_font_type1
		*m: fpdf_formfield_checkbox
		*m: fpdf_formfield_combobox
		*m: fpdf_formfield_listbox
		*m: fpdf_formfield_pushbutton
		*m: fpdf_formfield_radiobutton
		*m: fpdf_formfield_signature
		*m: fpdf_formfield_textfield
		*m: fpdf_formfield_unknown
		*m: fpdf_formflag_choice_combo
		*m: fpdf_formflag_choice_edit
		*m: fpdf_formflag_choice_multi_select
		*m: fpdf_formflag_noexport
		*m: fpdf_formflag_readonly
		*m: fpdf_formflag_required
		*m: fpdf_pageobj_form
		*m: fpdf_pageobj_image
		*m: fpdf_pageobj_path
		*m: fpdf_pageobj_shading
		*m: fpdf_pageobj_text
		*m: fpdf_pageobj_unknown
		*m: fpdf_printing
		*m: fpdf_textrendermode_fill
		*m: fpdf_textrendermode_fill_stroke
		*m: fpdf_textrendermode_stroke
		*m: fpdf_textrendermode_unknown
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_fpdf_const"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="fpdf_err_password" type="method" display="FPDF_ERR_PASSWORD"/>
			<memberdata name="fpdf_printing" type="method" display="FPDF_PRINTING"/>
			<memberdata name="fpdf_pageobj_form" type="method" display="FPDF_PAGEOBJ_FORM"/>
			<memberdata name="fpdf_pageobj_image" type="method" display="FPDF_PAGEOBJ_IMAGE"/>
			<memberdata name="fpdf_pageobj_path" type="method" display="FPDF_PAGEOBJ_PATH"/>
			<memberdata name="fpdf_pageobj_shading" type="method" display="FPDF_PAGEOBJ_SHADING"/>
			<memberdata name="fpdf_pageobj_text" type="method" display="FPDF_PAGEOBJ_TEXT"/>
			<memberdata name="fpdf_pageobj_unknown" type="method" display="FPDF_PAGEOBJ_UNKNOWN"/>
			<memberdata name="fpdf_font_truetype" type="method" display="FPDF_FONT_TRUETYPE"/>
			<memberdata name="fpdf_font_type1" type="method" display="FPDF_FONT_TYPE1"/>
			<memberdata name="fpdf_fillmode_alternate" type="method" display="FPDF_FILLMODE_ALTERNATE"/>
			<memberdata name="fpdf_fillmode_none" type="method" display="FPDF_FILLMODE_NONE"/>
			<memberdata name="fpdf_fillmode_winding" type="method" display="FPDF_FILLMODE_WINDING"/>
			<memberdata name="fpdf_textrendermode_fill" type="method" display="FPDF_TEXTRENDERMODE_FILL"/>
			<memberdata name="fpdf_textrendermode_fill_stroke" type="method" display="FPDF_TEXTRENDERMODE_FILL_STROKE"/>
			<memberdata name="fpdf_textrendermode_stroke" type="method" display="FPDF_TEXTRENDERMODE_STROKE"/>
			<memberdata name="fpdf_textrendermode_unknown" type="method" display="FPDF_TEXTRENDERMODE_UNKNOWN"/>
			<memberdata name="fpdfbitmap_bgr" type="method" display="FPDFBitmap_BGR"/>
			<memberdata name="fpdfbitmap_bgra" type="method" display="FPDFBitmap_BGRA"/>
			<memberdata name="fpdfbitmap_bgrx" type="method" display="FPDFBitmap_BGRx"/>
			<memberdata name="fpdfbitmap_gray" type="method" display="FPDFBitmap_Gray"/>
			<memberdata name="fpdfbitmap_unknown" type="method" display="FPDFBitmap_Unknown"/>
			<memberdata name="fpdf_formfield_checkbox" type="method" display="FPDF_FORMFIELD_CHECKBOX"/>
			<memberdata name="fpdf_formfield_combobox" type="method" display="FPDF_FORMFIELD_COMBOBOX"/>
			<memberdata name="fpdf_formfield_listbox" type="method" display="FPDF_FORMFIELD_LISTBOX"/>
			<memberdata name="fpdf_formfield_pushbutton" type="method" display="FPDF_FORMFIELD_PUSHBUTTON"/>
			<memberdata name="fpdf_formfield_radiobutton" type="method" display="FPDF_FORMFIELD_RADIOBUTTON"/>
			<memberdata name="fpdf_formfield_signature" type="method" display="FPDF_FORMFIELD_SIGNATURE"/>
			<memberdata name="fpdf_formfield_textfield" type="method" display="FPDF_FORMFIELD_TEXTFIELD"/>
			<memberdata name="fpdf_formfield_unknown" type="method" display="FPDF_FORMFIELD_UNKNOWN"/>
			<memberdata name="fpdf_err_file" type="method" display="FPDF_ERR_FILE"/>
			<memberdata name="fpdf_err_format" type="method" display="FPDF_ERR_FORMAT"/>
			<memberdata name="fpdf_err_page" type="method" display="FPDF_ERR_PAGE"/>
			<memberdata name="fpdf_err_security" type="method" display="FPDF_ERR_SECURITY"/>
			<memberdata name="fpdf_err_unknown" type="method" display="FPDF_ERR_UNKNOWN"/>
			<memberdata name="fpdf_formflag_choice_combo" type="method" display="FPDF_FORMFLAG_CHOICE_COMBO"/>
			<memberdata name="fpdf_formflag_choice_edit" type="method" display="FPDF_FORMFLAG_CHOICE_EDIT"/>
			<memberdata name="fpdf_formflag_choice_multi_select" type="method" display="FPDF_FORMFLAG_CHOICE_MULTI_SELECT"/>
			<memberdata name="fpdf_formflag_noexport" type="method" display="FPDF_FORMFLAG_NOEXPORT"/>
			<memberdata name="fpdf_formflag_readonly" type="method" display="FPDF_FORMFLAG_READONLY"/>
			<memberdata name="fpdf_formflag_required" type="method" display="FPDF_FORMFLAG_REQUIRED"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE fpdfbitmap_bgr
		RETURN 2
		
	ENDPROC

	PROCEDURE fpdfbitmap_bgra
		RETURN 4
		
	ENDPROC

	PROCEDURE fpdfbitmap_bgrx
		RETURN 3
		
	ENDPROC

	PROCEDURE fpdfbitmap_gray
		RETURN 1
		
	ENDPROC

	PROCEDURE fpdfbitmap_unknown
		RETURN 0
		
	ENDPROC

	PROCEDURE fpdf_err_file
		RETURN 2
		
	ENDPROC

	PROCEDURE fpdf_err_format
		RETURN 3
		
	ENDPROC

	PROCEDURE fpdf_err_page
		RETURN 6
		
	ENDPROC

	PROCEDURE fpdf_err_password
		RETURN 4
		
	ENDPROC

	PROCEDURE fpdf_err_security
		RETURN 5
		
	ENDPROC

	PROCEDURE fpdf_err_unknown
		RETURN 1
		
	ENDPROC

	PROCEDURE fpdf_fillmode_alternate
		RETURN 1
		
	ENDPROC

	PROCEDURE fpdf_fillmode_none
		RETURN 0
		
	ENDPROC

	PROCEDURE fpdf_fillmode_winding
		RETURN 2
		
	ENDPROC

	PROCEDURE fpdf_font_truetype
		RETURN 2
		
	ENDPROC

	PROCEDURE fpdf_font_type1
		RETURN 1
		
	ENDPROC

	PROCEDURE fpdf_formfield_checkbox
		RETURN 2
	ENDPROC

	PROCEDURE fpdf_formfield_combobox
		RETURN 4
	ENDPROC

	PROCEDURE fpdf_formfield_listbox
		RETURN 5
	ENDPROC

	PROCEDURE fpdf_formfield_pushbutton
		RETURN 1
	ENDPROC

	PROCEDURE fpdf_formfield_radiobutton
		RETURN 3
	ENDPROC

	PROCEDURE fpdf_formfield_signature
		RETURN 7
	ENDPROC

	PROCEDURE fpdf_formfield_textfield
		RETURN 6
	ENDPROC

	PROCEDURE fpdf_formfield_unknown
		RETURN 0
	ENDPROC

	PROCEDURE fpdf_formflag_choice_combo
		RETURN 131072
		
	ENDPROC

	PROCEDURE fpdf_formflag_choice_edit
		RETURN 262144
		
	ENDPROC

	PROCEDURE fpdf_formflag_choice_multi_select
		RETURN 2097152
		
	ENDPROC

	PROCEDURE fpdf_formflag_noexport
		RETURN 4
	ENDPROC

	PROCEDURE fpdf_formflag_readonly
		RETURN 1
	ENDPROC

	PROCEDURE fpdf_formflag_required
		RETURN 2
	ENDPROC

	PROCEDURE fpdf_pageobj_form
		RETURN 5
		
	ENDPROC

	PROCEDURE fpdf_pageobj_image
		RETURN 3
		
	ENDPROC

	PROCEDURE fpdf_pageobj_path
		RETURN 2
		
	ENDPROC

	PROCEDURE fpdf_pageobj_shading
		RETURN 4
		
	ENDPROC

	PROCEDURE fpdf_pageobj_text
		RETURN 1
		
	ENDPROC

	PROCEDURE fpdf_pageobj_unknown
		RETURN 0
		
	ENDPROC

	PROCEDURE fpdf_printing
		RETURN 0x800
		
	ENDPROC

	PROCEDURE fpdf_textrendermode_fill
		RETURN 0
		
	ENDPROC

	PROCEDURE fpdf_textrendermode_fill_stroke
		RETURN 2
		
	ENDPROC

	PROCEDURE fpdf_textrendermode_stroke
		RETURN 1
		
	ENDPROC

	PROCEDURE fpdf_textrendermode_unknown
		RETURN -1
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_fpdf_forms AS pdfium_api_fpdf_base OF "pdfium-vfp.vcx" 		&& Pdfium API wrapper
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: form_forcetokillfocus
		*m: form_getfocusedannot
		*m: form_getselectedtext
		*m: form_onafterloadpage
		*m: form_onbeforeclosepage
		*m: form_onchar
		*m: form_onfocus
		*m: form_onkeydown
		*m: form_onlbuttondoubleclick
		*m: form_onlbuttondown
		*m: form_onlbuttonup
		*m: form_onmousemove
		*m: form_replaceselection
		*m: form_selectalltext
		*m: form_setfocusedannot
		*m: form_setindexselected
		*m: fpdfpage_hasformfieldatpoint
		*m: fpdf_ffldraw
		*m: fpdf_setformfieldhighlightalpha
		*m: fpdf_setformfieldhighlightcolor
		*m: vfpdfdoc_exitformfillenvironment
		*m: vfpdfdoc_initformfillenvironment
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_fpdf_forms"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="vfpdfdoc_initformfillenvironment" type="method" display="VFPDFDOC_InitFormFillEnvironment"/>
			<memberdata name="fpdf_ffldraw" type="method" display="FPDF_FFLDraw"/>
			<memberdata name="fpdf_setformfieldhighlightcolor" type="method" display="FPDF_SetFormFieldHighlightColor"/>
			<memberdata name="fpdf_setformfieldhighlightalpha" type="method" display="FPDF_SetFormFieldHighlightAlpha"/>
			<memberdata name="form_onafterloadpage" type="method" display="Form_OnAfterLoadPage"/>
			<memberdata name="form_onbeforeclosepage" type="method" display="Form_OnBeforeClosePage"/>
			<memberdata name="form_onchar" type="method" display="Form_OnChar"/>
			<memberdata name="form_onfocus" type="method" display="Form_OnFocus"/>
			<memberdata name="form_onkeydown" type="method" display="Form_OnKeyDown"/>
			<memberdata name="form_onlbuttondown" type="method" display="Form_OnLButtonDown"/>
			<memberdata name="form_onlbuttonup" type="method" display="Form_OnLButtonUp"/>
			<memberdata name="form_onmousemove" type="method" display="Form_OnMouseMove"/>
			<memberdata name="fpdfpage_hasformfieldatpoint" type="method" display="FPDFPage_HasFormFieldAtPoint"/>
			<memberdata name="vfpdfdoc_exitformfillenvironment" type="method" display="VFPDFDOC_ExitFormFillEnvironment"/>
			<memberdata name="form_getfocusedannot" type="method" display="FORM_GetFocusedAnnot"/>
			<memberdata name="form_forcetokillfocus" type="method" display="FORM_ForceToKillFocus"/>
			<memberdata name="form_onlbuttondoubleclick" type="method" display="FORM_OnLButtonDoubleClick"/>
			<memberdata name="form_getselectedtext" type="method" display="FORM_GetSelectedText"/>
			<memberdata name="form_selectalltext" type="method" display="FORM_SelectAllText"/>
			<memberdata name="form_replaceselection" type="method" display="FORM_ReplaceSelection"/>
			<memberdata name="form_setfocusedannot" type="method" display="FORM_SetFocusedAnnot"/>
			<memberdata name="form_setindexselected" type="method" display="FORM_SetIndexSelected"/>
		</VFPData>
		CONST.Name = "CONST"
	*</PropValue>
	
	PROCEDURE form_forcetokillfocus
		LPARAMETERS hHandle as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_ForceToKillFocus(m.hHandle)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FORM_ForceToKillFocus IN (This.pdfium_dll_path) AS FPDF_FORM_ForceToKillFocus LONG hHandle
		    m.lvRes = FPDF_FORM_ForceToKillFocus(m.hHandle)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_getfocusedannot
		LPARAMETERS handle as Long, page_index as Long, annot as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_GetFocusedAnnot(m.handle, @m.page_index, @m.annot)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FORM_GetFocusedAnnot IN (This.pdfium_dll_path) AS FPDF_FORM_GetFocusedAnnot LONG handle, LONG @page_index, LONG @annot
		    m.lvRes = FPDF_FORM_GetFocusedAnnot(m.handle, @m.page_index, @m.annot)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_getselectedtext
		LPARAMETERS hHandle as Long, page as Long, buffer as String, buflen as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_GetSelectedText(m.hHandle, m.page, @m.buffer, m.buflen)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FORM_GetSelectedText IN (This.pdfium_dll_path) AS FPDF_FORM_GetSelectedText LONG hHandle, LONG page, STRING @modifier, long buflen
		    m.lvRes = FPDF_FORM_GetSelectedText(m.hHandle, m.page, @m.buffer, m.buflen)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_onafterloadpage
		LPARAMETERS page as Long, hHandle as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_OnAfterLoadPage(m.page, m.hHandle)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FORM_OnAfterLoadPage IN (This.pdfium_dll_path) AS FPDF_FORM_OnAfterLoadPage LONG page, LONG hHandle
		    m.lvRes = FPDF_FORM_OnAfterLoadPage(m.page, m.hHandle)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_onbeforeclosepage
		LPARAMETERS page as Long, hHandle as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_OnBeforeClosePage(m.page, m.hHandle)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FORM_OnBeforeClosePage IN (This.pdfium_dll_path) AS FPDF_FORM_OnBeforeClosePage LONG page, LONG hHandle
		    m.lvRes = FPDF_FORM_OnBeforeClosePage(m.page, m.hHandle)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_onchar
		LPARAMETERS hHandle as Long, page as Long, nChar as Integer, modifier as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_OnChar(m.hHandle, m.page, m.nChar, m.modifier)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FORM_OnChar IN (This.pdfium_dll_path) AS FPDF_FORM_OnChar LONG hHandle, LONG page, INTEGER nChar, INTEGER modifier
		    m.lvRes = FPDF_FORM_OnChar(m.hHandle, m.page, m.nChar, m.modifier)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_onfocus
		LPARAMETERS hHandle as Long, page as Long, modifier as Integer, page_x as Double, page_y as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_OnFocus(m.hHandle, m.page, m.modifier, m.page_x, m.page_y)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FORM_OnFocus IN (This.pdfium_dll_path) AS FPDF_FORM_OnFocus LONG hHandle, LONG page, INTEGER modifier, double page_x, double page_y
		    m.lvRes = FPDF_FORM_OnFocus(m.hHandle, m.page, m.modifier, m.page_x, m.page_y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_onkeydown
		LPARAMETERS hHandle as Long, page as Long, nKeyCode as Integer, modifier as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_OnKeyDown(m.hHandle, m.page, m.nKeyCode, m.modifier)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FORM_OnKeyDown IN (This.pdfium_dll_path) AS FPDF_FORM_OnKeyDown LONG hHandle, LONG page, INTEGER nKeyCode, INTEGER modifier
		    m.lvRes = FPDF_FORM_OnKeyDown(m.hHandle, m.page, m.nKeyCode, m.modifier)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_onlbuttondoubleclick
		LPARAMETERS hHandle as Long, page as Long, modifier as Integer, page_x as Double, page_y as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_OnLButtonDoubleClick(m.hHandle, m.page, m.modifier, m.page_x, m.page_y)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FORM_OnLButtonDoubleClick IN (This.pdfium_dll_path) AS FPDF_FORM_OnLButtonDoubleClick LONG hHandle, LONG page, INTEGER modifier, double page_x, double page_y
		    m.lvRes = FPDF_FORM_OnLButtonDoubleClick(m.hHandle, m.page, m.modifier, m.page_x, m.page_y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_onlbuttondown
		LPARAMETERS hHandle as Long, page as Long, modifier as Integer, page_x as Double, page_y as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_OnLButtonDown(m.hHandle, m.page, m.modifier, m.page_x, m.page_y)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FORM_OnLButtonDown IN (This.pdfium_dll_path) AS FPDF_FORM_OnLButtonDown LONG hHandle, LONG page, INTEGER modifier, double page_x, double page_y
		    m.lvRes = FPDF_FORM_OnLButtonDown(m.hHandle, m.page, m.modifier, m.page_x, m.page_y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_onlbuttonup
		LPARAMETERS hHandle as Long, page as Long, modifier as Integer, page_x as Double, page_y as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_OnLButtonUp(m.hHandle, m.page, m.modifier, m.page_x, m.page_y)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FORM_OnLButtonUp IN (This.pdfium_dll_path) AS FPDF_FORM_OnLButtonUp LONG hHandle, LONG page, INTEGER modifier, double page_x, double page_y
		    m.lvRes = FPDF_FORM_OnLButtonUp(m.hHandle, m.page, m.modifier, m.page_x, m.page_y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_onmousemove
		LPARAMETERS hHandle as Long, page as Long, modifier as Integer, page_x as Double, page_y as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_OnMouseMove(m.hHandle, m.page, m.modifier, m.page_x, m.page_y)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FORM_OnMouseMove IN (This.pdfium_dll_path) AS FPDF_FORM_OnMouseMove LONG hHandle, LONG page, INTEGER modifier, double page_x, double page_y
		    m.lvRes = FPDF_FORM_OnMouseMove(m.hHandle, m.page, m.modifier, m.page_x, m.page_y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_replaceselection
		LPARAMETERS hHandle as Long, page as Long, wsText as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_ReplaceSelection(m.hHandle, m.page, m.wsText)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FORM_ReplaceSelection IN (This.pdfium_dll_path) AS FPDF_FORM_ReplaceSelection LONG hHandle, LONG page, STRING wsText
		    m.lvRes = FPDF_FORM_ReplaceSelection(m.hHandle, m.page, m.wsText)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_selectalltext
		LPARAMETERS hHandle as Long, page as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_SelectAllText(m.hHandle, m.page)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FORM_SelectAllText IN (This.pdfium_dll_path) AS FPDF_FORM_SelectAllText LONG hHandle, LONG page
		    m.lvRes = FPDF_FORM_SelectAllText(m.hHandle, m.page)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_setfocusedannot
		LPARAMETERS hHandle as Long, annot as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_SetFocusedAnnot(m.hHandle, m.annot)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FORM_SetFocusedAnnot IN (This.pdfium_dll_path) AS FPDF_FORM_SetFocusedAnnot LONG hHandle, LONG annot
		    m.lvRes = FPDF_FORM_SetFocusedAnnot(m.hHandle, m.annot)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE form_setindexselected
		LPARAMETERS hHandle as Long, page as Long, index as Long, selected as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FORM_SetIndexSelected(m.hHandle, m.page, m.index, m.selected)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG FORM_SetIndexSelected IN (This.pdfium_dll_path) AS FPDF_FORM_SetIndexSelected LONG hHandle, LONG page, LONG index, LONG selected
		    m.lvRes = FPDF_FORM_SetIndexSelected(m.hHandle, m.page, m.index, m.selected)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdfpage_hasformfieldatpoint
		LPARAMETERS hHandle as Long, page as Long, page_x as Double, page_y as Double
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDFPage_HasFormFieldAtPoint(m.hHandle, m.page, m.page_x, m.page_y)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FPDFPage_HasFormFieldAtPoint IN (This.pdfium_dll_path) AS FPDFPage_HasFormFieldAtPoint LONG hHandle, LONG page, double page_x, double page_y
		    m.lvRes = FPDFPage_HasFormFieldAtPoint(m.hHandle, m.page, m.page_x, m.page_y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_ffldraw
		LPARAMETERS hHandle as Long, bitmap as Long, page as Long, start_x as Integer, start_y as Integer, size_x as Integer, size_y as Integer, rotate as Integer, flags as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_FFLDraw(m.hHandle, m.bitmap, m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.flags)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDF_FFLDraw IN (This.pdfium_dll_path) AS FPDF_FFLDraw LONG hHandle, LONG bitmap, LONG page, integer start_x, integer start_y, integer size_x, integer size_y, integer rotate, integer flags
		    m.lvRes = FPDF_FFLDraw(m.hHandle, m.bitmap, m.page, m.start_x, m.start_y, m.size_x, m.size_y, m.rotate, m.flags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_setformfieldhighlightalpha
		LPARAMETERS hHandle as Long, alpha as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_SetFormFieldHighlightAlpha(m.hHandle, m.alpha)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDF_SetFormFieldHighlightAlpha IN (This.pdfium_dll_path) AS FPDF_SetFormFieldHighlightAlpha LONG hHandle, INTEGER alpha
		    m.lvRes = FPDF_SetFormFieldHighlightAlpha(m.hHandle, m.alpha)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE fpdf_setformfieldhighlightcolor
		LPARAMETERS hHandle as Long, fieldType as Integer, color as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = FPDF_SetFormFieldHighlightColor(m.hHandle, m.fieldType, m.color)
		CATCH
		    SET CONSOLE OFF
		    DECLARE FPDF_SetFormFieldHighlightColor IN (This.pdfium_dll_path) AS FPDF_SetFormFieldHighlightColor LONG hHandle, INTEGER fieldType, INTEGER color
		    m.lvRes = FPDF_SetFormFieldHighlightColor(m.hHandle, m.fieldType, m.color)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE vfpdfdoc_exitformfillenvironment
		LPARAMETERS hHandle as Long
		
		TRY
		    VFPDFDOC_ExitFormFillEnvironment(m.hHandle)
		CATCH
		    SET CONSOLE OFF
		    DECLARE VFPDFDOC_ExitFormFillEnvironment IN (This.pdfium_vfp_dll_path) AS VFPDFDOC_ExitFormFillEnvironment LONG hHandle
		    VFPDFDOC_ExitFormFillEnvironment(m.hHandle)
		ENDTRY
		
	ENDPROC

	PROCEDURE vfpdfdoc_initformfillenvironment
		LPARAMETERS document as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = VFPDFDOC_InitFormFillEnvironment(m.document)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG VFPDFDOC_InitFormFillEnvironment IN (This.pdfium_vfp_dll_path) AS VFPDFDOC_InitFormFillEnvironment LONG document
		    m.lvRes = VFPDFDOC_InitFormFillEnvironment(m.document)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_gdip AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="CONST" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: argb
		*m: checkerror
		*m: gdipbitmaplockbits
		*m: gdipbitmapsetresolution
		*m: gdipbitmapunlockbits
		*m: gdipclonefontfamily
		*m: gdipclonestringformat
		*m: gdipcreatebitmapfromfile
		*m: gdipcreatebitmapfromhbitmap
		*m: gdipcreatebitmapfromscan0
		*m: gdipcreatefont
		*m: gdipcreatefontfamilyfromname
		*m: gdipcreatefromhdc
		*m: gdipcreatefromhwnd
		*m: gdipcreatesolidfill
		*m: gdipcreatestringformat
		*m: gdipdeletebrush
		*m: gdipdeletefont
		*m: gdipdeletefontfamily
		*m: gdipdeletegraphics
		*m: gdipdeleteprivatefontcollection
		*m: gdipdeletestringformat
		*m: gdipdisposeimage
		*m: gdipdrawimagei
		*m: gdipdrawstring
		*m: gdipfillrectanglei
		*m: gdipflush
		*m: gdipgetcellascent
		*m: gdipgetcelldescent
		*m: gdipgetdpix
		*m: gdipgetdpiy
		*m: gdipgetemheight
		*m: gdipgetfamilyname
		*m: gdipgetfontcollectionfamilycount
		*m: gdipgetfontcollectionfamilylist
		*m: gdipgetfontheightgivendpi
		*m: gdipgetgenericfontfamilysansserif
		*m: gdipgetimageencoder
		*m: gdipgetimageencoders
		*m: gdipgetimageencoderssize
		*m: gdipgetimagegraphicscontext
		*m: gdipgetimageheight
		*m: gdipgetimagepixelformat
		*m: gdipgetimagewidth
		*m: gdipgetlinespacing
		*m: gdipisstyleavailable
		*m: gdipmeasurestring
		*m: gdipnewprivatefontcollection
		*m: gdipprivateaddfontfile
		*m: gdipsaveimagetofile
		*m: gdipscaleworldtransform
		*m: gdipsetcompositingmode
		*m: gdipsetcompositingquality
		*m: gdipsetinterpolationmode
		*m: gdipsetpixeloffsetmode
		*m: gdipsetsolidfillcolor
		*m: gdipsetstringformatalign
		*m: gdipsetstringformatflags
		*m: gdipsetstringformattrimming
		*m: gdipsettextcontrast
		*m: gdipsettextrenderinghint
		*m: gdipstringformatgetgenericdefault
		*m: gdipstringformatgetgenerictypographic
		*p: imageencoders
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,imageencoders,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		imageencoders = .F.
		Name = "pdfium_api_gdip"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="gdipdrawstring" type="method" display="GdipDrawString"/>
			<memberdata name="gdipmeasurestring" type="method" display="GdipMeasureString"/>
			<memberdata name="gdipcreatefontfamilyfromname" type="method" display="GdipCreateFontFamilyFromName"/>
			<memberdata name="gdipdeletefontfamily" type="method" display="GdipDeleteFontFamily"/>
			<memberdata name="gdipnewprivatefontcollection" type="method" display="GdipNewPrivateFontCollection"/>
			<memberdata name="gdipdeleteprivatefontcollection" type="method" display="GdipDeletePrivateFontCollection"/>
			<memberdata name="gdipprivateaddfontfile" type="method" display="GdipPrivateAddFontFile"/>
			<memberdata name="gdipgetfontcollectionfamilylist" type="method" display="GdipGetFontCollectionFamilyList"/>
			<memberdata name="gdipgetfontcollectionfamilycount" type="method" display="GdipGetFontCollectionFamilyCount"/>
			<memberdata name="gdipclonefontfamily" type="method" display="GdipCloneFontFamily"/>
			<memberdata name="gdipgetfamilyname" type="method" display="GdipGetFamilyName"/>
			<memberdata name="gdipgetgenericfontfamilysansserif" type="method" display="GdipGetGenericFontFamilySansSerif"/>
			<memberdata name="gdipcreatefont" type="method" display="GdipCreateFont"/>
			<memberdata name="gdipdeletefont" type="method" display="GdipDeleteFont"/>
			<memberdata name="gdipisstyleavailable" type="method" display="GdipIsStyleAvailable"/>
			<memberdata name="gdipgetfontheightgivendpi" type="method" display="GdipGetFontHeightGivenDPI"/>
			<memberdata name="gdipgetemheight" type="method" display="GdipGetEmHeight"/>
			<memberdata name="gdipgetcellascent" type="method" display="GdipGetCellAscent"/>
			<memberdata name="gdipgetcelldescent" type="method" display="GdipGetCellDescent"/>
			<memberdata name="gdipgetlinespacing" type="method" display="GdipGetLineSpacing"/>
			<memberdata name="gdipcreatefromhwnd" type="method" display="GdipCreateFromHWND"/>
			<memberdata name="gdipdeletegraphics" type="method" display="GdipDeleteGraphics"/>
			<memberdata name="checkerror" type="method" display="CheckError"/>
			<memberdata name="gdipcreatebitmapfromhbitmap" type="method" display="GdipCreateBitmapFromHBITMAP"/>
			<memberdata name="gdipdisposeimage" type="method" display="GdipDisposeImage"/>
			<memberdata name="gdipcreatebitmapfromfile" type="method" display="GdipCreateBitmapFromFile"/>
			<memberdata name="gdipgetimagewidth" type="method" display="GdipGetImageWidth"/>
			<memberdata name="gdipgetimageheight" type="method" display="GdipGetImageHeight"/>
			<memberdata name="gdipcreatebitmapfromscan0" type="method" display="GdipCreateBitmapFromScan0"/>
			<memberdata name="gdipgetimagepixelformat" type="method" display="GdipGetImagePixelFormat"/>
			<memberdata name="gdipgetimagegraphicscontext" type="method" display="GdipGetImageGraphicsContext"/>
			<memberdata name="gdipdrawimagei" type="method" display="GdipDrawImageI"/>
			<memberdata name="gdipsaveimagetofile" type="method" display="GdipSaveImageToFile"/>
			<memberdata name="gdipgetimageencoderssize" type="method" display="GdipGetImageEncodersSize"/>
			<memberdata name="gdipgetimageencoders" type="method" display="GdipGetImageEncoders"/>
			<memberdata name="gdipgetimageencoder" type="method" display="GdipGetImageEncoder"/>
			<memberdata name="imageencoders" type="property" display="ImageEncoders"/>
			<memberdata name="gdipcreatesolidfill" type="method" display="GdipCreateSolidFill"/>
			<memberdata name="gdipdeletebrush" type="method" display="GdipDeleteBrush"/>
			<memberdata name="argb" type="method" display="ARGB"/>
			<memberdata name="gdipfillrectanglei" type="method" display="GdipFillRectangleI"/>
			<memberdata name="gdipsetsolidfillcolor" type="method" display="GdipSetSolidFillColor"/>
			<memberdata name="gdipflush" type="method" display="GdipFlush"/>
			<memberdata name="gdipcreatefromhdc" type="method" display="GdipCreateFromHDC"/>
			<memberdata name="gdipstringformatgetgenericdefault" type="method" display="GdipStringFormatGetGenericDefault"/>
			<memberdata name="gdipstringformatgetgenerictypographic" type="method" display="GdipStringFormatGetGenericTypographic"/>
			<memberdata name="gdipdeletestringformat" type="method" display="GdipDeleteStringFormat"/>
			<memberdata name="gdipclonestringformat" type="method" display="GdipCloneStringFormat"/>
			<memberdata name="gdipcreatestringformat" type="method" display="GdipCreateStringFormat"/>
			<memberdata name="gdipsetstringformatflags" type="method" display="GdipSetStringFormatFlags"/>
			<memberdata name="gdipsetstringformattrimming" type="method" display="GdipSetStringFormatTrimming"/>
			<memberdata name="gdipsetstringformatalign" type="method" display="GdipSetStringFormatAlign"/>
			<memberdata name="gdipsetcompositingmode" type="method" display="GdipSetCompositingMode"/>
			<memberdata name="gdipsetcompositingquality" type="method" display="GdipSetCompositingQuality"/>
			<memberdata name="gdipsetinterpolationmode" type="method" display="GdipSetInterpolationMode"/>
			<memberdata name="gdipsetpixeloffsetmode" type="method" display="GdipSetPixelOffsetMode"/>
			<memberdata name="gdipsettextrenderinghint" type="method" display="GdipSetTextRenderingHint"/>
			<memberdata name="gdipsettextcontrast" type="method" display="GdipSetTextContrast"/>
			<memberdata name="gdipscaleworldtransform" type="method" display="GdipScaleWorldTransform"/>
			<memberdata name="gdipbitmaplockbits" type="method" display="GdipBitmapLockBits"/>
			<memberdata name="gdipbitmapunlockbits" type="method" display="GdipBitmapUnlockBits"/>
			<memberdata name="gdipbitmapsetresolution" type="method" display="GdipBitmapSetResolution"/>
			<memberdata name="gdipgetdpix" type="method" display="GdipGetDpiX"/>
			<memberdata name="gdipgetdpiy" type="method" display="GdipGetDpiY"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'CONST' AS pdfium_api_gdip_const WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "CONST", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE argb
		LPARAMETERS Alpha, RedOrRGB, Green, Blue
		
		LOCAL lnARGB
		m.lnARGB = 0
		
		DO CASE
		CASE PCOUNT() = 1
		    m.lnARGB = BITLSHIFT(BITAND(m.Alpha, 0xFF), 24) + 0x00FFFFFF
		
		CASE PCOUNT() = 2
		    LOCAL lnRGB
		    m.lnRGB = m.RedOrRGB
		    m.lnARGB = BITLSHIFT(BITAND(m.Alpha, 0xFF), 24)+;
		        BITLSHIFT(BITAND(m.lnRGB, 0x000000FF), 16)+;
		        BITAND(m.lnRGB, 0x0000FF00)+;
		        BITRSHIFT(BITAND(m.lnRGB, 0x00FF0000), 16)
		
		CASE PCOUNT() = 3
		    m.lnARGB = BITLSHIFT(0xFF, 24)+;
		        BITLSHIFT(BITAND(m.RedOrRGB, 0xFF), 16)+;
		        BITLSHIFT(BITAND(m.Green, 0xFF), 8)+;
		        BITAND(m.Blue, 0xFF)
		
		CASE PCOUNT() = 4
		    m.lnARGB = BITLSHIFT(BITAND(m.Alpha, 0xFF), 24)+;
		        BITLSHIFT(BITAND(m.RedOrRGB, 0xFF), 16)+;
		        BITLSHIFT(BITAND(m.Green, 0xFF), 8)+;
		        BITAND(m.Blue,0xFF)
		ENDCASE
		
		RETURN m.lnARGB
		
	ENDPROC

	PROCEDURE checkerror
		LPARAMETERS GdipStatus, NoRaiseError
		
		IF EMPTY(m.GdipStatus)
		    RETURN m.GdipStatus
		ENDIF
		
		IF m.NoRaiseError
		    RETURN m.GdipStatus
		ENDIF
		
		
		LOCAL lcErrMsg
		lcErrMsg = TEXTMERGE("Gdiplus function returned error status <<m.GdipStatus>>")
		
		LOCAL laStack(1), lnStackCount
		m.lnStackCount = ASTACKINFO(m.laStack)
		IF m.lnStackCount > 1
		    m.lcErrMsg = m.lcErrMsg + NVL(CHR(13) + EVL(m.laStack[m.lnStackCount-1, 6], NULL), "")
		ENDIF
		
		ERROR (m.lcErrMsg)
		
	ENDPROC

	PROCEDURE Destroy
		This.ImageEncoders = .F.
		
	ENDPROC

	PROCEDURE gdipbitmaplockbits
		LPARAMETERS bitmap as Long, rect as String, flags as Long, format as Long, lockedBitmapData as String
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipBitmapLockBits(m.bitmap, m.rect, m.flags, m.format, @m.lockedBitmapData)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipBitmapLockBits IN GDIPLUS.DLL AS WinApi_GdipBitmapLockBits Long bitmap, String rect, Long flags, Long format, String @lockedBitmapData
		
		    m.lvRes = WinApi_GdipBitmapLockBits(m.bitmap, m.rect, m.flags, m.format, @m.lockedBitmapData)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipbitmapsetresolution
		LPARAMETERS bitmap as Long, xdpi as Single, ydpi as Single
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipBitmapSetResolution(m.bitmap, m.xdpi, m.ydpi)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipBitmapSetResolution IN GDIPLUS.DLL AS WinApi_GdipBitmapSetResolution LONG bitmap, SINGLE xdpi, SINGLE ydpi
		
		    m.lvRes = WinApi_GdipBitmapSetResolution(m.bitmap, m.xdpi, m.ydpi)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipbitmapunlockbits
		LPARAMETERS bitmap as Long, lockedBitmapData as String
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipBitmapUnlockBits(m.bitmap, m.lockedBitmapData)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipBitmapUnlockBits IN GDIPLUS.DLL AS WinApi_GdipBitmapUnlockBits Long bitmap, String lockedBitmapData
		
		    m.lvRes = WinApi_GdipBitmapUnlockBits(m.bitmap, m.lockedBitmapData)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipclonefontfamily
		LPARAMETERS FontFamily as Long, ClonedFontFamily as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCloneFontFamily(m.FontFamily, @m.ClonedFontFamily)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipCloneFontFamily IN GDIPLUS.DLL AS WinApi_GdipCloneFontFamily Long FontFamily, Long @ClonedFontFamily
		
		    m.lvRes = WinApi_GdipCloneFontFamily(m.FontFamily, @m.ClonedFontFamily)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipclonestringformat
		LPARAMETERS StringFormat as Long, newFormat as Long
		
		m.newFormat = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCloneStringFormat(m.StringFormat, @m.newFormat)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipCloneStringFormat IN GDIPLUS.DLL AS WinApi_GdipCloneStringFormat Long StringFormat, Long @newFormat
		
		    m.lvRes = WinApi_GdipCloneStringFormat(m.StringFormat, @m.newFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatebitmapfromfile
		LPARAMETERS filename as String, bitmap as Long
		
		m.bitmap = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateBitmapFromFile(m.filename, @m.bitmap)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipCreateBitmapFromFile IN GDIPLUS.DLL AS WinApi_GdipCreateBitmapFromFile String filename, Long @bitmap
		
		    m.lvRes = WinApi_GdipCreateBitmapFromFile(m.filename, @m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatebitmapfromhbitmap
		LPARAMETERS hbitmap as Long, hpalette as Long, hGpBitmap as Long
		
		m.hGpBitmap = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateBitmapFromHBITMAP(m.hbitmap, m.hpalette, @m.hGpBitmap)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipCreateBitmapFromHBITMAP IN GDIPLUS.DLL AS WinApi_GdipCreateBitmapFromHBITMAP Long hbitmap, Long hpalette, Long @hGpBitmap
		
		    m.lvRes = WinApi_GdipCreateBitmapFromHBITMAP(m.hbitmap, m.hpalette, @m.hGpBitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatebitmapfromscan0
		LPARAMETERS width as Long, height as Long, stride as Long, format as Long, scan0 as String, bitmap as Long
		
		m.bitmap = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateBitmapFromScan0(m.width, m.height, m.stride, m.format, m.scan0, @m.bitmap)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipCreateBitmapFromScan0 IN GDIPLUS.DLL AS WinApi_GdipCreateBitmapFromScan0 Long width, Long height, Long stride, Long format, String scan0, Long @bitmap
		
		    m.lvRes = WinApi_GdipCreateBitmapFromScan0(m.width, m.height, m.stride, m.format, m.scan0, @m.bitmap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatefont
		LPARAMETERS FontFamily as Long, emSize as Single, Style as Long, Unit as Long, font as Long
		
		m.font = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateFont(m.FontFamily, m.emSize, m.Style, m.Unit, @m.font)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipCreateFont IN GDIPLUS.DLL AS WinApi_GdipCreateFont Long FontFamily, Single emSize, Long style, Long unit, Long @font
		
		    m.lvRes = WinApi_GdipCreateFont(m.FontFamily, m.emSize, m.Style, m.Unit, @m.font)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatefontfamilyfromname
		LPARAMETERS FaceName as String, FontCollection as Long, FontFamily as Long
		
		m.FontFamily = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateFontFamilyFromName(m.FaceName, m.FontCollection, @m.FontFamily)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipCreateFontFamilyFromName IN GDIPLUS.DLL AS WinApi_GdipCreateFontFamilyFromName String FaceName, Long FontCollection, Long @FontFamily
		
		    m.lvRes = WinApi_GdipCreateFontFamilyFromName(m.FaceName, m.FontCollection, @m.FontFamily)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatefromhdc
		LPARAMETERS hdc as Long, graphics as Long
		
		m.graphics = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateFromHDC(m.hdc, @m.graphics)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipCreateFromHDC IN GDIPLUS.DLL AS WinApi_GdipCreateFromHDC Long hdc, Long @graphics
		
		    m.lvRes = WinApi_GdipCreateFromHDC(m.hdc, @m.graphics)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatefromhwnd
		LPARAMETERS hwnd as Long, graphics as Long
		
		m.graphics = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateFromHWND(m.hwnd, @m.graphics)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipCreateFromHWND IN GDIPLUS.DLL AS WinApi_GdipCreateFromHWND Long hwnd, Long @graphics
		
		    m.lvRes = WinApi_GdipCreateFromHWND(m.hwnd, @m.graphics)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatesolidfill
		LPARAMETERS color as Long, brush as Long
		
		m.brush = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateSolidFill(m.color, @m.brush)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipCreateSolidFill IN GDIPLUS.DLL AS WinApi_GdipCreateSolidFill Long color, Long @brush
		
		    m.lvRes = WinApi_GdipCreateSolidFill(m.color, @m.brush)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipcreatestringformat
		LPARAMETERS formatAttributes as Integer, language as Integer, StringFormat as Long
		
		m.StringFormat = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipCreateStringFormat(m.formatAttributes, m.language, @m.StringFormat)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipCreateStringFormat IN GDIPLUS.DLL AS WinApi_GdipCreateStringFormat Integer formatAttributes, Integer language, Long @StringFormat
		
		    m.lvRes = WinApi_GdipCreateStringFormat(m.formatAttributes, m.language, @m.StringFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdeletebrush
		LPARAMETERS brush as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDeleteBrush(m.brush)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipDeleteBrush IN GDIPLUS.DLL AS WinApi_GdipDeleteBrush Long brush
		
		    m.lvRes = WinApi_GdipDeleteBrush(m.brush)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdeletefont
		LPARAMETERS font as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDeleteFont(m.font)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipDeleteFont IN GDIPLUS.DLL AS WinApi_GdipDeleteFont Long font
		
		    m.lvRes = WinApi_GdipDeleteFont(m.font)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdeletefontfamily
		LPARAMETERS FontFamily as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDeleteFontFamily(m.FontFamily)    
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipDeleteFontFamily IN GDIPLUS.DLL AS WinApi_GdipDeleteFontFamily Long FontFamily
		
		    m.lvRes = WinApi_GdipDeleteFontFamily(m.FontFamily)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdeletegraphics
		LPARAMETERS graphics as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDeleteGraphics(m.graphics)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipDeleteGraphics IN GDIPLUS.DLL AS WinApi_GdipDeleteGraphics Long graphics
		
		    m.lvRes = WinApi_GdipDeleteGraphics(m.graphics)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdeleteprivatefontcollection
		LPARAMETERS FontCollection as Long
		
		m.FontCollection = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDeletePrivateFontCollection(@m.FontCollection)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipDeletePrivateFontCollection IN GDIPLUS.DLL AS WinApi_GdipDeletePrivateFontCollection Long @FontCollection
		
		    m.lvRes = WinApi_GdipDeletePrivateFontCollection(@m.FontCollection)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdeletestringformat
		LPARAMETERS StringFormat as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDeleteStringFormat(m.StringFormat)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipDeleteStringFormat IN GDIPLUS.DLL AS WinApi_GdipDeleteStringFormat Long StringFormat
		
		    m.lvRes = WinApi_GdipDeleteStringFormat(m.StringFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdisposeimage
		LPARAMETERS image as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDisposeImage(m.image)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipDisposeImage IN GDIPLUS.DLL AS WinApi_GdipDisposeImage Long image
		
		    m.lvRes = WinApi_GdipDisposeImage(m.image)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdrawimagei
		LPARAMETERS graphics as Long, image as Long, x as Integer, y as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDrawImageI(m.graphics, m.image, m.x, m.y)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipDrawImageI IN GDIPLUS.DLL AS WinApi_GdipDrawImageI Long graphics, Long image, Integer x, Integer y
		
		    m.lvRes = WinApi_GdipDrawImageI(m.graphics, m.image, m.x, m.y)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipdrawstring
		LPARAMETERS graphics as Long, str as String, length as Long, thefont as Long, layoutRect as String, StringFormat as Long, brush as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipDrawString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, m.brush)
		CATCH
		    SET CONSOLE OFF
		    DECLARE Long GdipDrawString IN GDIPLUS.DLL AS WinApi_GdipDrawString Long graphics, String str, Long length, Long thefont, String @layoutRect, Long StringFormat, Long brush
		    m.lvRes = WinApi_GdipDrawString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, m.brush)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipfillrectanglei
		LPARAMETERS graphics as Long, brush as Long, x as Long, y as Long, width as Long, height as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipFillRectangleI(m.graphics, m.brush, m.x, m.y, m.width, m.height)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipFillRectangleI IN GDIPLUS.DLL AS WinApi_GdipFillRectangleI Long graphics, Long brush, Long x, Long y, Long width, Long height
		
		    m.lvRes = WinApi_GdipFillRectangleI(m.graphics, m.brush, m.x, m.y, m.width, m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipflush
		LPARAMETERS graphics as Long, intention as Long
		
		m.intention = EVL(m.intention, 0)
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipFlush(m.graphics, m.intention)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipFlush IN GDIPLUS.DLL AS WinApi_GdipFlush Long graphics, Long intention
		
		    m.lvRes = WinApi_GdipFlush(m.graphics, m.intention)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetcellascent
		LPARAMETERS family as Long, style as Long, CellAscent as Long
		
		m.CellAscent = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetCellAscent(m.family, m.style, @m.CellAscent)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetCellAscent IN GDIPLUS.DLL AS WinApi_GdipGetCellAscent Long family, Long style, Long @CellAscent
		
		    m.lvRes = WinApi_GdipGetCellAscent(m.family, m.style, @m.CellAscent)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetcelldescent
		LPARAMETERS family as Long, style as Long, CellDescent as Long
		
		m.CellDescent = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetCellDescent(m.family, m.style, @m.CellDescent)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetCellDescent IN GDIPLUS.DLL AS WinApi_GdipGetCellDescent Long family, Long style, Long @CellDescent
		
		    m.lvRes = WinApi_GdipGetCellDescent(m.family, m.style, @m.CellDescent)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetdpix
		LPARAMETERS graphics as Long, dpi as Single
		
		m.dpi = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetDpiX(m.graphics, @m.dpi)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetDpiX IN GDIPLUS.DLL AS WinApi_GdipGetDpiX LONG graphics, SINGLE @dpi
		
		    m.lvRes = WinApi_GdipGetDpiX(m.graphics, @m.dpi)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetdpiy
		LPARAMETERS graphics as Long, dpi as Single
		
		m.dpi = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetDpiY(m.graphics, @m.dpi)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetDpiY IN GDIPLUS.DLL AS WinApi_GdipGetDpiY LONG graphics, SINGLE @dpi
		
		    m.lvRes = WinApi_GdipGetDpiY(m.graphics, @m.dpi)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetemheight
		LPARAMETERS family as Long, style as Long, EmHeight as Long
		
		m.EmHeight = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetEmHeight(m.family, m.style, @m.EmHeight)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetEmHeight IN GDIPLUS.DLL AS WinApi_GdipGetEmHeight Long family, Long style, Long @EmHeight
		
		    m.lvRes = WinApi_GdipGetEmHeight(m.family, m.style, @m.EmHeight)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetfamilyname
		LPARAMETERS FontFamily as Long, Name as String, Language as Integer
		
		#define LF_FACESIZE 32
		
		m.Name = REPLICATE(CHR(0), LF_FACESIZE * 2)
		m.Language = EVL(NVL(m.Language,0),0)
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetFamilyName(m.FontFamily, @m.Name, m.Language)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetFamilyName IN GDIPLUS.DLL AS WinApi_GdipGetFamilyName Long FontFamily, String @Name, Integer Language
		
		    m.lvRes = WinApi_GdipGetFamilyName(m.FontFamily, @m.Name, m.Language)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetfontcollectionfamilycount
		LPARAMETERS FontCollection as Long, numFound as Long
		
		m.numFound = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetFontCollectionFamilyCount(m.FontCollection, @m.numFound)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetFontCollectionFamilyCount IN GDIPLUS.DLL AS WinApi_GdipGetFontCollectionFamilyCount Long fontCollection, Long @numFound
		
		    m.lvRes = WinApi_GdipGetFontCollectionFamilyCount(m.FontCollection, @m.numFound)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetfontcollectionfamilylist
		LPARAMETERS FontCollection as Long, numSought as Long, gpfamilies as String, numFound as Long
		
		m.gpfamilies = REPLICATE(CHR(0), m.numSought * 4)
		m.numFound = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetFontCollectionFamilyList(m.FontCollection, m.numSought, @m.gpfamilies, @m.numFound)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetFontCollectionFamilyList IN GDIPLUS.DLL AS WinApi_GdipGetFontCollectionFamilyList Long fontCollection, Long numSought, String @gpfamilies, Long @numFound
		
		    m.lvRes = WinApi_GdipGetFontCollectionFamilyList(m.FontCollection, m.numSought, @m.gpfamilies, @m.numFound)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetfontheightgivendpi
		LPARAMETERS font as Long, dpi as Single, height as Long
		
		m.height = 0.0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetFontHeightGivenDPI(m.font, m.dpi, @m.height)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetFontHeightGivenDPI IN GDIPLUS.DLL AS WinApi_GdipGetFontHeightGivenDPI Long font, Single dpi, Single @height
		
		    m.lvRes = WinApi_GdipGetFontHeightGivenDPI(m.font, m.dpi, @m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetgenericfontfamilysansserif
		LPARAMETERS nativeFamily as Long
		
		m.nativeFamily = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetGenericFontFamilySansSerif(@m.nativeFamily)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetGenericFontFamilySansSerif IN GDIPLUS.DLL AS WinApi_GdipGetGenericFontFamilySansSerif Long @nativeFamily
		
		    m.lvRes = WinApi_GdipGetGenericFontFamilySansSerif(@m.nativeFamily)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetimageencoder
		LPARAMETERS MimeType as String
		
		IF VARTYPE(This.ImageEncoders) != "O"
		    
		    This.ImageEncoders = NEWOBJECT("Collection")
		
		    #define ClsidOffset 0
		    #define MimeTypeOffset 48
		    #define ImageCodecInfoSize 76
		
		    #define HEAP_CREATE_ENABLE_EXECUTE 0x00040000
		    #define HEAP_ZERO_MEMORY 0x00000008
		
		    LOCAL lhHeap, lnHeapPtr
		    STORE 0 TO m.lhHeap, m.lnHeapPtr
		
		    TRY
		
		        LOCAL loWin as Pdfium_api_win OF pdfium-vfp.vcx
		        m.loWin = NEWOBJECT("pdfium_api_win", This.ClassLibrary)
		
		        LOCAL lnEncodersCount, lnBufSize
		        STORE 0 TO m.lnEncodersCount, m.lnBufSize
		
		        This.CheckError(This.GdipGetImageEncodersSize(@m.lnEncodersCount, @m.lnBufSize))
		
		        IF EMPTY(m.lnBufSize)
		            EXIT
		        ENDIF
		
		        m.lhHeap = m.loWin.HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, m.lnBufSize, m.lnBufSize)
		        IF EMPTY(m.lhHeap)
		            EXIT
		        ENDIF
		
		        m.lnHeapPtr = m.loWin.HeapAlloc(m.lhHeap, HEAP_ZERO_MEMORY, m.lnBufSize)
		        IF EMPTY(m.lnHeapPtr)
		            EXIT
		        ENDIF
		
		        This.CheckError(This.GdipGetImageEncoders(m.lnEncodersCount, m.lnBufSize, m.lnHeapPtr))
		        
		        LOCAL liEncoder, lnEncPtr
		        m.liEncoder = 1
		        FOR m.liEncoder = 1 TO m.lnEncodersCount
		            
		            m.lnEncPtr = m.lnHeapPtr + (m.liEncoder - 1) * ImageCodecInfoSize
		
		            LOCAL lnMimeTypePtr
		            m.lnMimeTypePtr = CTOBIN(SYS(2600, m.lnEncPtr + MimeTypeOffset, 4), "4RS")
		            
		            IF EMPTY(m.lnMimeTypePtr)
		                LOOP
		            ENDIF
		            
		            LOCAL lcEncMimeType
		            m.lcEncMimeType = SYS(2600, m.lnMimeTypePtr, m.lnBufSize - (m.lnMimeTypePtr - m.lnHeapPtr))
		            m.lcEncMimeType = STRCONV(m.lcEncMimeType,6)
		            m.lcEncMimeType = LEFT(m.lcEncMimeType, AT(CHR(0), m.lcEncMimeType)-1)
		            m.lcEncMimeType = LOWER(ALLTRIM(m.lcEncMimeType))
		            
		            LOCAL lcEncCLSID
		            m.lcEncCLSID = SYS(2600, m.lnEncPtr + ClsidOffset, 16)
		            
		            IF EMPTY(This.ImageEncoders.GetKey(m.lcEncMimeType))
		                This.ImageEncoders.Add(m.lcEncCLSID, m.lcEncMimeType)
		            ENDIF
		            
		        ENDFOR
		
		    FINALLY
		        IF EMPTY(m.lnHeapPtr)=.F.
		            m.loWin.HeapFree(m.lhHeap, 0, m.lnHeapPtr)
		            m.lnHeapPtr = 0 
		        ENDIF
		        
		        IF EMPTY(m.lhHeap)=.F.
		            m.loWin.HeapDestroy(m.lhHeap)
		            m.lhHeap = 0 
		        ENDIF
		        
		    ENDTRY
		
		ENDIF
		
		IF EMPTY(m.MimeType)
		    RETURN ""
		ENDIF
		
		LOCAL lcImageEncoderCLSID
		m.lcImageEncoderCLSID = ""
		
		LOCAL liImageEncoder
		m.liImageEncoder = This.ImageEncoders.GetKey(LOWER(ALLTRIM(m.MimeType)))
		IF m.liImageEncoder > 0
		    m.lcImageEncoderCLSID = This.ImageEncoders.Item(m.liImageEncoder)
		ENDIF
		
		RETURN m.lcImageEncoderCLSID
		
	ENDPROC

	PROCEDURE gdipgetimageencoders
		LPARAMETERS numEncoders as Long, size as Long, encoders as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetImageEncoders(m.numEncoders, m.size, m.encoders)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetImageEncoders IN GDIPLUS.DLL AS WinApi_GdipGetImageEncoders Long numEncoders, Long size, Long encoders
		
		    m.lvRes = WinApi_GdipGetImageEncoders(m.numEncoders, m.size, m.encoders)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetimageencoderssize
		LPARAMETERS numEncoders as Long, size as Long
		
		m.numEncoders = 0
		m.size = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetImageEncodersSize(@m.numEncoders, @m.size)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetImageEncodersSize IN GDIPLUS.DLL AS WinApi_GdipGetImageEncodersSize Long @numEncoders, Long @size
		
		    m.lvRes = WinApi_GdipGetImageEncodersSize(@m.numEncoders, @m.size)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetimagegraphicscontext
		LPARAMETERS image as Long, graphics as Long
		
		m.graphics = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetImageGraphicsContext(m.image, @m.graphics)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetImageGraphicsContext IN GDIPLUS.DLL AS WinApi_GdipGetImageGraphicsContext Long image, Long @graphics
		
		    m.lvRes = WinApi_GdipGetImageGraphicsContext(m.image, @m.graphics)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetimageheight
		LPARAMETERS image as Long, height as Long
		
		m.height = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetImageHeight(m.image, @m.height)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetImageHeight IN GDIPLUS.DLL AS WinApi_GdipGetImageHeight Long image, Long @height
		
		    m.lvRes = WinApi_GdipGetImageHeight(m.image, @m.height)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetimagepixelformat
		LPARAMETERS image as Long, format as Long
		
		m.format = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetImagePixelFormat(m.image, @m.format)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetImagePixelFormat IN GDIPLUS.DLL AS WinApi_GdipGetImagePixelFormat Long image, Long @format
		
		    m.lvRes = WinApi_GdipGetImagePixelFormat(m.image, @m.format)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetimagewidth
		LPARAMETERS image as Long, width as Long
		
		m.width = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetImageWidth(m.image, @m.width)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetImageWidth IN GDIPLUS.DLL AS WinApi_GdipGetImageWidth Long image, Long @width
		
		    m.lvRes = WinApi_GdipGetImageWidth(m.image, @m.width)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipgetlinespacing
		LPARAMETERS family as Long, style as Long, LineSpacing as Long
		
		m.LineSpacing = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipGetLineSpacing(m.family, m.style, @m.LineSpacing)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipGetLineSpacing IN GDIPLUS.DLL AS WinApi_GdipGetLineSpacing Long family, Long style, Long @LineSpacing
		
		    m.lvRes = WinApi_GdipGetLineSpacing(m.family, m.style, @m.LineSpacing)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipisstyleavailable
		LPARAMETERS family as Long, style as Long, IsStyleAvailable as Long
		
		m.IsStyleAvailable = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipIsStyleAvailable(m.family, m.style, @m.IsStyleAvailable)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipIsStyleAvailable IN GDIPLUS.DLL AS WinApi_GdipIsStyleAvailable Long family, Long style, Long @IsStyleAvailable
		
		    m.lvRes = WinApi_GdipIsStyleAvailable(m.family, m.style, @m.IsStyleAvailable)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipmeasurestring
		LPARAMETERS graphics as Long, str as String, length as Long, thefont as Long, layoutRect as String, StringFormat as Long, boundingBox as String, codepointsFitted as Long, linesFilled as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipMeasureString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, @m.boundingBox, @m.codepointsFitted, @m.linesFilled)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipMeasureString IN GDIPLUS.DLL AS WinApi_GdipMeasureString ;
		        Long graphics, String str, Long length, Long thefont, String @layoutRect, Long StringFormat, String @boundingBox, Long @codepointsFitted, Long @linesFilled
		
		    m.lvRes = WinApi_GdipMeasureString(m.graphics, m.str, m.length, m.thefont, @m.layoutRect, m.StringFormat, @m.boundingBox, @m.codepointsFitted, @m.linesFilled)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipnewprivatefontcollection
		LPARAMETERS FontCollection as Long
		
		m.FontCollection = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipNewPrivateFontCollection(@m.FontCollection)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipNewPrivateFontCollection IN GDIPLUS.DLL AS WinApi_GdipNewPrivateFontCollection Long @FontCollection
		
		    m.lvRes = WinApi_GdipNewPrivateFontCollection(@m.FontCollection)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipprivateaddfontfile
		LPARAMETERS FontCollection as Long, FileName as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipPrivateAddFontFile(m.FontCollection, m.FileName)    
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipPrivateAddFontFile IN GDIPLUS.DLL AS WinApi_GdipPrivateAddFontFile Long FontCollection, String FileName
		
		    m.lvRes = WinApi_GdipPrivateAddFontFile(m.FontCollection, m.FileName)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsaveimagetofile
		LPARAMETERS image as Long, filename as String, clsidEncoder as String, EncoderParameters as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSaveImageToFile(m.image, m.filename, m.clsidEncoder, m.EncoderParameters)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipSaveImageToFile IN GDIPLUS.DLL AS WinApi_GdipSaveImageToFile Long image, String filename, String clsidEncoder, Long EncoderParameters
		
		    m.lvRes = WinApi_GdipSaveImageToFile(m.image, m.filename, m.clsidEncoder, m.EncoderParameters)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipscaleworldtransform
		LPARAMETERS graphics as Long, sx as Single, sy as Single, order as Long
		
		m.order = EVL(m.order, 0)
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipScaleWorldTransform(m.graphics, m.sx, m.sy, m.order)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipScaleWorldTransform IN GDIPLUS.DLL AS WinApi_GdipScaleWorldTransform Long graphics, Single sx, Single sy, Long order
		
		    m.lvRes = WinApi_GdipScaleWorldTransform(m.graphics, m.sx, m.sy, m.order)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetcompositingmode
		LPARAMETERS graphics as Long, mode as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetCompositingMode(m.graphics, m.mode)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipSetCompositingMode IN GDIPLUS.DLL AS WinApi_GdipSetCompositingMode Long graphics, Long mode
		
		    m.lvRes = WinApi_GdipSetCompositingMode(m.graphics, m.mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetcompositingquality
		LPARAMETERS graphics as Long, quality as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetCompositingQuality(m.graphics, m.quality)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipSetCompositingQuality IN GDIPLUS.DLL AS WinApi_GdipSetCompositingQuality Long graphics, Long quality
		
		    m.lvRes = WinApi_GdipSetCompositingQuality(m.graphics, m.quality)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetinterpolationmode
		LPARAMETERS graphics as Long, mode as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetInterpolationMode(m.graphics, m.mode)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipSetInterpolationMode IN GDIPLUS.DLL AS WinApi_GdipSetInterpolationMode Long graphics, Long mode
		
		    m.lvRes = WinApi_GdipSetInterpolationMode(m.graphics, m.mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetpixeloffsetmode
		LPARAMETERS graphics as Long, mode as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetPixelOffsetMode(m.graphics, m.mode)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipSetPixelOffsetMode IN GDIPLUS.DLL AS WinApi_GdipSetPixelOffsetMode Long graphics, Long mode
		
		    m.lvRes = WinApi_GdipSetPixelOffsetMode(m.graphics, m.mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetsolidfillcolor
		LPARAMETERS brush as Long, color as Long
		    
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetSolidFillColor(m.brush, m.color)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipSetSolidFillColor IN GDIPLUS.DLL AS WinApi_GdipSetSolidFillColor Long brush, Long color
		
		    m.lvRes = WinApi_GdipSetSolidFillColor(m.brush, m.color)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetstringformatalign
		LPARAMETERS StringFormat as Long, align as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetStringFormatAlign(m.StringFormat, m.align)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipSetStringFormatAlign IN GDIPLUS.DLL AS WinApi_GdipSetStringFormatAlign Long StringFormat, Long align
		
		    m.lvRes = WinApi_GdipSetStringFormatAlign(m.StringFormat, m.align)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetstringformatflags
		LPARAMETERS StringFormat as Long, flags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetStringFormatFlags(m.StringFormat, m.flags)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipSetStringFormatFlags IN GDIPLUS.DLL AS WinApi_GdipSetStringFormatFlags Long StringFormat, Long flags
		
		    m.lvRes = WinApi_GdipSetStringFormatFlags(m.StringFormat, m.flags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsetstringformattrimming
		LPARAMETERS StringFormat as Long, trimming as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetStringFormatTrimming(m.StringFormat, m.trimming)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipSetStringFormatTrimming IN GDIPLUS.DLL AS WinApi_GdipSetStringFormatTrimming Long StringFormat, Long trimming
		
		    m.lvRes = WinApi_GdipSetStringFormatTrimming(m.StringFormat, m.trimming)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsettextcontrast
		LPARAMETERS graphics as Long, contrast as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetTextContrast(m.graphics, m.contrast)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipSetTextContrast IN GDIPLUS.DLL AS WinApi_GdipSetTextContrast Long graphics, Long contrast
		
		    m.lvRes = WinApi_GdipSetTextContrast(m.graphics, m.contrast)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipsettextrenderinghint
		LPARAMETERS graphics as Long, mode as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipSetTextRenderingHint(m.graphics, m.mode)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipSetTextRenderingHint IN GDIPLUS.DLL AS WinApi_GdipSetTextRenderingHint Long graphics, Long mode
		
		    m.lvRes = WinApi_GdipSetTextRenderingHint(m.graphics, m.mode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipstringformatgetgenericdefault
		LPARAMETERS StringFormat as Long
		
		m.StringFormat = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipStringFormatGetGenericDefault(@m.StringFormat)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipStringFormatGetGenericDefault IN GDIPLUS.DLL AS WinApi_GdipStringFormatGetGenericDefault Long @StringFormat
		
		    m.lvRes = WinApi_GdipStringFormatGetGenericDefault(@m.StringFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gdipstringformatgetgenerictypographic
		LPARAMETERS StringFormat as Long
		
		m.StringFormat = 0
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GdipStringFormatGetGenericTypographic(@m.StringFormat)
		CATCH
		    SET CONSOLE OFF
		    
		    DECLARE Long GdipStringFormatGetGenericTypographic IN GDIPLUS.DLL AS WinApi_GdipStringFormatGetGenericTypographic Long @StringFormat
		
		    m.lvRes = WinApi_GdipStringFormatGetGenericTypographic(@m.StringFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_gdip_const AS custom 		&& Gdiplus constants
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: gdip_fontstylebold
		*m: gdip_fontstyleitalic
		*m: gdip_fontstyleregular
		*m: gdip_fontstylestrikeout
		*m: gdip_fontstyleunderline
		*m: gdip_imagelockmoderead
		*m: gdip_imagelockmodeuserinputbuf
		*m: gdip_imagelockmodewrite
		*m: gdip_pixelformat32bppargb
		*m: gdip_stringalignmentcenter
		*m: gdip_stringalignmentfar
		*m: gdip_stringalignmentnear
		*m: gdip_stringformatflagslinelimit
		*m: gdip_stringtrimmingcharacter
		*m: gdip_stringtrimmingellipsischaracter
		*m: gdip_stringtrimmingellipsispath
		*m: gdip_stringtrimmingellipsisword
		*m: gdip_stringtrimmingnone
		*m: gdip_stringtrimmingword
		*m: gdip_unitpoint
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_gdip_const"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="gdip_unitpoint" type="method" display="Gdip_UnitPoint"/>
			<memberdata name="gdip_fontstylebold" type="method" display="Gdip_FontStyleBold"/>
			<memberdata name="gdip_fontstyleregular" type="method" display="Gdip_FontStyleRegular"/>
			<memberdata name="gdip_fontstyleitalic" type="method" display="Gdip_FontStyleItalic"/>
			<memberdata name="gdip_fontstyleunderline" type="method" display="Gdip_FontStyleUnderline"/>
			<memberdata name="gdip_fontstylestrikeout" type="method" display="Gdip_FontStyleStrikeout"/>
			<memberdata name="gdip_stringformatflagslinelimit" type="method" display="Gdip_StringFormatFlagsLineLimit"/>
			<memberdata name="gdip_stringalignmentcenter" type="method" display="Gdip_StringAlignmentCenter"/>
			<memberdata name="gdip_stringalignmentfar" type="method" display="Gdip_StringAlignmentFar"/>
			<memberdata name="gdip_stringalignmentnear" type="method" display="Gdip_StringAlignmentNear"/>
			<memberdata name="gdip_stringtrimmingcharacter" type="method" display="Gdip_StringTrimmingCharacter"/>
			<memberdata name="gdip_stringtrimmingellipsischaracter" type="method" display="Gdip_StringTrimmingEllipsisCharacter"/>
			<memberdata name="gdip_stringtrimmingellipsispath" type="method" display="Gdip_StringTrimmingEllipsisPath"/>
			<memberdata name="gdip_stringtrimmingellipsisword" type="method" display="Gdip_StringTrimmingEllipsisWord"/>
			<memberdata name="gdip_stringtrimmingnone" type="method" display="Gdip_StringTrimmingNone"/>
			<memberdata name="gdip_stringtrimmingword" type="method" display="Gdip_StringTrimmingWord"/>
			<memberdata name="gdip_pixelformat32bppargb" type="method" display="Gdip_PixelFormat32bppARGB"/>
			<memberdata name="gdip_imagelockmoderead" type="method" display="Gdip_ImageLockModeRead"/>
			<memberdata name="gdip_imagelockmodewrite" type="method" display="Gdip_ImageLockModeWrite"/>
			<memberdata name="gdip_imagelockmodeuserinputbuf" type="method" display="Gdip_ImageLockModeUserInputBuf"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE gdip_fontstylebold
		RETURN 1
		
	ENDPROC

	PROCEDURE gdip_fontstyleitalic
		RETURN 2
		
	ENDPROC

	PROCEDURE gdip_fontstyleregular
		RETURN 0
		
	ENDPROC

	PROCEDURE gdip_fontstylestrikeout
		RETURN 8
		
	ENDPROC

	PROCEDURE gdip_fontstyleunderline
		RETURN 4
		
	ENDPROC

	PROCEDURE gdip_imagelockmoderead
		RETURN 0x0001
		
	ENDPROC

	PROCEDURE gdip_imagelockmodeuserinputbuf
		RETURN 0x0004
		
	ENDPROC

	PROCEDURE gdip_imagelockmodewrite
		RETURN 0x0002
		
	ENDPROC

	PROCEDURE gdip_pixelformat32bppargb
		RETURN (10 + 0x2000 + 0x00040000 + 0x00020000 + 0x00200000)
		
	ENDPROC

	PROCEDURE gdip_stringalignmentcenter
		RETURN 1
		
	ENDPROC

	PROCEDURE gdip_stringalignmentfar
		RETURN 2
		
	ENDPROC

	PROCEDURE gdip_stringalignmentnear
		RETURN 0
		
	ENDPROC

	PROCEDURE gdip_stringformatflagslinelimit
		RETURN 0x00002000
		
	ENDPROC

	PROCEDURE gdip_stringtrimmingcharacter
		RETURN 1
		
	ENDPROC

	PROCEDURE gdip_stringtrimmingellipsischaracter
		RETURN 3
		
	ENDPROC

	PROCEDURE gdip_stringtrimmingellipsispath
		RETURN 5
		
	ENDPROC

	PROCEDURE gdip_stringtrimmingellipsisword
		RETURN 4
		
	ENDPROC

	PROCEDURE gdip_stringtrimmingnone
		RETURN 0
		
	ENDPROC

	PROCEDURE gdip_stringtrimmingword
		RETURN 2
		
	ENDPROC

	PROCEDURE gdip_unitpoint
		RETURN 3
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_api_win AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: bcryptclosealgorithmprovider
		*m: bcryptcreatehash
		*m: bcryptdestroyhash
		*m: bcryptdestroykey
		*m: bcryptencrypt
		*m: bcryptfinishhash
		*m: bcryptgeneratesymmetrickey
		*m: bcryptgetproperty
		*m: bcrypthashdata
		*m: bcryptopenalgorithmprovider
		*m: beginpaint
		*m: bitblt
		*m: callwindowproc
		*m: closeclipboard
		*m: closeprinter
		*m: createcompatibledc
		*m: createdc
		*m: createdibsection
		*m: createwindowex
		*m: deletedc
		*m: deleteobject
		*m: destroywindow
		*m: devicecapabilities
		*m: documentproperties
		*m: emptyclipboard
		*m: enddoc
		*m: endpage
		*m: endpaint
		*m: enumforms
		*m: findnlsstring
		*m: getclassinfoex
		*m: getclipboarddata
		*m: getdc
		*m: getdefaultprinter
		*m: getdevicecaps
		*m: getkeystate
		*m: getkeyunicode		&& Convert keyboard key code (e.g. from KeyPress event) to utf-16 codepoint
		*m: getmodulehandle
		*m: getopenclipboardwindow
		*m: getsavefilenamea
		*m: getscrollinfo
		*m: getsystemdefaultlcid
		*m: gettickcount
		*m: getwindow
		*m: getwindowlong
		*m: globalalloc
		*m: globalfree
		*m: globallock
		*m: globalsize
		*m: globalunlock
		*m: heapalloc
		*m: heapcreate
		*m: heapdestroy
		*m: heapfree
		*m: invalidaterect
		*m: isclipboardformatavailable
		*m: movewindow
		*m: openclipboard
		*m: openprinter
		*m: registerclassex
		*m: releasedc
		*m: selectobject
		*m: sendmessage
		*m: setclipboarddata
		*m: setdefaultprinter
		*m: setfocus		&& Sets the focus to a control.
		*m: setscrollinfo
		*m: shellexecute
		*m: showwindow		&& Specifies the Form window to show the Form or Toolbar in at creation time.
		*m: startdoc
		*m: startpage
		*m: stretchdibits
		*m: uuidcreate
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_win"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="getmodulehandle" type="method" display="GetModuleHandle"/>
			<memberdata name="getwindowlong" type="method" display="GetWindowLong"/>
			<memberdata name="getclassinfoex" type="method" display="GetClassInfoEx"/>
			<memberdata name="registerclassex" type="method" display="RegisterClassEx"/>
			<memberdata name="createwindowex" type="method" display="CreateWindowEx"/>
			<memberdata name="movewindow" type="method" display="MoveWindow"/>
			<memberdata name="destroywindow" type="method" display="DestroyWindow"/>
			<memberdata name="getwindow" type="method" display="GetWindow"/>
			<memberdata name="bitblt" type="method" display="BitBlt"/>
			<memberdata name="createdibsection" type="method" display="CreateDIBSection"/>
			<memberdata name="selectobject" type="method" display="SelectObject"/>
			<memberdata name="deleteobject" type="method" display="DeleteObject"/>
			<memberdata name="createcompatibledc" type="method" display="CreateCompatibleDC"/>
			<memberdata name="getdc" type="method" display="GetDC"/>
			<memberdata name="releasedc" type="method" display="ReleaseDC"/>
			<memberdata name="deletedc" type="method" display="DeleteDC"/>
			<memberdata name="createdc" type="method" display="CreateDC"/>
			<memberdata name="findnlsstring" type="method" display="FindNLSString"/>
			<memberdata name="getsystemdefaultlcid" type="method" display="GetSystemDefaultLCID"/>
			<memberdata name="openprinter" type="method" display="OpenPrinter"/>
			<memberdata name="closeprinter" type="method" display="ClosePrinter"/>
			<memberdata name="documentproperties" type="method" display="DocumentProperties"/>
			<memberdata name="getdefaultprinter" type="method" display="GetDefaultPrinter"/>
			<memberdata name="setdefaultprinter" type="method" display="SetDefaultPrinter"/>
			<memberdata name="devicecapabilities" type="method" display="DeviceCapabilities"/>
			<memberdata name="getdevicecaps" type="method" display="GetDeviceCaps"/>
			<memberdata name="enumforms" type="method" display="EnumForms"/>
			<memberdata name="startpage" type="method" display="StartPage"/>
			<memberdata name="endpage" type="method" display="EndPage"/>
			<memberdata name="enddoc" type="method" display="EndDoc"/>
			<memberdata name="startdoc" type="method" display="StartDoc"/>
			<memberdata name="heapalloc" type="method" display="HeapAlloc"/>
			<memberdata name="heapcreate" type="method" display="HeapCreate"/>
			<memberdata name="heapdestroy" type="method" display="HeapDestroy"/>
			<memberdata name="heapfree" type="method" display="HeapFree"/>
			<memberdata name="globalalloc" type="method" display="GlobalAlloc"/>
			<memberdata name="globalfree" type="method" display="GlobalFree"/>
			<memberdata name="globallock" type="method" display="GlobalLock"/>
			<memberdata name="globalunlock" type="method" display="GlobalUnlock"/>
			<memberdata name="beginpaint" type="method" display="BeginPaint"/>
			<memberdata name="endpaint" type="method" display="EndPaint"/>
			<memberdata name="invalidaterect" type="method" display="InvalidateRect"/>
			<memberdata name="callwindowproc" type="method" display="CallWindowProc"/>
			<memberdata name="setscrollinfo" type="method" display="SetScrollInfo"/>
			<memberdata name="getscrollinfo" type="method" display="GetScrollInfo"/>
			<memberdata name="showwindow" type="method" display="ShowWindow"/>
			<memberdata name="getkeystate" type="method" display="GetKeyState"/>
			<memberdata name="closeclipboard" type="method" display="CloseClipboard"/>
			<memberdata name="emptyclipboard" type="method" display="EmptyClipboard"/>
			<memberdata name="getclipboarddata" type="method" display="GetClipboardData"/>
			<memberdata name="isclipboardformatavailable" type="method" display="IsClipboardFormatAvailable"/>
			<memberdata name="openclipboard" type="method" display="OpenClipboard"/>
			<memberdata name="setclipboarddata" type="method" display="SetClipboardData"/>
			<memberdata name="getopenclipboardwindow" type="method" display="GetOpenClipboardWindow"/>
			<memberdata name="gettickcount" type="method" display="GetTickCount"/>
			<memberdata name="uuidcreate" type="method" display="UuidCreate"/>
			<memberdata name="bcryptopenalgorithmprovider" type="method" display="BCryptOpenAlgorithmProvider"/>
			<memberdata name="bcryptgeneratesymmetrickey" type="method" display="BCryptGenerateSymmetricKey"/>
			<memberdata name="bcryptencrypt" type="method" display="BCryptEncrypt"/>
			<memberdata name="bcryptdestroykey" type="method" display="BCryptDestroyKey"/>
			<memberdata name="bcryptclosealgorithmprovider" type="method" display="BCryptCloseAlgorithmProvider"/>
			<memberdata name="bcryptdestroyhash" type="method" display="BCryptDestroyHash"/>
			<memberdata name="bcryptfinishhash" type="method" display="BCryptFinishHash"/>
			<memberdata name="bcrypthashdata" type="method" display="BCryptHashData"/>
			<memberdata name="bcryptcreatehash" type="method" display="BCryptCreateHash"/>
			<memberdata name="bcryptgetproperty" type="method" display="BCryptGetProperty"/>
			<memberdata name="getsavefilenamea" type="method" display="GetSaveFileNameA"/>
			<memberdata name="shellexecute" type="method" display="ShellExecute"/>
			<memberdata name="stretchdibits" type="method" display="StretchDIBits"/>
			<memberdata name="getkeyunicode" type="method" display="GetKeyUnicode"/>
			<memberdata name="setfocus" type="method" display="SetFocus"/>
			<memberdata name="sendmessage" type="method" display="SendMessage"/>
			<memberdata name="globalsize" type="method" display="GlobalSize"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE bcryptclosealgorithmprovider
		LPARAMETERS hAlgorithm as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptCloseAlgorithmProvider(m.hAlgorithm, m.dwFlags)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG BCryptCloseAlgorithmProvider IN BCrypt.DLL AS WinApi_BCryptCloseAlgorithmProvider LONG hAlgorithm, LONG dwFlags
		    m.lvRes = WinApi_BCryptCloseAlgorithmProvider(m.hAlgorithm, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptcreatehash
		LPARAMETERS hAlgorithm as Long, phHash as Long, pbHashObject as Long, cbHashObject as Long, pbSecret as String, cbSecret as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptCreateHash(m.hAlgorithm, @m.phHash, m.pbHashObject, m.cbHashObject, m.pbSecret, m.cbSecret, m.dwFlags)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG BCryptCreateHash IN BCrypt.DLL AS WinApi_BCryptCreateHash LONG hAlgorithm, LONG @phHash, LONG pbHashObject, LONG cbHashObject, STRING pbSecret, LONG cbSecret, LONG dwFlags
		    m.lvRes = WinApi_BCryptCreateHash(m.hAlgorithm, @m.phHash, m.pbHashObject, m.cbHashObject, m.pbSecret, m.cbSecret, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptdestroyhash
		LPARAMETERS hHash as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptDestroyHash(m.hHash)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG BCryptDestroyHash IN BCrypt.DLL AS WinApi_BCryptDestroyHash LONG hHash
		    m.lvRes = WinApi_BCryptDestroyHash(m.hHash)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptdestroykey
		LPARAMETERS hKey as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptDestroyKey(m.hKey)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG BCryptDestroyKey IN BCrypt.DLL AS WinApi_BCryptDestroyKey LONG hKey
		    m.lvRes = WinApi_BCryptDestroyKey(m.hKey)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptencrypt
		LPARAMETERS hKey as Long, pbInput as String, cbInput as Long, pPaddingInfo as String, pbIV as String, cbIV as Long, pbOutput as String, cbOutput as Long, pcbResult as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptEncrypt(@m.hKey, m.pbInput, m.cbInput, m.pPaddingInfo, @m.pbIV, m.cbIV, @m.pbOutput, m.cbOutput, @m.pcbResult, m.dwFlags)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG BCryptEncrypt IN BCrypt.DLL AS WinApi_BCryptEncrypt LONG hKey, STRING pbInput, LONG cbInput, STRING pPaddingInfo, STRING @pbIV, LONG cbIV, STRING @pbOutput, LONG cbOutput, LONG @pcbResult, LONG dwFlags
		    m.lvRes = WinApi_BCryptEncrypt(@m.hKey, m.pbInput, m.cbInput, m.pPaddingInfo, @m.pbIV, m.cbIV, @m.pbOutput, m.cbOutput, @m.pcbResult, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptfinishhash
		LPARAMETERS hHash as Long, pbOutput as String, cbOutput as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptFinishHash(m.hHash, @m.pbOutput, m.cbOutput, m.dwFlags)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG BCryptFinishHash IN BCrypt.DLL AS WinApi_BCryptFinishHash LONG hHash, STRING @pbOutput, LONG cbOutput, LONG dwFlags
		    m.lvRes = WinApi_BCryptFinishHash(m.hHash, @m.pbOutput, m.cbOutput, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptgeneratesymmetrickey
		LPARAMETERS phAlgorithm as Long, phKey as Long, pbKeyObject as String, cbKeyObject as Long, pbSecret as String, cbSecret as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptGenerateSymmetricKey(m.phAlgorithm, @m.phKey, m.pbKeyObject, m.cbKeyObject, m.pbSecret, m.cbSecret, m.dwFlags)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG BCryptGenerateSymmetricKey IN BCrypt.DLL AS WinApi_BCryptGenerateSymmetricKey LONG phAlgorithm, LONG @phKey, STRING pbKeyObject, LONG cbKeyObject, STRING pbSecret, LONG cbSecret, LONG dwFlags
		    m.lvRes = WinApi_BCryptGenerateSymmetricKey(m.phAlgorithm, @m.phKey, m.pbKeyObject, m.cbKeyObject, m.pbSecret, m.cbSecret, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptgetproperty
		LPARAMETERS hObject as Long, pszProperty as String, pbOutput as Long, cbOutput as Long, pcbResult as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptGetProperty(m.hObject, m.pszProperty, @m.pbOutput, m.cbOutput, @m.pcbResult, m.dwFlags)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG BCryptGetProperty IN BCrypt.DLL AS WinApi_BCryptGetProperty LONG hObject, STRING pszProperty, LONG @pbOutput, LONG cbOutput, LONG @pcbResult, LONG dwFlags
		    m.lvRes = WinApi_BCryptGetProperty(m.hObject, m.pszProperty, @m.pbOutput, m.cbOutput, @m.pcbResult, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcrypthashdata
		LPARAMETERS hHash as Long, pbInput as String, cbInput as Long, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptHashData(m.hHash, m.pbInput, m.cbInput, m.dwFlags)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG BCryptHashData IN BCrypt.DLL AS WinApi_BCryptHashData LONG hHash, STRING pbInput, LONG cbInput, LONG dwFlags
		    m.lvRes = WinApi_BCryptHashData(m.hHash, m.pbInput, m.cbInput, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bcryptopenalgorithmprovider
		LPARAMETERS phAlgorithm as Long, pszAlgId as String, pszImplementation as String, dwFlags as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BCryptOpenAlgorithmProvider(@m.phAlgorithm, m.pszAlgId, m.pszImplementation, m.dwFlags)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG BCryptOpenAlgorithmProvider IN BCrypt.DLL AS WinApi_BCryptOpenAlgorithmProvider LONG @phAlgorithm, STRING pszAlgId, STRING pszImplementation, LONG dwFlags
		    m.lvRes = WinApi_BCryptOpenAlgorithmProvider(@m.phAlgorithm, m.pszAlgId, m.pszImplementation, m.dwFlags)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE beginpaint
		LPARAMETERS hWnd as Long, lpPaint as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BeginPaint(m.hWnd, @m.lpPaint)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG BeginPaint IN user32 AS WinApi_BeginPaint LONG hWnd, STRING @lpPaint
		    m.lvRes = WinApi_BeginPaint(m.hWnd, @m.lpPaint)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE bitblt
		LPARAMETERS hdc as Long, nXDest as Integer, nYDest as Integer, nWidth as Integer, nHeight as Integer, hdcSrc as Long, nXSrc as Integer, nYSrc as Integer, nRop as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_BitBlt(m.hdc, m.nXDest, m.nYDest, m.nWidth, m.nHeight, m.hdcSrc, m.nXSrc, m.nYSrc, m.nRop)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER BitBlt IN Gdi32 AS WinApi_BitBlt LONG hdc, INTEGER nXDest, INTEGER nYDest, INTEGER nWidth, INTEGER nHeight, LONG hdcSrc, INTEGER nXSrc, INTEGER nYSrc, INTEGER nRop
		    m.lvRes = WinApi_BitBlt(m.hdc, m.nXDest, m.nYDest, m.nWidth, m.nHeight, m.hdcSrc, m.nXSrc, m.nYSrc, m.nRop)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE callwindowproc
		LPARAMETERS lpPrevWndFunc as Long, hWnd as Long, Msg as Long, wParam as Long, lParam as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CallWindowProc(m.lpPrevWndFunc, m.hWnd, m.Msg, m.wParam, m.lParam)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG CallWindowProc IN User32 AS WinApi_CallWindowProc LONG lpPrevWndFunc, LONG hWnd, LONG Msg, LONG wParam, LONG lParam
		    m.lvRes = WinApi_CallWindowProc(m.lpPrevWndFunc, m.hWnd, m.Msg, m.wParam, m.lParam)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE closeclipboard
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CloseClipboard()
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER CloseClipboard IN user32 AS WinApi_CloseClipboard
		    m.lvRes = WinApi_CloseClipboard()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE closeprinter
		LPARAMETERS hPrinter as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_ClosePrinter(m.hPrinter)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER ClosePrinter IN winspool.drv AS WinApi_ClosePrinter INTEGER hPrinter
		    m.lvRes = WinApi_ClosePrinter(m.hPrinter)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE createcompatibledc
		LPARAMETERS hDC as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CreateCompatibleDC(m.hDC)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER CreateCompatibleDC IN Gdi32 AS WinApi_CreateCompatibleDC INTEGER hDC
		    m.lvRes = WinApi_CreateCompatibleDC(m.hDC)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE createdc
		LPARAMETERS pwszDriver as String, pwszDevice as String, pszPort as String, pdm as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CreateDC(m.pwszDriver, m.pwszDevice, m.pszPort, @m.pdm)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG CreateDC IN Gdi32 AS WinApi_CreateDC STRING pwszDriver, STRING pwszDevice, STRING pszPort, STRING @pdm
		    m.lvRes = WinApi_CreateDC(m.pwszDriver, m.pwszDevice, m.pszPort, @m.pdm)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE createdibsection
		LPARAMETERS hdc as Integer, pbmi as String, iUsage as Long, ppvBits as Integer, hSection as Integer, dwOffset as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CreateDIBSection(m.hdc, m.pbmi, m.iUsage, @m.ppvBits, m.hSection, m.dwOffset)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER CreateDIBSection IN Gdi32 AS WinApi_CreateDIBSection INTEGER hdc, STRING pbmi, LONG iUsage, INTEGER @ppvBits, INTEGER hSection, LONG dwOffset
		    m.lvRes = WinApi_CreateDIBSection(m.hdc, m.pbmi, m.iUsage, @m.ppvBits, m.hSection, m.dwOffset)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE createwindowex
		LPARAMETERS ;
		    dwExStyle as Long, ;
		    lpClassName as String,;
		    lpWindowName as String, ;
		    dwStyle as Long,;
		    x as Integer, ;
		    y as Integer, ;
		    nWidth as Integer, ;
		    nHeight as Integer,;
		    hWndParent as Long, ;
		    hMenu as Long, ;
		    hInstance as Long,;
		    lpParam as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_CreateWindowEx(;
		        m.dwExStyle,;
		        m.lpClassName,;
		        m.lpWindowName,;
		        m.dwStyle,;
		        m.x,;
		        m.y,;
		        m.nWidth,;
		        m.nHeight,;
		        m.hWndParent,;
		        m.hMenu,;
		        m.hInstance,;
		        m.lpParam)
		
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG CreateWindowEx IN user32 AS WinApi_CreateWindowEx  ;
		        LONG dwExStyle, ;
		        STRING lpClassName,;
		        STRING lpWindowName, ;
		        LONG dwStyle,;
		        INTEGER x, ;
		        INTEGER y, ;
		        INTEGER nWidth, ;
		        INTEGER nHeight,;
		        LONG hWndParent, ;
		        LONG hMenu, ;
		        LONG hInstance,;
		        LONG lpParam  
		
		    m.lvRes = WinApi_CreateWindowEx(;
		        m.dwExStyle,;
		        m.lpClassName,;
		        m.lpWindowName,;
		        m.dwStyle,;
		        m.x,;
		        m.y,;
		        m.nWidth,;
		        m.nHeight,;
		        m.hWndParent,;
		        m.hMenu,;
		        m.hInstance,;
		        m.lpParam)
		
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE deletedc
		LPARAMETERS hdc as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DeleteDC(m.hdc)
		CATCH
		    SET CONSOLE OFF
		    DECLARE Long DeleteDC IN Gdi32 AS WinApi_DeleteDC Long hdc
		    m.lvRes = WinApi_DeleteDC(m.hdc)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE deleteobject
		LPARAMETERS hObject as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DeleteObject(m.hObject)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER DeleteObject IN Gdi32 AS WinApi_DeleteObject INTEGER hObject
		    m.lvRes = WinApi_DeleteObject(m.hObject)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE destroywindow
		LPARAMETERS hWnd as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DestroyWindow(m.hWnd)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG DestroyWindow IN user32 AS WinApi_DestroyWindow LONG hWnd
		    m.lvRes = WinApi_DestroyWindow(m.hWnd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE devicecapabilities
		LPARAMETERS pDevice as String, pPort as String, fwCapability as Integer, pOutput as String, pDevMode as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DeviceCapabilities(m.pDevice, m.pPort, m.fwCapability, @m.pOutput, @m.pDevMode)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER DeviceCapabilities IN winspool.drv AS WinApi_DeviceCapabilities STRING pDevice, STRING pPort, INTEGER fwCapability, STRING @pOutput, STRING @pDevMode
		    m.lvRes = WinApi_DeviceCapabilities(m.pDevice, m.pPort, m.fwCapability, @m.pOutput, @m.pDevMode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE documentproperties
		LPARAMETERS hWnd as Integer, hPrinter as Integer, pDeviceName as String, pDevModeOutput as String, pDevModeInput as String, fMode as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_DocumentProperties(m.hWnd, m.hPrinter, m.pDeviceName, @m.pDevModeOutput, @m.pDevModeInput, m.fMode)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER DocumentProperties IN winspool.drv AS WinApi_DocumentProperties INTEGER hWnd, INTEGER hPrinter, STRING pDeviceName, STRING @pDevModeOutput, STRING @pDevModeInput, INTEGER fMode
		    m.lvRes = WinApi_DocumentProperties(m.hWnd, m.hPrinter, m.pDeviceName, @m.pDevModeOutput, @m.pDevModeInput, m.fMode)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE emptyclipboard
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EmptyClipboard()
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER EmptyClipboard IN user32 AS WinApi_EmptyClipboard
		    m.lvRes = WinApi_EmptyClipboard()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE enddoc
		LPARAMETERS hdc as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EndDoc(m.hdc)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER EndDoc IN GDI32 AS WinApi_EndDoc INTEGER hdc
		    m.lvRes = WinApi_EndDoc(m.hdc)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE endpage
		LPARAMETERS hdc as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EndPage(m.hdc)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER EndPage IN GDI32 AS WinApi_EndPage INTEGER hdc
		    m.lvRes = WinApi_EndPage(m.hdc)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE endpaint
		LPARAMETERS hWnd as Long, lpPaint as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EndPaint(m.hWnd, m.lpPaint)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER EndPaint IN user32 AS WinApi_EndPaint LONG hWnd, STRING lpPaint
		    m.lvRes = WinApi_EndPaint(m.hWnd, m.lpPaint)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE enumforms
		LPARAMETERS hPrinter as Long, Level as Long, pForm as Long, cbBuf as Long, pcbNeeded as Long, pcReturned as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_EnumForms(m.hPrinter, m.Level, m.pForm, m.cbBuf, @m.pcbNeeded, @m.pcReturned)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG EnumForms IN winspool.drv AS WinApi_EnumForms LONG hPrinter, LONG Level, LONG pForm, LONG cbBuf, LONG @pcbNeeded, LONG @pcReturned
		    m.lvRes = WinApi_EnumForms(m.hPrinter, m.Level, m.pForm, m.cbBuf, @m.pcbNeeded, @m.pcReturned)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE findnlsstring
		LPARAMETERS ;
		    Locale as Integer, ;
		    dwFindNLSStringFlags as Integer, ;
		    lpStringSource as String, ;
		    cchSource as Integer, ;
		    lpStringValue as Integer, ;
		    cchValue as Integer, ;
		    pcchFound as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_FindNLSString(m.Locale, m.dwFindNLSStringFlags, m.lpStringSource, m.cchSource, m.lpStringValue, m.cchValue, @m.pcchFound)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER FindNLSString IN Kernel32 AS WinApi_FindNLSString ;
		        INTEGER Locale, ;
		        INTEGER dwFindNLSStringFlags, ;
		        STRING lpStringSource, ;
		        INTEGER cchSource, ;
		        STRING lpStringValue, ;
		        INTEGER cchValue, ;
		        INTEGER @pcchFound
		
		    m.lvRes = WinApi_FindNLSString(m.Locale, m.dwFindNLSStringFlags, m.lpStringSource, m.cchSource, m.lpStringValue, m.cchValue, @m.pcchFound)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getclassinfoex
		LPARAMETERS hInstance as Long, lpClassName as String, lpWndClassEx as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetClassInfoEx(m.hInstance, m.lpClassName, @m.lpWndClassEx)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER GetClassInfoEx IN user32 AS WinApi_GetClassInfoEx LONG hInstance, STRING lpClassName, STRING @lpWndClassEx
		    m.lvRes = WinApi_GetClassInfoEx(m.hInstance, m.lpClassName, @m.lpWndClassEx)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getclipboarddata
		LPARAMETERS uFormat as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetClipboardData(m.uFormat)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER GetClipboardData IN user32 AS WinApi_GetClipboardData INTEGER uFormat
		    m.lvRes = WinApi_GetClipboardData(m.uFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getdc
		LPARAMETERS hWnd as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetDC(m.hWnd)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG GetDC IN User32 AS WinApi_GetDC LONG hWnd
		    m.lvRes = WinApi_GetDC(m.hWnd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getdefaultprinter
		LPARAMETERS pszBuffer as String, pcchBuffer as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetDefaultPrinter(@m.pszBuffer, @m.pcchBuffer)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER GetDefaultPrinter IN WINSPOOL.DRV  AS WinApi_GetDefaultPrinter STRING @pszBuffer, LONG @pcchBuffer
		    m.lvRes = WinApi_GetDefaultPrinter(@m.pszBuffer, @m.pcchBuffer)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getdevicecaps
		LPARAMETERS hdc as Long, nIndex as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetDeviceCaps(m.hdc, m.nIndex)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG GetDeviceCaps IN Gdi32 AS WinApi_GetDeviceCaps LONG hdc, LONG nIndex 
		    m.lvRes = WinApi_GetDeviceCaps(m.hdc, m.nIndex)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getkeystate
		LPARAMETERS vKey as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetKeyState(m.vKey)
		CATCH
		    SET CONSOLE OFF
		    DECLARE SHORT GetKeyState IN user32 AS WinApi_GetKeyState INTEGER vKey
		    m.lvRes = WinApi_GetKeyState(m.vKey)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getkeyunicode		&& Convert keyboard key code (e.g. from KeyPress event) to utf-16 codepoint
		LPARAMETERS tnChar
		
		#define MAPVK_VK_TO_CHAR 2
		#define MAPVK_VK_TO_VSC_EX 4
		
		DECLARE INTEGER GetKeyboardState IN user32 AS WinApi_GetKeyboardState STRING @pbKeyState
		DECLARE INTEGER GetKeyboardLayout IN user32 AS WinApi_GetKeyboardLayout INTEGER idThread
		DECLARE INTEGER MapVirtualKey IN user32 AS WinApi_MapVirtualKey INTEGER uCode, INTEGER uMapType
		DECLARE INTEGER VkKeyScanExA IN user32 AS WinApi_VkKeyScanExA INTEGER ch, INTEGER dwhkl
		
		DECLARE INTEGER ToUnicodeEx IN user32 AS WinApi_ToUnicodeEx ;
		    INTEGER wVirtKey, INTEGER wScanCode, STRING @lpKeyState,;
		    STRING @pwszBuff, INTEGER cchBuff, INTEGER wFlags,;
		    INTEGER dwhkl
		
		LOCAL lnKL, lnVKCode, lnScanCode, lcKeyState
		
		m.lnKL = WinApi_GetKeyboardLayout(0)
		m.lnVKCode = BITAND(WinApi_VkKeyScanExA(m.tnChar, m.lnKL), 0xFF)
		IF EMPTY(m.lnVKCode)
		    RETURN 0
		ENDIF
		IF EMPTY(WinApi_MapVirtualKey(m.lnVKCode, MAPVK_VK_TO_CHAR))
		    RETURN 0
		ENDIF
		m.lnScanCode = WinApi_MapVirtualKey(m.lnVKCode, MAPVK_VK_TO_VSC_EX)
		
		m.lcKeyState = REPLICATE(CHR(0), 256)
		WinApi_GetKeyboardState(@m.lcKeyState)
		
		LOCAL lcCharUTF
		m.lcCharUTF = 0h00000000
		
		IF WinApi_ToUnicodeEx(m.lnVKCode, m.lnScanCode, m.lcKeyState, @m.lcCharUTF, 2, 0, m.lnKL) > 0
		    RETURN BITLSHIFT(ASC(SUBSTR(m.lcCharUTF, 2, 1)), 8) + ASC(SUBSTR(m.lcCharUTF, 1, 1))
		ELSE
		    RETURN 0
		ENDIF
		
	ENDPROC

	PROCEDURE getmodulehandle
		LPARAMETERS lpModuleName as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetModuleHandle(m.lpModuleName)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER GetModuleHandle IN kernel32 AS WinApi_GetModuleHandle STRING lpModuleName
		    m.lvRes = WinApi_GetModuleHandle(m.lpModuleName)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getopenclipboardwindow
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetOpenClipboardWindow()
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER GetOpenClipboardWindow IN user32 AS WinApi_GetOpenClipboardWindow
		    m.lvRes = WinApi_GetOpenClipboardWindow()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getsavefilenamea
		LPARAMETERS LPOPENFILENAMEA as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetSaveFileNameA(@m.LPOPENFILENAMEA)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG GetSaveFileNameA IN Comdlg32.dll AS WinApi_GetSaveFileNameA STRING @LPOPENFILENAMEA
		    m.lvRes = WinApi_GetSaveFileNameA(@m.LPOPENFILENAMEA)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getscrollinfo
		LPARAMETERS hwnd as Long, nBar as Integer, lpsi as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetScrollInfo(m.hwnd, m.nBar, @m.lpsi)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG GetScrollInfo IN User32 AS WinApi_GetScrollInfo LONG hwnd, INTEGER nBar, STRING @lpsi
		    m.lvRes = WinApi_GetScrollInfo(m.hwnd, m.nBar, @m.lpsi)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getsystemdefaultlcid
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetSystemDefaultLCID()
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER GetSystemDefaultLCID IN Kernel32 AS WinApi_GetSystemDefaultLCID
		    m.lvRes = WinApi_GetSystemDefaultLCID()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE gettickcount
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetTickCount()
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG GetTickCount IN Kernel32 AS WinApi_GetTickCount
		    m.lvRes = WinApi_GetTickCount()
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getwindow
		LPARAMETERS hWnd as Long, uCmd as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetWindow(m.hWnd, m.uCmd)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG GetWindow IN user32 AS WinApi_GetWindow LONG hWnd, LONG uCmd
		    m.lvRes = WinApi_GetWindow(m.hWnd, m.uCmd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE getwindowlong
		LPARAMETERS hWnd as Long, nIndex as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GetWindowLong(m.hWnd, m.nIndex)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG GetWindowLong IN user32 AS WinApi_GetWindowLong LONG hWnd, INTEGER nIndex
		    m.lvRes = WinApi_GetWindowLong(m.hWnd, m.nIndex)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globalalloc
		LPARAMETERS nFlags as Long, nSize as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalAlloc(m.nFlags, m.nSize)
		CATCH
		    SET CONSOLE OFF
		    DECLARE Long GlobalAlloc IN Kernel32 AS WinApi_GlobalAlloc Long nFlags, Long nSize
		    m.lvRes = WinApi_GlobalAlloc(m.nFlags, m.nSize)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globalfree
		LPARAMETERS nHandle as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalFree(m.nHandle)
		CATCH
		    SET CONSOLE OFF
		    DECLARE Long GlobalFree IN Kernel32 AS WinApi_GlobalFree Long nHandle
		    m.lvRes = WinApi_GlobalFree(m.nHandle)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globallock
		LPARAMETERS hMem as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalLock(m.hMem)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG GlobalLock IN Kernel32 AS WinApi_GlobalLock LONG hMem
		    m.lvRes = WinApi_GlobalLock(m.hMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globalsize
		LPARAMETERS hMem as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalSize(m.hMem)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG GlobalSize IN Kernel32 AS WinApi_GlobalSize LONG hMem
		    m.lvRes = WinApi_GlobalSize(m.hMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE globalunlock
		LPARAMETERS hMem as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_GlobalUnlock(m.hMem)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG GlobalUnlock IN Kernel32 AS WinApi_GlobalUnlock LONG hMem
		    m.lvRes = WinApi_GlobalUnlock(m.hMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE heapalloc
		LPARAMETERS hHeap as Integer, dwFlags as Integer, dwBytes as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_HeapAlloc(m.hHeap, m.dwFlags, m.dwBytes)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER HeapAlloc IN Kernel32 AS WinApi_HeapAlloc INTEGER hHeap, INTEGER dwFlags, INTEGER dwBytes
		    m.lvRes = WinApi_HeapAlloc(m.hHeap, m.dwFlags, m.dwBytes)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE heapcreate
		LPARAMETERS dwOptions as Integer, dwInitialSize as Integer, dwMaxSize as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_HeapCreate(m.dwOptions, m.dwInitialSize, m.dwMaxSize)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER HeapCreate IN Kernel32 AS WinApi_HeapCreate INTEGER dwOptions, INTEGER dwInitialSize, INTEGER dwMaxSize
		    m.lvRes = WinApi_HeapCreate(m.dwOptions, m.dwInitialSize, m.dwMaxSize)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE heapdestroy
		LPARAMETERS hHeap as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_HeapDestroy(m.hHeap)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER HeapDestroy IN Kernel32 AS WinApi_HeapDestroy INTEGER hHeap
		    m.lvRes = WinApi_HeapDestroy(m.hHeap)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE heapfree
		LPARAMETERS hHeap as Integer, dwFlags as Integer, pMem as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_HeapFree(m.hHeap, m.dwFlags, m.pMem)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER HeapFree IN Kernel32 AS WinApi_HeapFree INTEGER hHeap, INTEGER dwFlags, INTEGER lpMem
		    m.lvRes = WinApi_HeapFree(m.hHeap, m.dwFlags, m.pMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE invalidaterect
		LPARAMETERS hWnd as Long, lpRect as String, bErase as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_InvalidateRect(m.hWnd, m.lpRect, m.bErase)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG InvalidateRect IN User32 AS WinApi_InvalidateRect LONG hWnd, STRING lpRect, LONG bErase
		    m.lvRes = WinApi_InvalidateRect(m.hWnd, m.lpRect, m.bErase)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE isclipboardformatavailable
		LPARAMETERS uFormat as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_IsClipboardFormatAvailable(m.uFormat)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER IsClipboardFormatAvailable IN user32 AS WinApi_IsClipboardFormatAvailable INTEGER uFormat
		    m.lvRes = WinApi_IsClipboardFormatAvailable(m.uFormat)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE movewindow
		LPARAMETERS hWnd as Long, X as Integer, Y as Integer, nWidth as Integer, nHeight as Integer, bRepaint as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_MoveWindow(m.hWnd, m.X, m.Y, m.nWidth, m.nHeight, m.bRepaint)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG MoveWindow IN user32 AS WinApi_MoveWindow LONG hWnd, INTEGER X, INTEGER Y, INTEGER nWidth, INTEGER nHeight, INTEGER bRepaint
		    m.lvRes = WinApi_MoveWindow(m.hWnd, m.X, m.Y, m.nWidth, m.nHeight, m.bRepaint)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE openclipboard
		LPARAMETERS hWndNewOwner as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_OpenClipboard(m.hWndNewOwner)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER OpenClipboard IN user32 AS WinApi_OpenClipboard INTEGER hWndNewOwner
		    m.lvRes = WinApi_OpenClipboard(m.hWndNewOwner)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE openprinter
		LPARAMETERS pPrinterName as String, phPrinter as Integer, pDefault as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_OpenPrinter(m.pPrinterName, @m.phPrinter, m.pDefault)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER OpenPrinter IN winspool.drv AS WinApi_OpenPrinter STRING pPrinterName, INTEGER @phPrinter, INTEGER pDefault
		    m.lvRes = WinApi_OpenPrinter(m.pPrinterName, @m.phPrinter, m.pDefault)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE registerclassex
		LPARAMETERS lpWndClassEx as String 
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_RegisterClassEx(m.lpWndClassEx)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG RegisterClassEx IN user32 AS WinApi_RegisterClassEx STRING lpWndClassEx
		    m.lvRes = WinApi_RegisterClassEx(m.lpWndClassEx)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE releasedc
		LPARAMETERS hWnd as Long, hDC as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_ReleaseDC(m.hWnd, m.hDC)
		CATCH
		    SET CONSOLE OFF
		    DECLARE Long ReleaseDC IN User32 AS WinApi_ReleaseDC Long hWnd, Long hDC
		    m.lvRes = WinApi_ReleaseDC(m.hWnd, m.hDC)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE selectobject
		LPARAMETERS hdc as Integer, hgdiobj as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SelectObject(m.hdc, m.hgdiobj)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER SelectObject IN Gdi32 AS WinApi_SelectObject INTEGER hdc, INTEGER hgdiobj
		    m.lvRes = WinApi_SelectObject(m.hdc, m.hgdiobj)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE sendmessage
		LPARAMETERS hWnd as Integer, Msg as Integer, wParam as Integer, lParam as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SendMessage(m.hWnd, m.Msg, m.wParam, m.lParam)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG SendMessage IN user32 AS WinApi_SendMessage LONG hWnd, LONG Msg, LONG wParam, LONG lParam
		    m.lvRes = WinApi_SendMessage(m.hWnd, m.Msg, m.wParam, m.lParam)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE setclipboarddata
		LPARAMETERS uFormat as Integer, hMem as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SetClipboardData(m.uFormat, m.hMem)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER SetClipboardData IN user32 AS WinApi_SetClipboardData INTEGER uFormat, INTEGER hMem
		    m.lvRes = WinApi_SetClipboardData(m.uFormat, m.hMem)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE setdefaultprinter
		LPARAMETERS pszPrinter as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SetDefaultPrinter(m.pszPrinter)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER SetDefaultPrinter IN WINSPOOL.DRV  AS WinApi_SetDefaultPrinter STRING pszPrinter
		    m.lvRes = WinApi_SetDefaultPrinter(m.pszPrinter)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE setfocus		&& Sets the focus to a control.
		LPARAMETERS hWnd as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SetFocus(m.hWnd)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG SetFocus IN user32 AS WinApi_SetFocus LONG hWnd
		    m.lvRes = WinApi_SetFocus(m.hWnd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE setscrollinfo
		LPARAMETERS hwnd as Long, nBar as Integer, lpsi as String, redraw as Long
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_SetScrollInfo(m.hwnd, m.nBar, m.lpsi, m.redraw)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER SetScrollInfo IN User32 AS WinApi_SetScrollInfo LONG hwnd, INTEGER nBar, STRING lpsi, LONG redraw
		    m.lvRes = WinApi_SetScrollInfo(m.hwnd, m.nBar, m.lpsi, m.redraw)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE shellexecute
		LPARAMETERS hwnd as Long, lpOperation as String, lpFile as String, lpParameters as String, lpDirectory as String, nShowCmd as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_ShellExecute(m.hwnd, m.lpOperation, m.lpFile, m.lpParameters, m.lpDirectory, m.nShowCmd)
		CATCH
		    SET CONSOLE OFF
		    DECLARE Long ShellExecuteA IN Shell32 AS WinApi_ShellExecute Long hwnd, String lpOperation, String lpFile, String lpParameters, String lpDirectory, Integer nShowCmd
		    m.lvRes = WinApi_ShellExecute(m.hwnd, m.lpOperation, m.lpFile, m.lpParameters, m.lpDirectory, m.nShowCmd)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE showwindow		&& Specifies the Form window to show the Form or Toolbar in at creation time.
		LPARAMETERS hWnd as Long, nCmdShow as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_ShowWindow(m.hWnd, m.nCmdShow)
		CATCH
		    SET CONSOLE OFF
		    DECLARE LONG ShowWindow IN User32 AS WinApi_ShowWindow LONG hWnd, INTEGER nCmdShow
		    m.lvRes = WinApi_ShowWindow(m.hWnd, m.nCmdShow)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE startdoc
		LPARAMETERS hdc as Integer, lpdi as String
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_StartDoc(m.hdc, m.lpdi)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER StartDoc IN GDI32 AS WinApi_StartDoc INTEGER hdc, STRING lpdi
		    m.lvRes = WinApi_StartDoc(m.hdc, m.lpdi)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE startpage
		LPARAMETERS hdc as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_StartPage(m.hdc)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER StartPage IN GDI32 AS WinApi_StartPage INTEGER hdc
		    m.lvRes = WinApi_StartPage(m.hdc)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE stretchdibits
		LPARAMETERS hdc as Long, nXDest as Integer, nYDest as Integer, nWidth as Integer, nHeight as Integer, nXSrc as Integer, nYSrc as Integer, nSrcWidth as Integer, nSrcHeight as Integer, lpBits as Long, lpBMI as String, iUsage as Integer, nRop as Integer
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_StretchDIBits(m.hdc, m.nXDest, m.nYDest, m.nWidth, m.nHeight, m.nXSrc, m.nYSrc, m.nSrcWidth, m.nSrcHeight, m.lpBits, @m.lpBMI, m.iUsage, m.nRop)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER StretchDIBits IN Gdi32 AS WinApi_StretchDIBits LONG hdc, INTEGER nXDest, INTEGER nYDest, INTEGER nWidth, INTEGER nHeight, INTEGER nXSrc, INTEGER nYSrc, INTEGER nSrcWidth, INTEGER nSrcHeight, LONG lpBits, STRING@ lpBMI, INTEGER iUsage, INTEGER nRop
		    m.lvRes = WinApi_StretchDIBits(m.hdc, m.nXDest, m.nYDest, m.nWidth, m.nHeight, m.nXSrc, m.nYSrc, m.nSrcWidth, m.nSrcHeight, m.lpBits, @m.lpBMI, m.iUsage, m.nRop)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

	PROCEDURE uuidcreate
		LPARAMETERS Uuid
		
		m.Uuid = REPLICATE(CHR(0), 16)
		
		LOCAL m.lvRes
		TRY
		    m.lvRes = WinApi_UuidCreate(@m.Uuid)
		CATCH
		    SET CONSOLE OFF
		    DECLARE INTEGER UuidCreate IN Rpcrt4.dll AS WinApi_UuidCreate STRING @Uuid
		    m.lvRes = WinApi_UuidCreate(@m.Uuid)
		ENDTRY
		
		RETURN m.lvRes
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_env AS custom 		&& Pdfium Environment Configuration Object. Usage: create, setup and pass as first parameter of PdfiumViewer.Init, PdfiumReport.Init
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="API_FPDF" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="API_WIN" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="API_GDIP" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="API_FPDF_FORMS" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="API_FPDF_ANNOT" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: errfmt
		*m: errmsg
		*m: foxenv_restore		&& Restore VFP environment to the state before first call of This.FoxEnv_Set or first call after last This.FoxEnv_Restore call
		*m: foxenv_set		&& Sets VFP environment to fit pdfium-vfp requirements
		*m: getappname		&& Returns file name of application executable (app, exe) from the top of the call stack. Returns empty string if there is no application executable in stack
		*m: getpdfdpi		&& PDF standart resolution (72 DPI)
		*m: getsavefilename		&& SaveAs dialog
		*m: getscreendpix		&& Screen horizontal DPI (constant 96 DPI)
		*m: getscreendpiy		&& Screen vertical DPI (constant 96 DPI)
		*m: getuniquetempcursorname
		*m: getuniquetempfilename		&& Returns uniquie not existent filename in %userprofile%\AppData\Local\Temp
		*m: ok		&& Return TRUE if enviroment setup ended up with success
		*m: setup		&& Setup environment (from external environment if neccessary)
		*m: setuprelease
		*p: foxenv_prev		&& VFP environment state saving by This.FoxEnv_Set and restoring by This.FoxEnv_Restore
		*p: pdfium_dll_path		&& Path to file pdfium.dll. Filename without path also accepted
		*p: privatefonts		&& Collection of non system (custom / private) fonts. Key must be the font face name, Value - path to the font file
		*p: setup_ok
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,Error,foxenv_prev,Height,HelpContextID,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,setup_ok,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		foxenv_prev = .F.
		Height = 27
		Name = "pdfium_env"
		pdfium_dll_path = (IIF(FILE(ADDBS(JUSTPATH(This.ClassLibrary))+"pdfium.dll",1), ADDBS(JUSTPATH(This.ClassLibrary)), "") + IIF(ATC("x64", SYS(17))<>0 , "pdfium64.dll", "pdfium.dll"))
		privatefonts = .F.
		setup_ok = .F.
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="pdfium_dll_path" type="property" display="pdfium_dll_path"/>
			<memberdata name="errmsg" type="method" display="ErrMsg"/>
			<memberdata name="ok" type="method" display="ok"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="setuprelease" type="method" display="SetupRelease"/>
			<memberdata name="getpdfdpi" type="method" display="GetPDFDPI"/>
			<memberdata name="getscreendpix" type="method" display="GetScreenDPIX"/>
			<memberdata name="getscreendpiy" type="method" display="GetScreenDPIY"/>
			<memberdata name="getuniquetempfilename" type="method" display="GetUniqueTempFileName"/>
			<memberdata name="privatefonts" type="property" display="PrivateFonts"/>
			<memberdata name="getappname" type="method" display="GetAppName"/>
			<memberdata name="foxenv_prev" type="property" display="FoxEnv_Prev"/>
			<memberdata name="foxenv_restore" type="method" display="FoxEnv_Restore"/>
			<memberdata name="foxenv_set" type="method" display="FoxEnv_Set"/>
			<memberdata name="setup_ok" type="property" display="Setup_Ok"/>
			<memberdata name="getsavefilename" type="method" display="GetSaveFileName"/>
			<memberdata name="errfmt" type="method" display="ErrFmt"/>
			<memberdata name="getuniquetempcursorname" type="method" display="GetUniqueTempCursorName"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'API_FPDF' AS pdfium_api_fpdf WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_FPDF", ;
		Top = 0, ;
		Width = 0, ;
		CONST.Name = "CONST"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'API_FPDF_ANNOT' AS pdfium_api_fpdf_annot WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_FPDF_ANNOT", ;
		Top = 0, ;
		Width = 0, ;
		CONST.Name = "CONST"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'API_FPDF_FORMS' AS pdfium_api_fpdf_forms WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_FPDF_FORMS", ;
		Top = 0, ;
		Width = 0, ;
		CONST.Name = "CONST"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'API_GDIP' AS pdfium_api_gdip WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_GDIP", ;
		Top = 0, ;
		Width = 0, ;
		CONST.Name = "CONST"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'API_WIN' AS pdfium_api_win WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_WIN", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE Destroy
		This.PrivateFonts = .F.
		This.SetupRelease()
		
		This.FoxEnv_Prev = .F.
		
	ENDPROC

	PROCEDURE errfmt
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		m.lcMsg = ""
		
		DO CASE
		CASE VARTYPE(m.tvMsg)="O"
		
		    LOCAL lcLineContents
		    m.lcLineContents = ""
		
		    LOCAL laStack(1), lnStack
		    m.lnStack = ASTACKINFO(laStack)
		    IF m.lnStack > 2
		        m.lcLineContents = m.laStack[lnStack - 2, 6]
		    ENDIF
		
		    m.lcMsg = ;
		        m.tvMsg.Message + ;
		        RTRIM(" " + NVL(m.tvMsg.Details,"")) + ;
		        RTRIM(" " + NVL(m.tvMsg.UserValue,"")) + ;
		        CHR(13) + "Procedure: " + m.tvMsg.Procedure + ;
		        CHR(13) + "LineContents: " + m.lcLineContents
		
		CASE VARTYPE(m.tvMsg)="C"
		    m.lcMsg = ALLTRIM(m.tvMsg)
		
		ENDCASE
		
		RETURN m.lcMsg
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		m.lcMsg = This.ErrFmt(m.tvMsg)
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		IF SYS(2335) != '0'
		    MESSAGEBOX(This.Class + " ("+This.ClassLibrary+"): " + m.lcMsg, 0+48, This.Class + " ("+This.ClassLibrary+")")
		ELSE
		    THROW m.lcMsg
		ENDIF
		
	ENDPROC

	PROCEDURE foxenv_restore		&& Restore VFP environment to the state before first call of This.FoxEnv_Set or first call after last This.FoxEnv_Restore call
		IF VARTYPE(This.FoxEnv_Prev) <> "O"
		    RETURN
		ENDIF
		
		LOCAL loFoxEnv
		m.loFoxEnv = This.FoxEnv_Prev
		This.FoxEnv_Prev = .F.
		
		LOCAL lcVal
		
		m.lcVal = m.loFoxEnv.SET_COMPATIBLE
		IF m.lcVal <> SET("Compatible")
		    SET COMPATIBLE &lcVal
		ENDIF
		
		m.lcVal = m.loFoxEnv.SET_CONSOLE
		SET CONSOLE &lcVal
		
	ENDPROC

	PROCEDURE foxenv_set		&& Sets VFP environment to fit pdfium-vfp requirements
		IF VARTYPE(This.FoxEnv_Prev) <> "O"
		    This.FoxEnv_Prev = NEWOBJECT("Empty")
		    ADDPROPERTY(This.FoxEnv_Prev, "SET_COMPATIBLE", SET("Compatible"))
		    ADDPROPERTY(This.FoxEnv_Prev, "SET_CONSOLE", SET("Console"))
		ENDIF
		
		IF UPPER(SET("Compatible")) <> "OFF"
		    SET COMPATIBLE OFF
		ENDIF
		
		SET CONSOLE OFF
		
	ENDPROC

	PROCEDURE getappname		&& Returns file name of application executable (app, exe) from the top of the call stack. Returns empty string if there is no application executable in stack
		LOCAL ARRAY laStack(1)
		LOCAL lnStack, liStack
		m.lnStack = ASTACKINFO(laStack)
		
		FOR m.liStack = m.lnStack TO 1 STEP -1
		
		    IF INLIST(LOWER(JUSTEXT(m.laStack[m.liStack,2])), "app", "exe") = .F.
		        LOOP
		    ENDIF
		    
		    RETURN m.laStack[m.liStack,2]
		
		ENDFOR
		
		RETURN ""
		
	ENDPROC

	PROCEDURE getpdfdpi		&& PDF standart resolution (72 DPI)
		RETURN 72
		
	ENDPROC

	PROCEDURE getsavefilename		&& SaveAs dialog
		LPARAMETERS cFileName, cDefaultExtension, cFileExtensions
		
		#define OPENFILENAME_SIZE 88
		#define OFN_EXPLORER 0x00080000  
		#define OFN_OVERWRITEPROMPT 0x00000002
		
		
		LOCAL lcFile, lcDefExt, lcFilter
		m.lcFile = PADR(EVL(m.cFileName,""), 48000, CHR(0)) + CHR(0)+CHR(0)
		m.lcDefExt = EVL(m.cDefaultExtension, "")
		m.lcFilter = EVL(m.cFileExtensions, "*." + EVL(m.lcDefExt, "*")) + CHR(0) + EVL(m.cFileExtensions, "*." + EVL(m.lcDefExt, "*")) + CHR(0) + CHR(0)
		
		LOCAL lhHeap, lnPtrFile, lnPtrDefExt, lnPtrFilter, lnLenFile  
		STORE 0 TO m.lhHeap, m.lnPtrFile, m.lnPtrDefExt, m.lnPtrFilter, m.lnLenFile
		
		LOCAL lcSavePath
		m.lcSavePath = FULLPATH(".")
		
		LOCAL llRes
		m.llRes = .F.
		
		LOCAL lcResFile
		m.lcResFile = ""
		
		TRY
		    m.lhHeap = This.API_WIN.HeapCreate(0, 0, 0)
		    IF EMPTY(m.lhHeap)
		        EXIT
		    ENDIF
		
		    m.lnLenFile = LEN(m.lcFile)
		    m.lnPtrFile = This.API_WIN.HeapAlloc(m.lhHeap, 0, m.lnLenFile)
		    IF EMPTY(m.lnPtrFile)
		        EXIT
		    ENDIF
		    SYS(2600, m.lnPtrFile, m.lnLenFile, m.lcFile)
		
		    IF EMPTY(m.lcDefExt)=.F.
		        m.lnPtrDefExt = This.API_WIN.HeapAlloc(m.lhHeap, 0, LEN(m.lcDefExt))  
		        IF EMPTY(m.lnPtrDefExt)
		            EXIT
		        ENDIF  
		        SYS(2600, m.lnPtrDefExt, LEN(m.lcDefExt), m.lcDefExt)
		    ENDIF
		
		    IF EMPTY(m.lcFilter)=.F.
		        m.lnPtrFilter = This.API_WIN.HeapAlloc(m.lhHeap, 0, LEN(m.lcFilter))  
		        IF EMPTY(m.lnPtrFilter)
		            EXIT
		        ENDIF  
		        SYS(2600, m.lnPtrFilter, LEN(m.lcFilter), m.lcFilter)
		    ENDIF
		      
		    LOCAL lpOFN As String  
		      m.lpOFN = BINTOC(OPENFILENAME_SIZE, "4RS") ; && DWORD lStructSize  
		      + BINTOC(0, "4RS") ; && HWND hwndOwner  
		      + BINTOC(0, "4RS") ; && HINSTANCE hInstance  
		      + BINTOC(m.lnPtrFilter, "4RS") ; && LPCTSTR lpstrFilter  
		      + BINTOC(0, "4RS") ; && LPTSTR lpstrCustomFilter  
		      + BINTOC(0, "4RS") ; && DWORD nMaxCustFilter  
		      + BINTOC(0, "4RS") ; && DWORD nFilterIndex  
		      + BINTOC(m.lnPtrFile, "4RS") ; && LPTSTR lpstrFile  
		      + BINTOC(m.lnLenFile, "4RS") ; && DWORD nMaxFile  
		      + BINTOC(0, "4RS") ; && LPTSTR lpstrFileTitle  
		      + BINTOC(0, "4RS") ; && DWORD nMaxFileTitle  
		      + BINTOC(0, "4RS") ; && LPCTSTR lpstrInitialDir  
		      + BINTOC(0, "4RS") ; && LPCTSTR lpstrTitle  
		      + BINTOC(OFN_EXPLORER + OFN_OVERWRITEPROMPT, "4RS") ; && DWORD Flags  
		      + BINTOC(0, "2RS") ; && WORD nFileOffset  
		      + BINTOC(0, "2RS") ; && WORD nFileExtension  
		      + BINTOC(m.lnPtrDefExt, "4RS") ; && LPCTSTR lpstrDefExt  
		      + BINTOC(0, "4RS") ; && LPARAM lCustData  
		      + BINTOC(0, "4RS") ; && LPOFNHOOKPROC lpfnHook  
		      + BINTOC(0, "4RS") ; && LPCTSTR lpTemplateName  
		      + BINTOC(0, "4RS") ; && void * pvReserved  
		      + BINTOC(0, "4RS") ; && DWORD dwReserved  
		      + BINTOC(0, "4RS") && DWORD FlagsEx  
		      
		
		
		    IF EMPTY(This.API_WIN.GetSaveFileNameA(@m.lpOFN))
		        EXIT
		    ENDIF
		    
		    m.llRes = .T.
		
		    m.lcResFile = SYS(2600, m.lnPtrFile, m.lnLenFile)
		    m.lcResFile = LEFT(m.lcResFile, AT(CHR(0), m.lcResFile)-1)
		    
		
		FINALLY
		
		    IF EMPTY(m.lnPtrFile) = .F.
		        This.API_WIN.HeapFree(m.lhHeap, 0, m.lnPtrFile)
		        m.lnPtrFile = 0
		    ENDIF
		
		    IF EMPTY(m.lnPtrDefExt) = .F.
		        This.API_WIN.HeapFree(m.lhHeap, 0, m.lnPtrDefExt)
		        m.lnPtrDefExt = 0
		    ENDIF
		    
		    IF EMPTY(m.lnPtrFilter) = .F.
		        This.API_WIN.HeapFree(m.lhHeap, 0, m.lnPtrFilter)
		        m.lnPtrFilter = 0
		    ENDIF
		    
		    IF EMPTY(m.lhHeap) = .F.
		        This.API_WIN.HeapDestroy(m.lhHeap)
		        m.lhHeap = 0
		    ENDIF
		ENDTRY
		
		CD (m.lcSavePath)
		
		
		RETURN IIF(m.llRes, m.lcResFile, "")
		
		
	ENDPROC

	PROCEDURE getscreendpix		&& Screen horizontal DPI (constant 96 DPI)
		RETURN 96
		
	ENDPROC

	PROCEDURE getscreendpiy		&& Screen vertical DPI (constant 96 DPI)
		RETURN 96
		
	ENDPROC

	PROCEDURE getuniquetempcursorname
		#define RPC_S_OK 0
		#define RPC_S_UUID_LOCAL_ONLY 1824
		
		LOCAL lcCursorName
		m.lcCursorName = ""
		
		LOCAL i
		FOR m.i = 1 TO 500
		    
		    LOCAL lcUuid
		    m.lcUuid = ""
		    IF INLIST(This.API_WIN.UuidCreate(@m.lcUuid), RPC_S_OK, RPC_S_UUID_LOCAL_ONLY) = .F.
		        m.lcUuid = SYS(2015)
		    ENDIF
		    m.lcUuid = CHRTRAN(TRANSFORM(0h + m.lcUuid), '-', '')
		
		    m.lcCursorName = This.Class + m.lcUuid
		    
		    IF USED(m.lcCursorName)
		        m.lcCursorName = ""
		        LOOP
		    ENDIF
		
		    EXIT
		ENDFOR
		
		RETURN m.lcCursorName
		
		
	ENDPROC

	PROCEDURE getuniquetempfilename		&& Returns uniquie not existent filename in %userprofile%\AppData\Local\Temp
		LPARAMETERS tcFileExt
		
		#define RPC_S_OK 0
		#define RPC_S_UUID_LOCAL_ONLY 1824
		
		LOCAL lcFileExt
		m.lcFileExt = ALLTRIM(EVL(NVL(m.tcFileExt,""),""), 1, " ", ".")
		
		LOCAL lcPath
		m.lcPath = ADDBS(SYS(2023))
		
		LOCAL lcFilename
		m.lcFilename = ""
		
		LOCAL i
		FOR m.i = 1 TO 500
		    
		    LOCAL lcUuid
		    m.lcUuid = ""
		    IF INLIST(This.API_WIN.UuidCreate(@m.lcUuid), RPC_S_OK, RPC_S_UUID_LOCAL_ONLY) = .F.
		        m.lcUuid = SYS(2015)
		    ENDIF
		    m.lcUuid = TRANSFORM(0h + m.lcUuid)
		    
		    m.lcFilename = m.lcPath + "pdfium_vfp_" + m.lcUuid + IIF(EMPTY(m.lcFileExt), "", "." + m.lcFileExt)
		    
		    IF FILE(m.lcFilename,1) OR DIRECTORY(m.lcFilename,1)
		        m.lcFilename = ""
		        LOOP
		    ENDIF
		
		    EXIT
		ENDFOR
		
		RETURN m.lcFilename
		
		
	ENDPROC

	PROCEDURE Init
		This.PrivateFonts = NEWOBJECT("Collection")
		
	ENDPROC

	PROCEDURE ok		&& Return TRUE if enviroment setup ended up with success
		RETURN This.setup_ok
		
	ENDPROC

	PROCEDURE setup		&& Setup environment (from external environment if neccessary)
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.SetupRelease()
		
		IF VARTYPE(m.toEnv)="O"
		    This.pdfium_dll_path = EVL(NVL(m.toEnv.pdfium_dll_path,""), This.pdfium_dll_path)
		    This.PrivateFonts = IIF(VARTYPE(m.toEnv.PrivateFonts)="O", m.toEnv.PrivateFonts, This.PrivateFonts)
		ENDIF
		
		
		*****************************************************************
		* Pdfium.dll binding
		*****************************************************************
		This.pdfium_dll_path = FULLPATH(ALLTRIM(EVL(NVL(This.pdfium_dll_path,""),"")))
		
		IF FILE(This.pdfium_dll_path,1)=.F.
		    This.errMsg(TEXTMERGE("<<This.Class>>.pdfium_dll_path: File <<This.pdfium_dll_path>> does not exist"))
		    RETURN .F.
		ENDIF
		
		This.API_FPDF.pdfium_dll_path = This.pdfium_dll_path
		This.API_FPDF_FORMS.pdfium_dll_path = This.pdfium_dll_path
		This.API_FPDF_ANNOT.pdfium_dll_path = This.pdfium_dll_path
		
		
		*****************************************************************
		* Pdfium library initialization
		*****************************************************************
		This.setup_ok = .F.
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    This.API_FPDF.FPDF_InitLibraryWithConfig()
		    
		    This.setup_ok = .T.
		
		CATCH TO m.loErr
		    This.errMsg(m.loErr)
		ENDTRY
		
		IF This.setup_ok = .F.
		    RETURN .F.
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE setuprelease
		
		IF This.setup_ok = .F.
		    RETURN
		ENDIF
		
		This.setup_ok = .F.
		
		This.API_FPDF.FPDF_DestroyLibrary()
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_i18n AS custom 		&& PdfiumViewer Internationalization Helper. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="API_WIN" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: getlocaleid		&& Returns system locale id
		*m: text		&& Returns all of the text in a text-entry area of a control.
		*m: text_cn
		*m: text_cz
		*m: text_de
		*m: text_en
		*m: text_es
		*m: text_fr
		*m: text_ru
		*p: localeid
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,Error,Height,HelpContextID,localeid,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		localeid = 1033
		Name = "pdfium_i18n"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="localeid" type="property" display="LocaleID"/>
			<memberdata name="getlocaleid" type="method" display="GetLocaleID"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'API_WIN' AS pdfium_api_win WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_WIN", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE getlocaleid		&& Returns system locale id
		RETURN This.LocaleID
		
	ENDPROC

	PROCEDURE Init
		This.LocaleID = This.API_WIN.GetSystemDefaultLCID()
		
	ENDPROC

	PROCEDURE text		&& Returns all of the text in a text-entry area of a control.
		* This code is generated by BUILD\BUILD_I18N.prg
		
		LPARAMETERS tcTxtID
		
		LOCAL lcTxtID
		m.lcTxtID = UPPER(ALLTRIM(EVL(NVL(m.tcTxtID,""),"")))
		
		IF EMPTY(m.lcTxtID)
		RETURN ""
		ENDIF
		
		
		DO CASE 
		
		CASE This.LocaleID = 2052
		RETURN This.text_cn(m.lcTxtID)
		
		CASE This.LocaleID = 1031
		RETURN This.text_de(m.lcTxtID)
		
		CASE This.LocaleID = 1033
		RETURN This.text_en(m.lcTxtID)
		
		CASE This.LocaleID = 1034
		RETURN This.text_es(m.lcTxtID)
		
		CASE This.LocaleID = 1036
		RETURN This.text_fr(m.lcTxtID)
		
		CASE This.LocaleID = 1049
		RETURN This.text_ru(m.lcTxtID)
		
		CASE This.LocaleID = 1029
		RETURN This.text_cz(m.lcTxtID)
		
		OTHERWISE
		RETURN This.text_en(m.lcTxtID)
		
		ENDCASE
		
	ENDPROC

	HIDDEN PROCEDURE text_cn
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_CN.XML for LocaleID = 2052
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(184) + CHR(180) + CHR(214) + CHR(198)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(200) + CHR(171) + CHR(209) + CHR(161)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(188) + CHR(244) + CHR(199) + CHR(208)
		
		
		CASE m.tcTxtID == "MNU_PASTE"
		RETURN CHR(213) + CHR(179) + CHR(204) + CHR(249)
		
		
		CASE m.tcTxtID == "MNU_CLEAR"
		RETURN CHR(199) + CHR(229) + CHR(192) + CHR(237)
		
		
		CASE m.tcTxtID == "REPORTVIEWER_TITLE"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161) + CHR(212) + CHR(164) + CHR(192) + CHR(192)
		
		
		CASE m.tcTxtID == "SEARCH_NOT_FOUND"
		RETURN CHR(195) + CHR(187) + CHR(211) + CHR(208) + CHR(183) + CHR(162) + CHR(207) + CHR(214)
		
		
		CASE m.tcTxtID == "SEARCH_ENDED"
		RETURN CHR(203) + CHR(209) + CHR(203) + CHR(247) + CHR(205) + CHR(234) + CHR(177) + CHR(207)
		
		
		CASE m.tcTxtID == "BTN_PRINT"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161)
		
		
		CASE m.tcTxtID == "PRINTENV_TITLE"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161) + CHR(201) + CHR(232) + CHR(214) + CHR(195)
		
		
		CASE m.tcTxtID == "PRINTENV_OK"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161)
		
		
		CASE m.tcTxtID == "PRINTENV_CANCEL"
		RETURN CHR(200) + CHR(161) + CHR(207) + CHR(251)
		
		
		CASE m.tcTxtID == "PRINTENV_PRINTER"
		RETURN CHR(180) + CHR(242) + CHR(211) + CHR(161) + CHR(187) + CHR(250)
		
		
		CASE m.tcTxtID == "PRINTENV_COPIES"
		RETURN CHR(183) + CHR(221) + CHR(202) + CHR(253)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE"
		RETURN CHR(210) + CHR(179) + CHR(195) + CHR(230)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ALL"
		RETURN CHR(203) + CHR(249) + CHR(211) + CHR(208)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ODD"
		RETURN CHR(189) + CHR(246) + CHR(198) + CHR(230) + CHR(202) + CHR(253) + CHR(210) + CHR(179)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_EVEN"
		RETURN CHR(189) + CHR(246) + CHR(197) + CHR(188) + CHR(202) + CHR(253) + CHR(210) + CHR(179)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_PAGELIST"
		RETURN CHR(192) + CHR(253) + CHR(200) + CHR(231) + CHR(58) + CHR(32) + CHR(49) + CHR(45) + CHR(51) + CHR(44) + CHR(32) + CHR(53) + CHR(45) + CHR(56) + CHR(44) + CHR(32) + CHR(57)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_DUPLEX"
		RETURN CHR(203) + CHR(171) + CHR(195) + CHR(230) + CHR(180) + CHR(242) + CHR(211) + CHR(161)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE"
		RETURN CHR(214) + CHR(189) + CHR(213) + CHR(197) + CHR(185) + CHR(230) + CHR(184) + CHR(241)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE_AUTO"
		RETURN CHR(215) + CHR(212) + CHR(182) + CHR(175) + CHR(209) + CHR(161) + CHR(212) + CHR(241)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_TITLE"
		RETURN CHR(202) + CHR(228) + CHR(200) + CHR(235) + CHR(195) + CHR(220) + CHR(194) + CHR(235)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_PROMPT"
		RETURN CHR(80) + CHR(68) + CHR(70) + CHR(32) + CHR(206) + CHR(196) + CHR(188) + CHR(254) + CHR(202) + CHR(220) + CHR(195) + CHR(220) + CHR(194) + CHR(235) + CHR(177) + CHR(163) + CHR(187) + CHR(164) + CHR(161) + CHR(163) + CHR(202) + CHR(228) + CHR(200) + CHR(235) + CHR(195) + CHR(220) + CHR(194) + CHR(235) + CHR(188) + CHR(180) + CHR(191) + CHR(201) + CHR(180) + CHR(242) + CHR(191) + CHR(170) + CHR(206) + CHR(196) + CHR(188) + CHR(254) + CHR(161) + CHR(163)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_INCORRECTPASSWORD"
		RETURN CHR(195) + CHR(220) + CHR(194) + CHR(235) + CHR(180) + CHR(237) + CHR(206) + CHR(243)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_OK"
		RETURN CHR(180) + CHR(242) + CHR(191) + CHR(170) + CHR(206) + CHR(196) + CHR(181) + CHR(181)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_CANCEL"
		RETURN CHR(200) + CHR(161) + CHR(207) + CHR(251)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_TITLE"
		RETURN CHR(209) + CHR(161) + CHR(212) + CHR(241) + CHR(180) + CHR(242) + CHR(211) + CHR(161) + CHR(187) + CHR(250)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_OK"
		RETURN CHR(211) + CHR(166) + CHR(211) + CHR(195)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_CANCEL"
		RETURN CHR(200) + CHR(161) + CHR(207) + CHR(251)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_cz
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_CZ.XML for LocaleID = 1029
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(75) + CHR(111) + CHR(112) + CHR(237) + CHR(114) + CHR(111) + CHR(118) + CHR(97) + CHR(116)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(86) + CHR(121) + CHR(98) + CHR(114) + CHR(97) + CHR(116) + CHR(32) + CHR(118) + CHR(154) + CHR(101)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(86) + CHR(121) + CHR(106) + CHR(109) + CHR(111) + CHR(117) + CHR(116)
		
		
		CASE m.tcTxtID == "MNU_PASTE"
		RETURN CHR(86) + CHR(108) + CHR(111) + CHR(158) + CHR(105) + CHR(116)
		
		
		CASE m.tcTxtID == "MNU_CLEAR"
		RETURN CHR(86) + CHR(121) + CHR(109) + CHR(97) + CHR(122) + CHR(97) + CHR(116)
		
		
		CASE m.tcTxtID == "REPORTVIEWER_TITLE"
		RETURN CHR(78) + CHR(225) + CHR(104) + CHR(108) + CHR(101) + CHR(100) + CHR(32) + CHR(116) + CHR(105) + CHR(115) + CHR(107) + CHR(117)
		
		
		CASE m.tcTxtID == "SEARCH_NOT_FOUND"
		RETURN CHR(78) + CHR(101) + CHR(110) + CHR(97) + CHR(108) + CHR(101) + CHR(122) + CHR(101) + CHR(110) + CHR(111)
		
		
		CASE m.tcTxtID == "SEARCH_ENDED"
		RETURN CHR(72) + CHR(108) + CHR(101) + CHR(100) + CHR(225) + CHR(110) + CHR(237) + CHR(32) + CHR(117) + CHR(107) + CHR(111) + CHR(110) + CHR(232) + CHR(101) + CHR(110) + CHR(111)
		
		
		CASE m.tcTxtID == "BTN_PRINT"
		RETURN CHR(84) + CHR(105) + CHR(115) + CHR(107)
		
		
		CASE m.tcTxtID == "PRINTENV_TITLE"
		RETURN CHR(78) + CHR(97) + CHR(115) + CHR(116) + CHR(97) + CHR(118) + CHR(101) + CHR(110) + CHR(237) + CHR(32) + CHR(116) + CHR(105) + CHR(115) + CHR(107) + CHR(117)
		
		
		CASE m.tcTxtID == "PRINTENV_OK"
		RETURN CHR(84) + CHR(105) + CHR(115) + CHR(107)
		
		
		CASE m.tcTxtID == "PRINTENV_CANCEL"
		RETURN CHR(90) + CHR(114) + CHR(117) + CHR(154) + CHR(105) + CHR(116)
		
		
		CASE m.tcTxtID == "PRINTENV_PRINTER"
		RETURN CHR(84) + CHR(105) + CHR(115) + CHR(107) + CHR(225) + CHR(114) + CHR(110) + CHR(97)
		
		
		CASE m.tcTxtID == "PRINTENV_COPIES"
		RETURN CHR(80) + CHR(111) + CHR(232) + CHR(101) + CHR(116) + CHR(32) + CHR(107) + CHR(111) + CHR(112) + CHR(105) + CHR(237)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE"
		RETURN CHR(83) + CHR(116) + CHR(114) + CHR(97) + CHR(110) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ALL"
		RETURN CHR(86) + CHR(154) + CHR(101)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ODD"
		RETURN CHR(80) + CHR(111) + CHR(117) + CHR(122) + CHR(101) + CHR(32) + CHR(108) + CHR(105) + CHR(99) + CHR(104) + CHR(233) + CHR(32) + CHR(115) + CHR(116) + CHR(114) + CHR(97) + CHR(110) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_EVEN"
		RETURN CHR(80) + CHR(111) + CHR(117) + CHR(122) + CHR(101) + CHR(32) + CHR(115) + CHR(117) + CHR(100) + CHR(233) + CHR(32) + CHR(115) + CHR(116) + CHR(114) + CHR(97) + CHR(110) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_PAGELIST"
		RETURN CHR(80) + CHR(248) + CHR(237) + CHR(107) + CHR(108) + CHR(97) + CHR(100) + CHR(58) + CHR(32) + CHR(49) + CHR(45) + CHR(51) + CHR(44) + CHR(32) + CHR(53) + CHR(45) + CHR(56) + CHR(44) + CHR(32) + CHR(57)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_DUPLEX"
		RETURN CHR(79) + CHR(98) + CHR(111) + CHR(117) + CHR(115) + CHR(116) + CHR(114) + CHR(97) + CHR(110) + CHR(110) + CHR(253) + CHR(32) + CHR(116) + CHR(105) + CHR(115) + CHR(107)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE"
		RETURN CHR(86) + CHR(101) + CHR(108) + CHR(105) + CHR(107) + CHR(111) + CHR(115) + CHR(116) + CHR(32) + CHR(112) + CHR(97) + CHR(112) + CHR(237) + CHR(114) + CHR(117)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE_AUTO"
		RETURN CHR(65) + CHR(117) + CHR(116) + CHR(111) + CHR(109) + CHR(97) + CHR(116) + CHR(105) + CHR(99) + CHR(107) + CHR(225) + CHR(32) + CHR(118) + CHR(111) + CHR(108) + CHR(98) + CHR(97)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_TITLE"
		RETURN CHR(90) + CHR(97) + CHR(100) + CHR(101) + CHR(106) + CHR(116) + CHR(101) + CHR(32) + CHR(104) + CHR(101) + CHR(115) + CHR(108) + CHR(111)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_PROMPT"
		RETURN CHR(83) + CHR(111) + CHR(117) + CHR(98) + CHR(111) + CHR(114) + CHR(32) + CHR(80) + CHR(68) + CHR(70) + CHR(32) + CHR(106) + CHR(101) + CHR(32) + CHR(99) + CHR(104) + CHR(114) + CHR(225) + CHR(110) + CHR(236) + CHR(110) + CHR(32) + CHR(104) + CHR(101) + CHR(115) + CHR(108) + CHR(101) + CHR(109) + CHR(46) + CHR(32) + CHR(90) + CHR(97) + CHR(100) + CHR(101) + CHR(106) + CHR(116) + CHR(101) + CHR(32) + CHR(104) + CHR(101) + CHR(115) + CHR(108) + CHR(111) + CHR(32) + CHR(112) + CHR(114) + CHR(111) + CHR(32) + CHR(111) + CHR(116) + CHR(101) + CHR(118) + CHR(248) + CHR(101) + CHR(110) + CHR(237) + CHR(32) + CHR(115) + CHR(111) + CHR(117) + CHR(98) + CHR(111) + CHR(114) + CHR(117) + CHR(46)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_INCORRECTPASSWORD"
		RETURN CHR(78) + CHR(101) + CHR(115) + CHR(112) + CHR(114) + CHR(225) + CHR(118) + CHR(110) + CHR(233) + CHR(32) + CHR(104) + CHR(101) + CHR(115) + CHR(108) + CHR(111)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_OK"
		RETURN CHR(79) + CHR(116) + CHR(101) + CHR(118) + CHR(248) + CHR(237) + CHR(116) + CHR(32) + CHR(100) + CHR(111) + CHR(107) + CHR(117) + CHR(109) + CHR(101) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_CANCEL"
		RETURN CHR(90) + CHR(114) + CHR(117) + CHR(154) + CHR(105) + CHR(116)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_TITLE"
		RETURN CHR(86) + CHR(253) + CHR(98) + CHR(236) + CHR(114) + CHR(32) + CHR(116) + CHR(105) + CHR(115) + CHR(107) + CHR(225) + CHR(114) + CHR(110) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_OK"
		RETURN CHR(80) + CHR(111) + CHR(117) + CHR(158) + CHR(237) + CHR(116)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_CANCEL"
		RETURN CHR(90) + CHR(114) + CHR(117) + CHR(154) + CHR(105) + CHR(116)
		
		
		CASE m.tcTxtID == "PRINTENV_TOTAL_SHEETS"
		RETURN CHR(80) + CHR(111) + CHR(232) + CHR(101) + CHR(116) + CHR(32) + CHR(108) + CHR(105) + CHR(115) + CHR(116) + CHR(249) + CHR(32) + CHR(112) + CHR(97) + CHR(112) + CHR(237) + CHR(114) + CHR(117)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_de
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_DE.XML for LocaleID = 1031
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(75) + CHR(111) + CHR(112) + CHR(105) + CHR(101) + CHR(114) + CHR(101) + CHR(110)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(65) + CHR(108) + CHR(108) + CHR(101) + CHR(115) + CHR(32) + CHR(109) + CHR(97) + CHR(114) + CHR(107) + CHR(105) + CHR(101) + CHR(114) + CHR(101) + CHR(110)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_en
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_EN.XML for LocaleID = 1033
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(121)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(83) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(116) + CHR(32) + CHR(97) + CHR(108) + CHR(108)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(67) + CHR(117) + CHR(116)
		
		
		CASE m.tcTxtID == "MNU_PASTE"
		RETURN CHR(80) + CHR(97) + CHR(115) + CHR(116) + CHR(101)
		
		
		CASE m.tcTxtID == "MNU_CLEAR"
		RETURN CHR(67) + CHR(108) + CHR(101) + CHR(97) + CHR(114)
		
		
		CASE m.tcTxtID == "REPORTVIEWER_TITLE"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(32) + CHR(112) + CHR(114) + CHR(101) + CHR(118) + CHR(105) + CHR(101) + CHR(119)
		
		
		CASE m.tcTxtID == "SEARCH_NOT_FOUND"
		RETURN CHR(78) + CHR(111) + CHR(116) + CHR(32) + CHR(102) + CHR(111) + CHR(117) + CHR(110) + CHR(100)
		
		
		CASE m.tcTxtID == "SEARCH_ENDED"
		RETURN CHR(83) + CHR(101) + CHR(97) + CHR(114) + CHR(99) + CHR(104) + CHR(32) + CHR(101) + CHR(110) + CHR(100) + CHR(101) + CHR(100)
		
		
		CASE m.tcTxtID == "BTN_PRINT"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PRINTENV_TITLE"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(32) + CHR(115) + CHR(101) + CHR(116) + CHR(116) + CHR(105) + CHR(110) + CHR(103)
		
		
		CASE m.tcTxtID == "PRINTENV_OK"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PRINTENV_CANCEL"
		RETURN CHR(67) + CHR(97) + CHR(110) + CHR(99) + CHR(101) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTENV_PRINTER"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(101) + CHR(114)
		
		
		CASE m.tcTxtID == "PRINTENV_COPIES"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(105) + CHR(101) + CHR(115)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE"
		RETURN CHR(80) + CHR(97) + CHR(103) + CHR(101) + CHR(115)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ALL"
		RETURN CHR(65) + CHR(108) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ODD"
		RETURN CHR(79) + CHR(100) + CHR(100) + CHR(32) + CHR(112) + CHR(97) + CHR(103) + CHR(101) + CHR(115) + CHR(32) + CHR(111) + CHR(110) + CHR(108) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_EVEN"
		RETURN CHR(69) + CHR(118) + CHR(101) + CHR(110) + CHR(32) + CHR(112) + CHR(97) + CHR(103) + CHR(101) + CHR(115) + CHR(32) + CHR(111) + CHR(110) + CHR(108) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_PAGELIST"
		RETURN CHR(69) + CHR(120) + CHR(97) + CHR(109) + CHR(112) + CHR(108) + CHR(101) + CHR(58) + CHR(32) + CHR(49) + CHR(45) + CHR(51) + CHR(44) + CHR(32) + CHR(53) + CHR(45) + CHR(56) + CHR(44) + CHR(32) + CHR(57)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_DUPLEX"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(32) + CHR(111) + CHR(110) + CHR(32) + CHR(98) + CHR(111) + CHR(116) + CHR(104) + CHR(32) + CHR(115) + CHR(105) + CHR(100) + CHR(101) + CHR(115)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE"
		RETURN CHR(80) + CHR(97) + CHR(112) + CHR(101) + CHR(114) + CHR(32) + CHR(115) + CHR(105) + CHR(122) + CHR(101)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE_AUTO"
		RETURN CHR(65) + CHR(117) + CHR(116) + CHR(111) + CHR(109) + CHR(97) + CHR(116) + CHR(105) + CHR(99) + CHR(32) + CHR(99) + CHR(104) + CHR(111) + CHR(105) + CHR(99) + CHR(101)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_TITLE"
		RETURN CHR(73) + CHR(110) + CHR(112) + CHR(117) + CHR(116) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_PROMPT"
		RETURN CHR(80) + CHR(68) + CHR(70) + CHR(32) + CHR(102) + CHR(105) + CHR(108) + CHR(101) + CHR(32) + CHR(105) + CHR(115) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100) + CHR(32) + CHR(112) + CHR(114) + CHR(111) + CHR(116) + CHR(101) + CHR(99) + CHR(116) + CHR(101) + CHR(100) + CHR(46) + CHR(32) + CHR(73) + CHR(110) + CHR(112) + CHR(117) + CHR(116) + CHR(32) + CHR(97) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100) + CHR(32) + CHR(116) + CHR(111) + CHR(32) + CHR(111) + CHR(112) + CHR(101) + CHR(110) + CHR(32) + CHR(116) + CHR(104) + CHR(101) + CHR(32) + CHR(102) + CHR(105) + CHR(108) + CHR(101) + CHR(46)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_INCORRECTPASSWORD"
		RETURN CHR(73) + CHR(110) + CHR(99) + CHR(111) + CHR(114) + CHR(114) + CHR(101) + CHR(99) + CHR(116) + CHR(32) + CHR(112) + CHR(97) + CHR(115) + CHR(115) + CHR(119) + CHR(111) + CHR(114) + CHR(100)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_OK"
		RETURN CHR(79) + CHR(112) + CHR(101) + CHR(110) + CHR(32) + CHR(100) + CHR(111) + CHR(99) + CHR(117) + CHR(109) + CHR(101) + CHR(110) + CHR(116)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_CANCEL"
		RETURN CHR(67) + CHR(97) + CHR(110) + CHR(99) + CHR(101) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_TITLE"
		RETURN CHR(80) + CHR(114) + CHR(105) + CHR(110) + CHR(116) + CHR(101) + CHR(114) + CHR(32) + CHR(115) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(116) + CHR(105) + CHR(111) + CHR(110)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_OK"
		RETURN CHR(65) + CHR(112) + CHR(112) + CHR(108) + CHR(121)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_CANCEL"
		RETURN CHR(67) + CHR(97) + CHR(110) + CHR(99) + CHR(101) + CHR(108)
		
		
		CASE m.tcTxtID == "PRINTENV_TOTAL_SHEETS"
		RETURN CHR(84) + CHR(111) + CHR(116) + CHR(97) + CHR(108) + CHR(32) + CHR(115) + CHR(104) + CHR(101) + CHR(101) + CHR(116) + CHR(115) + CHR(32) + CHR(111) + CHR(102) + CHR(32) + CHR(112) + CHR(97) + CHR(112) + CHR(101) + CHR(114)
		
		OTHERWISE
		RETURN m.tcTxtID
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_es
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_ES.XML for LocaleID = 1034
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(105) + CHR(97) + CHR(114)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(83) + CHR(101) + CHR(108) + CHR(101) + CHR(99) + CHR(99) + CHR(105) + CHR(111) + CHR(110) + CHR(97) + CHR(114) + CHR(32) + CHR(116) + CHR(111) + CHR(100) + CHR(111)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_fr
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_FR.XML for LocaleID = 1036
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(67) + CHR(111) + CHR(112) + CHR(105) + CHR(101) + CHR(114)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(83) + CHR(233) + CHR(108) + CHR(101) + CHR(99) + CHR(116) + CHR(105) + CHR(111) + CHR(110) + CHR(110) + CHR(101) + CHR(114) + CHR(32) + CHR(116) + CHR(111) + CHR(117) + CHR(116)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

	HIDDEN PROCEDURE text_ru
		* This code is generated by BUILD\BUILD_I18N.prg from SOURCE\I18N\TEXT_RU.XML for LocaleID = 1049
		
		LPARAMETERS tcTxtID
		
		DO CASE
		
		CASE m.tcTxtID == "MNU_COPY"
		RETURN CHR(202) + CHR(238) + CHR(239) + CHR(232) + CHR(240) + CHR(238) + CHR(226) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "MNU_SLCTA"
		RETURN CHR(194) + CHR(251) + CHR(225) + CHR(240) + CHR(224) + CHR(242) + CHR(252) + CHR(32) + CHR(226) + CHR(241) + CHR(229)
		
		
		CASE m.tcTxtID == "MNU_CUT"
		RETURN CHR(194) + CHR(251) + CHR(240) + CHR(229) + CHR(231) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "MNU_PASTE"
		RETURN CHR(194) + CHR(241) + CHR(242) + CHR(224) + CHR(226) + CHR(232) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "MNU_CLEAR"
		RETURN CHR(211) + CHR(228) + CHR(224) + CHR(235) + CHR(232) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "REPORTVIEWER_TITLE"
		RETURN CHR(207) + CHR(240) + CHR(238) + CHR(241) + CHR(236) + CHR(238) + CHR(242) + CHR(240) + CHR(32) + CHR(239) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(232)
		
		
		CASE m.tcTxtID == "SEARCH_NOT_FOUND"
		RETURN CHR(205) + CHR(229) + CHR(32) + CHR(237) + CHR(224) + CHR(233) + CHR(228) + CHR(229) + CHR(237) + CHR(238)
		
		
		CASE m.tcTxtID == "SEARCH_ENDED"
		RETURN CHR(207) + CHR(238) + CHR(232) + CHR(241) + CHR(234) + CHR(32) + CHR(231) + CHR(224) + CHR(226) + CHR(229) + CHR(240) + CHR(248) + CHR(229) + CHR(237)
		
		
		CASE m.tcTxtID == "BTN_PRINT"
		RETURN CHR(207) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTENV_TITLE"
		RETURN CHR(207) + CHR(224) + CHR(240) + CHR(224) + CHR(236) + CHR(229) + CHR(242) + CHR(240) + CHR(251) + CHR(32) + CHR(239) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(232)
		
		
		CASE m.tcTxtID == "PRINTENV_OK"
		RETURN CHR(207) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTENV_CANCEL"
		RETURN CHR(206) + CHR(242) + CHR(236) + CHR(229) + CHR(237) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTENV_PRINTER"
		RETURN CHR(207) + CHR(240) + CHR(232) + CHR(237) + CHR(242) + CHR(229) + CHR(240)
		
		
		CASE m.tcTxtID == "PRINTENV_COPIES"
		RETURN CHR(202) + CHR(238) + CHR(239) + CHR(232) + CHR(232)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE"
		RETURN CHR(209) + CHR(242) + CHR(240) + CHR(224) + CHR(237) + CHR(232) + CHR(246) + CHR(251)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ALL"
		RETURN CHR(194) + CHR(241) + CHR(229)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_ODD"
		RETURN CHR(210) + CHR(238) + CHR(235) + CHR(252) + CHR(234) + CHR(238) + CHR(32) + CHR(237) + CHR(229) + CHR(247) + CHR(229) + CHR(242) + CHR(237) + CHR(251) + CHR(229)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_EVEN"
		RETURN CHR(210) + CHR(238) + CHR(235) + CHR(252) + CHR(234) + CHR(238) + CHR(32) + CHR(247) + CHR(229) + CHR(242) + CHR(237) + CHR(251) + CHR(229)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_PAGELIST"
		RETURN CHR(205) + CHR(224) + CHR(239) + CHR(240) + CHR(232) + CHR(236) + CHR(229) + CHR(240) + CHR(58) + CHR(32) + CHR(49) + CHR(45) + CHR(51) + CHR(44) + CHR(32) + CHR(53) + CHR(45) + CHR(56) + CHR(44) + CHR(32) + CHR(57)
		
		
		CASE m.tcTxtID == "PRINTENV_PAGEMODE_DUPLEX"
		RETURN CHR(196) + CHR(226) + CHR(243) + CHR(241) + CHR(242) + CHR(238) + CHR(240) + CHR(238) + CHR(237) + CHR(237) + CHR(255) + CHR(255) + CHR(32) + CHR(239) + CHR(229) + CHR(247) + CHR(224) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE"
		RETURN CHR(208) + CHR(224) + CHR(231) + CHR(236) + CHR(229) + CHR(240) + CHR(32) + CHR(225) + CHR(243) + CHR(236) + CHR(224) + CHR(227) + CHR(232)
		
		
		CASE m.tcTxtID == "PRINTENV_PAPERSIZE_AUTO"
		RETURN CHR(192) + CHR(226) + CHR(242) + CHR(238) + CHR(226) + CHR(251) + CHR(225) + CHR(238) + CHR(240)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_TITLE"
		RETURN CHR(194) + CHR(226) + CHR(229) + CHR(228) + CHR(232) + CHR(242) + CHR(229) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(252)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_PROMPT"
		RETURN CHR(80) + CHR(68) + CHR(70) + CHR(32) + CHR(244) + CHR(224) + CHR(233) + CHR(235) + CHR(32) + CHR(231) + CHR(224) + CHR(249) + CHR(232) + CHR(249) + CHR(229) + CHR(237) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(229) + CHR(236) + CHR(46) + CHR(32) + CHR(194) + CHR(226) + CHR(229) + CHR(228) + CHR(232) + CHR(242) + CHR(229) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(252) + CHR(32) + CHR(228) + CHR(235) + CHR(255) + CHR(32) + CHR(238) + CHR(242) + CHR(234) + CHR(240) + CHR(251) + CHR(242) + CHR(232) + CHR(255) + CHR(32) + CHR(244) + CHR(224) + CHR(233) + CHR(235) + CHR(224) + CHR(46)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_INCORRECTPASSWORD"
		RETURN CHR(205) + CHR(229) + CHR(239) + CHR(240) + CHR(224) + CHR(226) + CHR(232) + CHR(235) + CHR(252) + CHR(237) + CHR(251) + CHR(233) + CHR(32) + CHR(239) + CHR(224) + CHR(240) + CHR(238) + CHR(235) + CHR(252)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_OK"
		RETURN CHR(206) + CHR(242) + CHR(234) + CHR(240) + CHR(251) + CHR(242) + CHR(252) + CHR(32) + CHR(228) + CHR(238) + CHR(234) + CHR(243) + CHR(236) + CHR(229) + CHR(237) + CHR(242)
		
		
		CASE m.tcTxtID == "PASSWORDINPUT_CANCEL"
		RETURN CHR(206) + CHR(242) + CHR(236) + CHR(229) + CHR(237) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_TITLE"
		RETURN CHR(194) + CHR(251) + CHR(225) + CHR(238) + CHR(240) + CHR(32) + CHR(239) + CHR(240) + CHR(232) + CHR(237) + CHR(242) + CHR(229) + CHR(240) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_OK"
		RETURN CHR(209) + CHR(238) + CHR(245) + CHR(240) + CHR(224) + CHR(237) + CHR(232) + CHR(242) + CHR(252)
		
		
		CASE m.tcTxtID == "PRINTER_SELECTION_CANCEL"
		RETURN CHR(206) + CHR(242) + CHR(236) + CHR(229) + CHR(237) + CHR(224)
		
		
		CASE m.tcTxtID == "PRINTENV_TOTAL_SHEETS"
		RETURN CHR(194) + CHR(241) + CHR(229) + CHR(227) + CHR(238) + CHR(32) + CHR(235) + CHR(232) + CHR(241) + CHR(242) + CHR(238) + CHR(226) + CHR(32) + CHR(225) + CHR(243) + CHR(236) + CHR(224) + CHR(227) + CHR(232)
		
		OTHERWISE
		RETURN This.text_en(m.tcTxtID)
		
		ENDCASE
		
		RETURN m.tcTxtID
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_password_input AS form 		&& Password input form
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtPassword" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOk" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTitle" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFocusHolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPrompt" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblIncorrect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgPasswordShow" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgPasswordHide" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: in_incorrect		&& Incorrect password flag
		*p: out_ok		&& .T. - User pressed ok button, .F. - user pressed cancel
		*p: out_password		&& Inputted password
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BindControls = .F.
		BorderStyle = 2
		Caption = ""
		DoCreate = .T.
		Height = 187
		Icon = (NVL(EVL(JUSTPATH(This.ClassLibrary),NULL)+"\images\wwrite.ico",""))
		in_incorrect = .F.
		KeyPreview = .T.
		MaxButton = .F.
		MinButton = .F.
		Name = "pdfium_password_input"
		out_ok = .F.
		out_password = ("")
		ShowWindow = 1
		TitleBar = 0
		Visible = .T.
		Width = 331
		WindowType = 1
		_memberdata = <VFPData>
			<memberdata name="in_incorrect" type="property" display="In_Incorrect"/>
			<memberdata name="out_ok" type="property" display="Out_Ok"/>
			<memberdata name="out_password" type="property" display="Out_Password"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Cancel", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 192, ;
		Name = "cmdCancel", ;
		TabIndex = 3, ;
		Top = 144, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFocusHolder' AS commandbutton WITH ;
		Caption = "", ;
		Height = 27, ;
		Left = 444, ;
		Name = "cmdFocusHolder", ;
		Style = 1, ;
		TabIndex = 4, ;
		Top = 276, ;
		Width = 36
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOk' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Ok", ;
		Default = .T., ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 12, ;
		Name = "cmdOk", ;
		TabIndex = 2, ;
		Top = 144, ;
		Width = 160
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 300, ;
		Name = "i18n", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'imgPasswordHide' AS image WITH ;
		Height = 24, ;
		Left = 291, ;
		MousePointer = 15, ;
		Name = "imgPasswordHide", ;
		PictureVal = , ;
		Top = 73, ;
		Visible = .F., ;
		Width = 24
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'imgPasswordShow' AS image WITH ;
		Height = 24, ;
		Left = 291, ;
		MousePointer = 15, ;
		Name = "imgPasswordShow", ;
		PictureVal = , ;
		Top = 73, ;
		Visible = .F., ;
		Width = 24
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'lblIncorrect' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Incorrect password", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		ForeColor = 255,0,0, ;
		Height = 19, ;
		Left = 12, ;
		Name = "lblIncorrect", ;
		TabIndex = 5, ;
		Top = 106, ;
		Width = 300
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPrompt' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "This file is protected by password. Input password to open the file", ;
		FontBold = .F., ;
		FontName = "Segoe UI", ;
		FontSize = 9, ;
		Height = 33, ;
		Left = 12, ;
		Name = "lblPrompt", ;
		TabIndex = 5, ;
		Top = 36, ;
		Width = 300, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblTitle' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Input password", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 12, ;
		Name = "lblTitle", ;
		TabIndex = 5, ;
		Top = 12, ;
		Width = 300
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'txtPassword' AS pdfium_textbox WITH ;
		ControlSource = "Thisform.out_password", ;
		Format = "KF", ;
		Height = 27, ;
		InputMask = "", ;
		Left = 12, ;
		MaxLength = 255, ;
		Name = "txtPassword", ;
		PasswordChar = "", ;
		TabIndex = 1, ;
		Top = 72, ;
		Width = 276
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />
	
	PROCEDURE Init
		This.BindControls = .T.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 27 AND EMPTY(m.nShiftAltCtrl)
		    This.out_ok = .F.
		    This.Hide()
		ENDIF
		
		
	ENDPROC

	PROCEDURE Load
		CLEAR TYPEAHEAD 
		
		
		
		
	ENDPROC

	PROCEDURE Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_TITLE")
		
		This.txtPassword.Value = This.Out_Password
		This.lblIncorrect.Visible = This.in_incorrect
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.out_ok = .F.
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE cmdCancel.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_CANCEL")
		
	ENDPROC

	PROCEDURE cmdOk.Click
		
		Thisform.Out_Ok = .T.
		
		Thisform.Hide()
		
		
	ENDPROC

	PROCEDURE cmdOk.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_OK")
		
	ENDPROC

	PROCEDURE imgPasswordHide.Click
		This.Visible = .F.
		This.Parent.txtPassword.ResetToDefault("PasswordChar")
		This.Parent.txtPassword.InteractiveChange()
		This.Parent.txtPassword.SelStart = LEN(This.Parent.txtPassword.Text)
		
	ENDPROC

	PROCEDURE imgPasswordHide.Init
		This.PictureVal = STRCONV("iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAASnSURBVEhL7ZR7aFt1FMd/v/u+N69C3dwUpkWx7fLqc0xcZTIEFVe"+"FgmBfaZO1Da7+4R/6h8Ol9TFRhCKFdq3UPuI/boNVNhi+YFERtiZp0qKydi1tpfXFZpv0Jmnuy3PT24zVig78R/ADyb055/zON79zzu+H/udOwM3e9keN938NbDxRs6+j02y29IqJ5JujwwOvGeYcDQ0NVlIQdhGIEQiSoC"+"Q5LVoYZqWvr2/dCPlL8gJNXn85RZFnBMH0YCK51h0cGujS7SD8Ek3RJ+C1kCQphGGFoihIVuQVsH2LNfzx/Ox346FQSNbjt0MaTzQ1Gf7Z7ai4oGjqIwLP1ztcbhSLhkNlrspVROCDkPSaosgXpawUUzVlBWnaPo7jq1mOf"+"85kLXjW6apYmopFZo10efI72KKxtaPfYjb5NXCJ6+vdweHNnQDY42kv1jScHBsbWA4EAsT80koNJogXBV6o0yAgJYpvB4cHX90M3yS/A52mlrb3rVbrcQhckhUpYbZYavc7nDg+Gbnc1HS8ENPogmAxvessq3j+xs3EXHBk8"+"AvwnXE43ROqig5ZbdanS0oc1ngs8pmR8pYA/HOfzWZ7K53JLGqSclgjlTOKrD3D8/zR/Q43Co72XzpQVf6JpGh3IQ1XsDzrc7pc0dhkZAY+s/ZS1zko3RNmi7W2uLj0l6l4NKznzZWo3vvCfSyFpwmC5KTUxiEowVXd3uA5d"+"pBh2C8ZhhEyqVQ3TFeuXB5Px/0kS0/LsvRbyibYz/X0pHV7s8/nYmjT14qqYDktOYLBwSVCd9Ca/IoZZjSbTr+xlVyHEehfobm0JEmI5bmAx9eRExgdHViQlex5WFJkWU0V5YKBsaGhqWw2dUrPRdDEy7otJ6ARhKJp0CYSi"+"/rvPBmVg7GkVFVBugjDcoEWrz+guwiFPJFKp8KapppysQYwBKyeCpD0r00BUn0PJibBslxXo9fr0G06NK0twIpZmqaRCl2UQYRm2S5Pa0fXyEj/j1Jq7Ygo0D8Y4XCWvA/D6J4UxWQCq7hHt+WaPBWJrDnc5TdNJlOdKmtH7"+"BXu8eloNBGJRCRXZfUCgXE9RVG5AwZ/B7EcexjOCQ6ODn/6/cREFoy45Zi/hqKYs9Azazaz4R8dPv2VnvvWQYtFIqWlzkKbreApJSvVudxV1+Kx8PWpaHjG4SyfgFI5VA0VQklIEFI4nn/M7ihD8clwCJZjd1nVRzBB9sTqW"+"ieM7webWXc4aM1efzfPcyd1VzqTOksSxOD8zO7LoVC33NDWthdKRhIqsYciqHGW4+5Ni2JuujztnSWqLFcHPzwdNFLl+JOATnNr25OYpN6BaXCqiorSKfEGNO6KhtESCOh12geX0uOCIHBQMSSmxfzdtZ3bTvIW8Vj0+kMPF"+"A1hgrwqyTIBd9E90INKhmaqoOEHYOKKIfGMlM1+DpdeAUxlbandtVWu29hxB9tpbGw00bTlbpWUrHA6kKSi35fndi3rZWtpaasgaPoiL5j2JpPJ120m+lRvb++GsfSfCfwdDSACu7vE8dzu9WSyBi68bwzXziW6U6Zj0Z/sL"+"vcVRVZii3N7zi8uhlTD9Z8HoT8A5bAHNfkKxCkAAAAASUVORK5CYII=",14)
		
	ENDPROC

	PROCEDURE imgPasswordShow.Click
		This.Visible = .F.
		This.Parent.txtPassword.PasswordChar = ""
		This.Parent.txtPassword.InteractiveChange()
		This.Parent.txtPassword.SelStart = LEN(This.Parent.txtPassword.Text)
		
	ENDPROC

	PROCEDURE imgPasswordShow.Init
		This.PictureVal = STRCONV("iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAPxSURBV"+"EhL7ZRfaBxFHMdn9u/s7l1DHjQ2TTHFUqsBa1SKiKKSVqGGRi2o1Oz9SS53xT5IEGPBlxxtkWIffGmSW7zLXa4BEarWaC1UK6WgiE1JBNGWEmvQ+iAid7e7t//Hmbu9lJKYV33o52Fn9"+"7u/+f125vedBbf5z4HhuC6jo6PSn1V7E8dAiWEZzvXqRlQQbkxMTOhhyL+yboFk6mA/hoFKbh8jebtYjm1M8H0feL53A2J4ETL4g4I2+UljwhqsWeDV+PBTvCAeUxRlJ01WN83fMMCLJ"+"HwJBIAnSTtJ2KOSpNxJixq6fsnz8Fsni1PnmxluwoTjCmoyfUhRIl8jEe2s1fRTdUPfVcpPbZ7J5/p54B7lIHu4lM8NdHfdtdGyzD69VjstSdIjCAlfxZMH3gjTrHDLCgYT6SPt7e1vG"+"6bxR+D5mWJ+co7qaiI1wPLCMY5l74UQku3xf/Qcb6xczJ2h7xPDmT0MyxUkWe6oVqrZ8nRunOqUlQJqfESNtrXNWLa1bOvmM7OzhStUjw2N7JXkyGnPdYHrunMAQp8Uep7jeODY5t5iX"+"mt+hJraxknCWUWObKlVKqnSdC5P9UaB/UOv3Y04uMgwLGs71tPlgnaJ6vF4HGEWLQqi2O3V7f5iMXeO6olEZjeHhLOO4ywhDu/QNM1sxqce5iX5fBD42K27D5TL2nKjBzwMxpRIpM2yr"+"COt5BSflbYiSdpmW/aZVnIKvXccew4haavhwu5QBqXS+/O2bbyjRKJtDM+8SbWwyYGLMSarx17zuQmPcUD1tSC6SF6TGOCGUgOMGUguAEPg0OdGAQ8Gxw1Dr4iiNK6qQ71Uo/A8vm5b1"+"i8iEp+Lx9N9oQzU1I"+"FnRRHtsm3752hUWA5lsJ9sEUJoXNf1v33GP061lSbHkukkaXLBMutLlmHuaTVZTab6id/niHOA77mfknUGPMeRJnPAIn0pFSY/p3GvxFI9CkJfCEjcrFdr+8"+"pF7SOqs/RCWVyYX9h+Xw9UohtewBC/vKP3oasLl+ev/LBw+er9PQ9+DxnYy/PC48RB28nh+6nuWMlyIddInhhOv0iMcEpWlI3VSuXoyaJ2opGUsOokx4Yyr5Pg96gN66bxMdlF7fq1O7"+"68cCHrxWKZTTRmZib3Ox2J/3eTFR2UZWXA9Vxg29YYMcm79F2LVQUoanLkSYbjD0dk+QnaY9PQ/yLjd6Rxy6SBPgm5h65IlpQO8vMDpm5843jBodni1MVmhpusWaAFPaEQsi8Rx/SRf0"+"4Xy3LEacQUngeI168BzHwLOPDh9NSJz8Ipq1i3QIvBwUGF56MdAetuAEAgFnRrWzo7f81ms7fY+jb/RwD4B+vrrUXeOtApAAAAAElFTkSuQmCC",14)
	ENDPROC

	PROCEDURE lblIncorrect.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_INCORRECTPASSWORD")
	ENDPROC

	PROCEDURE lblPrompt.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_PROMPT")
	ENDPROC

	PROCEDURE lblTitle.Refresh
		This.Caption = Thisform.i18n.text("PASSWORDINPUT_TITLE")
	ENDPROC

	PROCEDURE txtPassword.InteractiveChange
		DO CASE
		CASE EMPTY(NVL(This.Value,""))
		    This.Parent.imgPasswordShow.Visible = .F.
		    This.Parent.imgPasswordHide.Visible = .F.
		
		CASE EMPTY(This.PasswordChar) = .T.
		    This.Parent.imgPasswordShow.Visible = .F.
		    This.Parent.imgPasswordHide.Visible = .T.
		
		OTHERWISE
		    This.Parent.imgPasswordShow.Visible = .T.
		    This.Parent.imgPasswordHide.Visible = .F.
		    
		ENDCASE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_pdfmeta AS custom 		&& PDF metadata (author,creator etc) + encryption (by password) + permission (read, edit, print etc)
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: author		&& The name of the person who created the document
		*p: creator		&& The the name of the application that created the document
		*p: keywords		&& The keywords associated with the document
		*p: ownerpassword		&& The password for the owner of the document. Owner password protects permissions of the document (Permit_* properties) . The same value as user password are not allowed. Mandatory if user password is set
		*p: permit_copy		&& Reader can copy the text and the graphics of the document; Owner password must be set to apply permission to the output doc
		*p: permit_edit		&& Reader can add or modify the annotations and form fields of the document. Owner password must be set to apply permission to the output doc
		*p: permit_edit_all		&& Reader can edit the contents of the document other than annotations, form fields. Owner password must be set to apply permission to the output doc
		*p: permit_print		&& Reader can print the document; Owner password must be set to apply permission to the output doc
		*p: producer		&& The name of the application that produced the document
		*p: subject		&& The subject of the document
		*p: title		&& The title of the document
		*p: userpassword		&& The password for the reader of the document. Document is encrypted if user password is set. Owner password is mandatory if User password is not empty
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,Error,Height,HelpContextID,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		author = ("")
		creator = ("")
		Height = 27
		keywords = ("")
		Name = "pdfium_pdfmeta"
		ownerpassword = ("")
		permit_copy = .T.
		permit_edit = .T.
		permit_edit_all = .T.
		permit_print = .T.
		producer = ("pdfium-vfp")
		subject = ("")
		title = ("")
		userpassword = ("")
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="author" type="property" display="Author"/>
			<memberdata name="creator" type="property" display="Creator"/>
			<memberdata name="keywords" type="property" display="Keywords"/>
			<memberdata name="ownerpassword" type="property" display="OwnerPassword"/>
			<memberdata name="producer" type="property" display="Producer"/>
			<memberdata name="subject" type="property" display="Subject"/>
			<memberdata name="title" type="property" display="Title"/>
			<memberdata name="userpassword" type="property" display="UserPassword"/>
		</VFPData>
	*</PropValue>

ENDDEFINE

DEFINE CLASS pdfium_print_env AS custom 		&& Print configuration state for PdfiumViewer and PdfiumReport.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="API_WIN" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: foxdefaultprinter_get		&& Returns VFP default printer (SET("Printer", 3))
		*m: foxdefaultprinter_restore		&& Restore VFP default printer to the value before first FoxDefaultPrinter_Set call or before first FoxDefaultPrinter_Set after previous FoxDefaultPrinter_Restore call
		*m: foxdefaultprinter_set		&& Set VFP default printer. If input parameter is empty default printer is set to This.Printer
		*m: getprinterdevmode		&& Return output structure DEVMODE from DocumentProperties win32api function
		*m: getprinterduplex		&& Returns printer duplex support: .T. - duplex is supported, .F. - duplex is not supported.
		*m: getprinterforms		&& Return full list of paper forms with the flag indicating that  form is supported by printer
		*m: getprintertitle
		*m: pagelist_parse		&& Parse page list input (string), returns valid string of page list
		*m: setup		&& Copy print configuration from external pdfium_print_env object
		*m: setupdefault		&& Set default values (as they are on Init)
		*m: statelen		&& Return length of the state stack
		*m: statepop		&& Restores object's state from stack saved by This.StatePush call
		*m: statepush		&& Stores object's state in the stack
		*m: sysdefaultprinter_get		&& Returns system default printer
		*m: sysdefaultprinter_restore		&& Restore system default printer to the value before first SysDefaultPrinter_Set call or before first SysDefaultPrinter_Set after previous SysDefaultPrinter_Restore call
		*m: sysdefaultprinter_set		&& Set system default printer. If input parameter is empty default printer is set to This.Printer
		*p: allowprintsetupui		&& Allows print setup dialog to be shown to a user. This is instructions to application using this object not to show any print settings dialogs. Values .T. (Default) | .F. | NULL
		*p: allowsetdefaultprinter		&& Allows set default printer. This is instructions to application using this object not to change default vfp printer. Values .T. (default) | .F. | NULL
		*p: copies		&& Number of  copies; Default value = 1
		*p: duplex		&& Duplex mode .T. | .F. (Default) | NULL
		*p: foxdefaultprinter_prev		&& VFP default printer before FoxDefaultPrinter_Set call
		*p: pagelist		&& List of pages to print (comma separated), supports intervals: 1,2-5,10; Default value = empty string
		*p: pagemode		&& 1 (default) - all, 2 - only odd, 3 - only even, 4 - PageList
		*p: papersize		&& Paper size index (like PRTINFO(2) returns); -1 - auto choice the fittest to the document; 0 (default) - unknown paper size
		*p: printer		&& Printer name; Default value = VFP default printer (sys("printer",3))
		*p: statestacksize		&& Size of StateStack
		*p: sysdefaultprinter_prev		&& System default printer before SysDefaultPrinter_Set call
		*a: statestack[1,0]		&& State store for This.StatePush and This.StatePop
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,Error,foxdefaultprinter_prev,Height,HelpContextID,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,statestacksize,statestack,sysdefaultprinter_prev,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		allowprintsetupui = .T.
		allowsetdefaultprinter = .T.
		copies = 1
		duplex = .F.
		foxdefaultprinter_prev = ("")
		Height = 27
		Name = "pdfium_print_env"
		pagelist = ("")
		pagemode = 1
		papersize = 0
		printer = ("")
		statestacksize = 0
		sysdefaultprinter_prev = ("")
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="getprinterdevmode" type="method" display="GetPrinterDevMode"/>
			<memberdata name="getprinterduplex" type="method" display="GetPrinterDuplex"/>
			<memberdata name="getprinterforms" type="method" display="GetPrinterForms"/>
			<memberdata name="getprintertitle" type="method" display="GetPrinterTitle"/>
			<memberdata name="pagelist" type="property" display="PageList"/>
			<memberdata name="pagelist_parse" type="method" display="PageList_Parse"/>
			<memberdata name="pagemode" type="property" display="PageMode"/>
			<memberdata name="papersize" type="property" display="PaperSize"/>
			<memberdata name="printer" type="property" display="Printer"/>
			<memberdata name="setup" type="method" display="SetUp"/>
			<memberdata name="setupdefault" type="method" display="SetupDefault"/>
			<memberdata name="statelen" type="method" display="StateLen"/>
			<memberdata name="statepop" type="method" display="StatePop"/>
			<memberdata name="statepush" type="method" display="StatePush"/>
			<memberdata name="statestack" type="property" display="StateStack"/>
			<memberdata name="statestacksize" type="property" display="StateStackSize"/>
			<memberdata name="sysdefaultprinter_get" type="method" display="SysDefaultPrinter_Get"/>
			<memberdata name="sysdefaultprinter_prev" type="property" display="SysDefaultPrinter_Prev"/>
			<memberdata name="sysdefaultprinter_restore" type="method" display="SysDefaultPrinter_Restore"/>
			<memberdata name="sysdefaultprinter_set" type="method" display="SysDefaultPrinter_Set"/>
			<memberdata name="allowprintsetupui" type="property" display="AllowPrintSetupUI"/>
			<memberdata name="allowsetdefaultprinter" type="property" display="AllowSetDefaultPrinter"/>
			<memberdata name="copies" type="property" display="Copies"/>
			<memberdata name="duplex" type="property" display="Duplex"/>
			<memberdata name="foxdefaultprinter_get" type="method" display="FoxDefaultPrinter_Get"/>
			<memberdata name="foxdefaultprinter_prev" type="property" display="FoxDefaultPrinter_Prev"/>
			<memberdata name="foxdefaultprinter_restore" type="method" display="FoxDefaultPrinter_Restore"/>
			<memberdata name="foxdefaultprinter_set" type="method" display="FoxDefaultPrinter_Set"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'API_WIN' AS pdfium_api_win WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_WIN", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE foxdefaultprinter_get		&& Returns VFP default printer (SET("Printer", 3))
		RETURN EVL(SET("Printer",3),"")
		
	ENDPROC

	PROCEDURE foxdefaultprinter_restore		&& Restore VFP default printer to the value before first FoxDefaultPrinter_Set call or before first FoxDefaultPrinter_Set after previous FoxDefaultPrinter_Restore call
		
		IF EMPTY(NVL(This.FoxDefaultPrinter_Prev,"")) = .T.
		    RETURN .F.
		ENDIF
		
		SET PRINTER TO NAME (This.FoxDefaultPrinter_Prev)
		
		This.FoxDefaultPrinter_Prev = ""
		
		
	ENDPROC

	PROCEDURE foxdefaultprinter_set		&& Set VFP default printer. If input parameter is empty default printer is set to This.Printer
		LPARAMETERS tcPrinter
		
		LOCAL lcPrinter
		m.lcPrinter = EVL(NVL(m.tcPrinter,""), EVL(NVL(This.Printer,""),""))
		
		IF EMPTY(m.lcPrinter) = .T.
		    RETURN .F.
		ENDIF
		
		IF EMPTY(This.FoxDefaultPrinter_Prev)
		    This.FoxDefaultPrinter_Prev = This.FoxDefaultPrinter_Get()
		ENDIF
		
		SET PRINTER TO NAME (m.lcPrinter)
		
		
	ENDPROC

	PROCEDURE getprinterdevmode		&& Return output structure DEVMODE from DocumentProperties win32api function
		LPARAMETERS lcPrinter
		
		* lcPrinter - printer name
		* Return: DEVMODE structure (as STRING)
		
		IF EMPTY(NVL(m.lcPrinter,""))
		    RETURN ""
		ENDIF
		
		
		#define DM_OUT_BUFFER 2
		#define DM_IN_BUFFER  8
		#define DM_IN_PROMPT  4
		
		LOCAL lcPrnDevMode
		m.lcPrnDevMode = ""
		
		LOCAL lhPrinter
		m.lhPrinter = 0
		
		This.API_WIN.OpenPrinter(m.lcPrinter, @m.lhPrinter, 0)
		
		IF m.lhPrinter = 0 
		    RETURN ""
		ENDIF
		
		LOCAL lnBufSize
		m.lnBufsize = This.API_WIN.DocumentProperties(Application.HWnd, m.lhPrinter, m.lcPrinter, NULL, NULL, 0)
		
		IF m.lnBufSize > 0
		    m.lcPrnDevMode = REPLICATE(CHR(0), m.lnBufsize)
		    This.API_WIN.DocumentProperties(Application.HWnd, m.lhPrinter, m.lcPrinter, @m.lcPrnDevMode, NULL, DM_OUT_BUFFER)
		ENDIF
		
		IF LEN(CHRTRAN(m.lcPrnDevMode, CHR(0), "")) = 0
		    m.lcPrnDevMode = ""
		ENDIF
		
		This.API_WIN.ClosePrinter(m.lhPrinter)
		
		RETURN m.lcPrnDevMode
		
	ENDPROC

	PROCEDURE getprinterduplex		&& Returns printer duplex support: .T. - duplex is supported, .F. - duplex is not supported.
		LPARAMETERS lcPrinter
		
		IF EMPTY(NVL(m.lcPrinter,""))
		    RETURN 0
		ENDIF
		
		#define DC_DUPLEX 7
		
		RETURN EMPTY(This.API_WIN.DeviceCapabilities(m.lcPrinter, NULL, DC_DUPLEX, NULL, NULL)) = .F.
		
	ENDPROC

	PROCEDURE getprinterforms		&& Return full list of paper forms with the flag indicating that  form is supported by printer
		LPARAMETERS laPrnForm, lcPrinter
		
		* laPrnForm - output array (form-info-1 of EnumForms + additional columns)
		* lcPrinter - printer name
		* Return: number of forms of printer 
		
		* laPrnForm[,1] - Flags
		* laPrnForm[,2] - pName
		* laPrnForm[,3] - Size width
		* laPrnForm[,4] - Size height
		* laPrnForm[,5] - ImageableArea Left
		* laPrnForm[,6] - ImageableArea Top
		* laPrnForm[,7] - ImageableArea Width
		* laPrnForm[,8] - ImageableArea Height
		* laPrnForm[,9] - Form is supported by the printer .T. | .F.
		
		IF EMPTY(NVL(m.lcPrinter,""))
		    RETURN 0
		ENDIF
		
		#define DC_PAPERS 2
		
		
		LOCAL lhPrinter
		m.lhPrinter = 0
		
		This.API_WIN.OpenPrinter(m.lcPrinter, @m.lhPrinter, 0)
		
		IF m.lhPrinter = 0 
		    RETURN 0
		ENDIF
		
		LOCAL lnPrnFormCnt
		m.lnPrnFormCnt = 0
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    LOCAL lnBufSize, lnFormHeap, lnFormHeapPtr
		    STORE 0 TO m.lnBufSize, m.lnFormHeap, m.lnFormHeapPtr
		
		    This.API_WIN.EnumForms(m.lhPrinter, 1,  0, 0, @m.lnBufSize, 0)
		    IF m.lnBufSize = 0
		        EXIT
		    ENDIF
		    m.lnFormHeap = This.API_WIN.HeapCreate(0, m.lnBufSize, 0)
		    IF EMPTY(m.lnFormHeap)
		        EXIT
		    ENDIF
		    m.lnFormHeapPtr = This.API_WIN.HeapAlloc(m.lnFormHeap, 0, m.lnBufSize)
		    IF EMPTY(m.lnFormHeapPtr)
		        EXIT
		    ENDIF
		    This.API_WIN.EnumForms(m.lhPrinter, 1, m.lnFormHeapPtr, m.lnBufSize, @m.lnBufSize, @m.lnPrnFormCnt)
		    IF EMPTY(m.lnPrnFormCnt)
		        EXIT
		    ENDIF
		    
		    DIMENSION m.laPrnForm(m.lnPrnFormCnt, 9)
		    
		    LOCAL liForm, lnFormOffs
		    m.liForm = 1
		    m.lnFormOffs = m.lnFormHeapPtr
		    FOR m.liForm = 1 TO m.lnPrnFormCnt
		        m.laPrnForm[m.liForm,1] = CTOBIN(SYS(2600, m.lnFormOffs, 4),"4RS") && Flags
		        m.laPrnForm[m.liForm,2] = SYS(2600, CTOBIN(SYS(2600, m.lnFormOffs+4, 4),"4RS"), 31) &&pName
		        m.laPrnForm[m.liForm,3] = CTOBIN(SYS(2600, m.lnFormOffs+8, 4),"4RS") &&Size width
		        m.laPrnForm[m.liForm,4] = CTOBIN(SYS(2600, m.lnFormOffs+12, 4),"4RS") &&Size height
		        m.laPrnForm[m.liForm,5] = CTOBIN(SYS(2600, m.lnFormOffs+16, 4),"4RS") && ImageableArea Left
		        m.laPrnForm[m.liForm,6] = CTOBIN(SYS(2600, m.lnFormOffs+20, 4),"4RS") && ImageableArea Top
		        m.laPrnForm[m.liForm,7] = CTOBIN(SYS(2600, m.lnFormOffs+24, 4),"4RS") && ImageableArea Width
		        m.laPrnForm[m.liForm,8] = CTOBIN(SYS(2600, m.lnFormOffs+28, 4),"4RS") && ImageableArea Height
		        m.laPrnForm[m.liForm,9] = .F.
		        m.lnFormOffs = m.lnFormOffs + 32        
		    ENDFOR
		
		CATCH TO m.loErr
		    
		FINALLY
		    IF EMPTY(m.lnFormHeap) = .F.
		        This.API_WIN.HeapDestroy(m.lnFormHeap)
		    ENDIF
		
		    This.API_WIN.ClosePrinter(m.lhPrinter)
		ENDTRY
		
		IF VARTYPE(m.loErr) = "O"
		    RETURN 0
		ENDIF
		
		LOCAL lcPapers, lnPaperCnt, liPaper, lnFormID
		m.lnPaperCnt = This.API_WIN.DeviceCapabilities(m.lcPrinter, NULL, DC_PAPERS, NULL, NULL)
		
		IF m.lnPaperCnt <> 0
		    m.lcPapers = REPLICATE(CHR(0), m.lnPaperCnt * 2)
		    m.lnPaperCnt = This.API_WIN.DeviceCapabilities(m.lcPrinter, NULL, DC_PAPERS, @m.lcPapers, NULL)
		    m.liPaper = 1
		    FOR m.liPaper = 1 TO m.lnPaperCnt
		        m.lnFormID = CTOBIN(SUBSTR(m.lcPapers, (m.liPaper-1)*2 + 1, 2), "2RS")
		        IF BETWEEN(m.lnFormID, 1, m.lnPrnFormCnt)
		            m.laPrnForm[m.lnFormID,9] = .T.
		        ENDIF
		    ENDFOR
		ENDIF
		
		
		RETURN m.lnPrnFormCnt
		
	ENDPROC

	PROCEDURE getprintertitle
		LPARAMETERS lcPrinter
		
		m.lcPrinter = EVL(NVL(m.lcPrinter,""), NVL(This.Printer,""))
		
		IF EMPTY(m.lcPrinter) = .T.
		    RETURN ""
		ENDIF
		
		LOCAL ARRAY laPrinters(1)
		LOCAL lnPrinters, liPrinter
		m.lnPrinters = APRINTERS(laPrinters,1)
		m.liPrinter = ASCAN(m.laPrinters, m.lcPrinter, 1, m.lnPrinters, 1, 15)
		IF m.liPrinter > 0
		    RETURN m.laPrinters[m.liPrinter,1]
		ENDIF
		
		RETURN ""
		
	ENDPROC

	PROCEDURE Init
		This.Printer = This.FoxDefaultPrinter_Get()
		
	ENDPROC

	PROCEDURE pagelist_parse		&& Parse page list input (string), returns valid string of page list
		LPARAMETERS m.tcPageList
		
		LOCAL lcPageList
		m.lcPageList = m.tcPageList
		
		IF INLIST(VARTYPE(m.lcPageList), "C", "N") = .F.
		    m.lcPageList = ""
		ENDIF
		
		m.lcPageList = LEFT(ALLTRIM(EVL(NVL(m.lcPageList,""),"")),200)
		m.lcPageList = CHRTRAN(m.lcPageList, ";.Ee", ",")
		
		
		LOCAL ARRAY laGroups(1)
		LOCAL lnGroups
		m.lnGroups = ALINES(laGroups, m.lcPageList, 1+4, ",")
		
		IF m.lnGroups = 0
		    RETURN ""
		ENDIF
		
		LOCAL ARRAY laGroups2(lnGroups * 2)
		LOCAL lnGroups2
		m.lnGroups2 = 0
		
		LOCAL i, lcGroup, lnLVal, lnRVal, lnEVal
		m.i = 1
		FOR m.i = 1 TO m.lnGroups
		    m.lcGroup = m.laGroups[m.i]
		    
		    m.lnLVal = MAX(INT(VAL(LEFT(STREXTRACT(m.lcGroup, "", "-",1,2),10))), 0)
		    m.lnRVal = MAX(INT(VAL(LEFT(STREXTRACT(m.lcGroup, "-", "",1,2),10))), 0)
		
		    m.lnEVal = m.lnLVal
		    m.lnLVal = EVL(MIN(m.lnEVal, m.lnRVal), m.lnEVal)
		    m.lnRVal = MAX(m.lnEVal, m.lnRVal)
		
		    IF EMPTY(m.lnLVal)
		        LOOP
		    ENDIF
		    
		    m.lnGroups2 = m.lnGroups2 + 1 
		    m.laGroups2[m.lnGroups2] = m.lnLVal
		    
		    m.lnGroups2 = m.lnGroups2 + 1 
		    m.laGroups2[m.lnGroups2] = m.lnRVal
		    
		ENDFOR
		
		
		
		LOCAL i, lnLInd, lnLVal, lnRVal
		
		DO WHILE .T.
		    m.i = 1
		    m.lnLInd = 1
		    m.lnLVal = 0
		    m.lnRVal = 0
		    DO WHILE m.i < m.lnGroups2 
		        
		        DO CASE
		        CASE m.laGroups2[m.lnLInd] > m.laGroups2[m.i]
		            m.lnLVal = m.laGroups2[m.lnLInd]
		            m.laGroups2[m.lnLInd] = m.laGroups2[m.i]
		            m.laGroups2[m.lnLInd+1] = m.laGroups2[m.i+1]
		               
		            m.laGroups2[m.i] = m.lnLVal
		            m.laGroups2[m.i+1] = m.lnRVal
		            m.lnLInd = m.i
		
		        CASE m.lnRVal < m.laGroups2[m.i]
		            m.lnLInd = m.i
		            m.lnRVal = m.laGroups2[m.i+1]
		
		        
		        CASE m.lnRVal = m.laGroups2[m.i]
		            m.lnRVal = m.laGroups2[m.i+1]
		
		        CASE m.lnRVal < m.laGroups2[m.i+1]
		            m.laGroups2[m.i] = m.lnRVal
		            m.lnRVal = m.laGroups2[m.i+1]
		
		        OTHERWISE
		            m.laGroups2[m.i] = m.lnRVal
		            m.laGroups2[m.i+1] = m.lnRVal
		        ENDCASE
		        
		        m.i = m.i + 2
		        
		    ENDDO
		
		    IF m.lnLVal = 0
		        EXIT
		    ENDIF
		ENDDO
		
		
		
		m.lcPageList = ""
		
		LOCAL i, lnLVal, lnRVal
		m.i = 1
		m.lnLVal = 0
		m.lnRVal = 0
		DO WHILE m.i < m.lnGroups2
		    
		    IF m.lnRVal = m.laGroups2[m.i+1]
		        m.i = m.i + 2
		        LOOP
		    ENDIF
		    
		    IF m.lnRVal = m.laGroups2[m.i]
		        m.lnLVal = m.laGroups2[m.i]
		        m.lnRVal = m.laGroups2[m.i+1]
		        m.i = m.i + 2
		        LOOP
		    ENDIF
		    
		    m.lcPageList = m.lcPageList + ;
		        IIF(m.lnLVal = m.lnRVal, "", "-" + TRANSFORM(m.lnRVal)) + ;
		        IIF(EMPTY(m.lcPageList), "", ", ") + ;
		        TRANSFORM(m.laGroups2[m.i])
		   
		    m.lnLVal = m.laGroups2[m.i]
		    m.lnRVal = m.laGroups2[m.i+1]
		    m.i = m.i + 2
		ENDDO
		
		m.lcPageList = m.lcPageList + IIF(m.lnLVal = m.lnRVal, "", "-" + TRANSFORM(m.lnRVal))
		
		
		RETURN m.lcPageList
		
		
	ENDPROC

	PROCEDURE setup		&& Copy print configuration from external pdfium_print_env object
		LPARAMETERS toPrintEnvSrc as pdfium_print_env of pdfium-vfp, tlCopyAsIs, tcFields, tcFieldsExcept
		
		* toPrintEnvSrc: if Object passed then copies state from it, if NULL is passed then set state to undefined
		* tcFields: restore fields those matching this list (format: string of comma separated field names)
		* tcFieldsExcept: restore fields except those matching this list (format: string of comma separated field names).
		
		LOCAL lcFields, lcFieldsExcept
		m.lcFields = ALLTRIM(CHRTRAN(EVL(NVL(m.tcFields,""),""), " ", ""), 1, ",")
		m.lcFieldsExcept = ALLTRIM(CHRTRAN(EVL(NVL(m.lcFieldsExcept,""),""), " ",""), 1, ",")
		
		**************************************************************
		* Store props according to tcFieldsExcept and tcFields
		**************************************************************
		
		LOCAL ARRAY laPropState(1,2) 
		LOCAL lnPropStateCnt
		m.lnPropStateCnt = 0
		
		IF EMPTY(m.lcFields)=.F. OR EMPTY(m.lcFieldsExcept) = .F.
		    LOCAL ARRAY laProps(1)
		    LOCAL lnProps, liProp
		    m.lnProps = AMEMBERS(laProps, This, 0, "U+G")
		
		    FOR m.liProp = 1 TO m.lnProps
		
		        LOCAL lcPropName
		        m.lcPropName = ALLTRIM(m.laProps[m.liProp])
		
		        IF EMPTY(m.lcFields)=.F. AND ATC(","+m.lcPropName+",", ","+m.lcFields+",") = 0
		            LOOP
		        ENDIF
		
		        IF EMPTY(m.lcFieldsExcept)=.F. AND ATC(","+m.lcPropName+",", ","+m.lcFieldsExcept+",") <> 0
		            LOOP
		        ENDIF
		
		        m.lnPropStateCnt = m.lnPropStateCnt + 1
		        DIMENSION m.laPropState(m.lnPropStateCnt, 2)
		
		        m.laPropState[m.lnPropStateCnt, 1] = m.lcPropName
		        m.laPropState[m.lnPropStateCnt, 2] = This.&lcPropName
		
		    ENDFOR
		ENDIF
		**************************************************************
		
		DO CASE
		CASE VARTYPE(m.toPrintEnvSrc)="O" AND m.tlCopyAsIs
		    This.Printer = m.toPrintEnvSrc.Printer
		    This.Copies = m.toPrintEnvSrc.Copies
		    This.PageMode = m.toPrintEnvSrc.PageMode
		    This.PageList = m.toPrintEnvSrc.PageList
		    This.Duplex = m.toPrintEnvSrc.Duplex
		    This.PaperSize = m.toPrintEnvSrc.PaperSize
		    This.AllowPrintSetupUI = m.toPrintEnvSrc.AllowPrintSetupUI
		    This.AllowSetDefaultPrinter = m.toPrintEnvSrc.AllowSetDefaultPrinter
		
		CASE VARTYPE(m.toPrintEnvSrc)="O"
		    IF NOT ALLTRIM(LOWER(EVL(NVL(m.toPrintEnvSrc.Printer,""), This.Printer))) == ALLTRIM(LOWER(This.Printer))
		        This.PaperSize = 0
		    ENDIF
		
		    This.Printer = EVL(NVL(m.toPrintEnvSrc.Printer,""), This.Printer)
		    This.Copies = EVL(NVL(m.toPrintEnvSrc.Copies, 0), This.Copies)
		    This.PageMode = EVL(NVL(m.toPrintEnvSrc.PageMode, 0), This.PageMode)
		    This.PageList = EVL(NVL(m.toPrintEnvSrc.PageList, ""), This.PageList)
		    This.Duplex = NVL(m.toPrintEnvSrc.Duplex, This.Duplex)
		    This.PaperSize = EVL(EVL(NVL(m.toPrintEnvSrc.PaperSize, 0), NVL(This.PaperSize,0)), EVL(MAX(PRTINFO(2, NVL(This.Printer,"")),0), -1))
		    This.AllowPrintSetupUI = NVL(m.toPrintEnvSrc.AllowPrintSetupUI, This.AllowPrintSetupUI)
		    This.AllowSetDefaultPrinter = NVL(m.toPrintEnvSrc.AllowSetDefaultPrinter, This.AllowSetDefaultPrinter)
		
		
		CASE ISNULL(m.toPrintEnvSrc)
		    This.Printer = ""
		    This.Copies = 0
		    This.PageMode = 0
		    This.PageList = ""
		    This.Duplex = NULL
		    This.PaperSize = 0
		    This.AllowPrintSetupUI = NULL
		    This.AllowSetDefaultPrinter = NULL
		
		ENDCASE
		
		
		**************************************************************
		* Restore props according to tcFieldsExcept and tcFields
		**************************************************************
		LOCAL liProp
		FOR m.liProp = 1 TO m.lnPropStateCnt
		
		    LOCAL lcPropName
		    m.lcPropName = ALLTRIM(m.laPropState[m.liProp, 1])
		
		    This.&lcPropName = m.laPropState[m.liProp, 2]
		
		ENDFOR
		**************************************************************
		
	ENDPROC

	PROCEDURE setupdefault		&& Set default values (as they are on Init)
		LPARAMETERS tlCopyAsIs, tcFields, tcFieldsExcept
		
		* tcFields: restore fields those matching this list (format: string of comma separated field names)
		* tcFieldsExcept: restore fields except those matching this list (format: string of comma separated field names).
		
		LOCAL loPrintEnv
		m.loPrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		
		This.Setup(m.loPrintEnv, m.tlCopyAsIs, m.tcFieldsExcept, m.tcFields)
		
	ENDPROC

	PROCEDURE statelen		&& Return length of the state stack
		RETURN This.StateStackSize
		
	ENDPROC

	PROCEDURE statepop		&& Restores object's state from stack saved by This.StatePush call
		LPARAMETERS tcFields, tcFieldsExcept
		
		* tcFields: restore fields those matching this list (format: string of comma separated field names)
		* tcFieldsExcept: restore fields except those matching this list (format: string of comma separated field names).
		
		
		IF EMPTY(This.StateStackSize)
		    RETURN 0
		ENDIF
		
		LOCAL lSavePrintEnv
		m.lSavePrintEnv = This.StateStack[This.StateStackSize]
		
		This.Setup(m.lSavePrintEnv, .T., m.tcFieldsExcept, m.tcFields)
		
		This.StateStack[This.StateStackSize] = .F.
		This.StateStackSize = This.StateStackSize - 1
		
		IF EMPTY(This.StateStackSize) = .F.
		    DIMENSION This.StateStack(This.StateStackSize)
		ENDIF    
		
		RETURN This.StateStackSize
		
	ENDPROC

	PROCEDURE statepush		&& Stores object's state in the stack
		This.StateStackSize = This.StateStackSize + 1
		DIMENSION This.StateStack(This.StateStackSize)
		
		LOCAL lSavePrintEnv
		m.lSavePrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		
		m.lSavePrintEnv.Setup(This, .T.)
		
		This.StateStack[This.StateStackSize] = m.lSavePrintEnv
		
		RETURN This.StateStackSize
		
	ENDPROC

	PROCEDURE sysdefaultprinter_get		&& Returns system default printer
		
		LOCAL lcBuf, lnBufLen
		m.lcBuf = REPLICATE(CHR(0),2000)
		m.lnBufLen = LEN(m.lcBuf)
		
		LOCAL lcPrinter
		m.lcPrinter = ""
		
		IF This.API_WIN.GetDefaultPrinter(@m.lcBuf, @m.lnBufLen) <> 0
		    IF m.lnBufLen > 0
		        m.lcPrinter = SUBSTR(m.lcBuf, 1, m.lnBufLen)
		    ENDIF
		ENDIF    
		
		RETURN m.lcPrinter
		
	ENDPROC

	PROCEDURE sysdefaultprinter_restore		&& Restore system default printer to the value before first SysDefaultPrinter_Set call or before first SysDefaultPrinter_Set after previous SysDefaultPrinter_Restore call
		IF EMPTY(NVL(This.SysDefaultPrinter_Prev,""))
		    RETURN .F.
		ENDIF
		
		IF This.API_WIN.SetDefaultPrinter(This.SysDefaultPrinter_Prev) = 0
		    RETURN .F.
		ENDIF
		
		This.SysDefaultPrinter_Prev = ""
		
	ENDPROC

	PROCEDURE sysdefaultprinter_set		&& Set system default printer. If input parameter is empty default printer is set to This.Printer
		LPARAMETERS tcPrinter
		
		LOCAL lcPrinter
		m.lcPrinter = EVL(NVL(m.tcPrinter,""), EVL(NVL(This.Printer,""),""))
		
		IF EMPTY(m.lcPrinter) = .T.
		    RETURN .F.
		ENDIF
		
		IF EMPTY(This.SysDefaultPrinter_Prev)
		    This.SysDefaultPrinter_Prev = This.SysDefaultPrinter_Get()
		ENDIF    
		
		IF This.API_WIN.SetDefaultPrinter(This.Printer) = 0
		    RETURN .F.
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_print_settings AS form 		&& Print settings dialog.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmbPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDuplex" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOk" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="PrintEnv" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCopies" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCopies" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ogrPageMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPageMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtPageList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPageList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFocusHolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmbPaperSize" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPaperSize" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTotalSheets" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: cancel		&& Specifies if a CommandButton is the Cancel button.
		*m: papersizerequery
		*m: refreshstate
		*m: setup
		*p: out_ok		&& .T. - User pressed ok button, .F. - user pressed cancel
		*p: pagecount		&& Total page count in document
		*p: printenvin
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN printenvin
	*<PropValue>
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BindControls = .F.
		BorderStyle = 2
		Caption = "Print setup"
		DoCreate = .T.
		Height = 297
		Icon = (NVL(EVL(JUSTPATH(This.ClassLibrary),NULL)+"\images\wwrite.ico",""))
		KeyPreview = .T.
		MaxButton = .F.
		MinButton = .F.
		Name = "pdfium_print_settings"
		out_ok = .F.
		pagecount = (.NULL.)
		printenvin = .F.
		ShowWindow = 1
		Visible = .T.
		Width = 435
		WindowType = 1
		_memberdata = <VFPData>
			<memberdata name="out_ok" type="property" display="Out_Ok"/>
			<memberdata name="papersizerequery" type="method" display="PaperSizeRequery"/>
			<memberdata name="cancel" type="method" display="Cancel"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="printenvin" type="property" display="PrintEnvIn"/>
			<memberdata name="pagecount" type="property" display="PageCount"/>
			<memberdata name="refreshstate" type="method" display="RefreshState"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'chkDuplex' AS checkbox WITH ;
		Alignment = 4, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Duplex printing", ;
		ControlSource = "Thisform.PrintEnv.duplex", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 20, ;
		Left = 12, ;
		Name = "chkDuplex", ;
		TabIndex = 4, ;
		Top = 125, ;
		Width = 177, ;
		WordWrap = .F.
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmbPaperSize' AS combobox WITH ;
		BoundColumn = 2, ;
		BoundTo = .T., ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "160,0", ;
		ControlSource = "", ;
		DisplayCount = 21, ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 28, ;
		Left = 12, ;
		Name = "cmbPaperSize", ;
		Style = 2, ;
		TabIndex = 5, ;
		Top = 180, ;
		Width = 180
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmbPrinters' AS combobox WITH ;
		BoundColumn = 1, ;
		BoundTo = .T., ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "370,200", ;
		ControlSource = "Thisform.PrintEnv.printer", ;
		DisplayCount = 30, ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 28, ;
		Left = 12, ;
		Name = "cmbPrinters", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 28, ;
		Width = 408
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Cancel", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 237, ;
		Name = "cmdCancel", ;
		TabIndex = 10, ;
		Top = 252, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFocusHolder' AS commandbutton WITH ;
		Caption = "", ;
		Height = 27, ;
		Left = 444, ;
		Name = "cmdFocusHolder", ;
		Style = 1, ;
		TabIndex = 1, ;
		Top = 276, ;
		Width = 36
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOk' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Ok", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 74, ;
		Name = "cmdOk", ;
		TabIndex = 9, ;
		Top = 252, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 336, ;
		Name = "i18n", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'lblCopies' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Copies", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblCopies", ;
		TabIndex = 12, ;
		Top = 69, ;
		Width = 117
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPageList' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "For example: 1,2, 4 -5", ;
		Enabled = .T., ;
		FontBold = .F., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 248, ;
		Name = "lblPageList", ;
		TabIndex = 11, ;
		Top = 183, ;
		Width = 143
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPageMode' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Pages", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 227, ;
		Name = "lblPageMode", ;
		TabIndex = 15, ;
		Top = 69, ;
		Width = 171
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPaperSize' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Paper size", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblPaperSize", ;
		TabIndex = 14, ;
		Top = 158, ;
		Width = 173
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPrinters' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Printer", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblPrinters", ;
		TabIndex = 13, ;
		Top = 4, ;
		Width = 173
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblTotalSheets' AS label WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Total number of sheets: <<SheetCount>> ", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 81, ;
		Name = "lblTotalSheets", ;
		TabIndex = 15, ;
		Top = 216, ;
		Width = 273
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'ogrPageMode' AS optiongroup WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		ButtonCount = 4, ;
		ControlSource = "Thisform.PrintEnv.PageMode", ;
		Height = 121, ;
		Left = 221, ;
		Name = "ogrPageMode", ;
		TabIndex = 7, ;
		Top = 90, ;
		Value = 1, ;
		Width = 208, ;
		Option1.AutoSize = .F., ;
		Option1.Caption = "All", ;
		Option1.FontName = "Segoe UI", ;
		Option1.FontSize = 10, ;
		Option1.Height = 19, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 5, ;
		Option1.Value = 1, ;
		Option1.Width = 193, ;
		Option2.AutoSize = .F., ;
		Option2.Caption = "Odd pages only", ;
		Option2.FontName = "Segoe UI", ;
		Option2.FontSize = 10, ;
		Option2.Height = 19, ;
		Option2.Left = 5, ;
		Option2.Name = "Option2", ;
		Option2.Top = 34, ;
		Option2.Width = 193, ;
		Option3.AutoSize = .F., ;
		Option3.Caption = "Even pages only", ;
		Option3.FontName = "Segoe UI", ;
		Option3.FontSize = 10, ;
		Option3.Height = 19, ;
		Option3.Left = 5, ;
		Option3.Name = "Option3", ;
		Option3.PictureMargin = 0, ;
		Option3.PictureSpacing = 0, ;
		Option3.Top = 63, ;
		Option3.Width = 193, ;
		Option4.AutoSize = .F., ;
		Option4.Caption = "", ;
		Option4.FontName = "Segoe UI", ;
		Option4.FontSize = 10, ;
		Option4.Height = 19, ;
		Option4.Left = 5, ;
		Option4.Name = "Option4", ;
		Option4.Top = 94, ;
		Option4.Width = 19
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'PrintEnv' AS pdfium_print_env WITH ;
		Left = 288, ;
		Name = "PrintEnv", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'txtCopies' AS pdfium_textbox WITH ;
		ControlSource = "Thisform.PrintEnv.copies", ;
		Height = 27, ;
		InputMask = "9999", ;
		Left = 12, ;
		Name = "txtCopies", ;
		TabIndex = 3, ;
		Top = 90, ;
		Width = 113
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtPageList' AS pdfium_textbox WITH ;
		ControlSource = "Thisform.PrintEnv.PageList", ;
		Height = 27, ;
		InputMask = "", ;
		Left = 242, ;
		Name = "txtPageList", ;
		TabIndex = 8, ;
		TabStop = .F., ;
		Top = 180, ;
		Width = 173
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />
	
	PROCEDURE cancel		&& Specifies if a CommandButton is the Cancel button.
		Thisform.out_ok = .F.
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE Destroy
		This.PrintEnvIn = .F.
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toPrintEnvIn as pdfium_print_env of pdfium-vfp.vcx, toDocProps
		
		This.PrintEnvIn = m.toPrintEnvIn
		This.PrintEnv.Setup(This.PrintEnvIn)
		
		IF VARTYPE(m.toDocProps) = "O"
		    IF PEMSTATUS(m.toDocProps, "PageCount", 5)
		        This.PageCount = m.toDocProps.PageCount
		    ENDIF
		ENDIF
		
		
		This.BindControls = .T.
		
		LOCAL ARRAY laPrinters(1)
		LOCAL lnPrinters
		m.lnPrinters = APRINTERS(laPrinters,1)
		
		LOCAL i, llHasComments
		m.llHasComments = .F.
		FOR m.i = 1 TO m.lnPrinters
		    LOCAL lcPrinter, lcComment
		    m.lcPrinter = RTRIM(EVL(NVL(m.laPrinters[m.i,1], ""),""))
		    m.lcComment = RTRIM(EVL(NVL(m.laPrinters[m.i,4],""),""))
		
		    IF EMPTY(m.lcPrinter)
		        LOOP
		    ENDIF
		    
		    IF EMPTY(m.lcComment)=.F.
		        m.llHasComments = .T.
		    ENDIF
		
		    This.cmbPrinters.AddItem(m.lcPrinter)
		    This.cmbPrinters.AddListItem(m.lcComment, m.i, 2)
		    
		    IF RTRIM(LOWER(This.PrintEnv.Printer)) == RTRIM(LOWER(m.lcPrinter))
		        This.PrintEnv.Printer = m.lcPrinter &&Fix uppercase printer name of set(printer,3) result
		    ENDIF
		ENDFOR
		
		IF m.llHasComments = .F.
		    This.cmbPrinters.ColumnWidths = STREXTRACT(This.cmbPrinters.ColumnWidths, "", ",",1,2) + ",0"
		ENDIF
		
		This.PaperSizeRequery()
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 27 AND EMPTY(m.nShiftAltCtrl)
		    This.Cancel()
		ENDIF
		
		
	ENDPROC

	PROCEDURE Load
		CLEAR TYPEAHEAD 
		
	ENDPROC

	PROCEDURE papersizerequery
		
		#define FORM_BUILTIN 0x00000001
		#define FORM_PRINTER 0x00000002
		
		This.cmbPaperSize.Clear()
		
		LOCAL lnPrnFormCnt
		LOCAL ARRAY laPrnForm(1,9)
		m.lnPrnFormCnt = This.PrintEnv.GetPrinterForms(@m.laPrnForm, This.PrintEnv.Printer)
		IF EMPTY(m.lnPrnFormCnt)
		    RETURN
		ENDIF
		
		This.cmbPaperSize.AddItem(Thisform.i18n.text("PRINTENV_PAPERSIZE_AUTO"))
		This.cmbPaperSize.AddListItem("-1", 1, 2)
		
		LOCAL liPrnForm, lcPrnForm, llPrnFormFound
		m.liPrnForm = 1
		m.llPrnFormFound = .F.
		FOR m.liPrnForm = 1 TO m.lnPrnFormCnt
		    m.lcPrnForm = RTRIM(TRANSFORM(EVL(NVL(m.laPrnForm[m.liPrnForm,2], ""),"")))
		
		    IF EMPTY(m.lcPrnForm)
		        LOOP
		    ENDIF
		    
		    IF m.laPrnForm[m.liPrnForm,9] = .F.
		        LOOP
		    ENDIF
		    
		    IF BITAND(m.laPrnForm[m.liPrnForm,1], FORM_BUILTIN) = 0
		        LOOP
		    ENDIF
		    
		    This.cmbPaperSize.AddItem(m.lcPrnForm)
		    This.cmbPaperSize.AddListItem(TRANSFORM(m.liPrnForm), This.cmbPaperSize.ListCount, 2)
		
		    IF m.liPrnForm = This.PrintEnv.PaperSize
		        m.llPrnFormFound = .T.
		    ENDIF
		ENDFOR
		
		IF m.llPrnFormFound = .F. AND This.PrintEnv.PaperSize <> -1
		    This.PrintEnv.PaperSize = EVL(MAX(PRTINFO(2, This.PrintEnv.Printer),0), -1)
		ENDIF
		
		This.cmbPaperSize.Value = TRANSFORM(This.Printenv.PaperSize)
		
	ENDPROC

	PROCEDURE Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_TITLE")
		
	ENDPROC

	PROCEDURE refreshstate
		This.lblTotalSheets.Refresh()
		
	ENDPROC

	PROCEDURE setup
		IF NVL(This.PrintEnv.AllowSetDefaultPrinter, .F.) = .T.
		    This.PrintEnv.FoxDefaultPrinter_Set()
		ENDIF
		
		This.PrintEnv.Copies = MAX(This.PrintEnv.Copies, 0)
		IF VARTYPE(This.PrintEnvIn) = "O"
		    This.PrintEnvIn.Setup(This.PrintEnv)
		ENDIF
		
		Thisform.Out_Ok = .T.
		
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE chkDuplex.InteractiveChange
		Thisform.RefreshState()
	ENDPROC

	PROCEDURE chkDuplex.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_DUPLEX")
		
		
	ENDPROC

	PROCEDURE cmbPaperSize.InteractiveChange
		Thisform.PrintEnv.PaperSize = INT(VAL(This.Value))
		Thisform.RefreshState()
		
	ENDPROC

	PROCEDURE cmbPrinters.InteractiveChange
		Thisform.PrintEnv.Printer = This.Value
		Thisform.PaperSizeRequery()
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.Cancel()
		
	ENDPROC

	PROCEDURE cmdCancel.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_CANCEL")
		
	ENDPROC

	PROCEDURE cmdOk.Click
		Thisform.Setup()
	ENDPROC

	PROCEDURE cmdOk.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_OK")
		
	ENDPROC

	PROCEDURE lblCopies.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_COPIES")
	ENDPROC

	PROCEDURE lblPageList.Init
		DODEFAULT()
		
		This.ForeColor = This.DisabledForeColor
		
		
	ENDPROC

	PROCEDURE lblPageList.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.Parent.txtPageList.SetFocus()
		
	ENDPROC

	PROCEDURE lblPageList.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_PAGELIST")
		
		This.Visible = EMPTY(This.Parent.txtPageList.Value)
		
		
	ENDPROC

	PROCEDURE lblPageMode.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE")
		
		IF VARTYPE(Thisform.PageCount) = "N" AND Thisform.PageCount > 0
		    This.Caption = This.Caption + ": " + TRANSFORM(Thisform.PageCount)
		ENDIF
		
	ENDPROC

	PROCEDURE lblPaperSize.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAPERSIZE")
		
	ENDPROC

	PROCEDURE lblPrinters.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PRINTER")
		
	ENDPROC

	PROCEDURE lblTotalSheets.Refresh
		IF VARTYPE(Thisform.PageCount) != "N"
		    This.Visible = .F.
		ENDIF
		
		LOCAL lnSheetCount
		m.lnSheetCount = Thisform.PageCount
		DO CASE
		CASE Thisform.ogrPageMode.Value = 2 && Odd pages
		    m.lnSheetCount = CEILING(m.lnSheetCount / 2)
		
		CASE Thisform.ogrPageMode.Value = 3 && Even pages
		    m.lnSheetCount = CEILING(m.lnSheetCount / 2) - MOD(m.lnSheetCount,2)
		
		CASE Thisform.ogrPageMode.Value = 4 && Page numbers
		    m.lnSheetCount = 0
		    LOCAL lcPageList
		    m.lcPageList = Thisform.PrintEnv.PageList_Parse(Thisform.txtPageList.Value)
		    LOCAL ARRAY laPageList(1)
		    m.lnPageRangeCnt = ALINES(laPageList, m.lcPageList,1+4,",")
		    LOCAL lnRange, lnRangeFrom, lnRangeTo
		    FOR m.lnRange = 1 TO m.lnPageRangeCnt
		        m.lnRangeFrom = MIN(MAX(INT(VAL(STREXTRACT(m.laPageList[m.lnRange], "", "-",1,2))), 1), Thisform.PageCount)
		        m.lnRangeTo = MIN(MAX(EVL(INT(VAL(STREXTRACT(m.laPageList[m.lnRange], "-", "",1,2))), m.lnRangeFrom), 1), Thisform.PageCount)
		        m.lnSheetCount = m.lnSheetCount + m.lnRangeTo - m.lnRangeFrom + 1
		    ENDFOR
		    m.lnSheetCount = MIN(m.lnSheetCount, Thisform.PageCount)
		ENDCASE
		
		m.lnSheetCount = m.lnSheetCount * MAX(Thisform.txtCopies.Value,0)
		
		IF Thisform.chkDuplex.Value
		    m.lnSheetCount = CEILING(m.lnSheetCount / 2)
		ENDIF
		
		This.Caption = Thisform.i18n.text("PRINTENV_TOTAL_SHEETS") + ": " + TRANSFORM(m.lnSheetCount)
		
	ENDPROC

	PROCEDURE ogrPageMode.InteractiveChange
		Thisform.txtPageList.TabStop = (This.Value = 4)
		Thisform.RefreshState()
	ENDPROC

	PROCEDURE ogrPageMode.Option1.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_ALL")
	ENDPROC

	PROCEDURE ogrPageMode.Option2.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_ODD")
	ENDPROC

	PROCEDURE ogrPageMode.Option3.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_EVEN")
		
	ENDPROC

	PROCEDURE ogrPageMode.ProgrammaticChange
		Thisform.txtPageList.TabStop = (This.Value = 4)
		Thisform.RefreshState()
	ENDPROC

	PROCEDURE txtCopies.InteractiveChange
		DODEFAULT()
		Thisform.RefreshState()
		
	ENDPROC

	PROCEDURE txtPageList.GotFocus
		DODEFAULT()
		
		This.Parent.lblPageList.Visible = .F.
		This.Parent.ogrPageMode.Value = 4
		
	ENDPROC

	PROCEDURE txtPageList.InteractiveChange
		DODEFAULT()
		Thisform.RefreshState()
		
	ENDPROC

	PROCEDURE txtPageList.LostFocus
		DODEFAULT()
		
		Thisform.Refresh()
		This.Parent.ogrPageMode.Value = IIF(EMPTY(This.Value), 1, 4)
		
		This.Value = Thisform.PrintEnv.PageList_Parse(This.Value)
		Thisform.RefreshState()
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_printer_selection AS form 		&& Printer selection dialog.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmbPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDuplex" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOk" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="PrintEnv" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPrinters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFocusHolder" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: cancel		&& Specifies if a CommandButton is the Cancel button.
		*m: setup
		*p: out_ok		&& .T. - User pressed ok button, .F. - user pressed cancel
		*p: printenvin
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN printenvin
	*<PropValue>
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BindControls = .F.
		BorderStyle = 2
		Caption = "Print setup"
		DoCreate = .T.
		Height = 163
		Icon = (NVL(EVL(JUSTPATH(This.ClassLibrary),NULL)+"\images\wwrite.ico",""))
		KeyPreview = .T.
		MaxButton = .F.
		MinButton = .F.
		Name = "pdfium_printer_selection"
		out_ok = .F.
		printenvin = .F.
		ShowWindow = 1
		Visible = .T.
		Width = 435
		WindowType = 1
		_memberdata = <VFPData>
			<memberdata name="out_ok" type="property" display="Out_Ok"/>
			<memberdata name="cancel" type="method" display="Cancel"/>
			<memberdata name="setup" type="method" display="Setup"/>
			<memberdata name="printenvin" type="property" display="PrintEnvIn"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'chkDuplex' AS checkbox WITH ;
		Alignment = 4, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Duplex printing", ;
		ControlSource = "Thisform.PrintEnv.duplex", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 20, ;
		Left = 12, ;
		Name = "chkDuplex", ;
		TabIndex = 4, ;
		Top = 72, ;
		Width = 177, ;
		WordWrap = .F.
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmbPrinters' AS combobox WITH ;
		BoundColumn = 1, ;
		BoundTo = .T., ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "370,200", ;
		ControlSource = "Thisform.PrintEnv.printer", ;
		DisplayCount = 30, ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 28, ;
		Left = 12, ;
		Name = "cmbPrinters", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 28, ;
		Width = 408
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Cancel", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 235, ;
		Name = "cmdCancel", ;
		TabIndex = 10, ;
		Top = 108, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFocusHolder' AS commandbutton WITH ;
		Caption = "", ;
		Height = 27, ;
		Left = 444, ;
		Name = "cmdFocusHolder", ;
		Style = 1, ;
		TabIndex = 1, ;
		Top = 276, ;
		Width = 36
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOk' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Ok", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 30, ;
		Left = 72, ;
		Name = "cmdOk", ;
		TabIndex = 9, ;
		Top = 108, ;
		Width = 124
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 336, ;
		Name = "i18n", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'lblPrinters' AS label WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Printer", ;
		FontBold = .T., ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 16, ;
		Name = "lblPrinters", ;
		TabIndex = 13, ;
		Top = 4, ;
		Width = 173
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'PrintEnv' AS pdfium_print_env WITH ;
		Left = 288, ;
		Name = "PrintEnv", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE cancel		&& Specifies if a CommandButton is the Cancel button.
		Thisform.out_ok = .F.
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE Destroy
		This.PrintEnvIn = .F.
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toPrintEnvIn as pdfium_print_env of pdfium-vfp.vcx
		
		This.PrintEnvIn = m.toPrintEnvIn
		This.PrintEnv.Setup(This.PrintEnvIn)
		
		This.BindControls = .T.
		
		LOCAL ARRAY laPrinters(1)
		LOCAL lnPrinters
		m.lnPrinters = APRINTERS(laPrinters,1)
		
		LOCAL i, llHasComments
		m.llHasComments = .F.
		FOR m.i = 1 TO m.lnPrinters
		    LOCAL lcPrinter, lcComment
		    m.lcPrinter = RTRIM(EVL(NVL(m.laPrinters[m.i,1], ""),""))
		    m.lcComment = RTRIM(EVL(NVL(m.laPrinters[m.i,4],""),""))
		
		    IF EMPTY(m.lcPrinter)
		        LOOP
		    ENDIF
		    
		    IF EMPTY(m.lcComment)=.F.
		        m.llHasComments = .T.
		    ENDIF
		
		    This.cmbPrinters.AddItem(m.lcPrinter)
		    This.cmbPrinters.AddListItem(m.lcComment, m.i, 2)
		    
		    IF RTRIM(LOWER(This.PrintEnv.Printer)) == RTRIM(LOWER(m.lcPrinter))
		        This.PrintEnv.Printer = m.lcPrinter &&Fix uppercase printer name of set(printer,3) result
		    ENDIF
		ENDFOR
		
		IF m.llHasComments = .F.
		    This.cmbPrinters.ColumnWidths = STREXTRACT(This.cmbPrinters.ColumnWidths, "", ",",1,2) + ",0"
		ENDIF
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 27 AND EMPTY(m.nShiftAltCtrl)
		    This.Cancel()
		ENDIF
		
	ENDPROC

	PROCEDURE Load
		CLEAR TYPEAHEAD 
		
	ENDPROC

	PROCEDURE Refresh
		This.Caption = Thisform.i18n.text("PRINTER_SELECTION_TITLE")
		
	ENDPROC

	PROCEDURE setup
		IF NVL(This.PrintEnv.AllowSetDefaultPrinter, .F.) = .T.
		    This.PrintEnv.FoxDefaultPrinter_Set()
		ENDIF
		
		IF VARTYPE(This.PrintEnvIn) = "O"
		    This.PrintEnvIn.Setup(This.PrintEnv)
		ENDIF
		
		Thisform.Out_Ok = .T.
		
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE chkDuplex.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PAGEMODE_DUPLEX")
		
		
	ENDPROC

	PROCEDURE cmbPrinters.InteractiveChange
		Thisform.PrintEnv.Printer = This.Value
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.Cancel()
		
	ENDPROC

	PROCEDURE cmdCancel.Refresh
		This.Caption = Thisform.i18n.text("PRINTER_SELECTION_CANCEL")
		
	ENDPROC

	PROCEDURE cmdOk.Click
		Thisform.Setup()
		
		
	ENDPROC

	PROCEDURE cmdOk.Refresh
		This.Caption = Thisform.i18n.text("PRINTER_SELECTION_OK")
		
	ENDPROC

	PROCEDURE lblPrinters.Refresh
		This.Caption = Thisform.i18n.text("PRINTENV_PRINTER")
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_textbox AS textbox 		&& Pdfium-vfp Textbox. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: contextmenu
		*m: selectall
		*p: allow_lost_focus
		*p: changed		&& .T. on InteractiveChange
		*p: mousefocused		&& Focused by Click
		*p: prevvalue		&& Value on GotFocus event
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED allow_lost_focus,changed,mousefocused,prevvalue
	*<PropValue>
		Alignment = 0
		allow_lost_focus = .T.
		changed = .F.
		EnableHyperlinks = .F.
		FontName = "Segoe UI"
		FontSize = 10
		Format = "K"
		Height = 27
		mousefocused = 0
		Name = "pdfium_textbox"
		prevvalue = 
		SelectOnEntry = .T.
		Width = 173
		_memberdata = <VFPData>
			<memberdata name="changed" type="property" display="Changed"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="mousefocused" type="property" display="MouseFocused"/>
			<memberdata name="prevvalue" type="property" display="PrevValue"/>
			<memberdata name="selectall" type="method" display="SelectAll"/>
			<memberdata name="allow_lost_focus" type="property" display="allow_lost_focus"/>
		</VFPData>
	*</PropValue>
	
	PROTECTED PROCEDURE contextmenu
		LOCAL lcMenuName
		m.lcMenuName = "_context_menu"
		
		DEFINE POPUP (m.lcMenuName) FROM MROW(), MCOL() MARGIN RELATIVE SHORTCUT FONT 'Segoe UI', 10
		
		LOCAL lcSelect, lcClipboard
		m.lcSelect = IIF(EMPTY(This.SelLength)=.T., "SKIP FOR .T.", "")
		m.lcClipboard = IIF(EMPTY(_CLIPTEXT)=.T., "SKIP FOR .T.", "")
		
		LOCAL i
		m.i=9000
		
		m.i=m.i+1
		DEFINE BAR (m.i) OF _context_menu PROMPT (Thisform.i18n.text("MNU_CUT")) PICTRES _MED_CUT  &lcSelect
		ON SELECTION BAR (m.i) OF _context_menu poThis.KeyPress(24,2)
		
		m.i=m.i+1
		DEFINE BAR (m.i) OF _context_menu PROMPT (Thisform.i18n.text("MNU_COPY")) PICTRES _MED_COPY &lcSelect
		ON SELECTION BAR (m.i) OF _context_menu poThis.KeyPress(3,2)
		
		DEFINE BAR _med_paste OF _context_menu PROMPT (Thisform.i18n.text("MNU_PASTE")) PICTRES _MED_PASTE &lcClipboard
		DEFINE BAR _med_slcta OF _context_menu PROMPT (Thisform.i18n.text("MNU_SLCTA"))
		DEFINE BAR _med_clear OF _context_menu PROMPT (Thisform.i18n.text("MNU_CLEAR")) &lcSelect
		
		RETURN m.lcMenuName
		
	ENDPROC

	PROCEDURE GotFocus
		DODEFAULT()
		
		This.PrevValue = This.Value
		
		IF This.SelectOnEntry
		    This.MouseFocused = MDOWN()
		    This.SelectAll()
		ENDIF
		
		
		This.allow_lost_focus = .T.
		
	ENDPROC

	PROCEDURE InteractiveChange
		This.Changed = .T.
		
		This.allow_lost_focus = .F.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode=44 AND VARTYPE(This.Value) = 'N'
		    KEYBOARD '.' PLAIN CLEAR
		ENDIF
		
		IF m.nKeyCode=3 AND m.nShiftAltCtrl=2
		    IF INLIST(VARTYPE(This.SelText),'C')
		        _cliptext = ALLTRIM(NVL(This.SelText,''))
		        NODEFAULT
		    ENDIF
		ENDIF
		
		IF m.nKeyCode=24 AND m.nShiftAltCtrl=2
		    IF INLIST(VARTYPE(This.SelText),'C')
		        _cliptext = ALLTRIM(NVL(This.SelText,''))
		        This.SelText = ''
		        NODEFAULT
		    ENDIF
		ENDIF
		
		
		IF INLIST(m.nKeyCode, 13, 27, 9)
		    This.allow_lost_focus = .T.
		ENDIF
		
	ENDPROC

	PROCEDURE LostFocus
		IF VARTYPE(This.Value)="C"
		    IF NOT (This.Value == ALLTRIM(This.Value,1,CHR(13),CHR(10)))
		        This.Value = ALLTRIM(This.Value,1,CHR(13),CHR(10))
		    ENDIF
		ENDIF
		
		*******************************************************
		LOCAL lcInvalidChars
		m.lcInvalidChars = ""
		LOCAL i
		FOR m.i=0x1 TO 0x1F
		    m.lcInvalidChars = m.lcInvalidChars + CHR(m.i)
		ENDFOR
		FOR m.i=0x7F TO 0x84
		    m.lcInvalidChars = m.lcInvalidChars + CHR(m.i)
		ENDFOR
		FOR m.i=0x86 TO 0x9F
		    m.lcInvalidChars = m.lcInvalidChars + CHR(m.i)
		ENDFOR
		
		IF VARTYPE(This.Value) = 'C'
		    IF NOT (This.Value == CHRTRAN(This.Value, m.lcInvalidChars, ''))
		        This.Value = CHRTRAN(This.Value, m.lcInvalidChars, '')
		    ENDIF    
		ENDIF
		*******************************************************
		
		#define VK_LBUTTON 0x01
		#define VK_RBUTTON 0x02
		IF This.allow_lost_focus = .F. AND This.SelStart+1 >= LEN(This.Text) AND NOT EMPTY(This.Value) AND NOT MDOWN() 
		    IF This.env.API_WIN.GetKeyState(VK_LBUTTON)>=0 AND This.env.API_WIN.GetKeyState(VK_RBUTTON)>=0 
		        This.SelStart = LEN(This.Text)
		        NODEFAULT
		        RETURN
		    ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.SelectOnEntry
		    IF This.SelLength <> 0 AND This.MouseFocused
		        NODEFAULT
		    ENDIF
		ENDIF
		This.MouseFocused = .F.
		
	ENDPROC

	PROCEDURE RightClick
		LOCAL lcMenuName
		m.lcMenuName = This.ContextMenu()
		
		PRIVATE poThis
		m.poThis = This
		IF CNTBAR(m.lcMenuName)<>0
		    ACTIVATE POPUP &lcMenuName
		ENDIF
		m.poThis = NULL
		
		
	ENDPROC

	PROCEDURE selectall
		This.SelStart = 0
		This.SelLength = 255
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfium_uistate AS custom 		&& UI states handling (visible, enable) respecting PageFrames. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: geteffectivelyenabled
		*m: geteffectivelyvisible
		*m: getispageframe
		*m: objtoclient
		*m: onenabled
		*m: onmoved
		*m: onresize
		*m: onvisible
		*m: setstate
		*m: _onenabled
		*m: _onpagecountchange
		*m: _onpagegotfocus
		*m: _onpagelostfocus
		*m: _onuienable
		*m: _onvisible
		*p: effectivelyenabled
		*p: effectivelyvisible
		*p: ispageframe
		*p: uienabled		&& State received from UIEnable event of the parent control
		*p: uienabledforce		&& Page.SetFocus doesn't raise UIEnable, thus this property is for mocking UIEnable behavior. Accepts: .T. | .F. | NULL. See This._OnPageGotFocus, _OnPageLostFocus
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,BaseClass,CloneObject,Comment,ControlCount,Controls,effectivelyenabled,effectivelyvisible,Error,Height,HelpContextID,ispageframe,NewObject,Objects,ParentClass,Parent,Picture,ReadExpression,ReadMethod,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,uienabledforce,uienabled,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		effectivelyenabled = .F.
		effectivelyvisible = .F.
		Height = 24
		ispageframe = .F.
		Name = "pdfium_uistate"
		Tag = ""
		uienabled = .F.
		uienabledforce = (.NULL.)
		Width = 37
		_memberdata = <VFPData>
			<memberdata name="objtoclient" display="ObjToClient"/>
			<memberdata name="addobject" display="AddObject"/>
			<memberdata name="writemethod" display="WriteMethod"/>
			<memberdata name="writeexpression" display="WriteExpression"/>
			<memberdata name="whatsthishelpid" display="WhatsThisHelpID"/>
			<memberdata name="tag" display="Tag"/>
			<memberdata name="showwhatsthis" display="ShowWhatsThis"/>
			<memberdata name="saveasclass" display="SaveAsClass"/>
			<memberdata name="resettodefault" display="ResetToDefault"/>
			<memberdata name="removeobject" display="RemoveObject"/>
			<memberdata name="readmethod" display="ReadMethod"/>
			<memberdata name="readexpression" display="ReadExpression"/>
			<memberdata name="picture" display="Picture"/>
			<memberdata name="parentclass" display="ParentClass"/>
			<memberdata name="parent" display="Parent"/>
			<memberdata name="objects" display="Objects"/>
			<memberdata name="newobject" display="Newobject"/>
			<memberdata name="helpcontextid" display="HelpContextID"/>
			<memberdata name="error" display="Error"/>
			<memberdata name="controls" display="Controls"/>
			<memberdata name="classlibrary" display="ClassLibrary"/>
			<memberdata name="addproperty" display="AddProperty"/>
			<memberdata name="setstate" display="SetState"/>
			<memberdata name="effectivelyenabled" display="EffectivelyEnabled"/>
			<memberdata name="effectivelyvisible" display="EffectivelyVisible"/>
			<memberdata name="geteffectivelyenabled" display="GetEffectivelyEnabled"/>
			<memberdata name="geteffectivelyvisible" display="GetEffectivelyVisible"/>
			<memberdata name="ispageframe" display="IsPageFrame"/>
			<memberdata name="getispageframe" display="GetIsPageFrame"/>
			<memberdata name="onenabled" display="OnEnabled"/>
			<memberdata name="onvisible" display="OnVisible"/>
			<memberdata name="uienabled" type="property" display="UIEnabled"/>
			<memberdata name="_onenabled" type="method" display="_OnEnabled"/>
			<memberdata name="_onuienable" type="method" display="_OnUIEnable"/>
			<memberdata name="_onvisible" type="method" display="_OnVisible"/>
			<memberdata name="onmoved" type="method" display="OnMoved"/>
			<memberdata name="onresize" type="method" display="OnResize"/>
			<memberdata name="_onpagecountchange" type="method" display="_OnPageCountChange"/>
			<memberdata name="_onpagegotfocus" type="method" display="_OnPageGotFocus"/>
			<memberdata name="_onpagelostfocus" type="method" display="_OnPageLostFocus"/>
			<memberdata name="uienabledforce" type="property" display="UIEnabledForce"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE Destroy
		UNBINDEVENTS(This)
		
	ENDPROC

	PROCEDURE geteffectivelyenabled
		RETURN This.EffectivelyEnabled
		
	ENDPROC

	PROCEDURE geteffectivelyvisible
		RETURN This.EffectivelyVisible
		
	ENDPROC

	PROCEDURE getispageframe
		RETURN This.IsPageFrame
		
	ENDPROC

	PROCEDURE Init
		LOCAL loControl
		m.loControl = This.Parent
		
		This.IsPageFrame = .F.
		This.UIEnabled = m.loControl.Visible
		BINDEVENT(m.loControl, "Visible", This, "_OnVisible",1)
		BINDEVENT(m.loControl, "Enabled", This, "_OnEnabled",1)
		IF PEMSTATUS(m.loControl, "UIEnable", 5)
		    BINDEVENT(m.loControl, "UIEnable", This, "_OnUIEnable", 2)
		ENDIF
		IF PEMSTATUS(m.loControl, "Moved", 5)
		    BINDEVENT(m.loControl, "Moved", This, "OnMoved", 1)
		ENDIF
		IF PEMSTATUS(m.loControl, "Resize", 5)
		    BINDEVENT(m.loControl, "Resize", This, "OnResize", 1)
		ENDIF
		
		DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		    IF PEMSTATUS(m.loControl, "Enabled", 5) AND NOT PEMSTATUS(m.loControl, "Enabled", 2)
		        BINDEVENT(m.loControl, "Enabled", This, "_OnEnabled", 1)
		    ENDIF
		
		    IF PEMSTATUS(m.loControl, "Visible", 5) AND NOT PEMSTATUS(m.loControl, "Visible", 2)
		        BINDEVENT(m.loControl, "Visible", This, "_OnVisible", 1)
		    ENDIF
		
		    IF UPPER(m.loControl.BASECLASS) == [PAGE] 
		        This.IsPageFrame = .T.
		
		        IF m.loControl.Parent.ActivePage != EVL(m.loControl.PageOrder, 1)
		            This.UIEnabled = .F.
		        ENDIF
		        
		        BINDEVENT(m.loControl.Parent, "AddObject", This, "_OnPageCountChange", 1)
		        BINDEVENT(m.loControl.Parent, "PageCount", This, "_OnPageCountChange", 1)
		        BINDEVENT(m.loControl, "SetFocus", This, "_OnPageGotFocus", 1)
		        LOCAL liPage
		        FOR m.liPage = 1 TO m.loControl.Parent.PageCount
		            IF m.loControl.Parent.Pages[m.liPage] != m.loControl
		                BINDEVENT(m.loControl.Parent.Pages[m.liPage], "SetFocus", This, "_OnPageLostFocus", 1)
		            ENDIF
		        ENDFOR
		    ENDIF
		
		    IF INLIST(UPPER(m.loControl.BASECLASS), [PAGEFRAME], [CONTAINER], [CONTROL])
		        BINDEVENT(m.loControl, "Moved", This, "OnMoved", 1)
		        BINDEVENT(m.loControl, "Resize", This, "OnResize", 1)
		    ENDIF
		    
		    m.loControl = m.loControl.PARENT
		ENDDO
		
		This.SetState()
		
	ENDPROC

	PROCEDURE objtoclient
		*********************************************************************
		** Based on GDPIPlusX xfcBitmap.ObjToClientEx
		**
		** This replaces OBJTOCLIENT that has bugs with pageframes and SP2
		*********************************************************************
		LPARAMETERS tnLeft, tnTop, tnRight, tnBottom
		
		LOCAL loControl
		m.loControl = This.Parent
		
		*!* TabOrientation parameters
		#DEFINE TABOR_TOP    0
		#DEFINE TABOR_BOTTOM 1
		#DEFINE TABOR_LEFT   2
		#DEFINE TABOR_RIGHT  3
		
		STORE 0 TO m.tnLeft, m.tnTop
		m.tnRight = Thisform.Width
		m.tnBottom = Thisform.Height
		
		LOCAL lnCLeft, lnCTop, lnCWidth, lnCHeight
		
		DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		    
		    STORE 0 TO m.lnCLeft, m.lnCTop, m.lnCWidth, m.lnCHeight
		    
		    IF PEMSTATUS(m.loControl, [Left], 5)
		        m.lnCLeft = m.loControl.Left
		    ENDIF
		    IF PEMSTATUS(m.loControl, [Top], 5)
		        m.lnCTop = m.loControl.Top
		    ENDIF
		    IF PEMSTATUS(m.loControl, [Width], 5)
		        m.lnCWidth = m.loControl.Width
		    ENDIF
		    IF PEMSTATUS(m.loControl, [Height], 5)
		        m.lnCHeight = m.loControl.Height
		    ENDIF
		    
		    DO CASE
		    CASE UPPER(m.loControl.BASECLASS) == [PAGE]
		        IF m.loControl.PARENT.TABORIENTATION = TABOR_LEFT
		            m.lnCLeft = m.lnCLeft + ;
		                m.loControl.PARENT.WIDTH - ;
		                m.loControl.PARENT.PAGEWIDTH - ;
		                m.loControl.PARENT.BORDERWIDTH * 2
		        ELSE
		            m.lnCLeft = m.lnCLeft + 1
		        ENDIF
		
		        IF m.loControl.PARENT.TABORIENTATION = TABOR_TOP
		            m.lnCTop = m.lnCTop + ;
		                m.loControl.PARENT.HEIGHT - ;
		                m.loControl.PARENT.PAGEHEIGHT - ;
		                m.loControl.PARENT.BORDERWIDTH * 2
		        ELSE
		            m.lnCTop = m.lnCTop + 1
		        ENDIF
		        
		        m.lnCWidth = m.loControl.PARENT.PAGEWIDTH - m.loControl.PARENT.BORDERWIDTH * 2
		        m.lnCHeight = m.loControl.PARENT.PAGEHEIGHT - m.loControl.PARENT.BORDERWIDTH * 2
		    ENDCASE
		    
		    m.tnLeft = m.tnLeft + m.lnCLeft
		    m.tnTop = m.tnTop + m.lnCTop
		    m.tnRight = m.lnCLeft + MIN(m.tnRight, m.lnCWidth)
		    m.tnBottom = m.lnCTop + MIN(m.tnBottom, m.lnCHeight)
		    
		    m.loControl = m.loControl.PARENT
		ENDDO
		
		m.tnRight = MAX(m.tnRight, m.tnLeft)
		m.tnBottom = MAX(m.tnBottom, m.tnTop)
		
	ENDPROC

	PROCEDURE onenabled
	ENDPROC

	PROCEDURE onmoved
	ENDPROC

	PROCEDURE onresize
	ENDPROC

	PROCEDURE onvisible
	ENDPROC

	HIDDEN PROCEDURE setstate
		LOCAL loControl
		m.loControl = This.Parent
		
		LOCAL llPrevVisible, llPrevEnabled
		m.llPrevVisible = This.EffectivelyVisible
		m.llPrevEnabled = This.EffectivelyEnabled
		
		This.EffectivelyVisible = m.loControl.Visible AND (This.UIEnabled OR NVL(This.UIEnabledForce,.F.))
		IF NVL(This.UIEnabledForce, .T.) = .F.
		    This.EffectivelyVisible = .F.
		ENDIF
		This.EffectivelyEnabled = m.loControl.Enabled
		
		DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		    IF PEMSTATUS(m.loControl, "Enabled", 5) AND NOT PEMSTATUS(m.loControl, "Enabled", 2)
		        IF m.loControl.Enabled = .F.
		            This.EffectivelyEnabled = .F.
		        ENDIF
		    ENDIF
		
		    IF PEMSTATUS(m.loControl, "Visible", 5) AND NOT PEMSTATUS(m.loControl, "Visible", 2)
		        IF m.loControl.Visible = .F.
		            This.EffectivelyVisible = .F.
		        ENDIF
		    ENDIF
		
		    IF UPPER(m.loControl.BASECLASS) == [PAGE]
		        IF m.loControl.Parent.ActivePage != EVL(m.loControl.PageOrder, 1) AND NVL(This.UIEnabledForce,.F.) = .F.
		            This.EffectivelyVisible = .F.
		        ENDIF
		    ENDIF
		
		    m.loControl = m.loControl.PARENT
		ENDDO
		
		DO CASE
		CASE m.llPrevVisible <> This.EffectivelyVisible
		    This.OnVisible()
		CASE m.llPrevEnabled <> This.EffectivelyEnabled
		    This.OnEnabled()
		ENDCASE
		
	ENDPROC

	PROCEDURE _onenabled
		LPARAMETERS tlEnabled
		This.SetState()
		
	ENDPROC

	PROCEDURE _onpagecountchange
		LPARAMETERS p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
		
		LOCAL loControl
		m.loControl = This.Parent
		
		DO WHILE NOT UPPER(m.loControl.BASECLASS) == [FORM]
		    IF UPPER(m.loControl.BASECLASS) == [PAGE] 
		        LOCAL liPage
		        FOR m.liPage = 1 TO m.loControl.Parent.PageCount
		            IF m.loControl = m.loControl.Parent.Pages[m.liPage]
		                UNBINDEVENTS(m.loControl, "SetFocus", This, "_OnPageGotFocus")
		                BINDEVENT(m.loControl, "SetFocus", This, "_OnPageGotFocus", 1)
		            ELSE
		                UNBINDEVENTS(m.loControl.Parent.Pages[m.liPage], "SetFocus", This, "_OnPageLostFocus")
		                BINDEVENT(m.loControl.Parent.Pages[m.liPage], "SetFocus", This, "_OnPageLostFocus", 1)
		            ENDIF
		        ENDFOR
		    ENDIF
		
		    m.loControl = m.loControl.PARENT
		ENDDO
		
	ENDPROC

	PROCEDURE _onpagegotfocus
		LPARAMETERS p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
		
		* PageFrame.ActivePage stays unchaned after a call of Page.SetFocus()
		* that's why UIEnabledForce is used
		This.UIEnabledForce = .T.
		This.SetState()
		This.UIEnabledForce = .NULL.
		
	ENDPROC

	PROCEDURE _onpagelostfocus
		LPARAMETERS p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
		
		* PageFrame.ActivePage stays unchaned after a call of Page.SetFocus()
		* that's why UIEnabledForce is used
		This.UIEnabledForce = .F.
		This.SetState()
		This.UIEnabledForce = .NULL.
		
	ENDPROC

	PROCEDURE _onuienable
		LPARAMETERS lEnable
		This.UIEnabled = m.lEnable
		This.SetState()
		
	ENDPROC

	PROCEDURE _onvisible
		LPARAMETERS tlVisible
		This.SetState()
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumviewer AS control 		&& PDF viewer control.
 	*< CLASSDATA: Baseclass="control" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdFocus" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="env" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="UIState" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: afterviewportupdate		&& Event. Triggered after ViewPortUpdate call
		*m: backcolor_assign
		*m: closepdf		&& Close pdf file, previously opened by PdfiumViewer.openpdf
		*m: contextmenu
		*m: drawbufcreate
		*m: drawbufrelease
		*m: errmsg
		*m: fitwidth_assign
		*m: getcurrentpage		&& Current page number. First page has number = 1
		*m: getformfield		&& Accepts PDF form field name in UTF-16LE or 1-based field index,  returns object or .F. if field doesn't exist
		*m: getformfieldscount		&& Returns number of fields in PDF form
		*m: getpagecount		&& Returns page count
		*m: getpagesize		&& Returns page dimensions (see comment in source code)
		*m: keypress		&& Occurs when the user presses and releases a key.
		*m: openpdf		&& Open pdf file. Returns: .T. on success, .F. if file was not loaded
		*m: pagepick
		*m: paste		&& Paste text from clipboard to form field
		*m: printdocument		&& Send document to printer with preceding setup dialog
		*m: printenv_access
		*m: printenv_assign
		*m: redraw
		*m: renderpages
		*m: rendersearch
		*m: renderselection
		*m: savedocument		&& Save document to file
		*m: scale_assign
		*m: scrollbars_assign
		*m: scrollhorz
		*m: scrollvert
		*m: searchclose		&& Stop search
		*m: searchtext		&& Text for searching. SearchClose must be called to stop search results rendering
		*m: selectioncopy		&& Copy selected text to clipboard
		*m: selecttext
		*m: selecttextall		&& Select all text in the document
		*m: setformfieldvalue		&& Accepts PDF form field name in UTF-16LE or 1-based form field index and a value of type String (UTF-16LE) for textbox, combobox, Logical for checkbox, Numeric as a number of selected RadioButton in OptionGroup; Returs True if the value was set
		*m: viewportupdate
		*m: wndcreate
		*m: wndproc		&& Events handler of PdfiumViewer internal window. Developer must not use or redefine this method
		*m: wndredraw
		*m: wndrelease
		*m: wndresize
		*m: wndshow		&& Show child window (for internal use, public for bindevent)
		*p: allowformedit		&& Allows interactive input in PDF forms.
		*p: backcolorbrush
		*p: dblclickbegin
		*p: drawbufbitmap		&& FPDF_Bitmap buffer for document rendering
		*p: drawbufbitmapbmi
		*p: drawbufdc
		*p: drawbufdib
		*p: drawbufgfx
		*p: fitwidth
		*p: formfields		&& Form Fields Collection
		*p: fpdf_doc
		*p: fpdf_form
		*p: fpdf_opened
		*p: fpdf_pagecount
		*p: fpdf_page_first_visible		&& Index of the page that appears first after rendering
		*p: fpdf_page_last_visible
		*p: isfocused		&& .T. if control has input focus
		*p: pagefillbrush
		*p: printenv		&& Print configuration state (pdfium_print_env object); Read-Only
		*p: scale
		*p: scrollbars		&& Specifies the type of scroll bars that an EditBox control, Form object, or Grid control has. 0 - None (Default); 1 - Horizontal; 2 - Vertical; 3 - Both vertical and horizontal
		*p: searchbrush
		*p: searchstate_dir
		*p: searchstate_findwhat
		*p: searchstate_rescount
		*p: searchstate_resindex
		*p: searchstate_respage
		*p: searchstate_resrect
		*p: selectionbrush
		*p: selectioncharindexprev
		*p: selectioncharindexstart
		*p: tplclickbegin
		*p: viewportmaxx
		*p: viewportmaxy
		*p: viewportsizex
		*p: viewportsizey
		*p: viewportx
		*p: viewporty
		*p: wndclassname
		*p: wnddc
		*p: wndhandle		&& Specifies the Window handle of the Window.
		*p: wndviewport
		*a: fpdf_pages[1,0]
		*a: fpdf_pages_pos[1,4]
		*a: fpdf_pages_selection[1,3]
		*a: fpdf_pages_size[1,4]
		*a: fpdf_text_pages[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _printenv
	*</DefinedPropArrayMethod>

	HIDDEN ActiveControl,AddProperty,backcolorbrush,BackStyle,BorderColor,BorderWidth,Click,CloneObject,ColorSource,ControlCount,Controls,dblclickbegin,DblClick,drawbufbitmapbmi,drawbufbitmap,drawbufdc,drawbufdib,drawbufgfx,Draw,Error,ForeColor,formfields,fpdf_doc,fpdf_form,fpdf_opened,fpdf_pagecount,fpdf_pages,fpdf_pages_pos,fpdf_pages_selection,fpdf_pages_size,fpdf_page_first_visible,fpdf_page_last_visible,fpdf_text_pages,GotFocus,HelpContextID,isfocused,LostFocus,MiddleClick,MouseDown,MouseEnter,MouseIcon,MouseLeave,MouseMove,MousePointer,MouseUp,MouseWheel,Objects,pagefillbrush,Picture,ReadExpression,ReadMethod,RightClick,SaveAsClass,searchbrush,searchstate_dir,searchstate_findwhat,searchstate_rescount,searchstate_resindex,searchstate_respage,searchstate_resrect,selectionbrush,selectioncharindexprev,selectioncharindexstart,ShowWhatsThis,SpecialEffect,Style,tplclickbegin,viewportmaxx,viewportmaxy,viewportsizex,viewportsizey,viewportx,viewporty,WhatsThisHelpID,wndclassname,wnddc,wndhandle,wndviewport,WriteExpression,WriteMethod,ZOrder,_printenv
	*<PropValue>
		allowformedit = .T.
		backcolorbrush = .F.
		BackStyle = 1
		dblclickbegin = 0
		drawbufbitmap = 0
		drawbufbitmapbmi = ("")
		drawbufdc = 0
		drawbufdib = 0
		drawbufgfx = 0
		fitwidth = .F.
		formfields = .F.
		fpdf_doc = 0
		fpdf_form = 0
		fpdf_opened = .F.
		fpdf_pagecount = 0
		fpdf_page_first_visible = 0
		fpdf_page_last_visible = 0
		Height = 622
		isfocused = .F.
		Name = "pdfiumviewer"
		pagefillbrush = 0
		printenv = .F.
		scale = 1
		scrollbars = 0
		searchbrush = .F.
		searchstate_dir = 0
		searchstate_findwhat = ("")
		searchstate_rescount = 0
		searchstate_resindex = 0
		searchstate_respage = 0
		searchstate_resrect = ("")
		selectionbrush = .F.
		selectioncharindexprev = -1
		selectioncharindexstart = 0
		tplclickbegin = 0
		viewportmaxx = 0
		viewportmaxy = 0
		viewportsizex = 0
		viewportsizey = 0
		viewportx = 0
		viewporty = 0
		Visible = .T.
		Width = 445
		wndclassname = ("PDFIUM-VFP-VIEWER")
		wnddc = 0
		wndhandle = 0
		wndviewport = 0
		_memberdata = <VFPData>
			<memberdata name="closepdf" display="ClosePDF" favorites="True"/>
			<memberdata name="backcolorbrush" type="property" display="BackColorBrush"/>
			<memberdata name="backcolor_assign" type="method" display="BackColor_Assign"/>
			<memberdata name="contextmenu" type="method" display="ContextMenu"/>
			<memberdata name="drawbufcreate" type="method" display="DrawBufCreate"/>
			<memberdata name="drawbufdc" type="property" display="DrawBufDC"/>
			<memberdata name="drawbufdib" type="property" display="DrawBufDIB"/>
			<memberdata name="drawbufgfx" type="property" display="DrawBufGFX"/>
			<memberdata name="drawbufrelease" type="method" display="DrawBufRelease"/>
			<memberdata name="errmsg" type="method" display="ErrMsg"/>
			<memberdata name="fpdf_doc" type="property" display="fpdf_doc"/>
			<memberdata name="fpdf_opened" type="property" display="fpdf_opened"/>
			<memberdata name="fpdf_pagecount" type="property" display="fpdf_pagecount"/>
			<memberdata name="fpdf_pages" type="property" display="fpdf_pages"/>
			<memberdata name="fpdf_pages_pos" type="property" display="fpdf_pages_pos"/>
			<memberdata name="fpdf_pages_selection" type="property" display="fpdf_pages_selection"/>
			<memberdata name="fpdf_pages_size" type="property" display="fpdf_pages_size"/>
			<memberdata name="fpdf_page_first_visible" type="property" display="fpdf_page_first_visible"/>
			<memberdata name="fpdf_page_last_visible" type="property" display="fpdf_page_last_visible"/>
			<memberdata name="fpdf_text_pages" type="property" display="fpdf_text_pages"/>
			<memberdata name="getcurrentpage" type="method" display="GetCurrentPage"/>
			<memberdata name="getpagecount" type="method" display="GetPageCount"/>
			<memberdata name="getpagesize" type="method" display="GetPageSize"/>
			<memberdata name="keypress" type="method" display="KeyPress"/>
			<memberdata name="openpdf" type="method" display="OpenPDF" favorites="True"/>
			<memberdata name="pagepick" type="method" display="PagePick"/>
			<memberdata name="redraw" type="method" display="Redraw"/>
			<memberdata name="renderpages" type="method" display="RenderPages"/>
			<memberdata name="renderselection" type="method" display="RenderSelection"/>
			<memberdata name="scale" type="property" display="Scale"/>
			<memberdata name="scale_assign" type="method" display="Scale_Assign"/>
			<memberdata name="scrollbars" type="property" display="ScrollBars"/>
			<memberdata name="scrollbars_assign" type="method" display="ScrollBars_Assign"/>
			<memberdata name="scrollhorz" type="method" display="ScrollHorz"/>
			<memberdata name="scrollvert" type="method" display="ScrollVert"/>
			<memberdata name="selectionbrush" type="property" display="SelectionBrush"/>
			<memberdata name="selectioncharindexprev" type="property" display="SelectionCharIndexPrev"/>
			<memberdata name="selectioncharindexstart" type="property" display="SelectionCharIndexStart"/>
			<memberdata name="selectioncopy" type="method" display="SelectionCopy"/>
			<memberdata name="selecttext" type="method" display="SelectText"/>
			<memberdata name="viewportmaxx" type="property" display="ViewPortMaxX"/>
			<memberdata name="viewportmaxy" type="property" display="ViewPortMaxY"/>
			<memberdata name="viewportsizex" type="property" display="ViewPortSizeX"/>
			<memberdata name="viewportsizey" type="property" display="ViewPortSizeY"/>
			<memberdata name="viewportupdate" type="method" display="ViewPortUpdate"/>
			<memberdata name="viewportx" type="property" display="ViewPortX"/>
			<memberdata name="viewporty" type="property" display="ViewPortY"/>
			<memberdata name="wndclassname" type="property" display="WndClassName"/>
			<memberdata name="wndcreate" type="method" display="WndCreate"/>
			<memberdata name="wnddc" type="property" display="WndDC"/>
			<memberdata name="wndhandle" type="property" display="WndHandle"/>
			<memberdata name="wndproc" type="method" display="WndProc"/>
			<memberdata name="wndredraw" type="method" display="WndRedraw"/>
			<memberdata name="wndrelease" type="method" display="WndRelease"/>
			<memberdata name="wndresize" type="method" display="WndResize"/>
			<memberdata name="wndshow" type="method" display="WndShow"/>
			<memberdata name="selecttextall" type="method" display="SelectTextAll"/>
			<memberdata name="dblclickbegin" type="property" display="DblClickBegin"/>
			<memberdata name="tplclickbegin" type="property" display="TplClickBegin"/>
			<memberdata name="rendersearch" type="method" display="RenderSearch"/>
			<memberdata name="searchbrush" type="property" display="SearchBrush"/>
			<memberdata name="searchclose" type="method" display="SearchClose"/>
			<memberdata name="searchstate_findwhat" type="property" display="SearchState_FindWhat"/>
			<memberdata name="searchstate_rescount" type="property" display="SearchState_ResCount"/>
			<memberdata name="searchstate_resindex" type="property" display="SearchState_ResIndex"/>
			<memberdata name="searchstate_respage" type="property" display="SearchState_ResPage"/>
			<memberdata name="searchstate_resrect" type="property" display="SearchState_ResRect"/>
			<memberdata name="searchtext" type="method" display="SearchText"/>
			<memberdata name="searchstate_dir" type="property" display="SearchState_Dir"/>
			<memberdata name="savedocument" type="method" display="SaveDocument"/>
			<memberdata name="fitwidth" type="property" display="FitWidth"/>
			<memberdata name="fitwidth_assign" type="method" display="FitWidth_Assign"/>
			<memberdata name="isfocused" type="property" display="IsFocused"/>
			<memberdata name="printdocument" type="method" display="PrintDocument"/>
			<memberdata name="afterviewportupdate" type="method" display="AfterViewportUpdate"/>
			<memberdata name="printenv" type="property" display="PrintEnv"/>
			<memberdata name="printenv_assign" type="method" display="PrintEnv_Assign"/>
			<memberdata name="printenv_access" type="method" display="PrintEnv_Access"/>
			<memberdata name="_printenv" type="property" display="_PrintEnv"/>
			<memberdata name="pagefillbrush" type="property" display="PageFillBrush"/>
			<memberdata name="wndviewport" type="property" display="WndViewport"/>
			<memberdata name="drawbufbitmap" type="property" display="DrawBufBitmap"/>
			<memberdata name="drawbufbitmapbmi" type="property" display="DrawBufBitmapBMI"/>
			<memberdata name="fpdf_form" type="property" display="fpdf_form"/>
			<memberdata name="allowformedit" type="property" display="AllowFormEdit"/>
			<memberdata name="paste" type="method" display="Paste"/>
			<memberdata name="formfields" type="property" display="FormFields"/>
			<memberdata name="getformfield" type="method" display="GetFormField"/>
			<memberdata name="getformfieldscount" type="method" display="GetFormFieldsCount"/>
			<memberdata name="setformfieldvalue" type="method" display="SetFormFieldValue"/>
		</VFPData>
		_printenv = .F.
	*</PropValue>

	ADD OBJECT 'cmdFocus' AS pdfiumviewer_cmdfocus WITH ;
		Left = -100, ;
		Name = "cmdFocus", ;
		Top = -100
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'env' AS pdfium_env WITH ;
		Left = 69, ;
		Name = "env", ;
		Top = 24, ;
		API_FPDF.CONST.Name = "CONST", ;
		API_FPDF.Name = "API_FPDF", ;
		API_WIN.Name = "API_WIN", ;
		API_GDIP.CONST.Name = "CONST", ;
		API_GDIP.Name = "API_GDIP", ;
		API_FPDF_FORMS.CONST.Name = "CONST", ;
		API_FPDF_FORMS.Name = "API_FPDF_FORMS", ;
		API_FPDF_ANNOT.CONST.Name = "CONST", ;
		API_FPDF_ANNOT.Name = "API_FPDF_ANNOT"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 108, ;
		Name = "i18n", ;
		Top = 24, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'UIState' AS pdfium_uistate WITH ;
		Left = 24, ;
		Name = "UIState", ;
		Top = 24
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />
	
	PROCEDURE afterviewportupdate		&& Event. Triggered after ViewPortUpdate call
	ENDPROC

	HIDDEN PROCEDURE backcolor_assign
		LPARAMETERS vNewVal
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.BackColor = m.vNewVal
		
		IF EMPTY(This.BackColorBrush) = .F.
		    This.env.API_GDIP.GdipSetSolidFillColor(This.BackColorBrush, This.env.API_GDIP.ARGB(255, This.BackColor))
		ENDIF
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE closepdf		&& Close pdf file, previously opened by PdfiumViewer.openpdf
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		LOCAL loFPDF, loFPDF_FORMS
		m.loFPDF = This.env.API_FPDF
		m.loFPDF_FORMS = This.env.API_FPDF_FORMS
		
		IF This.fpdf_opened
		    This._PrintEnv = .F.
		ENDIF
		
		This.fpdf_opened = .F.
		
		This.FormFields.Remove(-1)
		
		This.SearchClose()
		
		LOCAL lnPage, lnPageCount
		m.lnPageCount = This.fpdf_pagecount
		
		This.fpdf_pagecount = 0
		
		This.fpdf_page_first_visible = 0
		This.fpdf_page_last_visible = 0
		
		This.ViewPortX = 0
		This.ViewPortY = 0
		This.ViewPortSizeX = 0
		This.ViewPortSizeY = 0
		This.ViewPortMaxX = 0
		This.ViewPortMaxY = 0
		
		This.scale = 1
		
		LOCAL lnPage
		FOR m.lnPage = 1 TO m.lnPageCount
		    IF EMPTY(This.fpdf_form) = .F.
		        m.loFPDF_FORMS.FORM_OnBeforeClosePage(This.fpdf_pages[m.lnPage], This.fpdf_form)
		    ENDIF
		
		    m.loFPDF.FPDFText_ClosePage(This.fpdf_text_pages[m.lnPage])
		    m.loFPDF.FPDF_ClosePage(This.fpdf_pages[m.lnPage])
		    
		    This.fpdf_pages[m.lnPage] = 0
		    This.fpdf_text_pages[m.lnPage] = 0
		    This.fpdf_pages_selection[m.lnPage,1] = ""
		    This.fpdf_pages_selection[m.lnPage,2] = 0
		    This.fpdf_pages_selection[m.lnPage,3] = 0
		ENDFOR
		
		DIMENSION This.fpdf_pages(1)
		DIMENSION This.fpdf_text_pages(1)
		DIMENSION This.fpdf_pages_selection(1,3)
		DIMENSION This.fpdf_pages_pos(1,4)
		DIMENSION This.fpdf_pages_size(1,2)
		
		STORE 0 TO This.fpdf_pages_pos, This.fpdf_pages_size
		
		IF EMPTY(This.fpdf_form) = .F.
		    m.loFPDF_FORMS.VFPDFDOC_ExitFormFillEnvironment(This.fpdf_form)
		    This.fpdf_form = 0
		ENDIF
		
		IF EMPTY(This.fpdf_doc)=.F.
		    m.loFPDF.FPDF_CloseDocument(This.fpdf_doc)
		    This.fpdf_doc = 0
		ENDIF
		
		This.ViewPortUpdate()
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE contextmenu
		
		LOCAL lcMenuName
		m.lcMenuName = "_context_menu"
		
		DEFINE POPUP (m.lcMenuName) FROM MROW(), MCOL() MARGIN RELATIVE SHORTCUT FONT 'Segoe UI', 10
		
		LOCAL lcSelectCopy, lcSelectAll, lcPaste
		m.lcSelectCopy = "SKIP FOR .T."
		m.lcSelectAll = ""
		m.lcPaste = IIF(EMPTY(_CLIPTEXT), "SKIP FOR .T.", "")
		
		IF This.fpdf_opened = .T.
		    LOCAL lnPage
		    FOR m.lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		        IF This.fpdf_pages_selection[m.lnPage,3] > 0
		            m.lcSelectCopy = ""
		            EXIT
		        ENDIF
		    ENDFOR
		ELSE
		    m.lcSelectAll = "SKIP FOR .T."
		ENDIF
		
		LOCAL llIsFormField
		m.llIsFormField = .F.
		IF EMPTY(This.fpdf_form) = .F.
		    LOCAL lnAnnotPage, lnAnnot
		    STORE 0 TO m.lnAnnotPage, m.lnAnnot
		    IF This.env.API_FPDF_FORMS.FORM_GetFocusedAnnot(This.fpdf_form, @m.lnAnnotPage, @m.lnAnnot) = 1
		        IF BETWEEN(m.lnAnnotPage + 1, This.fpdf_page_first_visible, This.fpdf_page_last_visible)
		            LOCAL lnFPDF_Page
		            m.lnFPDF_Page = This.fpdf_pages[m.lnAnnotPage + 1]
		            IF This.env.API_FPDF_FORMS.FORM_GetSelectedText(This.fpdf_form, m.lnFPDF_Page, "", 0) > 2
		                m.lcSelectCopy = ""
		            ENDIF
		            m.llIsFormField = .T.
		        ENDIF
		    ENDIF
		ENDIF
		
		
		LOCAL i
		m.i=0
		
		m.i=m.i+1
		DEFINE BAR (m.i) OF (m.lcMenuName) PROMPT (This.i18n.text("MNU_COPY")) PICTRES _MED_COPY &lcSelectCopy
		ON SELECTION BAR (m.i) OF (m.lcMenuName) m.poThis.SelectionCopy()
		
		IF m.llIsFormField
		    m.i=m.i+1
		    DEFINE BAR (m.i) OF (m.lcMenuName) PROMPT (This.i18n.text("MNU_PASTE")) PICTRES _MED_PASTE &lcPaste
		    ON SELECTION BAR (m.i) OF (m.lcMenuName) m.poThis.Paste()
		ENDIF
		
		m.i=m.i+1
		DEFINE BAR (m.i) OF (m.lcMenuName) PROMPT (This.i18n.text("MNU_SLCTA")) &lcSelectAll
		ON SELECTION BAR (m.i) OF (m.lcMenuName) m.poThis.SelectTextAll()
		
		
		PRIVATE poThis
		m.poThis = This
		IF CNTBAR(m.lcMenuName)<>0
		    ACTIVATE POPUP &lcMenuName
		ENDIF
		m.poThis = .F.
		
		
	ENDPROC

	PROCEDURE Destroy
		
		IF This.env.ok() 
		    IF EMPTY(This.BackColorBrush) = .F.
		        This.env.API_GDIP.GdipDeleteBrush(This.BackColorBrush)
		        This.BackColorBrush = 0
		    ENDIF
		
		    IF EMPTY(This.SelectionBrush) = .F.
		        This.env.API_GDIP.GdipDeleteBrush(This.SelectionBrush)
		        This.SelectionBrush = 0
		    ENDIF
		
		    IF EMPTY(This.SearchBrush) = .F.
		        This.env.API_GDIP.GdipDeleteBrush(This.SearchBrush)
		        This.SearchBrush = 0
		    ENDIF
		
		    IF EMPTY(This.PageFillBrush) = .F.
		        This.env.API_GDIP.GdipDeleteBrush(This.PageFillBrush)
		        This.PageFillBrush = 0
		    ENDIF
		
		ENDIF
		
		This.ClosePDF()
		
		This.DrawBufRelease()
		
		This.WndRelease()
		
		This._PrintEnv = .F.
		This.FormFields = .F.
		
	ENDPROC

	HIDDEN PROCEDURE drawbufcreate
		
		#DEFINE FF_RGBQUAD_SIZE     4
		#DEFINE FF_DIB_RGB_COLORS   0
		#DEFINE FF_BFHDR_SIZE      14
		#DEFINE FF_BHDR_SIZE       40
		#DEFINE FF_BI_RGB           0
		
		IF EMPTY(This.WndDC)
		    RETURN
		ENDIF
		
		
		This.DrawBufRelease()
		
		
		***********************************************************************************
		IF EMPTY(This.DrawBufDC)
		    This.DrawBufDC = This.env.API_WIN.CreateCompatibleDC(This.WndDC)
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		LOCAL lnWidth, lnHeight, lnBitsPerPixel
		m.lnWidth = This.Width
		m.lnHeight = This.Height
		m.lnBitsPerPixel = 16
		
		LOCAL lcBMI
		m.lcBMI = BINTOC(FF_BHDR_SIZE ,"4RS") + BINTOC(m.lnWidth,"4RS") + BINTOC(m.lnHeight, "4RS") + ;
		        (CHR(MOD(1,256)) + CHR(INT(1/256))) + (CHR(MOD(m.lnBitsPerPixel,256))+ CHR(INT(m.lnBitsPerPixel/256))) +;
		        BINTOC(FF_BI_RGB, "4RS") + REPLICATE(0h00, 20)
		
		
		LOCAL lnDibDataPtr
		m.lnDibDataPtr = 0
		
		This.DrawBufDIB = This.env.API_WIN.CreateDIBSection(This.DrawBufDC, m.lcBMI, FF_DIB_RGB_COLORS, @m.lnDibDataPtr, 0, 0)
		This.env.API_WIN.SelectObject(This.DrawBufDC, This.DrawBufDIB)
		
		LOCAL lhDrawBufGfx
		m.lhDrawBufGfx = 0
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateFromHDC(This.DrawBufDC, @m.lhDrawBufGfx))
		This.DrawBufGfx = m.lhDrawBufGfx
		
		This.DrawBufBitmap = This.env.API_FPDF.FPDFBitmap_Create(m.lnWidth, m.lnHeight, 0)
		
		m.lnBitsPerPixel = 32
		This.DrawBufBitmapBMI = BINTOC(FF_BHDR_SIZE ,"4RS") + BINTOC(m.lnWidth,"4RS") + BINTOC(-m.lnHeight, "4RS") + ;
		        (CHR(MOD(1,256)) + CHR(INT(1/256))) + (CHR(MOD(m.lnBitsPerPixel,256))+ CHR(INT(m.lnBitsPerPixel/256))) +;
		        BINTOC(FF_BI_RGB, "4RS") + REPLICATE(0h00, 20)
		
	ENDPROC

	HIDDEN PROCEDURE drawbufrelease
		IF EMPTY(This.DrawBufGfx) = .F.
		    This.env.API_GDIP.GdipDeleteGraphics(This.DrawBufGfx)
		    This.DrawBufGfx = 0
		ENDIF
		
		IF EMPTY(This.DrawBufDC) = .F.
		    This.env.API_WIN.DeleteDC(This.DrawBufDC)
		    This.DrawBufDC = 0
		ENDIF
		
		IF EMPTY(This.DrawBufDIB) = .F.
		    This.env.API_WIN.DeleteObject(This.DrawBufDIB)
		    This.DrawBufDIB = 0
		ENDIF
		
		IF EMPTY(This.DrawBufBitmap) = .F.
		    This.env.API_FPDF.FPDFBitmap_Destroy(This.DrawBufBitmap)
		    This.DrawBufBitmap = 0
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		m.lcMsg = This.env.ErrFmt(m.tvMsg)
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		IF SYS(2335) != '0'
		    MESSAGEBOX(m.lcMsg, 0+48, This.Class + " ("+This.ClassLibrary+")")
		ELSE
		    THROW m.lcMsg
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE fitwidth_assign
		LPARAMETERS vNewVal
		
		This.FitWidth = m.vNewVal
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
		
	ENDPROC

	PROCEDURE getcurrentpage		&& Current page number. First page has number = 1
		RETURN This.fpdf_page_first_visible
	ENDPROC

	PROCEDURE getformfield		&& Accepts PDF form field name in UTF-16LE or 1-based field index,  returns object or .F. if field doesn't exist
		LPARAMETERS tcFieldNameOrIndex as String
		
		IF EMPTY(This.fpdf_form)
		    RETURN .F.
		ENDIF
		
		IF EMPTY(NVL(m.tcFieldNameOrIndex, ""))
		    RETURN .F.
		ENDIF
		
		LOCAL lcFormFieldName, lnFormFieldIndex
		DO CASE
		CASE VARTYPE(m.tcFieldNameOrIndex) = "C"
		    m.lcFormFieldName = m.tcFieldNameOrIndex
		    m.lnFormFieldIndex = This.FormFields.GetKey(m.lcFormFieldName)
		CASE VARTYPE(m.tcFieldNameOrIndex) = "N"    
		    m.lnFormFieldIndex = m.tcFieldNameOrIndex
		    m.lcFormFieldName = This.FormFields.GetKey(m.lnFormFieldIndex)
		OTHERWISE
		    RETURN .F.
		ENDCASE
		
		IF m.lnFormFieldIndex = 0 OR EMPTY(m.lcFormFieldName)
		    RETURN .F.
		ENDIF
		
		LOCAL loFormFieldIn
		m.loFormFieldIn = This.FormFields[m.lnFormFieldIndex]
		
		LOCAL lnPageIndex, lnAnnotIndex
		m.lnPageIndex = m.loFormFieldIn.PageIndex
		m.lnAnnotIndex = m.loFormFieldIn.AnnotIndex
		
		LOCAL lnAnnotHandle
		m.lnAnnotHandle = This.env.API_FPDF_ANNOT.FPDFPage_GetAnnot(This.fpdf_pages[m.lnPageIndex], m.lnAnnotIndex - 1)
		IF EMPTY(m.lnAnnotHandle)
		    RETURN .F.
		ENDIF
		
		LOCAL loFormFieldOutOptions
		m.loFormFieldOutOptions = NEWOBJECT("Collection")
		
		LOCAL loFormFieldOutGroupItems
		m.loFormFieldOutGroupItems = NEWOBJECT("Collection")
		
		TRY
		    LOCAL lcFormFieldValue, lnFormFieldType
		    m.lcFormFieldValue = ""
		    m.lnFormFieldType = -1
		
		    LOCAL lcBuffer, lnBuflen
		    m.lnBuflen = This.env.API_FPDF_ANNOT.FPDFAnnot_GetFormFieldValue(This.fpdf_form, m.lnAnnotHandle, "", 0)
		    IF m.lnBuflen > 2
		        m.lcBuffer = REPLICATE(CHR(0), m.lnBuflen)
		        m.lnBuflen = This.env.API_FPDF_ANNOT.FPDFAnnot_GetFormFieldValue(This.fpdf_form, m.lnAnnotHandle, @m.lcBuffer, m.lnBuflen)
		        m.lcBuffer = LEFT(m.lcBuffer, MAX(m.lnBuflen - 2, 0))
		        IF EMPTY(m.lcBuffer) = .F.
		            m.lcFormFieldValue = m.lcBuffer 
		        ENDIF
		    ENDIF
		    m.lnFormFieldType = This.env.API_FPDF_ANNOT.FPDFAnnot_GetFormFieldType(This.fpdf_form, m.lnAnnotHandle)
		
		    LOCAL lnGroupItem
		    FOR m.lnGroupItem = 1 TO m.loFormFieldIn.GroupItemsCount
		        LOCAL loGroupItemIn, loGroupItemOut
		        m.loGroupItemIn = m.loFormFieldIn.GroupItems[m.lnGroupItem]
		        m.loGroupItemOut = NEWOBJECT("Empty")
		        ADDPROPERTY(m.loGroupItemOut, "Value", m.loGroupItemIn.Value)
		        ADDPROPERTY(m.loGroupItemOut, "PageIndex", m.loGroupItemIn.PageIndex)
		        ADDPROPERTY(m.loGroupItemOut, "AnnotIndex", m.loGroupItemIn.AnnotIndex)
		        m.loFormFieldOutGroupItems.Add(m.loGroupItemOut)
		    ENDFOR
		
		    LOCAL lnOptCnt, lnOpt
		    m.lnOptCnt = This.env.API_FPDF_ANNOT.FPDFAnnot_GetOptionCount(This.fpdf_form, m.lnAnnotHandle)
		    FOR m.lnOpt = 1 TO m.lnOptCnt
		        LOCAL loOpt
		        m.loOpt = NEWOBJECT("Empty")
		        ADDPROPERTY(m.loOpt, "Label", "")
		        ADDPROPERTY(m.loOpt, "IsSelected", .F.)
		        
		        LOCAL lcBuffer, lnBuflen
		        m.lnBuflen = This.env.API_FPDF_ANNOT.FPDFAnnot_GetOptionLabel(This.fpdf_form, m.lnAnnotHandle, m.lnOpt - 1, "", 0)
		        IF m.lnBuflen > 2
		            m.lcBuffer = REPLICATE(CHR(0), m.lnBuflen)
		            m.lnBuflen = This.env.API_FPDF_ANNOT.FPDFAnnot_GetOptionLabel(This.fpdf_form, m.lnAnnotHandle, m.lnOpt - 1, @m.lcBuffer, m.lnBuflen)
		            m.lcBuffer = LEFT(m.lcBuffer, MAX(m.lnBuflen - 2, 0))
		            IF EMPTY(m.lcBuffer) = .F.
		                m.loOpt.Label = m.lcBuffer 
		            ENDIF
		        ENDIF
		        
		        IF This.env.API_FPDF_ANNOT.FPDFAnnot_IsOptionSelected(This.fpdf_form, m.lnAnnotHandle, m.lnOpt - 1) = 1
		            m.loOpt.IsSelected = .T.
		        ENDIF
		        
		        m.loFormFieldOutOptions.Add(m.loOpt)
		    ENDFOR
		FINALLY
		    This.env.API_FPDF_ANNOT.FPDFPage_CloseAnnot(m.lnAnnotHandle)
		ENDTRY
		
		IF m.lnFormFieldType = -1
		    RETURN .F.
		ENDIF
		
		LOCAL loFormFieldOut
		m.loFormFieldOut = NEWOBJECT("Empty")
		ADDPROPERTY(m.loFormFieldOut, "Name", m.lcFormFieldName) && field name in UTF-16LE encoding
		ADDPROPERTY(m.loFormFieldOut, "Type", "") && field type, string (ANSI encoding): CheckBox, ComboBox, ListBox, Button, TextBox, OptionGroup, Signature or Unknown
		ADDPROPERTY(m.loFormFieldOut, "Value", m.lcFormFieldValue) && value of a field, the property contains String (UTF-16LE), Logical or Numeric value depending on field type
		ADDPROPERTY(m.loFormFieldOut, "ValueRaw", m.lcFormFieldValue) && unformatted field value in PDF (UTF-16LE encoding)
		
		ADDPROPERTY(m.loFormFieldOut, "GroupItems", m.loFormFieldOutGroupItems) && Collection of items for OptionGroup fields. 
		                                                                        && Contains objects with props "Value" String (UTF-16LE), "PageIndex" Numeric, "AnnotIndex" Numeric
		
		ADDPROPERTY(m.loFormFieldOut, "Options", m.loFormFieldOutOptions) && Collection of options for ComboBox and ListBox fields. 
		                                                            && Contains objects with props "Label" String (UTF-16LE), "IsSelected" Logical
		ADDPROPERTY(m.loFormFieldOut, "PageIndex", m.lnPageIndex) && 1-based index of a page where field is placed
		ADDPROPERTY(m.loFormFieldOut, "AnnotIndex", m.lnAnnotIndex) && 1-based page scoped index of a PDF annotation linked with a field. 
		
		DO CASE
		CASE m.lnFormFieldType = This.env.API_FPDF.CONST.FPDF_FORMFIELD_CHECKBOX()
		    m.loFormFieldOut.Type = "CheckBox"
		    m.loFormFieldOut.Value = ICASE(m.loFormFieldOut.ValueRaw == STRCONV('Yes', 5), .T., .F.)
		
		CASE m.lnFormFieldType = This.env.API_FPDF.CONST.FPDF_FORMFIELD_COMBOBOX()
		    m.loFormFieldOut.Type = "ComboBox"
		
		CASE m.lnFormFieldType = This.env.API_FPDF.CONST.FPDF_FORMFIELD_LISTBOX()
		    m.loFormFieldOut.Type = "ListBox"
		
		CASE m.lnFormFieldType = This.env.API_FPDF.CONST.FPDF_FORMFIELD_PUSHBUTTON()
		    m.loFormFieldOut.Type = "Button"
		    m.loFormFieldOut.Value = NULL
		
		CASE m.lnFormFieldType = This.env.API_FPDF.CONST.FPDF_FORMFIELD_TEXTFIELD()
		    m.loFormFieldOut.Type = "TextBox"
		
		CASE m.lnFormFieldType = This.env.API_FPDF.CONST.FPDF_FORMFIELD_RADIOBUTTON()
		    m.loFormFieldOut.Type = "OptionGroup"
		    m.loFormFieldOut.Value = 0
		    LOCAL lnGroupItem, loGroupItem
		    FOR m.lnGroupItem = 1 TO m.loFormFieldOut.GroupItems.Count
		        m.loGroupItem = m.loFormFieldOut.GroupItems[m.lnGroupItem]
		        IF m.loGroupItem.Value == m.loFormFieldOut.ValueRaw
		            m.loFormFieldOut.Value = m.lnGroupItem
		            EXIT
		        ENDIF
		    ENDFOR
		
		CASE m.lnFormFieldType = This.env.API_FPDF.CONST.FPDF_FORMFIELD_SIGNATURE()
		    m.loFormFieldOut.Type = "Signature"
		
		OTHERWISE
		    m.loFormFieldOut.Type = "Unknown"
		ENDCASE
		
		RETURN m.loFormFieldOut
		
	ENDPROC

	PROCEDURE getformfieldscount		&& Returns number of fields in PDF form
		RETURN This.FormFields.Count
		
	ENDPROC

	PROCEDURE getpagecount		&& Returns page count
		RETURN This.fpdf_pagecount
		
	ENDPROC

	PROCEDURE getpagesize		&& Returns page dimensions (see comment in source code)
		LPARAMETERS tnPageIndex, tnPosition
		
		*tnPageIndex: page number from 1 to This.fpdf_pagecount
		*tnPosition: 1 - width in pdf units  (1/72 on inch)
		*tnPosition: 2 - height in pdf units  (1/72 on inch)
		*tnPosition: 3 - width in pixels
		*tnPosition: 4 - height in pixels
		*tnPosition: 5 - width / height relation
		
		IF BETWEEN(m.tnPageIndex, 1, This.fpdf_pagecount)=.F.
		    RETURN 0
		ENDIF
		
		LOCAL lnPdfPageWidth, lnPdfPageHeight
		m.lnPdfPageWidth = This.fpdf_pages_size[m.tnPageIndex,1]
		m.lnPdfPageHeight = This.fpdf_pages_size[m.tnPageIndex,2]
		
		LOCAL lnPageWidth, lnPageHeight
		m.lnPageWidth = INT(m.lnPdfPageWidth * This.env.GetScreenDPIX() / This.env.GetPDFDPI())
		m.lnPageHeight = INT(m.lnPdfPageHeight * This.env.GetScreenDPIY() / This.env.GetPDFDPI())
		
		DO CASE
		
		CASE m.tnPosition = 1
		    RETURN m.lnPdfPageWidth
		
		CASE m.tnPosition = 2
		    RETURN m.lnPdfPageHeight
		
		CASE m.tnPosition = 3
		    RETURN m.lnPageWidth
		    
		CASE m.tnPosition = 4
		    RETURN m.lnPageHeight
		
		CASE m.tnPosition = 5
		    RETURN IIF(EMPTY(m.lnPdfPageHeight), 0, m.lnPdfPageWidth / m.lnPdfPageHeight)
		
		ENDCASE
		
		RETURN 0
		
	ENDPROC

	HIDDEN PROCEDURE GotFocus
		This.IsFocused = .T.
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.FormFields = NEWOBJECT("Collection")
		
		This.env.Setup(m.toEnv)
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		*********************************************************
		This.BorderWidth = 0
		
		
		*********************************************************
		IF This.WndCreate() = .F.
		    RETURN
		ENDIF
		
		LOCAL lhBackColorBrush
		m.lhBackColorBrush = 0
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateSolidFill(This.env.API_GDIP.ARGB(255, This.BackColor), @m.lhBackColorBrush))
		This.BackColorBrush = m.lhBackColorBrush
		
		LOCAL lhSelectionBrush
		m.lhSelectionBrush = 0
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateSolidFill(This.env.API_GDIP.ARGB(72, 70, 130, 180), @m.lhSelectionBrush))
		This.SelectionBrush = m.lhSelectionBrush
		
		LOCAL lhSearchBrush
		m.lhSearchBrush = 0
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateSolidFill(This.env.API_GDIP.ARGB(96, 255, 255, 0), @m.lhSearchBrush))
		This.SearchBrush = lhSearchBrush
		
		LOCAL lhPageFillBrush
		m.lhPageFillBrush = 0
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateSolidFill(This.env.API_GDIP.ARGB(255, 255, 255, 255), @m.lhPageFillBrush))
		This.PageFillBrush = lhPageFillBrush
		
		
		
		*********************************************************
		This.Resize()
		This.WndShow()
		
	ENDPROC

	PROCEDURE keypress		&& Occurs when the user presses and releases a key.
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		#define KEY_BACK 127
		#define KEY_TAB 0x09
		#define KEY_LEFT_ARROW 19
		#define KEY_RIGHT_ARROW 4
		#define KEY_UP_ARROW 5
		#define KEY_DOWN_ARROW 24
		#define KEY_PAGE_UP 18
		#define KEY_PAGE_DOWN 3
		#define KEY_HOME 1
		#define KEY_END 6
		#define KEY_CTRL_C 3
		#define KEY_CTRL_V 22
		#define KEY_RETURN 13
		#define KEY_SPACE 32
		
		
		LOCAL loFPDF_CONST
		m.loFPDF_CONST = This.env.API_FPDF.CONST
		
		IF This.AllowFormEdit ;
		    AND EMPTY(This.fpdf_form) = .F. ;
		    AND BITAND(m.nShiftAltCtrl, 4) = 0 ;
		    AND NOT (INLIST(m.nKeyCode, KEY_CTRL_C, KEY_CTRL_V) AND m.nShiftAltCtrl = 2)
		    
		    #define VK_INSERT 0x2D
		    #define VK_HOME 0x24
		    #define VK_DELETE 0x2E
		    #define VK_END 0x23
		    #define VK_PRIOR 0x21
		    #define VK_NEXT 0x22
		    #define VK_UP 0x26
		    #define VK_DOWN 0x28
		    #define VK_RIGHT 0x27
		    #define VK_LEFT 0x25
		    #define VK_ESCAPE 0x1B
		    #define VK_BACK 0x08
		    #define VK_TAB 0x09
		    #define VK_RETURN 0x09
		        
		
		    LOCAL lnVKey
		    m.lnVKey = 0
		    DO CASE
		    CASE m.nKeyCode = 22 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_INSERT
		    CASE m.nKeyCode = 22 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_INSERT
		    CASE m.nKeyCode = 146 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_INSERT
		
		    CASE m.nKeyCode = 1 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_HOME
		    CASE m.nKeyCode = 55 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_HOME
		    CASE m.nKeyCode = 29 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_HOME
		
		    CASE m.nKeyCode = 7 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_DELETE
		    CASE m.nKeyCode = 7 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_DELETE
		    CASE m.nKeyCode = 147 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_DELETE
		
		    CASE m.nKeyCode = 6 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_END
		    CASE m.nKeyCode = 49 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_END
		    CASE m.nKeyCode = 23 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_END
		
		    CASE m.nKeyCode = 18 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_PRIOR
		    CASE m.nKeyCode = 57 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_PRIOR
		    CASE m.nKeyCode = 31 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_PRIOR
		
		    CASE m.nKeyCode = 3 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_NEXT
		    CASE m.nKeyCode = 51 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_NEXT
		    CASE m.nKeyCode = 30 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_NEXT
		
		    CASE m.nKeyCode = 5 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_UP
		    CASE m.nKeyCode = 56 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_UP
		    CASE m.nKeyCode = 141 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_UP
		
		    CASE m.nKeyCode = 24 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_DOWN
		    CASE m.nKeyCode = 50 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_DOWN
		    CASE m.nKeyCode = 145 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_DOWN
		
		    CASE m.nKeyCode = 4 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_RIGHT
		    CASE m.nKeyCode = 54 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_RIGHT
		    CASE m.nKeyCode = 2 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_RIGHT
		
		    CASE m.nKeyCode = 19 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_LEFT
		    CASE m.nKeyCode = 52 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_LEFT
		    CASE m.nKeyCode = 26 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_LEFT
		
		    CASE m.nKeyCode = 27 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_ESCAPE
		    CASE m.nKeyCode = 27 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_ESCAPE
		    CASE m.nKeyCode = 27 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_ESCAPE
		
		    CASE m.nKeyCode = 13 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_RETURN
		    CASE m.nKeyCode = 13 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_RETURN
		    CASE m.nKeyCode = 10 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_RETURN
		
		    CASE m.nKeyCode = 127 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_BACK
		    CASE m.nKeyCode = 127 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_BACK
		    CASE m.nKeyCode = 127 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_BACK
		
		    CASE m.nKeyCode = 9 AND m.nShiftAltCtrl = 0
		        m.lnVKey = VK_TAB
		    CASE m.nKeyCode = 15 AND m.nShiftAltCtrl = 1
		        m.lnVKey = VK_TAB
		    CASE m.nKeyCode = 148 AND m.nShiftAltCtrl = 2
		        m.lnVKey = VK_TAB
		    ENDCASE
		    
		    LOCAL llFormHandled, lnAnnotPage, lnAnnot
		    m.llFormHandled = .F.
		    STORE 0 TO m.lnAnnotPage, m.lnAnnot
		    TRY
		        IF This.env.API_FPDF_FORMS.FORM_GetFocusedAnnot(This.fpdf_form, @m.lnAnnotPage, @m.lnAnnot) = 1
		            IF BETWEEN(m.lnAnnotPage + 1, This.fpdf_page_first_visible, This.fpdf_page_last_visible)
		                LOCAL lnFPDF_Page
		                m.lnFPDF_Page = This.fpdf_pages[m.lnAnnotPage + 1]
		                
		                LOCAL lnFormFieldType
		                m.lnFormFieldType = 0
		                IF EMPTY(m.lnAnnot) = .F.
		                    m.lnFormFieldType = This.env.API_FPDF_ANNOT.FPDFAnnot_GetFormFieldType(This.fpdf_form, m.lnAnnot)
		                ENDIF
		            
		                LOCAL lnKeyCodeUTF
		                m.lnKeyCodeUTF = 0
		                
		                DO CASE
		                CASE INLIST(m.nKeyCode, KEY_RETURN, KEY_SPACE) ;
		                 AND INLIST(m.lnFormFieldType, ;
		                             m.loFPDF_CONST.FPDF_FORMFIELD_CHECKBOX(), ;
		                             m.loFPDF_CONST.FPDF_FORMFIELD_RADIOBUTTON())
		                    
		                    m.lnKeyCodeUTF = This.env.API_WIN.GetKeyUnicode(m.nKeyCode)
		                
		                CASE INLIST(m.lnVKey, 0, VK_BACK) AND INLIST(m.nShiftAltCtrl,0,1)
		                    m.lnKeyCodeUTF = This.env.API_WIN.GetKeyUnicode(m.nKeyCode)
		                ENDCASE
		                
		                DO CASE
		                CASE m.lnKeyCodeUTF > 0 AND NOT INLIST(m.lnKeyCodeUTF, KEY_TAB)
		                    This.env.API_FPDF_FORMS.FORM_OnChar(This.fpdf_form, m.lnFPDF_Page, m.lnKeyCodeUTF, 0)
		                CASE m.lnVKey > 0
		                    This.env.API_FPDF_FORMS.FORM_OnKeyDown(This.fpdf_form, m.lnFPDF_Page, m.lnVKey, m.nShiftAltCtrl)
		                ENDCASE
		                
		                m.llFormHandled = .T.
		            ENDIF
		        ENDIF
		    FINALLY
		        IF EMPTY(m.lnAnnot) = .F.
		            This.env.API_FPDF_ANNOT.FPDFPage_CloseAnnot(m.lnAnnot)
		        ENDIF
		    ENDTRY
		
		    IF m.llFormHandled 
		        This.Redraw()
		        NODEFAULT
		        RETURN
		    ENDIF    
		ENDIF
		
		
		DO CASE
		CASE This.fpdf_opened = .F.
		 
		CASE This.UIState.GetEffectivelyVisible() = .F.
		
		CASE This.UIState.GetEffectivelyEnabled() = .F. 
		 
		CASE m.nKeyCode = KEY_LEFT_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollHorz(-0.05 * This.Width, .F., .T.)
		
		CASE m.nKeyCode = KEY_RIGHT_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollHorz(0.05 * This.Width, .F., .T.)
		
		CASE m.nKeyCode = KEY_UP_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(-0.05 * This.Height, .F., .T.)
		
		CASE m.nKeyCode = KEY_DOWN_ARROW AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(0.05 * This.Height, .F., .T.)
		
		CASE m.nKeyCode = KEY_PAGE_UP AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(-1, .T., .T.)
		
		CASE m.nKeyCode = KEY_PAGE_DOWN AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(1, .T., .T.)
		
		CASE m.nKeyCode = KEY_HOME AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(1, .T., .F.)
		
		CASE m.nKeyCode = KEY_END AND EMPTY(m.nShiftAltCtrl)
		    NODEFAULT
		    This.ScrollVert(This.ViewPortMaxY, .T., .F.)
		
		CASE m.nKeyCode = KEY_CTRL_C AND m.nShiftAltCtrl = 2
		    NODEFAULT
		    This.SelectionCopy()
		
		CASE m.nKeyCode = KEY_CTRL_V AND m.nShiftAltCtrl = 2
		    NODEFAULT
		    This.SelectTextAll()
		
		ENDCASE
		
		
	ENDPROC

	HIDDEN PROCEDURE LostFocus
		This.IsFocused = .F.
		IF EMPTY(This.fpdf_form) = .F.
		    This.env.API_FPDF_FORMS.FORM_ForceToKillFocus(This.fpdf_form)
		    This.Redraw()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		LOCAL loFPDF, loFPDF_FORMS
		m.loFPDF = This.env.API_FPDF
		m.loFPDF_FORMS = This.env.API_FPDF_FORMS
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		This.SelectionCharIndexStart = 0
		
		IF m.nButton <> 1
		    RETURN 
		ENDIF
		
		LOCAL lnMouseX, lnMouseY
		m.lnMouseX = m.nXCoord
		m.lnMouseY = m.nYCoord
		
		LOCAL llDblClick, llTplClick
		m.llDblClick = .F.
		m.llTplClick = .F.
		
		********************************************************************
		LOCAL lnTick
		m.lnTick = This.env.API_WIN.GetTickCount()
		m.lnTick = IIF(m.lnTick < 0, 0x80000000 + BITCLEAR(m.lnTick,31), m.lnTick)
		
		DO CASE 
		
		CASE This.DblClickBegin = 0 AND This.TplClickBegin = 0
		    This.DblClickBegin = -m.lnTick
		    This.TplClickBegin = -m.lnTick
		
		CASE This.DblClickBegin < 0
		    This.DblClickBegin = -This.DblClickBegin
		    
		    IF ABS(m.lnTick - This.DblClickBegin)/1000 <= _DBLCLICK
		        m.llDblClick = .T.
		        This.DblClickBegin = 0
		    ELSE
		        This.DblClickBegin = -m.lnTick
		        This.TplClickBegin = -m.lnTick
		    ENDIF
		
		CASE This.TplClickBegin < 0
		    This.TplClickBegin = -This.TplClickBegin
		    IF ABS(m.lnTick - This.TplClickBegin)/1000 <= _DBLCLICK 
		        m.llTplClick = .T.
		        This.DblClickBegin = 0
		        This.TplClickBegin = 0
		    ELSE
		        This.DblClickBegin = -m.lnTick
		        This.TplClickBegin = -m.lnTick
		    ENDIF
		
		ENDCASE
		
		
		********************************************************************
		LOCAL lnPage, lnFPDF_Page, lnFPDF_Text_Page
		m.lnPage = This.PagePick(m.lnMouseX, m.lnMouseY)
		
		IF EMPTY(m.lnPage) = .T.
		    RETURN
		ENDIF
		
		m.lnFPDF_Page = This.fpdf_pages[m.lnPage]
		m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPage]
		
		LOCAL lnPageX as Double, lnPageY as Double
		STORE 0 TO m.lnPageX, m.lnPageY
		
		IF m.loFPDF.FPDF_DeviceToPage(m.lnFPDF_Page, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnMouseX, m.lnMouseY, @m.lnPageX, @m.lnPageY) <> 1
		    RETURN
		ENDIF
		
		IF m.nButton = 1 AND This.AllowFormEdit AND EMPTY(This.fpdf_form) = .F.
		    DO CASE
		    CASE m.llDblClick = .T. AND m.llTplClick = .F.
		        IF m.loFPDF_FORMS.FORM_OnLButtonDoubleClick(This.fpdf_form, m.lnFPDF_Page, m.nShift, m.lnPageX, m.lnPageY) > 0
		            m.loFPDF_FORMS.Form_OnFocus(This.fpdf_form, m.lnFPDF_Page, m.nShift, m.lnPageX, m.lnPageY)
		            This.Redraw()
		            RETURN
		        ENDIF
		    OTHERWISE
		        IF m.loFPDF_FORMS.FORM_OnLButtonDown(This.fpdf_form, m.lnFPDF_Page, m.nShift, m.lnPageX, m.lnPageY) > 0
		            m.loFPDF_FORMS.Form_OnFocus(This.fpdf_form, m.lnFPDF_Page, m.nShift, m.lnPageX, m.lnPageY)
		            This.Redraw()
		            RETURN
		        ENDIF
		    ENDCASE
		    m.loFPDF_FORMS.FORM_ForceToKillFocus(This.fpdf_form)
		ENDIF
		
		
		********************************************************************
		LOCAL lnCharIndexStart
		m.lnCharIndexStart = m.loFPDF.FPDFText_GetCharIndexAtPos(m.lnFPDF_Text_Page, m.lnPageX, m.lnPageY, 10, 0)
		
		IF m.lnCharIndexStart > 0
		    This.SelectionCharIndexStart = m.lnCharIndexStart
		ENDIF
		
		IF m.lnCharIndexStart < 0
		    * TEXT MISCLICK
		    This.SelectText()
		    RETURN
		ENDIF
		
		
		IF m.llDblClick = .F. AND m.llTplClick = .F.
		    * TEXT SINGLE CLICK
		    This.SelectText()
		    RETURN
		ENDIF
		
		
		********************************************************************
		* TEXT DOUBLE CLICK, TRIPLE CLICK
		********************************************************************
		
		LOCAL lnCharCountMax
		m.lnCharCountMax = m.loFPDF.FPDFText_CountChars(m.lnFPDF_Text_Page)
		IF m.lnCharCountMax < 0
		    RETURN
		ENDIF
		
		LOCAL lnCharCount
		m.lnCharCount = 1
		
		LOCAL lnCharIndexLeft
		m.lnCharIndexLeft = m.lnCharIndexStart
		
		DO WHILE m.lnCharIndexLeft > 0
		    LOCAL lcChar
		    m.lcChar = LEFT(STRCONV(STRCONV(BINTOC(m.loFPDF.FPDFText_GetUnicode(m.lnFPDF_Text_Page, m.lnCharIndexLeft-1), "4RS"),6),2),1)
		    
		    IF INLIST(m.lcChar, CHR(10),CHR(13))
		        EXIT
		    ENDIF
		    
		    IF EMPTY(m.lcChar) AND m.llTplClick = .F.
		        EXIT
		    ENDIF
		    
		    m.lnCharIndexLeft = m.lnCharIndexLeft - 1
		    m.lnCharCount = m.lnCharCount + 1
		ENDDO
		
		
		DO WHILE m.lnCharIndexLeft + m.lnCharCount < m.lnCharCountMax
		    LOCAL lcChar
		    m.lcChar = LEFT(STRCONV(STRCONV(BINTOC(m.loFPDF.FPDFText_GetUnicode(m.lnFPDF_Text_Page, m.lnCharIndexLeft + m.lnCharCount), "4RS"),6),2),1)
		
		    IF INLIST(m.lcChar, CHR(10),CHR(13))
		        EXIT
		    ENDIF
		
		    IF EMPTY(m.lcChar) AND m.llTplClick = .F.
		        EXIT
		    ENDIF
		
		    m.lnCharCount = m.lnCharCount + 1
		ENDDO
		
		
		This.SelectText(m.lnPage, m.lnCharIndexLeft, m.lnCharCount)
		
		
	ENDPROC

	HIDDEN PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL loFPDF, loFPDF_FORMS
		m.loFPDF = This.env.API_FPDF
		m.loFPDF_FORMS = This.env.API_FPDF_FORMS
		
		LOCAL lnMouseX, lnMouseY
		m.lnMouseX = m.nXCoord
		m.lnMouseY = m.nYCoord
		
		LOCAL lnPage, lnFPDF_Page, lnFPDF_Text_Page
		m.lnPage = This.PagePick(m.lnMouseX, m.lnMouseY)
		IF EMPTY(m.lnPage)
		    RETURN
		ENDIF
		
		m.lnFPDF_Page = This.fpdf_pages[m.lnPage]
		m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPage]
		
		LOCAL lnPageX as Double, lnPageY as Double
		STORE 0 TO m.lnPageX, m.lnPageY
		
		IF m.loFPDF.FPDF_DeviceToPage(m.lnFPDF_Page, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnMouseX, m.lnMouseY, @m.lnPageX, @m.lnPageY) <> 1
		    RETURN
		ENDIF
		
		IF m.nButton = 1 AND This.AllowFormEdit AND EMPTY(This.fpdf_form) = .F.
		    IF m.loFPDF_FORMS.FORM_OnMouseMove(This.fpdf_form, m.lnFPDF_Page, m.nShift + IIF(m.nButton=1, 64,0), m.lnPageX, m.lnPageY) > 0
		        This.Redraw()
		        RETURN
		    ENDIF
		ENDIF
		
		LOCAL lnCharIndex
		m.lnCharIndex = m.loFPDF.FPDFText_GetCharIndexAtPos(m.lnFPDF_Text_Page, m.lnPageX, m.lnPageY, 10, 0)
		
		DO CASE
		CASE m.lnCharIndex >= 0
		    This.MousePointer = 3
		    
		    IF m.nButton = 1 AND m.lnCharIndex <> This.SelectionCharindexPrev
		        This.SelectText(m.lnPage, MIN(This.SelectionCharIndexStart,m.lnCharIndex), ABS(m.lnCharIndex-This.SelectionCharIndexStart)+1)
		    ENDIF
		    
		OTHERWISE
		    This.MousePointer = 0
		ENDCASE
		
		This.SelectionCharindexPrev = m.lnCharIndex
		
	ENDPROC

	HIDDEN PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		LOCAL loFPDF, loFPDF_FORMS
		m.loFPDF = This.env.API_FPDF
		m.loFPDF_FORMS = This.env.API_FPDF_FORMS
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL lnMouseX, lnMouseY
		m.lnMouseX = m.nXCoord
		m.lnMouseY = m.nYCoord
		
		LOCAL lnPage, lnFPDF_Page, lnFPDF_Text_Page
		m.lnPage = This.PagePick(m.lnMouseX, m.lnMouseY)
		
		IF EMPTY(m.lnPage) = .T.
		    RETURN
		ENDIF
		
		m.lnFPDF_Page = This.fpdf_pages[m.lnPage]
		m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPage]
		
		LOCAL lnPageX as Double, lnPageY as Double
		STORE 0 TO m.lnPageX, m.lnPageY
		
		IF m.loFPDF.FPDF_DeviceToPage(m.lnFPDF_Page, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnMouseX, m.lnMouseY, @m.lnPageX, @m.lnPageY) <> 1
		    RETURN
		ENDIF
		
		IF m.nButton = 1 AND This.AllowFormEdit AND EMPTY(This.fpdf_form) = .F.
		    IF m.loFPDF_FORMS.FORM_OnLButtonUp(This.fpdf_form, m.lnFPDF_Page, m.nShift + 64, m.lnPageX, m.lnPageY) > 0
		        This.Redraw()
		        RETURN
		    ENDIF
		ENDIF
		
		IF m.nButton = 2
		    This.contextmenu()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE MouseWheel
		LPARAMETERS nDirection, nShift, nXCoord, nYCoord
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		
		DO CASE
		CASE EVL(m.nShift,0)=2
		     This.scale = This.scale + (SIGN(m.nDirection) * 0.1)
		 
		CASE EVL(m.nShift,0)=0
		    This.ScrollVert(-0.05 * This.Height * m.nDirection/120, .F., .T.)
		
		ENDCASE
		
	ENDPROC

	PROCEDURE openpdf		&& Open pdf file. Returns: .T. on success, .F. if file was not loaded
		LPARAMETERS tcFilename, tcPassword
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.ClosePDF()
		
		LOCAL loFPDF, loFPDF_FORMS
		m.loFPDF = This.env.API_FPDF
		m.loFPDF_FORMS = This.env.API_FPDF_FORMS
		
		
		LOCAL lcFilename
		m.lcFilename = ALLTRIM(EVL(NVL(m.tcFilename,""),""))
		
		IF EMPTY(m.lcFilename)
		    RETURN .F.
		ENDIF
		
		IF FILE(m.lcFilename,1)=.F.
		    This.errMsg(TEXTMERGE("File <<FULLPATH(lcFilename)>> not found"))
		    RETURN .F.
		ENDIF    
		
		LOCAL lcPassword
		m.lcPassword = IIF(VARTYPE(m.tcPassword)<>"C", "", m.tcPassword)
		
		
		DO WHILE .T.
		    This.fpdf_doc = m.loFPDF.FPDF_LoadDocument(STRCONV(m.lcFilename,9)+CHR(0), STRCONV(m.lcPassword,9)+CHR(0))
		
		    IF EMPTY(This.fpdf_doc) = .F.
		        EXIT
		    ENDIF
		    
		    LOCAL lnLoadError
		    m.lnLoadError = m.loFPDF.FPDF_GetLastError()
		    
		    IF m.lnLoadError = m.loFPDF.CONST.FPDF_ERR_PASSWORD()
		        LOCAL loPasswordInput
		        m.loPasswordInput = NEWOBJECT("pdfium_password_input", This.ClassLibrary)
		        m.loPasswordInput.out_password = m.lcPassword
		        m.loPasswordInput.in_incorrect = EMPTY(m.lcPassword)=.F.
		        m.loPasswordInput.Show(1)
		        
		        IF VARTYPE(m.loPasswordInput) = "O" AND m.loPasswordInput.out_ok = .T.
		            m.lcPassword = m.loPasswordInput.out_password
		            m.loPasswordInput = .F.
		            LOOP
		        ENDIF
		        m.loPasswordInput = .F.
		    ENDIF
		    
		    RETURN .F.
		ENDDO
		
		This.fpdf_form = m.loFPDF_FORMS.VFPDFDOC_InitFormFillEnvironment(This.fpdf_doc)
		IF EMPTY(This.fpdf_form) = .F.
		    m.loFPDF_FORMS.FPDF_SetFormFieldHighlightColor(This.fpdf_form, m.loFPDF.CONST.FPDF_FORMFIELD_UNKNOWN() , 0xFFE4DD)
		    m.loFPDF_FORMS.FPDF_SetFormFieldHighlightAlpha(This.fpdf_form, 100)
		ENDIF
		
		This.fpdf_pagecount = m.loFPDF.FPDF_GetPageCount(This.fpdf_doc)
		
		IF This.fpdf_pagecount > 0
		    DIMENSION This.fpdf_pages(This.fpdf_pagecount)
		    DIMENSION This.fpdf_text_pages(This.fpdf_pagecount)
		    DIMENSION This.fpdf_pages_selection(This.fpdf_pagecount,3)
		    DIMENSION This.fpdf_pages_pos(This.fpdf_pagecount,4)
		    DIMENSION This.fpdf_pages_size(This.fpdf_pagecount,2)
		    STORE 0 TO This.fpdf_pages, This.fpdf_text_pages, This.fpdf_pages_pos, This.fpdf_pages_size
		ENDIF
		
		LOCAL lnPage
		FOR m.lnPage = 1 TO This.FPDF_PageCount
		    This.fpdf_pages[m.lnPage] = m.loFPDF.FPDF_LoadPage(This.FPDF_Doc, m.lnPage-1)
		    
		    This.fpdf_text_pages[m.lnPage] = m.loFPDF.FPDFText_LoadPage(This.fpdf_pages[m.lnPage])
		    IF EMPTY(This.fpdf_form) = .F.
		        m.loFPDF_FORMS.FORM_OnAfterLoadPage(This.fpdf_pages[m.lnPage], This.fpdf_form)
		    ENDIF
		    
		    This.fpdf_pages_selection[m.lnPage,1] = ""
		    This.fpdf_pages_selection[m.lnPage,2] = 0
		    This.fpdf_pages_selection[m.lnPage,3] = 0
		    
		    This.fpdf_pages_size[m.lnPage,1] = m.loFPDF.FPDF_GetPageWidth(This.fpdf_pages[m.lnPage])
		    This.fpdf_pages_size[m.lnPage,2] = m.loFPDF.FPDF_GetPageHeight(This.fpdf_pages[m.lnPage])
		    
		    IF EMPTY(This.fpdf_form) = .F.
		        LOCAL lnAnnotCnt, lnAnnot, lnAnnotHandle
		        m.lnAnnotCnt = This.env.API_FPDF_ANNOT.FPDFPage_GetAnnotCount(This.fpdf_pages[m.lnPage])
		        FOR m.lnAnnot = 1 TO m.lnAnnotCnt
		            m.lnAnnotHandle = This.env.API_FPDF_ANNOT.FPDFPage_GetAnnot(This.fpdf_pages[m.lnPage], m.lnAnnot - 1)
		            IF EMPTY(m.lnAnnotHandle)
		                LOOP
		            ENDIF
		            
		            TRY
		                LOCAL lcBuffer, lnBuflen
		                m.lnBuflen = This.env.API_FPDF_ANNOT.FPDFAnnot_GetFormFieldName(This.fpdf_form, m.lnAnnotHandle, "", 0)
		                IF m.lnBuflen > 2
		                    m.lcBuffer = REPLICATE(CHR(0), m.lnBuflen)
		                    m.lnBuflen = This.env.API_FPDF_ANNOT.FPDFAnnot_GetFormFieldName(This.fpdf_form, m.lnAnnotHandle, @m.lcBuffer, m.lnBuflen)
		                    m.lcBuffer = LEFT(m.lcBuffer, MAX(m.lnBuflen - 2, 0))
		                    IF EMPTY(m.lcBuffer) = .F.
		                        LOCAL lcFormFieldName
		                        m.lcFormFieldName = m.lcBuffer
		                        
		                        LOCAL loFormField, lnFormFieldIndex
		                        m.lnFormFieldIndex = This.FormFields.GetKey(m.lcFormFieldName)
		                        IF m.lnFormFieldIndex = 0
		                            m.loFormField = NEWOBJECT("Empty")
		                            ADDPROPERTY(m.loFormField, "PageIndex", m.lnPage)
		                            ADDPROPERTY(m.loFormField, "AnnotIndex", m.lnAnnot)
		                            ADDPROPERTY(m.loFormField, "GroupItemsCount", 1)
		                            ADDPROPERTY(m.loFormField, "GroupItems[1]")
		                            
		                            This.FormFields.Add(m.loFormField, m.lcFormFieldName)
		                        ELSE
		                            m.loFormField = This.FormFields[m.lnFormFieldIndex]
		                            m.loFormField.GroupItemsCount = m.loFormField.GroupItemsCount + 1
		                            
		                            LOCAL laGroupItems(m.loFormField.GroupItemsCount - 1), lnGroupItem
		                            FOR m.lnGroupItem = 1 TO m.loFormField.GroupItemsCount - 1
		                                m.laGroupItems[m.lnGroupItem] = m.loFormField.GroupItems[m.lnGroupItem]
		                            ENDFOR
		                            
		                            ADDPROPERTY(m.loFormField, TEXTMERGE("GroupItems[<<m.loFormField.GroupItemsCount>>]"))
		                            
		                            FOR m.lnGroupItem = 1 TO m.loFormField.GroupItemsCount - 1
		                                m.loFormField.GroupItems[m.lnGroupItem] = m.laGroupItems[m.lnGroupItem]
		                            ENDFOR
		                        ENDIF
		
		                        LOCAL loGroupItem
		                        m.loGroupItem = NEWOBJECT("Empty")
		                        ADDPROPERTY(m.loGroupItem, "PageIndex", m.lnPage)
		                        ADDPROPERTY(m.loGroupItem, "AnnotIndex", m.lnAnnot)
		                        ADDPROPERTY(m.loGroupItem, "Value", "")
		                        m.loFormField.GroupItems[m.loFormField.GroupItemsCount] = m.loGroupItem
		                        
		                        LOCAL lcBuffer, lnBuflen
		                        m.lnBuflen = This.env.API_FPDF_ANNOT.FPDFAnnot_GetFormFieldExportValue(This.fpdf_form, m.lnAnnotHandle, "", 0)
		                        IF m.lnBuflen > 2
		                            m.lcBuffer = REPLICATE(CHR(0), m.lnBuflen)
		                            m.lnBuflen = This.env.API_FPDF_ANNOT.FPDFAnnot_GetFormFieldExportValue(This.fpdf_form, m.lnAnnotHandle, @m.lcBuffer, m.lnBuflen)
		                            m.lcBuffer = LEFT(m.lcBuffer, MAX(m.lnBuflen - 2, 0))
		                        ELSE
		                            m.lcBuffer = ""
		                        ENDIF
		                        m.loGroupItem.Value = m.lcBuffer
		                    ENDIF
		                ENDIF
		            FINALLY
		                This.env.API_FPDF_ANNOT.FPDFPage_CloseAnnot(m.lnAnnotHandle)
		            ENDTRY
		        ENDFOR
		    ENDIF
		ENDFOR
		
		This.ViewPortUpdate()
		
		This.fpdf_opened = .T.
		
		This.WndRedraw()
		
	ENDPROC

	HIDDEN PROCEDURE pagepick
		LPARAMETERS lnCoordX, lnCoordY
		
		* lnCoordX, lnCoordY coordinates in the control space (0,0) is top left corner of the control
		
		IF This.fpdf_opened = .F.
		    RETURN 0
		ENDIF
		
		IF This.fpdf_page_first_visible = 0
		    RETURN 0
		ENDIF
		
		
		LOCAL lnPage, lnPageFound
		m.lnPageFound = 0
		FOR m.lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		    DO CASE
		    CASE BETWEEN(m.lnCoordX, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX + This.fpdf_pages_pos[m.lnPage,3]) = .F.
		         LOOP
		    CASE BETWEEN(m.lnCoordY, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY + This.fpdf_pages_pos[m.lnPage,4]) = .F.
		         LOOP
		    OTHERWISE
		        m.lnPageFound = m.lnPage
		        EXIT
		    ENDCASE
		ENDFOR
		
		RETURN m.lnPageFound
		
	ENDPROC

	PROCEDURE paste		&& Paste text from clipboard to form field
		
		#define CF_UNICODETEXT 13
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL lcPasteTextUTF
		m.lcPasteTextUTF = ""
		
		IF This.env.API_WIN.OpenClipboard(0) = 0
		    EXIT
		ENDIF
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    LOCAL lnMemHandle
		    m.lnMemHandle = This.env.API_WIN.GetClipboardData(CF_UNICODETEXT)
		    IF m.lnMemHandle <> 0
		        LOCAL lnBufLen, lnMemPtr
		        m.lnBufLen = This.env.API_WIN.GlobalSize(m.lnMemHandle)
		        m.lnMemPtr = This.env.API_WIN.GlobalLock(m.lnMemHandle)
		
		        IF m.lnBufLen <> 0 AND m.lnMemPtr <> 0
		            m.lcPasteTextUTF = SYS(2600, m.lnMemPtr, m.lnBufLen)
		        ENDIF
		        This.env.API_WIN.GlobalUnlock(m.lnMemHandle)
		    ENDIF
		    
		    IF EMPTY(m.lcPasteTextUTF)
		        m.lcPasteTextUTF = STRCONV(_CLIPTEXT, 5)
		    ENDIF
		    
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		FINALLY
		    This.env.API_WIN.CloseClipboard()
		ENDTRY
		
		IF EMPTY(m.lcPasteTextUTF)
		    RETURN
		ENDIF
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    IF EMPTY(This.fpdf_form) = .F.
		        LOCAL lnAnnotPage, lnAnnot
		        STORE 0 TO m.lnAnnotPage, m.lnAnnot
		        IF This.env.API_FPDF_FORMS.FORM_GetFocusedAnnot(This.fpdf_form, @m.lnAnnotPage, @m.lnAnnot) = 1
		            IF BETWEEN(m.lnAnnotPage + 1, This.fpdf_page_first_visible, This.fpdf_page_last_visible)
		                LOCAL lnFPDF_Page
		                m.lnFPDF_Page = This.fpdf_pages[m.lnAnnotPage + 1]
		
		                This.env.API_FPDF_FORMS.FORM_ReplaceSelection(This.fpdf_form, m.lnFPDF_Page, m.lcPasteTextUTF + CHR(0))
		                This.Redraw()
		                EXIT
		            ENDIF
		        ENDIF
		    ENDIF
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		ENDTRY
		
	ENDPROC

	PROCEDURE printdocument		&& Send document to printer with preceding setup dialog
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		IF EMPTY(This.fpdf_doc)
		    RETURN
		ENDIF
		
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		*********************************************************************
		IF This.PrintEnv.AllowPrintSetupUI = .T.
		
		    LOCAL loDocProps
		    m.loDocProps = NEWOBJECT("Empty")
		    ADDPROPERTY(m.loDocProps, "PageCount", This.GetPageCount())
		    
		    LOCAL loFrmSetup
		    m.loFrmSetup = NEWOBJECT("pdfium_print_settings", This.ClassLibrary, "", This.PrintEnv, m.loDocProps)
		    m.loFrmSetup.Show(1)
		
		    This.SetFocus()
		
		    IF VARTYPE(m.loFrmSetup)<>"O"
		        RETURN
		    ENDIF
		
		    IF m.loFrmSetup.out_ok = .F.
		        RETURN
		    ENDIF
		
		    m.loFrmSetup = .F.
		
		ENDIF
		
		IF EMPTY(This.PrintEnv.Printer)
		    RETURN
		ENDIF
		*********************************************************************
		
		
		*********************************************************************
		
		#define PHYSICALOFFSETX 112
		#define PHYSICALOFFSETY 113
		
		#define DM_ORIENTATION  1
		#define DM_PAPERSIZE    2
		#define DM_PAPERLENGTH  4
		#define DM_PAPERWIDTH   8
		#define DM_COPIES 0x00000100
		#define DM_DUPLEX 0x00001000
		#define DM_YRESOLUTION 0x00002000
		
		#DEFINE DM_OFFSET_DMFIELDS 41  && DEVMODE dmFields offset
		#define DM_OFFSET_ORIENTATION 45  && DEVMODE dmOrientation offset
		#define DM_OFFSET_PAPERSIZE 47  && DEVMODE dmPaperSize offset
		#define DM_OFFSET_PAPERLENGTH 49  && DEVMODE dmPaperLength offset
		#define DM_OFFSET_PAPERWIDTH 51  && DEVMODE dmPaperWidth offset
		#define DM_OFFSET_COPIES 55  && DEVMODE dmCopies offset
		#define DM_OFFSET_DUPLEX 63 && DEVMODE dmDuplex offset
		#define DM_OFFSET_YRESOLUTION 65 && DEVMODE dmYResolution offset
		#define DMDUP_SIMPLEX    1
		#define DMDUP_VERTICAL   2
		#define DMDUP_HORIZONTAL 3
		#define DMORIENT_PORTRAIT 1
		#define DMORIENT_LANDSCAPE 2
		
		#define DMPAPER_A4 9
		
		#define FORM_BUILTIN 0x00000001
		#define FORM_PRINTER 0x00000002
		*********************************************************************
		* Get printer document properties and printer forms
		*********************************************************************
		
		LOCAL lcPrnDevMode
		m.lcPrnDevMode = This.PrintEnv.GetPrinterDevMode(This.PrintEnv.Printer)
		
		IF EMPTY(m.lcPrnDevMode)
		    This.ErrMsg(TEXTMERGE("PrintEnv.GetPrinterDevMode returned empty value for <<This.PrintEnv.Printer>>"))
		    RETURN
		ENDIF
		
		LOCAL lnPrnFormCnt
		LOCAL laPrnForm(1,9)
		m.lnPrnFormCnt = This.PrintEnv.GetPrinterForms(@m.laPrnForm, This.PrintEnv.Printer)
		IF EMPTY(m.lnPrnFormCnt)
		    This.ErrMsg(TEXTMERGE("PrintEnv.GetPrinterForms returned empty value for <<This.PrintEnv.Printer>>"))
		    RETURN
		ENDIF
		
		LOCAL lnPrnDevModeFlags
		m.lnPrnDevModeFlags = CTOBIN(SUBSTR(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4),"4RS")
		
		
		*********************************************************************
		* Setup page ranges according to PrintEnv.PageMode 
		*********************************************************************
		LOCAL lnPageMode, lcPageList
		m.lnPageMode = 1
		m.lcPageList = ""
		
		m.lnPageMode = This.printEnv.PageMode
		m.lcPageList = This.printEnv.PageList_Parse(This.printEnv.PageList)
		
		
		LOCAL ARRAY laPageRanges(1,2)
		LOCAL lnPageRangeCnt
		m.lnPageRangeCnt = 0
		DO CASE
		CASE m.lnPageMode = 1 && All pages
		    m.lnPageRangeCnt = 1
		    DIMENSION m.laPageRanges(1,2)
		    m.laPageRanges[1,1] = 1
		    m.laPageRanges[1,2] = This.fpdf_pagecount
		
		CASE m.lnPageMode = 2 && Odd pages
		    m.lnPageRangeCnt = INT(This.fpdf_pagecount / 2) + MOD(This.fpdf_pagecount, 2)
		    LOCAL lnRange
		    FOR m.lnRange = 1 TO m.lnPageRangeCnt
		        DIMENSION m.laPageRanges(m.lnRange,2)
		        m.laPageRanges[m.lnRange,1] = m.lnRange*2 - 1
		        m.laPageRanges[m.lnRange,2] = m.lnRange*2 - 1
		    ENDFOR
		
		CASE m.lnPageMode = 3 && Even pages
		    m.lnPageRangeCnt = INT(This.fpdf_pagecount / 2)
		    LOCAL lnRange
		    FOR m.lnRange = 1 TO m.lnPageRangeCnt
		        DIMENSION m.laPageRanges(m.lnRange,2)
		        m.laPageRanges[m.lnRange,1] = m.lnRange*2
		        m.laPageRanges[m.lnRange,2] = m.lnRange*2
		    ENDFOR
		
		CASE m.lnPageMode = 4
		    LOCAL ARRAY laPageList(1)
		    m.lnPageRangeCnt = ALINES(laPageList, m.lcPageList,1+4,",")
		    LOCAL lnRange
		    FOR m.lnRange = 1 TO m.lnPageRangeCnt
		        DIMENSION m.laPageRanges(m.lnRange,2)
		        m.laPageRanges[m.lnRange,1] = INT(VAL(STREXTRACT(m.laPageList[m.lnRange], "", "-",1,2)))
		        m.laPageRanges[m.lnRange,2] = EVL(INT(VAL(STREXTRACT(m.laPageList[m.lnRange], "-", "",1,2))), m.laPageRanges[m.lnRange,1])
		    ENDFOR
		ENDCASE
		*********************************************************************
		
		
		*********************************************************************
		LOCAL lnPrinterDPI
		m.lnPrinterDPI =  EVL(IIF(BITAND(m.lnPrnDevModeFlags, DM_YRESOLUTION)<>0, CTOBIN(SUBSTR(m.lcPrnDevMode,DM_OFFSET_YRESOLUTION,2),"2RS"), 0), 600)
		
		LOCAL llPrinterHasDuplex, lnPrinterDuplex
		m.llPrinterHasDuplex = This.PrintEnv.GetPrinterDuplex(This.PrintEnv.Printer)
		
		* Get default duplex setting of the printer
		m.lnPrinterDuplex = EVL(IIF(BITAND(m.lnPrnDevModeFlags, DM_DUPLEX)<>0, CTOBIN(SUBSTR(m.lcPrnDevMode,DM_OFFSET_DUPLEX,2),"2RS"), 0), DMDUP_SIMPLEX)
		
		DO CASE
		CASE m.llPrinterHasDuplex = .F. OR This.PrintEnv.Duplex  = .F.
		    m.lnPrinterDuplex = DMDUP_SIMPLEX
		OTHERWISE
		    m.lnPrinterDuplex = DMDUP_VERTICAL
		ENDCASE
		
		
		
		LOCAL loErr
		m.loErr = .F.
		
		TRY
		
		    LOCAL lcDocName
		    m.lcDocName = This.Class
		
		    LOCAL lhDocNameHeap, lhDocNameHeapPtr
		    m.lhDocNameHeap = This.env.API_WIN.HeapCreate(0, LEN(m.lcDocName)+1, 0)
		    m.lhDocNameHeapPtr = 0
		    IF EMPTY(m.lhDocNameHeap) = .F.
		        m.lhDocNameHeapPtr = This.env.API_WIN.HeapAlloc(m.lhDocNameHeap, 0, LEN(m.lcDocName)+1)
		        IF EMPTY(m.lhDocNameHeapPtr) = .F.
		            SYS(2600, m.lhDocNameHeapPtr, LEN(m.lcDocName)+1, m.lcDocName+CHR(0))
		        ENDIF
		    ENDIF
		    
		    LOCAL lhPrinterDC
		    m.lhPrinterDC = 0
		
		    LOCAL lcDocInfo
		    m.lcDocInfo = BINTOC(20, "4RS") + BINTOC(m.lhDocNameHeapPtr, "4RS") + BINTOC(0, "4RS") + BINTOC(0, "4RS") + BINTOC(0, "4RS")
		    
		
		    LOCAL llStartDoc
		    m.llStartDoc = .T.
		    
		    LOCAL lnDocPageNum
		    m.lnDocPageNum = 0
		    
		    LOCAL lnOrientation
		    m.lnOrientation = 0
		    
		    LOCAL lnPaperSize, lnPaperSizePrev
		    m.lnPaperSize = 0
		    m.lnPaperSizePrev = 0
		
		    LOCAL lnPageRange
		    m.lnPageRange = 1
		    FOR m.lnPageRange = 1 TO m.lnPageRangeCnt
		        
		        LOCAL lnPageFrom, lnPageTo
		        m.lnPageFrom = MAX(m.laPageRanges[m.lnPageRange,1], 1)
		        m.lnPageTo = MIN(m.laPageRanges[m.lnPageRange,2], This.fpdf_pagecount)
		        
		        LOCAL lnPageIndex
		        m.lnPageIndex = m.lnPageFrom
		
		        
		        FOR m.lnPageIndex = m.lnPageFrom TO m.lnPageTo
		
		            LOCAL lnPageWidth, lnPageHeight
		            m.lnPageWidth = This.GetPageSize(m.lnPageIndex,1)  / This.env.GetPDFDPI()
		            m.lnPageHeight = This.GetPageSize(m.lnPageIndex,2) / This.env.GetPDFDPI()
		
		
		            * Find paper size 
		            m.lnPaperSize = This.PrintEnv.PaperSize
		            
		            IF BETWEEN(m.lnPaperSize, 1, m.lnPrnFormCnt)
		               m.lnPaperSize = IIF(m.laPrnForm[m.lnPaperSize,9], m.lnPaperSize, -1) && check form is supported by printer
		            ELSE
		                m.lnPaperSize = -1 
		            ENDIF
		            
		            IF m.lnPaperSize = -1 && Find fittest paper form
		                LOCAL liPrnForm, lnFitFormWidth, lnFitFormHeight
		                m.liPrnForm = 1
		                STORE 0 TO m.lnFitFormWidth, m.lnFitFormHeight 
		                FOR m.liPrnForm = 1 TO m.lnPrnFormCnt
		                    DO CASE
		                    CASE BITAND(m.laPrnForm[m.liPrnForm,1], FORM_BUILTIN) = 0
		                    CASE m.laPrnForm[m.liPrnForm,9] = .F.
		                    CASE ROUND(m.laPrnForm[m.liPrnForm,3]/1000,0) < ROUND(IIF(m.lnPageWidth < m.lnPageHeight, m.lnPageWidth, m.lnPageHeight) * 25.4, 0)
		                    CASE ROUND(m.laPrnForm[m.liPrnForm,4]/1000,0) < ROUND(IIF(m.lnPageWidth < m.lnPageHeight, m.lnPageHeight, m.lnPageWidth) * 25.4, 0)
		                    CASE m.lnFitFormWidth > 0 AND m.lnFitFormWidth < m.laPrnForm[m.liPrnForm,3]
		                    CASE m.lnFitFormHeight > 0 AND m.lnFitFormHeight < m.laPrnForm[m.liPrnForm,4]
		                    OTHERWISE
		                        m.lnPaperSize = m.liPrnForm
		                        m.lnFitFormWidth = m.laPrnForm[m.liPrnForm,3]
		                        m.lnFitFormHeight = m.laPrnForm[m.liPrnForm,4]
		                    ENDCASE
		                ENDFOR
		                m.lnPaperSize = EVL(MAX(m.lnPaperSize,0), EVL(MAX(PRTINFO(2, This.PrintEnv.Printer), 0), DMPAPER_A4 ))
		            ENDIF
		            
		            *********************************************************
		            IF BETWEEN(m.lnPaperSize, 1, m.lnPrnFormCnt) = .F.
		                ERROR TEXTMERGE("Not Found Paper Form For Page number <<lnPageIndex>>, page size <<ROUND(lnPageWidth * 25.4,0)>> mm, <<ROUND(lnPageHeight * 25.4,0)>> mm ")
		            ENDIF
		            *********************************************************
		
		            IF m.lnPaperSizePrev <> m.lnPaperSize
		                m.lnPaperSizePrev = m.lnPaperSize
		                m.llStartDoc = .T.
		            ENDIF
		
		            IF m.llStartDoc
		
		                IF EMPTY(m.lhPrinterDC) = .F.
		                    This.env.API_WIN.EndDoc(m.lhPrinterDC)
		                    This.env.API_WIN.DeleteDC(m.lhPrinterDC)
		                ENDIF
		
		                m.lnDocPageNum = 0
		                
		                m.lnOrientation = IIF(m.lnPageWidth > m.lnPageHeight, DMORIENT_LANDSCAPE, DMORIENT_PORTRAIT)
		                
		                * Set paper size
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(m.lnPrnDevModeFlags, DM_PAPERSIZE), "4RS"))
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_PAPERSIZE, 2, BINTOC(m.lnPaperSize, "2RS"))
		
		                * Set duplex
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(m.lnPrnDevModeFlags, DM_DUPLEX), "4RS"))
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DUPLEX, 2, BINTOC(m.lnPrinterDuplex, "2RS"))
		                
		                * Set page orientation
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(m.lnPrnDevModeFlags, DM_ORIENTATION), "4RS"))
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_ORIENTATION, 2, BINTOC(m.lnOrientation, "2RS"))
		
		                * Set copies
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_DMFIELDS, 4, BINTOC(BITOR(m.lnPrnDevModeFlags, DM_COPIES), "4RS"))
		                m.lcPrnDevMode = STUFF(m.lcPrnDevMode, DM_OFFSET_COPIES, 2, BINTOC(EVL(This.PrintEnv.copies,1), "2RS"))
		                
		                m.lhPrinterDC = This.env.API_WIN.CreateDC(NULL, This.printenv.Printer + CHR(0), NULL, @m.lcPrnDevMode)
		
		                IF EMPTY(m.lhPrinterDC)
		                    ERROR TEXTMERGE("WinApi CreateDC error on page <<lnPageIndex>>, printer <<This.PrintEnv.Printer>>")
		                ENDIF
		            
		                This.env.API_WIN.StartDoc(m.lhPrinterDC, m.lcDocInfo)
		                
		                m.llStartDoc = .F.
		            ENDIF
		
		            m.lnDocPageNum = m.lnDocPageNum + 1
		
		
		            ***********************************
		            * Render page 
		            ***********************************
		            This.env.API_WIN.StartPage(m.lhPrinterDC)
		            
		            LOCAL lnPrintX, lnPrintY, lnPrintWidth, lnPrintHeight
		            m.lnPrintX = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETY), This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETX))
		            m.lnPrintY = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETX), This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETY))
		
		            m.lnPrintWidth = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, m.laPrnForm[m.lnPaperSize,4], m.laPrnForm[m.lnPaperSize,3])
		            m.lnPrintHeight = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, m.laPrnForm[m.lnPaperSize,3], m.laPrnForm[m.lnPaperSize,4])
		            m.lnPrintWidth = (m.lnPrintWidth / (25.4 * 1000)) * m.lnPrinterDPI
		            m.lnPrintHeight = (m.lnPrintHeight / (25.4 * 1000)) * m.lnPrinterDPI
		
		            #if .F. && pdfium style scaling "fill printable area" (not implemented). Only print without scaling is implemented
		            m.lnPrintWidth = m.lnPrintWidth - m.lnPrintX * 2
		            m.lnPrintHeight = m.lnPrintHeight - m.lnPrintY * 2
		            #endif
		            
		            m.lnPrintX = 0
		            m.lnPrintY = 0
		            
		            LOCAL lnPrintRotate
		            m.lnPrintRotate = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, IIF(m.lnPageWidth > m.lnPageHeight, 0, 1), IIF(m.lnPageWidth > m.lnPageHeight, 1, 0))
		            IF m.lnPrinterDuplex = DMDUP_VERTICAL AND MOD(m.lnDocPageNum,2) = 0
		                m.lnPrintRotate = IIF(m.lnOrientation = DMORIENT_LANDSCAPE, IIF(m.lnPageWidth > m.lnPageHeight, 2, 1), IIF(m.lnPageWidth > m.lnPageHeight, 3, 0)) 
		            ENDIF
		            
		            LOCAL lnFPDF_Page 
		            m.lnFPDF_Page = This.fpdf_pages[m.lnPageIndex]
		            
		            IF EMPTY(m.lnFPDF_Page) = .F.
		                
		                m.loFPDF.FPDF_RenderPage(m.lhPrinterDC, ;
		                    m.lnFPDF_Page, ;
		                    m.lnPrintX, ;
		                    m.lnPrintY, ;
		                    m.lnPrintWidth, ;
		                    m.lnPrintHeight, ;
		                    m.lnPrintRotate, ;
		                    m.loFPDF.CONST.FPDF_PRINTING())
		
		            ENDIF
		            
		            This.env.API_WIN.EndPage(m.lhPrinterDC)
		            ***********************************
		            * / Render page 
		            ***********************************
		
		
		        ENDFOR
		
		    ENDFOR
		    
		
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		
		FINALLY
		    IF EMPTY(m.lhPrinterDC) = .F.
		        IF m.llStartDoc = .F.
		            This.env.API_WIN.EndDoc(m.lhPrinterDC)
		        ENDIF
		        This.env.API_WIN.DeleteDC(m.lhPrinterDC)
		    ENDIF
		    
		    IF EMPTY(m.lhDocNameHeap) = .F.
		        This.env.API_WIN.HeapDestroy(m.lhDocNameHeap)
		    ENDIF
		    
		ENDTRY
		
		
		
	ENDPROC

	PROCEDURE printenv_access
		
		IF VARTYPE(This._PrintEnv) <> "O"
		    This._PrintEnv = NEWOBJECT("pdfium_print_env", This.ClassLibrary)
		ENDIF
		
		RETURN This._PrintEnv
		
	ENDPROC

	PROCEDURE printenv_assign
		LPARAMETERS vNewVal
		
		ERROR 1740, TEXTMERGE("<<This.Class>>.PrintEnv")
		
	ENDPROC

	HIDDEN PROCEDURE redraw
		LPARAMETERS tnWndDC
		
		LOCAL lnWndDC
		m.lnWndDC = EVL(m.tnWndDC, This.WndDC)
		
		IF EMPTY(m.lnWndDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDIB)
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufGfx)
		    RETURN
		ENDIF
		
		IF This.UIState.GetEffectivelyVisible() = .F.
		    RETURN
		ENDIF
		
		LOCAL lnWidth, lnHeight
		m.lnWidth = This.Width
		m.lnHeight = This.Height
		
		******************************************************************************
		This.env.API_GDIP.GdipFillRectangleI(This.DrawBufGfx, This.BackColorBrush, 0, 0, m.lnWidth, m.lnHeight)
		
		This.renderpages()
		
		This.env.API_GDIP.GdipFlush(This.DrawBufGfx)
		
		******************************************************************************
		#define FF_SRCCOPY 0x00CC0020
		
		This.env.API_WIN.BitBlt(m.lnWndDC, 0,0, m.lnWidth, m.lnHeight, This.DrawBufDC, 0, 0, FF_SRCCOPY)
		
	ENDPROC

	HIDDEN PROCEDURE renderpages
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		IF EMPTY(This.DrawBufDC)
		    RETURN
		ENDIF
		
		IF EMPTY(This.fpdf_page_first_visible)
		    RETURN
		ENDIF
		
		LOCAL loFPDF, loFPDF_FORMS
		m.loFPDF = This.env.API_FPDF
		m.loFPDF_FORMS = This.env.API_FPDF_FORMS
		
		#define FF_DIB_RGB_COLORS   0
		#define FF_SRCCOPY 0x00CC0020
		
		IF EMPTY(This.fpdf_form) = .F.
		    IF EMPTY(This.DrawBufBitmap)
		        RETURN
		    ENDIF
		    m.loFPDF.FPDFBitmap_FillRect(This.DrawBufBitmap, 0, 0, This.Width, This.Height, 0xFFFFFFFF)
		    LOCAL lnDibDataPtr
		    m.lnDibDataPtr = This.env.API_FPDF.FPDFBitmap_GetBuffer(This.DrawBufBitmap)
		ENDIF
		
		LOCAL lnFPDF_Page, lnPageX, lnPageY, lnPageWidth, lnPageHeight
		
		LOCAL lnPage
		FOR m.lnPage = This.fpdf_page_first_visible TO This.fpdf_page_last_visible
		    
		    m.lnFPDF_Page = This.fpdf_pages[m.lnPage]
		    m.lnPageX = This.fpdf_pages_pos[m.lnPage,1] - This.ViewPortX
		    m.lnPageY = This.fpdf_pages_pos[m.lnPage,2] - This.ViewPortY
		    m.lnPageWidth = This.fpdf_pages_pos[m.lnPage,3]
		    m.lnPageHeight = This.fpdf_pages_pos[m.lnPage,4]
		
		    This.env.API_GDIP.GdipFillRectangleI(This.DrawBufGfx, This.PageFillBrush, m.lnPageX, m.lnPageY, m.lnPageWidth, m.lnPageHeight)
		    
		    IF EMPTY(This.fpdf_form) = .T.
		        m.loFPDF.FPDF_RenderPage(This.DrawBufDC, m.lnFPDF_Page, m.lnPageX, m.lnPageY, m.lnPageWidth, m.lnPageHeight, 0, 0)
		    ELSE
		        m.loFPDF.FPDF_RenderPageBitmap(This.DrawBufBitmap, m.lnFPDF_Page, m.lnPageX, m.lnPageY, m.lnPageWidth, m.lnPageHeight, 0, 0)
		        m.loFPDF_FORMS.FPDF_FFLDraw(This.fpdf_form, This.DrawBufBitmap, m.lnFPDF_Page, m.lnPageX, m.lnPageY, m.lnPageWidth, m.lnPageHeight, 0, 0)
		        This.env.API_WIN.StretchDIBits(This.DrawBufDC, m.lnPageX, m.lnPageY, m.lnPageWidth, m.lnPageHeight, m.lnPageX, This.Height - m.lnPageY - m.lnPageHeight, m.lnPageWidth, m.lnPageHeight, m.lnDibDataPtr, This.DrawBufBitmapBMI, FF_DIB_RGB_COLORS, FF_SRCCOPY)
		    ENDIF
		    
		    This.RenderSearch(m.lnPage)
		    This.RenderSelection(m.lnPage)
		ENDFOR
		
	ENDPROC

	HIDDEN PROCEDURE rendersearch
		LPARAMETERS lnPage
		
		IF m.lnPage <> This.SearchState_ResPage
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		
		LOCAL lnRectCount
		m.lnRectCount = LEN(This.SearchState_ResRect)/32
		
		LOCAL lnRect, lcRect
		FOR m.lnRect = 1 TO m.lnRectCount
		    
		    m.lcRect = SUBSTR(This.SearchState_ResRect, 32*(m.lnRect-1) + 1, 32)
		    
		    LOCAL lnPageLeft,lnPageTop,lnPageRight,lnPageBottom
		    m.lnPageLeft = CTOBIN(SUBSTR(m.lcRect,1,8),"B")
		    m.lnPageTop = CTOBIN(SUBSTR(m.lcRect,9,8),"B")
		    m.lnPageRight = CTOBIN(SUBSTR(m.lcRect,17,8),"B")
		    m.lnPageBottom = CTOBIN(SUBSTR(m.lcRect,25,8),"B")
		    
		       
		    LOCAL lnLeft, lnTop, lnRight, lnBottom
		    STORE 0 TO m.lnLeft, m.lnTop, m.lnRight, m.lnBottom
		    
		    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPage], This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnPageLeft, m.lnPageTop, @m.lnLeft, @m.lnTop) = 0
		        LOOP
		    ENDIF
		    
		    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPage], This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnPageRight, m.lnPageBottom, @m.lnRight, @m.lnBottom) = 0
		        LOOP
		    ENDIF
		    
		    This.env.API_GDIP.GdipFillRectangleI(This.DrawBufGfx, This.SearchBrush, m.lnLeft, m.lnTop, m.lnRight - m.lnLeft, m.lnBottom - m.lnTop)
		    
		ENDFOR
		
		
	ENDPROC

	HIDDEN PROCEDURE renderselection
		LPARAMETERS lnPage
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL lnRectCount
		m.lnRectCount = LEN(This.fpdf_pages_selection[m.lnPage,1])/32
		
		LOCAL lnRect, lcRect
		FOR m.lnRect = 1 TO m.lnRectCount
		    
		    m.lcRect = SUBSTR(This.fpdf_pages_selection[m.lnPage,1], 32*(m.lnRect-1) + 1, 32)
		    
		    LOCAL lnPageLeft,lnPageTop,lnPageRight,lnPageBottom
		    m.lnPageLeft = CTOBIN(SUBSTR(m.lcRect,1,8),"B")
		    m.lnPageTop = CTOBIN(SUBSTR(m.lcRect,9,8),"B")
		    m.lnPageRight = CTOBIN(SUBSTR(m.lcRect,17,8),"B")
		    m.lnPageBottom = CTOBIN(SUBSTR(m.lcRect,25,8),"B")
		    
		    
		    LOCAL lnLeft, lnTop, lnRight, lnBottom
		    STORE 0 TO m.lnLeft, m.lnTop, m.lnRight, m.lnBottom
		    
		    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPage], This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnPageLeft, m.lnPageTop, @m.lnLeft, @m.lnTop) = 0
		        LOOP
		    ENDIF
		    
		    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPage], This.fpdf_pages_pos[m.lnPage,1]-This.ViewPortX, This.fpdf_pages_pos[m.lnPage,2]-This.ViewPortY, This.fpdf_pages_pos[m.lnPage,3], This.fpdf_pages_pos[m.lnPage,4], 0, m.lnPageRight, m.lnPageBottom, @m.lnRight, @m.lnBottom) = 0
		        LOOP
		    ENDIF
		
		    This.env.API_GDIP.GdipFillRectangleI(This.DrawBufGfx, This.SelectionBrush, m.lnLeft, m.lnTop, m.lnRight - m.lnLeft, m.lnBottom - m.lnTop)
		ENDFOR
		
	ENDPROC

	PROCEDURE savedocument		&& Save document to file
		LPARAMETERS tcFileName
		
		IF EMPTY(This.fpdf_doc)
		    RETURN .F.
		ENDIF
		
		IF VARTYPE(m.tcFileName) <> "C"
		    RETURN .F.
		ENDIF
		
		
		LOCAL lcFileName
		m.lcFileName = ALLTRIM(EVL(NVL(m.tcFileName,""), ""))
		
		IF EMPTY(m.lcFileName)
		    RETURN .F.
		ENDIF
		
		LOCAL lcErrMsg
		m.lcErrMsg = SPACE(500)
		This.env.API_FPDF.VFPDF_SaveDocument(This.fpdf_doc, m.lcFilename, @m.lcErrMsg, LEN(m.lcErrMsg))
		
		IF EMPTY(m.lcErrMsg)=.F.
		    This.ErrMsg(ALLTRIM(m.lcErrMsg))
		    RETURN .F.
		ENDIF
		
		
	ENDPROC

	HIDDEN PROCEDURE scale_assign
		LPARAMETERS vNewVal
		
		
		This.Scale = MIN(MAX(EVL(NVL(m.vNewVal,0),0),0.2),4)
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE scrollbars_assign
		LPARAMETERS vNewVal
		
		This.ScrollBars = IIF(INLIST(m.vNewVal, 0,1,2,3), m.vNewVal, This.ScrollBars)
		
		IF This.fpdf_opened = .T.
		    This.ViewPortUpdate()
		    This.WndRedraw()
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE scrollhorz
		LPARAMETERS tnScroll, tlPage, tlRelative
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL lnScroll
		m.lnScroll = EVL(NVL(m.tnScroll,0),0)
		
		DO CASE
		CASE m.tlPage=.F. AND m.tlRelative = .T.
		    This.ViewPortX = This.ViewPortX + m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .T.
		    This.ViewPortX = This.ViewPortX + m.lnScroll * This.ViewPortSizeX
		    
		CASE m.tlPage=.F. AND m.tlRelative = .F.
		    This.ViewPortX = m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .F.
		    This.ViewPortX = (m.lnScroll - 1) * This.ViewPortSizeX
		
		ENDCASE
		
		This.ViewPortUpdate()
		
		This.WndRedraw()
		
	ENDPROC

	HIDDEN PROCEDURE scrollvert
		LPARAMETERS tnScroll, tlPage, tlRelative
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL lnScroll
		m.lnScroll = EVL(NVL(m.tnScroll,0),0)
		
		DO CASE
		CASE m.tlPage=.F. AND m.tlRelative = .T.
		    This.ViewPortY = This.ViewPortY + m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .T.
		    This.ViewPortY = This.ViewPortY + m.lnScroll * This.ViewPortSizeY
		    
		CASE  m.tlPage=.F. AND m.tlRelative = .F.
		    This.ViewPortY = m.lnScroll
		
		CASE m.tlPage=.T. AND m.tlRelative = .F.
		    This.ViewPortY = (m.lnScroll - 1) * This.ViewPortSizeY
		
		ENDCASE
		
		This.ViewPortUpdate()
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE searchclose		&& Stop search
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.SearchState_FindWhat = ""
		This.SearchState_Dir = 0
		
		This.SearchState_ResPage = 0
		This.SearchState_ResIndex = 0
		This.SearchState_ResCount = 0
		This.SearchState_ResRect = ""
		
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE searchtext		&& Text for searching. SearchClose must be called to stop search results rendering
		LPARAMETERS tcFindWhat, tnDirection, tlMatchCase, tlMatchWholeWord
		
		* tcFindWhat - text to find
		* tnDirection - search direction: 1 - forward (default), 2 - backward
		* tlMatchCase - .T. - case sensitive, .F. - case insensitive (default)
		* tlMatchWholeWord - .T. match whole word, .F. - not match whole word (default)
		
		* return value: -1 - error, 0 - not found, 1 - found, 2 - search ended
		
		#define SCH_ERROR -1
		#define SCH_NOT_FOUND 0
		#define SCH_FOUND 1
		#define SCH_ENDED 2
		
		#define SCH_FWD 1
		#define SCH_BCK 2
		
		#define SCH_WHITESPACE CHR(0x00)+CHR(0x09) + CHR(0x00)+CHR(0x0A) + CHR(0x00)+CHR(0x0B) + CHR(0x00)+CHR(0x0C) + CHR(0x00)+CHR(0x0D) + CHR(0x00)+CHR(0x20) + CHR(0x00)+CHR(0x85) + CHR(0x00)+CHR(0xA0) + CHR(0x16)+CHR(0x80) + CHR(0x20)+CHR(0x00) + CHR(0x20)+CHR(0x01) + CHR(0x20)+CHR(0x02) + CHR(0x20)+CHR(0x03) + CHR(0x20)+CHR(0x04) + CHR(0x20)+CHR(0x05) + CHR(0x20)+CHR(0x06) + CHR(0x20)+CHR(0x07) + CHR(0x20)+CHR(0x08) + CHR(0x20)+CHR(0x09) + CHR(0x20)+CHR(0x0A) + CHR(0x20)+CHR(0x28) + CHR(0x20)+CHR(0x29) + CHR(0x20)+CHR(0x2F) + CHR(0x20)+CHR(0x5F) + CHR(0x30)+CHR(0x00)
		#define SCH_PUNCTIATION CHR(0x00)+CHR(0x21) + CHR(0x00)+CHR(0x22) + CHR(0x00)+CHR(0x23) + CHR(0x00)+CHR(0x25) + CHR(0x00)+CHR(0x26) + CHR(0x00)+CHR(0x27) + CHR(0x00)+CHR(0x2A) + CHR(0x00)+CHR(0x2C) + CHR(0x00)+CHR(0x2D) + CHR(0x00)+CHR(0x2E) + CHR(0x00)+CHR(0x2F) + CHR(0x00)+CHR(0x3A) + CHR(0x00)+CHR(0x3B) + CHR(0x00)+CHR(0x3D) + CHR(0x00)+CHR(0x3F) + CHR(0x20)+CHR(0x10) + CHR(0x20)+CHR(0x11) + CHR(0x20)+CHR(0x12) + CHR(0x20)+CHR(0x13) + CHR(0x20)+CHR(0x14) + CHR(0x20)+CHR(0x15) + CHR(0x00)+CHR(0xAB) + CHR(0x00)+CHR(0xBB) + CHR(0x20)+CHR(0x18) + CHR(0x20)+CHR(0x19) + CHR(0x20)+CHR(0x1B) + CHR(0x20)+CHR(0x1C) + CHR(0x20)+CHR(0x1D) + CHR(0x00)+CHR(0x28) + CHR(0x00)+CHR(0x29) + CHR(0x00)+CHR(0x5B) + CHR(0x00)+CHR(0x5C) + CHR(0x00)+CHR(0x5D) + CHR(0x00)+CHR(0x7B) + CHR(0x00)+CHR(0x7D) + CHR(0x20)+CHR(0x1A) + CHR(0x20)+CHR(0x1E)
		
		IF This.fpdf_opened = .F.
		    RETURN SCH_ERROR
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL lcFindWhat, lnDirection, llMatchCase, llMatchWholeWord
		
		m.lcFindWhat = CHRTRAN(ALLTRIM(EVL(NVL(m.tcFindWhat,""),"")), CHR(10)+CHR(13)+CHR(9),"")
		m.lnDirection = EVL(NVL(m.tnDirection,0), SCH_FWD)
		m.llMatchCase = EMPTY(NVL(m.tlMatchCase,.F.))=.F.
		m.llMatchWholeWord = EMPTY(NVL(m.tlMatchWholeWord,.F.))=.F.
		
		#define LOCALE_USER_DEFAULT       0x0400
		
		#define FIND_FROMSTART            0x00400000  && look for value in source, starting at the beginning
		#define FIND_FROMEND              0x00800000  && look for value in source, starting at the end
		
		#define NORM_IGNORECASE           0x00000001  && ignore case
		#define NORM_IGNORENONSPACE       0x00000002  && ignore nonspacing chars
		#define NORM_IGNORESYMBOLS        0x00000004  && ignore symbols
		
		
		LOCAL lnSearchFlags
		m.lnSearchFlags = 0
		m.lnSearchFlags = m.lnSearchFlags + IIF(m.lnDirection = SCH_BCK, FIND_FROMEND, FIND_FROMSTART)
		m.lnSearchFlags = m.lnSearchFlags + IIF(m.llMatchCase=.T., 0, NORM_IGNORECASE)
		
		LOCAL llNewSearch
		m.llNewSearch = .F.
		DO CASE
		CASE m.lnDirection <> This.SearchState_Dir
		    m.llNewSearch = .T.
		CASE NOT m.lcFindWhat == This.SearchState_FindWhat
		    m.llNewSearch = .T.
		ENDCASE
		
		
		LOCAL lnSearchStartPage, lnSearchStartIndex
		m.lnSearchStartPage = EVL(This.SearchState_ResPage, EVL(This.fpdf_page_first_visible,1))
		m.lnSearchStartIndex = This.SearchState_ResIndex + IIF(m.lnDirection = SCH_BCK, 0, This.SearchState_ResCount)
		
		IF m.llNewSearch = .T.    
		    IF NOT (m.lcFindWhat == This.SearchState_FindWhat)
		        m.lnSearchStartPage = EVL(This.fpdf_page_first_visible,1)
		        m.lnSearchStartIndex = IIF(m.lnDirection = SCH_BCK, -1, 0)
		    ENDIF
		    
		    This.SearchClose()
		ENDIF
		
		This.SearchState_FindWhat = m.lcFindWhat
		This.SearchState_Dir = m.lnDirection
		
		
		IF EMPTY(m.lcFindWhat)
		    RETURN SCH_NOT_FOUND
		ENDIF
		
		
		
		LOCAL lnLocaleId
		m.lnLocaleId = This.i18n.GetLocaleID()
		
		LOCAL lcFindWhatUnicode
		m.lcFindWhatUnicode = ""
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    m.lcFindWhatUnicode = STRCONV(m.lcFindWhat, 5, m.lnLocaleId)
		
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		ENDTRY
		
		IF LEN(m.lcFindWhatUnicode) = 0
		    RETURN SCH_ERROR
		ENDIF
		
		
		LOCAL lnPageIndex
		m.lnPageIndex = m.lnSearchStartPage
		
		DO WHILE m.lnPageIndex > 0 AND m.lnPageIndex <= This.fpdf_pagecount
		
		    LOCAL lnFPDF_Text_Page
		    m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPageIndex]
		
		    LOCAL lnFindResIndex, lnFindResCount
		    m.lnFindResIndex = -1
		    m.lnFindResCount = 0
		
		    LOCAL lnPageTextLen, lcPageText
		    m.lnPageTextLen = MAX(m.loFPDF.FPDFText_CountChars(m.lnFPDF_Text_Page), 0)
		    
		    DO CASE
		    CASE EMPTY(m.lnPageTextLen)
		    
		    CASE m.lnDirection = SCH_FWD
		        m.lnPageTextLen = MAX(m.lnPageTextLen - m.lnSearchStartIndex, 0)
		        m.lcPageText = REPLICATE(CHR(0), m.lnPageTextLen * 2)
		        m.lnPageTextLen = m.loFPDF.FPDFText_GetText(m.lnFPDF_TEXT_PAGE, m.lnSearchStartIndex, m.lnPageTextLen, @m.lcPageText)
		
		        IF m.lnPageTextLen > 0
		            m.lnFindResIndex = This.env.API_WIN.FindNLSString(LOCALE_USER_DEFAULT, m.lnSearchFlags, m.lcPageText + CHR(0), -1, m.lcFindWhatUnicode + CHR(0), -1, @m.lnFindResCount)
		            
		            IF m.lnFindResIndex >= 0
		                m.lnFindResIndex = m.lnSearchStartIndex + m.lnFindResIndex
		            ENDIF
		        ENDIF
		    
		    CASE m.lnDirection = SCH_BCK
		        m.lnPageTextLen = MAX(IIF(m.lnSearchStartIndex < 0,  m.lnPageTextLen, m.lnSearchStartIndex), 0)
		        m.lcPageText = REPLICATE(CHR(0), m.lnPageTextLen * 2)
		        m.lnPageTextLen = m.loFPDF.FPDFText_GetText(m.lnFPDF_TEXT_PAGE, 0, m.lnPageTextLen, @m.lcPageText)
		        
		        IF m.lnPageTextLen > 0
		            m.lnFindResIndex = This.env.API_WIN.FindNLSString(LOCALE_USER_DEFAULT, m.lnSearchFlags, m.lcPageText + CHR(0), -1, m.lcFindWhatUnicode + CHR(0), -1, @m.lnFindResCount)
		        ENDIF
		    
		    ENDCASE
		
		
		    IF m.llMatchWholeWord = .T. AND m.lnFindResIndex >= 0 AND m.lnFindResCount > 0
		        LOCAL lcNextChar
		        m.lcNextChar = BINTOC(m.loFPDF.FPDFText_GetUnicode(m.lnFPDF_Text_Page, m.lnFindResIndex + m.lnFindResCount), "2RS")
		
		        DO CASE
		        CASE m.lcNextChar == CHR(0)+CHR(0)
		        CASE AT(m.lcNextChar, SCH_WHITESPACE) <> 0 
		        CASE AT(m.lcNextChar, SCH_PUNCTIATION) <> 0
		        OTHERWISE
		            m.lnSearchStartIndex = IIF(m.lnDirection = SCH_BCK, m.lnFindResIndex, m.lnFindResIndex + m.lnFindResCount)
		            LOOP
		        ENDCASE
		    ENDIF
		
		
		    IF m.lnFindResIndex >= 0 AND m.lnFindResCount > 0
		        This.SearchState_ResPage = m.lnPageIndex
		        This.SearchState_ResIndex = m.lnFindResIndex
		        This.SearchState_ResCount = m.lnFindResCount
		
		        LOCAL lnRectCount
		        m.lnRectCount = m.loFPDF.FPDFText_CountRects(m.lnFPDF_Text_Page, m.lnFindResIndex, m.lnFindResCount)
		
		        This.SearchState_ResRect = ""
		        
		        LOCAL lnPageLeft as Double, lnPageRight as Double, lnPageBottom as Double, lnPageTop as Double
		        STORE 0 TO m.lnPageLeft, m.lnPageRight, m.lnPageBottom, m.lnPageTop
		
		        LOCAL lnRect
		        FOR m.lnRect=1 TO m.lnRectCount
		            IF m.loFPDF.FPDFText_GetRect(m.lnFPDF_Text_Page, m.lnRect-1, @m.lnPageLeft, @m.lnPageTop, @m.lnPageRight, @m.lnPageBottom) > 0
		                This.SearchState_ResRect = This.SearchState_ResRect + BINTOC(m.lnPageLeft,"8")+BINTOC(m.lnPageTop,"8")+BINTOC(m.lnPageRight,"8")+BINTOC(m.lnPageBottom,"8")
		                
		                IF m.lnRect = 1
		                    LOCAL lnLeft, lnTop
		                    STORE 0 TO m.lnLeft, m.lnTop
		                    
		                    IF m.loFPDF.FPDF_PageToDevice(This.FPDF_PAGES[m.lnPageIndex], 0, 0, This.fpdf_pages_pos[m.lnPageIndex,3], This.fpdf_pages_pos[m.lnPageIndex,4], 0, m.lnPageLeft, m.lnPageTop, @m.lnLeft, @m.lnTop) > 0
		                        LOCAL lnScrollVert
		                        m.lnScrollVert = This.fpdf_pages_pos[m.lnPageIndex,2] + m.lnTop
		                        m.lnScrollVert = m.lnScrollVert - This.ViewPortSizeY * 0.5
		                        This.ScrollVert(m.lnScrollVert)
		
		                        LOCAL lnScrollHorz
		                        m.lnScrollHorz = This.fpdf_pages_pos[m.lnPageIndex,1] + m.lnLeft
		                        m.lnScrollHorz = m.lnScrollHorz - This.ViewPortSizeX * 0.5
		                        This.ScrollHorz(m.lnScrollHorz)
		                    ENDIF
		                ENDIF
		            ENDIF
		        ENDFOR
		
		        This.WndRedraw()
		        
		        RETURN SCH_FOUND
		    ENDIF
		
		
		    IF m.lnDirection = SCH_BCK
		        m.lnPageIndex = m.lnPageIndex - 1
		        m.lnSearchStartIndex = -1
		    ELSE
		        m.lnPageIndex = m.lnPageIndex + 1
		        m.lnSearchStartIndex = 0
		    ENDIF
		    
		    
		    
		ENDDO
		
		IF EMPTY(This.SearchState_ResCount)=.F.
		    RETURN SCH_ENDED
		ELSE
		    RETURN SCH_NOT_FOUND
		ENDIF
		
	ENDPROC

	PROCEDURE selectioncopy		&& Copy selected text to clipboard
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		#define CF_TEXT       1
		#define CF_UNICODETEXT 13
		#DEFINE CF_LOCALE     16
		#define GMEM_MOVEABLE 0x0002
		#define GMEM_ZEROINIT 0x0040
		
		
		LOCAL lcCopyText
		m.lcCopyText = ""
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    IF EMPTY(This.fpdf_form) = .F.
		        LOCAL lnAnnotPage, lnAnnot
		        STORE 0 TO m.lnAnnotPage, m.lnAnnot
		        IF This.env.API_FPDF_FORMS.FORM_GetFocusedAnnot(This.fpdf_form, @m.lnAnnotPage, @m.lnAnnot) = 1
		            IF BETWEEN(m.lnAnnotPage + 1, This.fpdf_page_first_visible, This.fpdf_page_last_visible)
		                LOCAL lnFPDF_Page
		                m.lnFPDF_Page = This.fpdf_pages[m.lnAnnotPage + 1]
		
		                LOCAL lcBuffer, lnBufLen
		                m.lnBufLen = This.env.API_FPDF_FORMS.FORM_GetSelectedText(This.fpdf_form, m.lnFPDF_Page, "", 0)
		                IF m.lnBufLen > 0
		                    m.lcBuffer = REPLICATE(CHR(0), m.lnBufLen)
		                    
		                    IF This.env.API_FPDF_FORMS.FORM_GetSelectedText(This.fpdf_form, m.lnFPDF_Page, @m.lcBuffer, m.lnBufLen) > 0
		                        m.lcCopyText = m.lcBuffer
		                    ENDIF
		                ENDIF
		                EXIT
		            ENDIF
		        ENDIF
		    ENDIF
		
		    LOCAL lnPage, lnFPDF_TEXT_PAGE, lnSelStart, lnSelCount
		    FOR m.lnPage = 1 TO This.fpdf_pagecount
		
		        m.lnFPDF_TEXT_PAGE = This.FPDF_TEXT_PAGES[m.lnPage]
		        m.lnSelStart = EVL(This.fpdf_pages_selection[m.lnPage,2],0)
		        m.lnSelCount = EVL(This.fpdf_pages_selection[m.lnPage,3],0)
		        
		        IF m.lnSelCount = 0
		            LOOP
		        ENDIF
		        
		        LOCAL lcBuffer, lnBufLen
		        m.lcBuffer = REPLICATE(CHR(0), m.lnSelCount * 2)
		        m.lnBufLen = m.loFPDF.FPDFText_GetText(m.lnFPDF_TEXT_PAGE, m.lnSelStart, m.lnSelCount, @m.lcBuffer)
		        
		        IF m.lnBufLen > 0
		            m.lcCopyText = m.lcCopyText + m.lcBuffer
		        ENDIF
		
		    ENDFOR
		
		CATCH TO loErr
		    This.ErrMsg(m.loErr)
		ENDTRY
		
		IF EMPTY(m.lcCopyText)=.F.
		    
		    LOCAL lnCopyTextLen
		    m.lnCopyTextLen = LEN(m.lcCopyText)
		
		    LOCAL lnDefaultLocaleID
		    m.lnDefaultLocaleID = EVL(This.env.API_WIN.GetSystemDefaultLCID(), 1033) &&English LocaleID = 1033
		
		    IF This.env.API_WIN.OpenClipboard(0) = 0
		        RETURN
		    ENDIF
		    
		    This.env.API_WIN.EmptyClipboard()
		
		    LOCAL lnMemHandle
		    m.lnMemHandle = This.env.API_WIN.GlobalAlloc(GMEM_MOVEABLE + GMEM_ZEROINIT, m.lnCopyTextLen+2)
		    
		    IF m.lnMemHandle <> 0
		        LOCAL lnMemPtr
		        m.lnMemPtr = This.env.API_WIN.GlobalLock(m.lnMemHandle)
		        IF m.lnMemPtr <> 0
		            SYS(2600, m.lnMemPtr, m.lnCopyTextLen, m.lcCopyText)
		        ENDIF
		        This.env.API_WIN.GlobalUnlock(m.lnMemHandle)
		        
		        This.env.API_WIN.SetClipboardData(CF_UNICODETEXT, m.lnMemHandle)
		        
		        This.env.API_WIN.GlobalFree(m.lnMemHandle)
		    ENDIF
		
		
		    LOCAL lnMemHandle
		    m.lnMemHandle = This.env.API_WIN.GlobalAlloc(GMEM_MOVEABLE + GMEM_ZEROINIT, 4)
		    IF m.lnMemHandle <> 0
		        LOCAL lnMemPtr
		        m.lnMemPtr = This.env.API_WIN.GlobalLock(m.lnMemHandle)
		        IF m.lnMemPtr <> 0
		            SYS(2600, m.lnMemPtr, 4, BINTOC(m.lnDefaultLocaleID, "4RS"))
		        ENDIF
		        This.env.API_WIN.GlobalUnlock(m.lnMemHandle)
		        
		        This.env.API_WIN.SetClipboardData(CF_LOCALE, m.lnMemHandle)
		        
		        This.env.API_WIN.GlobalFree(m.lnMemHandle)
		    ENDIF
		
		    This.env.API_WIN.CloseClipboard()
		
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE selecttext
		LPARAMETERS tnPage, tnStartIndex, tnCount
		
		* tnPage - page index, from 1 to This.fpdf_pagecount, 0 for all pages
		* tnStartIndex - Index for the start character (zero-based)
		* tnCount - Number of characters, or -1 for all remaining.
		
		IF This.fpdf_opened = .F.
		    RETURN
		ENDIF
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		
		LOCAL lnPage, lnStartIndex, lnCount
		m.lnPage = EVL(m.tnPage,0)
		m.lnStartIndex = EVL(m.tnStartIndex,0)
		m.lnCount = EVL(m.tnCount, 0)
		
		IF m.lnStartIndex < 0
		    RETURN
		ENDIF
		IF m.lnCount < -1
		    RETURN
		ENDIF
		
		
		LOCAL lnPageStart, lnPageEnd
		m.lnPageStart = EVL(m.lnPage,1)
		m.lnPageEnd = EVL(m.lnPage,This.fpdf_pagecount)
		
		FOR m.lnPage = m.lnPageStart TO m.lnPageEnd
		    LOCAL lnFPDF_Text_Page
		    m.lnFPDF_Text_Page = This.fpdf_text_pages[m.lnPage]
		
		    LOCAL lnCountChars
		    DO CASE
		    CASE m.lnCount = 0
		        m.lnCountChars = 0
		         
		    CASE m.lnCount = -1
		        m.lnCountChars = MAX(m.loFPDF.FPDFText_CountChars(m.lnFPDF_Text_Page) - m.lnStartIndex,0)
		
		    CASE m.loFPDF.FPDFText_CountChars(m.lnFPDF_Text_Page) >= m.lnStartIndex + m.lnCount
		        m.lnCountChars = m.lnCount
		
		    OTHERWISE
		        m.lnCountChars = 0
		
		    ENDCASE
		    
		    LOCAL lnRectCount
		    IF m.lnCountChars > 0
		        m.lnRectCount = m.loFPDF.FPDFText_CountRects(m.lnFPDF_Text_Page, m.lnStartIndex, m.lnCountChars)
		    ELSE
		        m.lnRectCount = 0
		    ENDIF
		
		    IF m.lnRectCount > 0 
		        This.fpdf_pages_selection[m.lnPage,1] = ""
		        This.fpdf_pages_selection[m.lnPage,2] = m.lnStartIndex
		        This.fpdf_pages_selection[m.lnPage,3] = m.lnCountChars
		
		        LOCAL lnPageLeft as Double, lnPageRight as Double, lnPageBottom as Double, lnPageTop as Double
		        STORE 0 TO m.lnPageLeft, m.lnPageRight, m.lnPageBottom, m.lnPageTop
		
		        LOCAL lnRect
		        FOR m.lnRect=1 TO m.lnRectCount
		            IF m.loFPDF.FPDFText_GetRect(m.lnFPDF_Text_Page, m.lnRect-1, @m.lnPageLeft, @m.lnPageTop, @m.lnPageRight, @m.lnPageBottom) > 0
		                This.fpdf_pages_selection[m.lnPage,1] = This.fpdf_pages_selection[m.lnPage,1] + BINTOC(m.lnPageLeft,"8")+BINTOC(m.lnPageTop,"8")+BINTOC(m.lnPageRight,"8")+BINTOC(m.lnPageBottom,"8")
		            ENDIF
		        ENDFOR
		    ELSE
		        This.fpdf_pages_selection[m.lnPage,1] = ""
		        This.fpdf_pages_selection[m.lnPage,2] = 0
		        This.fpdf_pages_selection[m.lnPage,3] = 0
		    ENDIF
		    
		ENDFOR
		
		This.Redraw()
		
	ENDPROC

	PROCEDURE selecttextall		&& Select all text in the document
		LOCAL loErr
		m.loErr = .F.
		TRY
		    IF EMPTY(This.fpdf_form) = .F.
		        LOCAL lnAnnotPage, lnAnnot
		        STORE 0 TO m.lnAnnotPage, m.lnAnnot
		        IF This.env.API_FPDF_FORMS.FORM_GetFocusedAnnot(This.fpdf_form, @m.lnAnnotPage, @m.lnAnnot) = 1
		            IF BETWEEN(m.lnAnnotPage + 1, This.fpdf_page_first_visible, This.fpdf_page_last_visible)
		                LOCAL lnFPDF_Page
		                m.lnFPDF_Page = This.fpdf_pages[m.lnAnnotPage + 1]
		
		                This.env.API_FPDF_FORMS.FORM_SelectAllText(This.fpdf_form, m.lnFPDF_Page)
		                This.Redraw()
		                EXIT
		            ENDIF
		        ENDIF
		    ENDIF
		
		    This.SelectText(0,0,-1)
		    
		CATCH TO loErr
		    This.ErrMsg(m.loErr)
		ENDTRY
		
	ENDPROC

	PROCEDURE setformfieldvalue		&& Accepts PDF form field name in UTF-16LE or 1-based form field index and a value of type String (UTF-16LE) for textbox, combobox, Logical for checkbox, Numeric as a number of selected RadioButton in OptionGroup; Returs True if the value was set
		LPARAMETERS tcFieldNameOrIndex as String, tvFormFieldValue
		
		IF EMPTY(This.fpdf_form)
		    RETURN .F.
		ENDIF
		
		LOCAL loFormField
		m.loFormField = This.GetFormField(m.tcFieldNameOrIndex)
		IF VARTYPE(m.loFormField) != "O"
		    RETURN .F.
		ENDIF
		
		LOCAL lnFPDF_Page
		m.lnFPDF_Page = This.fpdf_pages[m.loFormField.PageIndex]
		
		LOCAL lnPrevAnntoPage, lnPrevAnnot
		STORE 0 TO m.lnPrevAnnotPage, m.lnPrevAnnot
		IF This.env.API_FPDF_FORMS.FORM_GetFocusedAnnot(This.fpdf_form, @m.lnPrevAnnotPage, @m.lnPrevAnnot) = 0
		    STORE 0 TO m.lnPrevAnnotPage, m.lnPrevAnnot
		ENDIF
		
		LOCAL lnAnnotHandle
		m.lnAnnotHandle = This.env.API_FPDF_ANNOT.FPDFPage_GetAnnot(m.lnFPDF_Page, m.loFormField.AnnotIndex - 1)
		IF EMPTY(m.lnAnnotHandle)
		    RETURN .F.
		ENDIF
		
		LOCAL llRes
		m.llRes = .F.
		TRY
		    LOCAL lnFormFieldType, lnFormFieldFlags
		    m.lnFormFieldType = This.env.API_FPDF_ANNOT.FPDFAnnot_GetFormFieldType(This.fpdf_form, m.lnAnnotHandle)
		    m.lnFormFieldFlags = This.env.API_FPDF_ANNOT.FPDFAnnot_GetFormFieldFlags(This.fpdf_form, m.lnAnnotHandle)
		
		    DO CASE
		    CASE m.lnFormFieldType = This.env.API_FPDF.CONST.FPDF_FORMFIELD_TEXTFIELD()
		        IF VARTYPE(m.tvFormFieldValue) != "C"
		            EXIT
		        ENDIF
		
		        IF This.env.API_FPDF_FORMS.FORM_SetFocusedAnnot(This.fpdf_form, m.lnAnnotHandle) = 0
		            EXIT
		        ENDIF
		
		        IF This.env.API_FPDF_FORMS.FORM_SelectAllText(This.fpdf_form, m.lnFPDF_Page) = 0
		            EXIT
		        ENDIF
		        
		        This.env.API_FPDF_FORMS.FORM_ReplaceSelection(This.fpdf_form, m.lnFPDF_Page, m.tvFormFieldValue + CHR(0))
		        m.llRes = .T.
		
		    CASE m.lnFormFieldType = This.env.API_FPDF.CONST.FPDF_FORMFIELD_COMBOBOX()
		
		        IF This.env.API_FPDF_FORMS.FORM_SetFocusedAnnot(This.fpdf_form, m.lnAnnotHandle) = 0
		            EXIT
		        ENDIF
		
		        DO CASE
		        CASE VARTYPE(m.tvFormFieldValue) = "N"
		            IF This.env.API_FPDF_FORMS.FORM_SetIndexSelected(This.fpdf_form, m.lnFPDF_Page, MAX(m.tvFormFieldValue - 1, 0), 1) = 1
		                m.llRes = .T.
		            ENDIF
		
		        CASE VARTYPE(m.tvFormFieldValue) = "C" AND BITAND(m.lnFormFieldFlags, This.env.API_FPDF_FORMS.CONST.FPDF_FORMFLAG_CHOICE_EDIT()) != 0
		            IF This.env.API_FPDF_FORMS.FORM_SelectAllText(This.fpdf_form, m.lnFPDF_Page) = 0
		                EXIT
		            ENDIF
		
		            This.env.API_FPDF_FORMS.FORM_ReplaceSelection(This.fpdf_form, m.lnFPDF_Page, m.tvFormFieldValue + CHR(0))
		            m.llRes = .T.
		        ENDCASE
		
		    CASE m.lnFormFieldType = This.env.API_FPDF.CONST.FPDF_FORMFIELD_CHECKBOX()
		        IF VARTYPE(m.tvFormFieldValue) != "L"
		            EXIT
		        ENDIF
		
		        IF VARTYPE(m.loFormField.Value) = "L" AND m.loFormField.Value != m.tvFormFieldValue
		            IF This.env.API_FPDF_FORMS.FORM_SetFocusedAnnot(This.fpdf_form, m.lnAnnotHandle) = 0
		                EXIT
		            ENDIF
		        
		            IF This.env.API_FPDF_FORMS.Form_OnChar(This.fpdf_form, m.lnFPDF_Page, 13, 0) = 1
		                m.llRes = .T.
		            ENDIF
		        ENDIF
		
		    CASE m.lnFormFieldType = This.env.API_FPDF.CONST.FPDF_FORMFIELD_RADIOBUTTON()
		        IF VARTYPE(m.tvFormFieldValue) != "N"
		            EXIT
		        ENDIF
		    
		        IF BETWEEN(m.tvFormFieldValue, 1, m.loFormField.GroupItems.Count) = .F.
		            EXIT
		        ENDIF
		        
		        LOCAL loGroupItem
		        m.loGroupItem = m.loFormField.GroupItems[m.tvFormFieldValue]
		        
		        LOCAL lnGroupItemFPDF_Page, lnGroupItemAnnot
		        m.lnGroupItemFPDF_Page = This.fpdf_pages[m.loGroupItem.PageIndex]
		        m.lnGroupItemAnnot = This.env.API_FPDF_ANNOT.FPDFPage_GetAnnot(m.lnGroupItemFPDF_Page, m.loGroupItem.AnnotIndex - 1)
		        IF EMPTY(m.lnGroupItemAnnot)
		            EXIT
		        ENDIF
		        
		        TRY
		            IF This.env.API_FPDF_FORMS.FORM_SetFocusedAnnot(This.fpdf_form, m.lnGroupItemAnnot) = 0
		                EXIT
		            ENDIF
		
		            IF This.env.API_FPDF_FORMS.Form_OnChar(This.fpdf_form, m.lnGroupItemFPDF_Page, 13, 0) = 1
		                m.llRes = .T.
		            ENDIF
		        FINALLY
		            This.env.API_FPDF_ANNOT.FPDFPage_CloseAnnot(m.lnGroupItemAnnot)
		        ENDTRY
		    ENDCASE
		FINALLY
		    IF EMPTY(m.lnAnnotHandle) = .F.
		        This.env.API_FPDF_ANNOT.FPDFPage_CloseAnnot(m.lnAnnotHandle)
		    ENDIF
		
		    IF EMPTY(m.lnPrevAnnot) = .F.
		        This.env.API_FPDF_FORMS.FORM_SetFocusedAnnot(This.fpdf_form, m.lnPrevAnnot)
		        This.env.API_FPDF_ANNOT.FPDFPage_CloseAnnot(m.lnPrevAnnot)
		    ELSE
		        This.env.API_FPDF_FORMS.FORM_ForceToKillFocus(This.fpdf_form)
		    ENDIF
		ENDTRY
		
		IF m.llRes
		    This.Redraw()
		ENDIF
		
		RETURN m.llRes
		
	ENDPROC

	HIDDEN PROCEDURE viewportupdate
		LOCAL lnVewPortUpdateStep
		m.lnVewPortUpdateStep = 1
		
		FOR m.lnVewPortUpdateStep = 1 TO 2
		
		    This.fpdf_page_first_visible = 0
		    This.fpdf_page_last_visible = 0
		
		    *********************************************************************
		
		    This.ViewPortSizeX = MAX(This.Width - IIF(INLIST(This.ScrollBars,2,3), SYSMETRIC(5),0), 0)
		    This.ViewPortSizeY = MAX(This.Height - IIF(INLIST(This.ScrollBars,1,3), SYSMETRIC(8),0), 0)
		
		
		    *********************************************************************
		
		    IF This.ViewPortMaxX > This.ViewPortSizeX
		        This.ViewPortX = MIN(MAX(-0.5 * (This.ViewPortMaxX - This.ViewPortSizeX), This.ViewPortX), MAX(0.5 * (This.ViewPortMaxX - This.ViewPortSizeX),0))
		    ELSE
		        This.ViewPortX = 0
		    ENDIF    
		
		    This.ViewPortY = MIN(MAX(This.ViewPortY,0), MAX(This.ViewPortMaxY - This.Height,0))
		
		
		
		
		    LOCAL lnViewPortMaxXNew
		    m.lnViewPortMaxXNew = 0
		
		    *********************************************************************
		    LOCAL lnPageX, lnPageY
		    STORE 0 TO m.lnPageX, m.lnPageY
		
		    LOCAL lnPageWidthUnscaled, lnPageHeightUnscaled
		    LOCAL lnPageWidthUnscaledFirst
		    LOCAL lnPageWidth, lnPageHeight
		
		
		    LOCAL lnPageCount, lnPage
		    m.lnPageCount = This.FPDF_PageCount
		
		    FOR m.lnPage = 1 TO m.lnPageCount
		        
		        m.lnPageWidthUnscaled = This.GetPageSize(m.lnPage,3)
		        m.lnPageHeightUnscaled = This.GetPageSize(m.lnPage,4)
		        
		        IF m.lnPage = 1
		            m.lnPageWidthUnscaledFirst = m.lnPageWidthUnscaled
		        ENDIF
		
		        m.lnPageWidth = m.lnPageWidthUnscaled
		        m.lnPageHeight = m.lnPageHeightUnscaled
		
		        IF This.FitWidth
		            m.lnPageWidth = This.ViewPortSizeX * m.lnPageWidthUnscaled / EVL(m.lnPageWidthUnscaledFirst, EVL(m.lnPageWidthUnscaled, 1))
		            m.lnPageHeight = INT(m.lnPageHeight * m.lnPageWidth / EVL(m.lnPageWidthUnscaled, EVL(m.lnPageWidth, 1)))
		        ENDIF
		        
		        m.lnPageWidth = m.lnPageWidth * This.scale
		        m.lnPageHeight = m.lnPageHeight * This.scale    
		        
		        m.lnPageX = (This.ViewPortSizeX - m.lnPageWidth) * 0.5
		        
		        IF m.lnPage > 1
		            m.lnPageY = m.lnPageY +  MIN(MAX(INT(m.lnPageWidth * 0.02),5),40) &&page separator
		        ENDIF
		        
		        This.fpdf_pages_pos[m.lnPage,1] = m.lnPageX
		        This.fpdf_pages_pos[m.lnPage,2] = m.lnPageY
		
		        This.fpdf_pages_pos[m.lnPage,3] = m.lnPageWidth
		        This.fpdf_pages_pos[m.lnPage,4] = m.lnPageHeight
		       
		        DO CASE
		        CASE This.Width < 30
		        CASE m.lnPageY + m.lnPageHeight < This.ViewPortY
		        CASE m.lnPageY > This.ViewPortY + This.ViewPortSizeY
		        OTHERWISE
		
		            IF This.fpdf_page_first_visible = 0
		                This.fpdf_page_first_visible = m.lnPage
		            ENDIF
		            
		            This.fpdf_page_last_visible = m.lnPage
		            
		        ENDCASE
		        
		      
		        m.lnPageY = m.lnPageY + m.lnPageHeight
		        
		        m.lnViewPortMaxXNew = MAX(m.lnViewPortMaxXNew, m.lnPageWidth)
		        
		    ENDFOR
		
		
		    *********************************************************************
		    IF This.ViewPortMaxX > 0 && Adjust ViewPortX after scaling
		        This.ViewPortX = INT(This.ViewPortX * m.lnViewPortMaxXNew * 10000 / This.ViewPortMaxX) / 10000
		    ENDIF
		
		    This.ViewPortMaxX = m.lnViewPortMaxXNew
		
		    *********************************************************************
		    LOCAL lnViewPortYPrev
		    m.lnViewPortYPrev = This.ViewPortY
		
		    LOCAL lnViewPortMaxYNew
		    m.lnViewPortMaxYNew = m.lnPageY
		    
		    IF This.ViewPortMaxY > 0 && Adjust ViewPortY after scaling
		        This.ViewPortY = INT(This.ViewPortY * m.lnViewPortMaxYNew * 10000 / This.ViewPortMaxY) / 10000
		    ENDIF
		    
		    This.ViewPortMaxY = m.lnViewPortMaxYNew
		    
		    
		    IF m.lnViewPortYPrev <> This.ViewPortY
		        * ViewPortY changed, need to recalculate page visibility
		        * Go to the second step
		        LOOP 
		    ENDIF
		    
		    EXIT 
		
		ENDFOR
		
		
		*********************************************************************
		* Scrollbars update
		*********************************************************************
		IF EMPTY(This.WndHandle)=.T.
		    RETURN
		ENDIF
		
		#define SIF_RANGE 0x0001
		#define SIF_PAGE 0x0002
		#define SIF_POS 0x0004
		#define SIF_DISABLENOSCROLL 0x0008
		
		*********************************************************************
		* Vertical scrollbar update
		
		LOCAL lnScrollMin, lnScrollMax, lnScrollPageSize, lnScrollPos
		IF INLIST(This.ScrollBars,2,3) AND This.ViewPortSizeY > 0
		    m.lnScrollMin = 0
		    m.lnScrollMax = This.ViewPortMaxY
		    m.lnScrollPageSize = This.ViewPortSizeY
		    m.lnScrollPos = This.ViewPortY
		ELSE
		    m.lnScrollMin = 0
		    m.lnScrollMax = 0
		    m.lnScrollPageSize = 0
		    m.lnScrollPos = 0
		ENDIF
		
		LOCAL lcScrollInfo
		m.lcScrollInfo = ;
		    BINTOC(28, "4RS")+;
		    BINTOC(SIF_RANGE+SIF_PAGE+SIF_POS, "4RS")+;
		    BINTOC(m.lnScrollMin, "4RS")+;
		    BINTOC(m.lnScrollMax, "4RS")+;
		    BINTOC(m.lnScrollPageSize, "4RS")+;
		    BINTOC(m.lnScrollPos, "4RS")+;
		    BINTOC(0, "4RS")
		
		This.env.API_WIN.SetScrollInfo(This.WndHandle, 1, m.lcScrollInfo, 1)
		
		
		*********************************************************************
		* Horizontal scrollbar update
		
		LOCAL lnScrollMin, lnScrollMax, lnScrollPageSize, lnScrollPos
		IF INLIST(This.ScrollBars,1,3) AND This.ViewPortMaxX > This.ViewPortSizeX AND This.ViewPortSizeX > 0
		    m.lnScrollMin = -0.5 * (This.ViewPortMaxX - This.ViewPortSizeX)
		    m.lnScrollMax = 0.5 * (This.ViewPortMaxX - This.ViewPortSizeX)
		    m.lnScrollPageSize = This.ViewPortSizeX
		    m.lnScrollMax = m.lnScrollMax + m.lnScrollPageSize
		    m.lnScrollPos = MIN(MAX(m.lnScrollMin, This.ViewPortX), m.lnScrollMax)
		ELSE
		    m.lnScrollMin = 0
		    m.lnScrollMax = 0
		    m.lnScrollPageSize = 0
		    m.lnScrollPos = 0
		ENDIF
		
		LOCAL lcScrollInfo
		m.lcScrollInfo = ;
		    BINTOC(28, "4RS")+;
		    BINTOC(SIF_RANGE+SIF_PAGE+SIF_POS, "4RS")+;
		    BINTOC(m.lnScrollMin, "4RS")+;
		    BINTOC(m.lnScrollMax, "4RS")+;
		    BINTOC(m.lnScrollPageSize, "4RS")+;
		    BINTOC(m.lnScrollPos, "4RS")+;
		    BINTOC(0, "4RS")
		
		This.env.API_WIN.SetScrollInfo(This.WndHandle, 0, m.lcScrollInfo, 1)
		
		
		*********************************************************************
		* Events triggering
		This.AfterViewportUpdate()
		*********************************************************************
		
		
	ENDPROC

	HIDDEN PROCEDURE wndcreate
		
		#DEFINE WNDCLASSEX_SIZE 48
		#DEFINE GW_CHILD 5
		#DEFINE GWL_WNDPROC -4
		#DEFINE GWL_HINSTANCE -6
		#DEFINE GWL_STYLE -16
		#define CS_OWNDC            0x0020
		#define CS_PARENTDC         0x0080
		#define WS_CHILD            0x40000000
		#define WS_DISABLED         0x08000000
		#define WS_VISIBLE          0x10000000
		#define WS_CLIPSIBLINGS     0x04000000
		#define WS_CLIPCHILDREN     0x02000000
		#define WS_VSCROLL          0x00200000
		#define WS_HSCROLL          0x00100000
		#define GMEM_FIXED 0x0
		#define GMEM_ZEROINIT 0x0040
		
		
		LOCAL lhWndParent
		m.lhWndParent = This.env.API_WIN.GetWindow(Thisform.HWnd, GW_CHILD) && VFP window with ScrollBars != 0 or with ShowWindow = 2 - As Top-Level Form creates his own child window
		IF EMPTY(m.lhWndParent) = .F. AND Thisform.ShowWindow = 2 AND Thisform.ScrollBars <> 0
		    m.lhWndParent = EVL(This.env.API_WIN.GetWindow(m.lhWndParent, GW_CHILD), m.lhWndParent)
		ENDIF
		IF EMPTY(m.lhWndParent)=.T. OR (Thisform.ScrollBars = 0 AND Thisform.ShowWindow <> 2)
		    m.lhWndParent = Thisform.HWnd
		ENDIF
		
		LOCAL lhInstance
		m.lhInstance = This.env.API_WIN.GetModuleHandle(NULL)
		
		
		LOCAL lcWndClassEx
		m.lcWndClassEx = REPLICATE(CHR(0), WNDCLASSEX_SIZE)
		
		IF EMPTY( This.env.API_WIN.GetClassInfoEx(m.lhInstance, This.WndClassName, @m.lcWndClassEx) )
		
		    LOCAL lnWndClassNamePtr
		    m.lnWndClassNamePtr = This.env.API_WIN.GlobalAlloc(GMEM_FIXED + GMEM_ZEROINIT, LEN(This.WndClassName)+1)
		
		    SYS(2600, m.lnWndClassNamePtr, LEN(This.WndClassName), This.WndClassName)
		
		    m.lcWndClassEx = ;
		        BINTOC(WNDCLASSEX_SIZE, "4RS")+; &&cbSize
		        BINTOC(CS_PARENTDC,"4RS")+; &&style
		        BINTOC(This.env.API_WIN.GetWindowLong(Application.HWnd, GWL_WNDPROC),"4RS")+; &&lpfnWndProc
		        BINTOC(0,"4RS")+; &&cbClsExtra
		        BINTOC(0,"4RS")+; &&cbWndExtra
		        BINTOC(m.lhInstance,"4RS")+; &&hInstance
		        BINTOC(0,"4RS")+; &&hIcon
		        BINTOC(0,"4RS")+; &&hCursor
		        BINTOC(0,"4RS")+; &&hbrBackground
		        BINTOC(0,"4RS")+; &&lpszMenuName
		        BINTOC(m.lnWndClassNamePtr,"4RS")+; &&lpszClassName
		        BINTOC(0,"4RS") &&hIconSm
		
		    This.env.API_WIN.RegisterClassEx(m.lcWndClassEx)
		
		    This.env.API_WIN.GlobalFree(m.lnWndClassNamePtr)
		    
		ENDIF
		
		
		This.WndViewport = This.env.API_WIN.CreateWindowEx( ;
		    0, ;
		    This.WndClassName, ;
		    "", ;
		    WS_CHILD + WS_CLIPCHILDREN + WS_CLIPSIBLINGS, ;
		    0,0,1,1, ;
		    m.lhWndParent, ;
		    0, ;
		    m.lhInstance, ;
		    0)
		
		IF EMPTY(This.WndViewport)=.T.
		    This.errMsg("CreateWindowEx returned 0")
		    RETURN
		ENDIF
		
		This.WndHandle = This.env.API_WIN.CreateWindowEx( ;
		    0, ;
		    This.WndClassName, ;
		    "", ;
		    WS_CHILD + WS_CLIPCHILDREN + WS_CLIPSIBLINGS + WS_HSCROLL + WS_VSCROLL, ;
		    0,0,1,1, ;
		    This.WndViewport, ;
		    0, ;
		    m.lhInstance, ;
		    0)
		
		
		IF EMPTY(This.WndHandle)=.T.
		    This.errMsg("CreateWindowEx returned 0")
		    RETURN
		ENDIF
		
		******************************************************
		This.WndDC = This.env.API_WIN.GetDC(This.WndHandle)
		
		
		******************************************************
		#define WM_PAINT 0x000F
		BINDEVENT(This.WndHandle, WM_PAINT, This, "WndProc")
		
		#define WM_MOUSEACTIVATE 0x0021
		BINDEVENT(This.WndHandle, WM_MOUSEACTIVATE, This, "WndProc")
		
		#define WM_MOUSEMOVE 0x0200
		#define WM_LBUTTONDOWN 0x0201
		#define WM_LBUTTONUP 0x0202
		#define WM_RBUTTONDOWN 0x0204
		#define WM_RBUTTONUP 0x0205
		#define WM_MOUSEWHEEL 0x020A
		BINDEVENT(This.WndHandle, WM_MOUSEMOVE, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_LBUTTONDOWN, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_LBUTTONUP, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_RBUTTONDOWN, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_RBUTTONUP, This, "WndProc")
		BINDEVENT(This.WndHandle, WM_MOUSEWHEEL, This, "WndProc")
		
		#define WM_VSCROLL 0x0115
		BINDEVENT(This.WndHandle, WM_VSCROLL, This, "WndProc")
		
		#define WM_HSCROLL 0x0114
		BINDEVENT(This.WndHandle, WM_HSCROLL, This, "WndProc")
		
	ENDPROC

	PROCEDURE wndproc		&& Events handler of PdfiumViewer internal window. Developer must not use or redefine this method
		LPARAMETERS thWnd, tnMsg, tnWParam, tnLParam
		
		#define GWL_WNDPROC -4
		#define WM_PAINT  0x000F
		#define WM_MOUSEACTIVATE 0x0021
		#define WM_VSCROLL 0x0115
		#define WM_HSCROLL 0x0114
		#define WM_MOUSEMOVE 0x0200
		#define WM_LBUTTONDOWN 0x0201
		#define WM_LBUTTONUP 0x0202
		#define WM_RBUTTONDOWN 0x0204
		#define WM_RBUTTONUP 0x0205
		#define WM_MOUSEWHEEL 0x020A
		#define MK_LBUTTON 0x0001
		#define MK_RBUTTON 0x0002
		#define MK_SHIFT 0x0004
		#define MK_CONTROL 0x0008
		
		#define SB_LINEUP           0
		#define SB_LINELEFT         0
		#define SB_LINEDOWN         1
		#define SB_LINERIGHT        1
		#define SB_PAGEUP           2
		#define SB_PAGELEFT         2
		#define SB_PAGEDOWN         3
		#define SB_PAGERIGHT        3
		#define SB_THUMBPOSITION    4
		#define SB_THUMBTRACK       5
		#define SB_TOP              6
		#define SB_LEFT             6
		#define SB_BOTTOM           7
		#define SB_RIGHT            7
		#define SB_ENDSCROLL        8
		#define SIF_TRACKPOS 0x0010
		#define SB_SCROLLINFO_TRACKPOS BINTOC(28, "4RS")+BINTOC(SIF_TRACKPOS, "4RS")+REPLICATE(CHR(0),20)
		
		
		LOCAL lnRetVal
		m.lnRetVal = 0
		
		DO CASE
		
		CASE This.UIState.GetEffectivelyVisible() = .F.
		 
		CASE m.tnMsg = WM_PAINT
		
		    LOCAL lcPaint
		    m.lcPaint = REPLICATE(CHR(0), 256)
		
		    LOCAL lnWndDC
		    m.lnWndDC = This.env.API_WIN.BeginPaint(m.thWnd, @m.lcPaint)
		
		    This.Redraw(m.lnWndDC)
		
		    This.env.API_WIN.EndPaint(m.thWnd, m.lcPaint)
		
		
		CASE This.UIState.GetEffectivelyEnabled() = .F.
		 
		
		CASE m.tnMsg = WM_MOUSEACTIVATE
		    IF This.IsFocused = .F.
		        LOCAL lSaveMousePointer
		        m.lSaveMousePointer = This.MousePointer
		        IF TYPE("Application.ActiveForm.HWnd") = "N"
		            IF Application.ActiveForm.WindowType <> 1 OR Application.ActiveForm.HWnd = Thisform.HWnd
		                This.SetFocus()
		            ENDIF
		        ENDIF
		        This.MousePointer = m.lSaveMousePointer
		    ENDIF
		    
		CASE INLIST(m.tnMsg, WM_MOUSEMOVE, WM_MOUSEWHEEL, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_RBUTTONDOWN, WM_RBUTTONUP) 
		    LOCAL lnMBtn, lnMShift, lnMouseX, lnMouseY
		    m.lnMBtn = BITAND(m.tnWParam, MK_LBUTTON + MK_RBUTTON)
		    m.lnMShift = BITRSHIFT(BITAND(m.tnWParam, MK_SHIFT + MK_CONTROL),2)
		    m.lnMouseX = BITAND(m.tnLParam, 0xffff)
		    m.lnMouseY = BITAND(BITRSHIFT(m.tnLParam,16), 0xffff)
		    
		    DO CASE
		    
		    CASE m.tnMsg = WM_MOUSEMOVE AND This.IsFocused
		        This.MouseMove(m.lnMBtn, m.lnMShift, m.lnMouseX, m.lnMouseY)
		 
		    CASE m.tnMsg = WM_MOUSEWHEEL
		        LOCAL lnMWDir 
		        m.lnMWDir = BITAND(BITRSHIFT(m.tnWParam,16), 0xffff)
		        m.lnMWDir = IIF(BITTEST(m.lnMWDir,15), m.lnMWDir - 0xffff, m.lnMWDir)
		        
		        This.MouseWheel(m.lnMWDir, m.lnMShift, m.lnMouseX, m.lnMouseY)
		
		    CASE m.tnMsg =  WM_LBUTTONDOWN AND This.IsFocused
		        This.MouseDown(1, m.lnMShift, m.lnMouseX, m.lnMouseY)
		
		    CASE m.tnMsg = WM_LBUTTONUP AND This.IsFocused
		        This.MouseUp(1, m.lnMShift, m.lnMouseX, m.lnMouseY)
		
		    CASE m.tnMsg =  WM_RBUTTONDOWN AND This.IsFocused
		        This.MouseDown(2, m.lnMShift, m.lnMouseX, m.lnMouseY)
		        
		    CASE m.tnMsg = WM_RBUTTONUP AND This.IsFocused
		        This.MouseUp(2, m.lnMShift, m.lnMouseX, m.lnMouseY)
		
		    ENDCASE
		    
		    
		CASE m.tnMsg = WM_VSCROLL
		
		    LOCAL lnSbReq
		    m.lnSbReq = BITAND(m.tnWParam, 0xffff)
		     
		    DO CASE
		    CASE m.lnSbReq = SB_LINEUP
		       This.ScrollVert(-0.05 * This.Height, .F., .T.)
		
		    CASE m.lnSbReq = SB_LINEDOWN
		       This.ScrollVert(0.05 * This.Height, .F., .T.)
		
		    CASE m.lnSbReq = SB_PAGEUP
		       This.ScrollVert(-1, .T., .T.)
		
		    CASE m.lnSbReq = SB_PAGEDOWN
		       This.ScrollVert(1, .T., .T.)
		
		    CASE m.lnSbReq = SB_TOP
		       This.ScrollVert(0, .F., .F.)
		
		    CASE m.lnSbReq = SB_BOTTOM
		       This.ScrollVert(This.ViewPortMaxY, .F., .F.)
		
		    CASE m.lnSbReq = SB_THUMBTRACK
		       LOCAL lcScrollInfo
		       m.lcScrollInfo = SB_SCROLLINFO_TRACKPOS
		
		       IF This.env.API_WIN.GetScrollInfo(m.thWnd, 1, @m.lcScrollInfo) = 1
		           LOCAL lnSbPos
		           m.lnSbPos = CTOBIN(SUBSTR(m.lcScrollInfo,25,4),"4RS")
		           This.ScrollVert(m.lnSbPos)
		       ENDIF
		    ENDCASE
		
		
		CASE m.tnMsg = WM_HSCROLL
		
		    LOCAL lnSbReq
		    m.lnSbReq = BITAND(m.tnWParam, 0xffff)
		     
		    DO CASE
		    CASE m.lnSbReq = SB_LINELEFT
		       This.ScrollHorz(-0.05 * This.Width, .F., .T.)
		
		    CASE m.lnSbReq = SB_LINERIGHT
		       This.ScrollHorz(0.05 * This.Width, .F., .T.)
		
		    CASE m.lnSbReq = SB_PAGELEFT
		       This.ScrollHorz(-1, .T., .T.)
		
		    CASE m.lnSbReq = SB_PAGERIGHT
		       This.ScrollHorz(1, .T., .T.)
		
		    CASE m.lnSbReq = SB_LEFT
		       This.ScrollHorz(-This.ViewPortMaxY, .F., .F.)
		
		    CASE m.lnSbReq = SB_RIGHT
		       This.ScrollHorz(This.ViewPortMaxY, .F., .F.)
		
		    CASE m.lnSbReq = SB_THUMBTRACK
		       LOCAL lcScrollInfo
		       m.lcScrollInfo = SB_SCROLLINFO_TRACKPOS
		
		       IF This.env.API_WIN.GetScrollInfo(m.thWnd, 0, @m.lcScrollInfo) = 1
		           LOCAL lnSbPos
		           m.lnSbPos = CTOBIN(SUBSTR(m.lcScrollInfo,25,4),"4RS")
		           This.ScrollHorz(m.lnSbPos)
		       ENDIF
		    ENDCASE
		
		OTHERWISE
		    LOCAL lnWndProcDefault
		    m.lnWndProcDefault = This.env.API_WIN.GetWindowLong(m.thWnd, GWL_WNDPROC)
		    m.lnRetVal = This.env.API_WIN.CallWindowProc(m.lnWndProcDefault, m.thWnd, m.tnMsg, m.tnWParam, m.tnLParam)
		
		ENDCASE
		
		RETURN m.lnRetVal
		
	ENDPROC

	HIDDEN PROCEDURE wndredraw
		IF EMPTY(This.WndHandle)
		    RETURN
		ENDIF
		
		This.env.API_WIN.InvalidateRect(This.WndHandle, NULL, 1)
		
	ENDPROC

	HIDDEN PROCEDURE wndrelease
		IF EMPTY(This.WndDC) = .F.
		    This.env.API_WIN.ReleaseDC(This.WndHandle, This.WndDC)
		    This.WndDC = 0
		ENDIF
		
		IF EMPTY(This.WndHandle) = .F.
		    UNBINDEVENTS(This.WndHandle)
		    This.env.API_WIN.DestroyWindow(This.WndHandle)
		    This.WndHandle = 0
		ENDIF
		
		IF EMPTY(This.WndViewport) = .F.
		    UNBINDEVENTS(This.WndViewport)
		    This.env.API_WIN.DestroyWindow(This.WndViewport)
		    This.WndViewport = 0
		ENDIF
		
	ENDPROC

	PROCEDURE wndresize
		IF EMPTY(This.WndHandle)
		    RETURN
		ENDIF
		
		This.ViewPortUpdate()
		This.DrawBufCreate()
		
		LOCAL lnViewLeft, lnViewTop, lnViewRight, lnViewBottom
		This.UIState.ObjToClient(@m.lnViewLeft, @m.lnViewTop, @m.lnViewRight, @m.lnViewBottom)
		
		This.env.API_WIN.MoveWindow(This.WndViewport, ;
		    m.lnViewLeft, ;
		    m.lnViewTop, ;
		    MAX(m.lnViewRight - m.lnViewLeft, 0), ;
		    MAX(m.lnViewBottom - m.lnViewTop, 0), ;
		    1)
		
		This.env.API_WIN.MoveWindow(This.WndHandle, 0, 0, This.Width, This.Height, 1)
		
		This.WndRedraw()
		
	ENDPROC

	PROCEDURE wndshow		&& Show child window (for internal use, public for bindevent)
		
		#define SW_HIDE 0
		#define SW_SHOWNA 8
		IF EMPTY(This.WndHandle)=.F.
		    This.env.API_WIN.ShowWindow(This.WndHandle, IIF(This.UIState.GetEffectivelyVisible(), SW_SHOWNA, SW_HIDE))
		ENDIF
		
		IF EMPTY(This.WndViewport)=.F.
		    This.env.API_WIN.ShowWindow(This.WndViewport, IIF(This.UIState.GetEffectivelyVisible(), SW_SHOWNA, SW_HIDE))
		ENDIF
		
	ENDPROC

	PROCEDURE UIState.onmoved
		This.Parent.WndResize()
		
	ENDPROC

	PROCEDURE UIState.onresize
		This.Parent.WndResize()
		
	ENDPROC

	PROCEDURE UIState.onvisible
		This.Parent.WndShow()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumviewer_cmdfocus AS commandbutton 		&& PdfiumViewer input focus holder. Library consumer must not use this class directly
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: this_access
	*</DefinedPropArrayMethod>

	*<PropValue>
		Caption = ""
		Enabled = .T.
		Height = 27
		Name = "pdfiumviewer_cmdfocus"
		Style = 0
		Visible = .T.
		Width = 27
	*</PropValue>
	
	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF INLIST(m.nKeyCode, 13, 32) AND INLIST(m.nShiftAltCtrl, 0,1,2)
		    NODEFAULT
		    This.KeyPress(m.nKeyCode, m.nShiftAltCtrl)
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE this_access
		LPARAMETERS cMember
		
		RETURN This.Parent
		
	ENDPROC

ENDDEFINE
