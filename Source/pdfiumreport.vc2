*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="pdfiumreport.vcx" CPID="1251" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS pdfium_api_frx AS custom 		&& FRX (VFP Reports) API
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="CONST" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_frx"
		Width = 27
		_memberdata = <VFPData>

		</VFPData>
	*</PropValue>

	ADD OBJECT 'CONST' AS pdfium_api_frx_const WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "CONST", ;
		Top = 0, ;
		Width = 0
		*< END OBJECT: ClassLib="pdfiumreport.vcx" BaseClass="custom" />

ENDDEFINE

DEFINE CLASS pdfium_api_frx_const AS custom 		&& FRX (VFP Reports) API constants
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: align_center
		*m: align_left
		*m: align_right
		*m: frx_obj_comment
		*m: frx_obj_field
		*m: frx_obj_label
		*m: frx_obj_line
		*m: frx_obj_picture
		*m: frx_obj_rectangle
		*m: frx_obj_variable
		*m: outputto_file
		*m: outputto_printer
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		Height = 27
		Name = "pdfium_api_frx_const"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="frx_obj_comment" type="method" display="FRX_OBJ_COMMENT"/>
			<memberdata name="frx_obj_field" type="method" display="FRX_OBJ_FIELD"/>
			<memberdata name="frx_obj_label" type="method" display="FRX_OBJ_LABEL"/>
			<memberdata name="frx_obj_line" type="method" display="FRX_OBJ_LINE"/>
			<memberdata name="frx_obj_picture" type="method" display="FRX_OBJ_PICTURE"/>
			<memberdata name="frx_obj_rectangle" type="method" display="FRX_OBJ_RECTANGLE"/>
			<memberdata name="frx_obj_variable" type="method" display="FRX_OBJ_VARIABLE"/>
			<memberdata name="align_center" type="method" display="ALIGN_CENTER"/>
			<memberdata name="align_left" type="method" display="ALIGN_LEFT"/>
			<memberdata name="align_right" type="method" display="ALIGN_RIGHT"/>
			<memberdata name="outputto_file" type="method" display="OUTPUTTO_FILE"/>
			<memberdata name="outputto_printer" type="method" display="OUTPUTTO_PRINTER"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE align_center
		RETURN 2
		
	ENDPROC

	PROCEDURE align_left
		RETURN 0
		
	ENDPROC

	PROCEDURE align_right
		RETURN 1
		
	ENDPROC

	PROCEDURE frx_obj_comment
		RETURN 0
		
	ENDPROC

	PROCEDURE frx_obj_field
		RETURN 8
		
	ENDPROC

	PROCEDURE frx_obj_label
		RETURN 5
		
	ENDPROC

	PROCEDURE frx_obj_line
		RETURN 6
		
	ENDPROC

	PROCEDURE frx_obj_picture
		RETURN 17
		
	ENDPROC

	PROCEDURE frx_obj_rectangle
		RETURN 7
		
	ENDPROC

	PROCEDURE frx_obj_variable
		RETURN 18
		
	ENDPROC

	PROCEDURE outputto_file
		RETURN 2
		
	ENDPROC

	PROCEDURE outputto_printer
		RETURN 1
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport AS reportlistener 		&& Report listener with integrated report preview based on PdfiumViewer control
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: batchbegin
		*m: batchend
		*m: errlogshow
		*m: errmsg
		*m: finalize
		*m: fontsrelease
		*m: gdipprivatefontsload
		*m: gdipprivatefontsrelease
		*m: getfont
		*m: getfontsubset
		*m: getrenderer		&& Get current renderer object. Not an object return value means that default pdfiumreport_renderer_pdf is used
		*m: printenvdefault_access
		*m: printenvdefault_assign
		*m: printenv_access
		*m: printenv_assign
		*m: process_frxdynamics
		*m: process_frxheader
		*m: process_frxpicture
		*m: runrenderer		&& Runs report rendering with specified renderer object (subclass of pdfiumreport_renderer_base). Returns path to the temporary file containing rendering output results or empty string if there is nothing to render. Temp file must be deleted by  a caller
		*m: saveas_pdfmeta_access
		*m: saveas_pdfmeta_assign
		*m: setrenderer		&& Sets renderer object (subclass of pdfiumreport_renderer_base). If not an object value is passed then default pdfiumreport_renderer_pdf is used
		*m: statuswindowcreate
		*m: statuswindowoncancel
		*p: api_frx
		*p: batchmode
		*p: batchmodeauto		&& .T. if report was created by  _REPORTOUTPUT (= PdfiumReport.app)  and NOPAGEEJECT was set
		*p: batchpagecount		&& Total page count of a batch
		*p: env		&& pdfium_env object
		*p: errlog
		*p: ext_func_getfiledata		&& User's function name with signature String (String). That accepts the filename at return file data. Example: return FILETOSTR(m.cFileName) where cFileName is the function's parameter
		*p: fonts
		*p: fontsubset
		*p: gdipprivatefontshandle
		*p: isreportcancelled
		*p: printenv		&& Print configuration state (pdfium_print_env object). ; Read-only; Overrides default print settings when report is printed from preview window or by TO PRINTER clause with This.ToPrinterNative=.T.
		*p: printenvdefault
		*p: renderer		&& User set renderer object  (subclass of pdfiumreport_renderer_base). If not an object then default pdfiumreport_renderer_pdf is used
		*p: repobj
		*p: repobjcursor
		*p: repobjdynamicscursor
		*p: rep_offsetx
		*p: rep_offsety
		*p: rep_pagecount
		*p: rep_wholepage
		*p: saveas_filename		&& Filename suggestion for "save as" dialog
		*p: saveas_pdfmeta		&& Pdfium_pdfmeta object; Output PDF metadata + encryption (password) and reader permissions
		*p: screengfx
		*p: statuswindow
		*p: toprinternative		&& TO PRINTER clause handing mode:: .T. - report is printed by VFP (PdfiumReport does nothing) ; .F. (default) - report is printed by PdfiumReport (renders report to PDF and prints PDF)
		*p: _memberdata		&& XML Metadata for customizable properties
		*p: _printenv		&& Print configuration state (pdfium_print_env object)
		*p: _printenvdefault
		*p: _saveas_pdfmeta
	*</DefinedPropArrayMethod>

	HIDDEN api_frx,batchmodeauto,batchmode,batchpagecount,env,errlog,fontsubset,fonts,gdipprivatefontshandle,isreportcancelled,renderer,repobjcursor,repobjdynamicscursor,repobj,rep_offsetx,rep_offsety,rep_pagecount,rep_wholepage,screengfx,statuswindow,_printenvdefault,_printenv,_saveas_pdfmeta
	*<PropValue>
		AllowModalMessages = .T.
		api_frx = .F.
		batchmode = .F.
		batchmodeauto = .F.
		batchpagecount = 0
		DynamicLineHeight = .F.
		env = .F.
		errlog = ("")
		ext_func_getfiledata = ("")
		fonts = .F.
		fontsubset = .F.
		FRXDataSession = 0
		gdipprivatefontshandle = 0
		Height = 23
		isreportcancelled = .F.
		ListenerType = -1
		Name = "pdfiumreport"
		printenv = .F.
		printenvdefault = .F.
		QuietMode = .F.
		renderer = .F.
		repobj = .F.
		repobjcursor = ("")
		repobjdynamicscursor = ("")
		rep_offsetx = 0
		rep_offsety = 0
		rep_pagecount = 0
		rep_wholepage = .F.
		saveas_filename = ("")
		saveas_pdfmeta = .F.
		screengfx = .F.
		SendGDIPlusImage = 1
		statuswindow = .F.
		toprinternative = .F.
		TwoPassProcess = .T.
		Width = 23
		_memberdata = <VFPData>
			<memberdata name="env" type="property" display="env"/>
			<memberdata name="errlog" type="property" display="ErrLog"/>
			<memberdata name="errlogshow" type="method" display="ErrLogShow"/>
			<memberdata name="errmsg" type="method" display="ErrMsg"/>
			<memberdata name="finalize" type="method" display="Finalize"/>
			<memberdata name="batchbegin" type="method" display="BatchBegin"/>
			<memberdata name="batchend" type="method" display="BatchEnd"/>
			<memberdata name="batchmode" type="property" display="BatchMode"/>
			<memberdata name="batchmodeauto" type="property" display="BatchModeAuto"/>
			<memberdata name="saveas_filename" type="property" display="SaveAs_Filename"/>
			<memberdata name="printenv" type="property" display="PrintEnv"/>
			<memberdata name="printenv_access" type="method" display="PrintEnv_Access"/>
			<memberdata name="printenv_assign" type="method" display="PrintEnv_Assign"/>
			<memberdata name="_printenv" type="property" display="_PrintEnv"/>
			<memberdata name="printenvdefault" type="property" display="PrintEnvDefault"/>
			<memberdata name="printenvdefault_access" type="method" display="PrintEnvDefault_Access"/>
			<memberdata name="printenvdefault_assign" type="method" display="PrintEnvDefault_Assign"/>
			<memberdata name="_printenvdefault" type="property" display="_PrintEnvDefault"/>
			<memberdata name="toprinternative" type="property" display="ToPrinterNative"/>
			<memberdata name="saveas_pdfmeta" type="property" display="SaveAs_PDFMeta"/>
			<memberdata name="saveas_pdfmeta_access" type="method" display="SaveAs_PDFMeta_Access"/>
			<memberdata name="saveas_pdfmeta_assign" type="method" display="SaveAs_PDFMeta_Assign"/>
			<memberdata name="_saveas_pdfmeta" type="property" display="_SaveAs_PDFMeta"/>
			<memberdata name="ext_func_getfiledata" type="method" display="Ext_Func_GetFileData"/>
			<memberdata name="renderer" type="property" display="Renderer"/>
			<memberdata name="fonts" type="property" display="Fonts"/>
			<memberdata name="getfont" type="method" display="GetFont"/>
			<memberdata name="screengfx" type="property" display="ScreenGfx"/>
			<memberdata name="process_frxdynamics" type="method" display="Process_FrxDynamics"/>
			<memberdata name="process_frxheader" type="method" display="Process_FrxHeader"/>
			<memberdata name="process_frxpicture" type="method" display="Process_FrxPicture"/>
			<memberdata name="rep_offsetx" type="property" display="Rep_OffsetX"/>
			<memberdata name="rep_offsety" type="property" display="Rep_OffsetY"/>
			<memberdata name="rep_pagecount" type="property" display="Rep_PageCount"/>
			<memberdata name="rep_wholepage" type="property" display="Rep_WholePage"/>
			<memberdata name="gdipprivatefontshandle" type="property" display="GdipPrivateFontsHandle"/>
			<memberdata name="gdipprivatefontsload" type="method" display="GdipPrivateFontsLoad"/>
			<memberdata name="gdipprivatefontsrelease" type="method" display="GdipPrivateFontsRelease"/>
			<memberdata name="batchpagecount" type="property" display="BatchPageCount"/>
			<memberdata name="fontsrelease" type="method" display="FontsRelease"/>
			<memberdata name="fontsubset" type="property" display="FontSubset"/>
			<memberdata name="getfontsubset" type="method" display="GetFontSubset"/>
			<memberdata name="setrenderer" type="method" display="SetRenderer"/>
			<memberdata name="runrenderer" type="method" display="RunRenderer"/>
			<memberdata name="repobjcursor" type="property" display="RepObjCursor"/>
			<memberdata name="repobjdynamicscursor" type="property" display="RepObjDynamicsCursor"/>
			<memberdata name="repobj" type="property" display="RepObj"/>
			<memberdata name="getrenderer" type="method" display="GetRenderer"/>
			<memberdata name="api_frx" type="property" display="API_FRX"/>
			<memberdata name="statuswindow" type="property" display="StatusWindow"/>
			<memberdata name="statuswindowoncancel" type="method" display="StatusWindowOnCancel"/>
			<memberdata name="statuswindowcreate" type="method" display="StatusWindowCreate"/>
			<memberdata name="isreportcancelled" type="property" display="IsReportCancelled"/>
		</VFPData>
		_printenv = .F.
		_printenvdefault = .F.
		_saveas_pdfmeta = .F.
	*</PropValue>
	
	PROCEDURE batchbegin
		This.BatchMode = .T.
		This.BatchPageCount = 0
		
		
	ENDPROC

	PROCEDURE batchend
		IF This.BatchMode = .F.
		    RETURN
		ENDIF
		
		This.Finalize()
		
		This.BatchMode = .F.
		
	ENDPROC

	PROCEDURE CancelReport
		This.IsReportCancelled = .T.
	ENDPROC

	PROCEDURE Destroy
		This.StatusWindow = .F.
		
		IF VARTYPE(This.env) = "O"
		    This.FontsRelease()
		    This.GdipPrivateFontsRelease()
		
		    IF EMPTY(This.ScreenGfx) = .F.
		        This.env.API_GDIP.GdipDeleteGraphics(This.ScreenGfx)
		    ENDIF
		ENDIF
		
		This.env = .F.
		This.API_FRX = .F.
		This._PrintEnv = .F.
		This._PrintEnvDefault = .F.
		This.Fonts = .F.
		This.FontSubset = .F.
		This.ScreenGfx = 0
		
		This.RepObj = .F.
		
		IF EMPTY(This.RepObjCursor) = .F. AND USED(This.RepObjCursor)
		    USE IN (This.RepObjCursor)
		ENDIF
		This.RepObjCursor = ""
		
		IF EMPTY(This.RepObjDynamicsCursor) = .F. AND USED(This.RepObjDynamicsCursor)
		    USE IN (This.RepObjDynamicsCursor)
		ENDIF
		This.RepObjDynamicsCursor = ""
		
		This._SaveAs_PDFMeta = .F.
		
		This.PreviewContainer = NULL
		This.Renderer = .F.
		
	ENDPROC

	PROCEDURE DoMessage
		LPARAMETERS cMessage, nParams, cTitle
		
		IF SYS(2335) != '0' AND This.QuietMode = .F.
		    DODEFAULT(m.cMessage, m.nParams, m.cTitle)
		ELSE
		    NODEFAULT
		ENDIF
		
	ENDPROC

	PROCEDURE DoStatus
		LPARAMETERS cMessage
		
		NODEFAULT
		IF VARTYPE(This.StatusWindow) = "O"
		    This.StatusWindow.UpdateStatus(m.cMessage)
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE errlogshow
		IF EMPTY(This.errLog)
		    RETURN
		ENDIF
		
		IF This.QuietMode
		    RETURN
		ENDIF
		
		IF This.AllowModalMessages
		    This.DoMessage(LEFT(This.errLog, 500), 0+48, This.Class + " ("+This.ClassLibrary+")")
		ELSE
		    This.DoStatus(LEFT(This.errLog, 250))
		ENDIF
		
		This.errLog = ""
		
	ENDPROC

	HIDDEN PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		m.lcMsg = This.env.ErrFmt(m.tvMsg)
		
		IF EMPTY(m.lcMsg)
		    RETURN
		ENDIF
		
		This.errLog = LEFT(IIF(EMPTY(This.errLog), "", This.errLog + CHR(13) + CHR(13)) + m.lcMsg, 10000)
		
	ENDPROC

	HIDDEN PROCEDURE finalize
		LOCAL lSaveSafety
		m.lSaveSafety = SET("Safety")
		
		LOCAL lcTempFileName
		m.lcTempFileName = ""
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    IF This.IsReportCancelled = .T.
		        This.IsReportCancelled = .F.
		        EXIT
		    ENDIF
		
		    SET SAFETY OFF
		
		    IF This.BatchPageCount = 0
		        EXIT
		    ENDIF
		        
		    IF This.CommandClauses.OUTPUTTO = This.API_FRX.CONST.OUTPUTTO_PRINTER() AND This.ToPrinterNative = .T. && VFP native output to the printer, do nothing
		        EXIT
		    ENDIF
		
		    IF This.CommandClauses.PREVIEW = .F. AND ;
		       INLIST(This.CommandClauses.OUTPUTTO, This.API_FRX.CONST.OUTPUTTO_PRINTER(), This.API_FRX.CONST.OUTPUTTO_FILE())=.F. 
		
		        ** not preview or output to the printer or to the file
		        EXIT
		    ENDIF
		
		
		    *************************************************
		    * Rendering report in renderer specific format
		    *************************************************
		    LOCAL loRenderer
		    m.loRenderer = This.Renderer
		    IF VARTYPE(m.loRenderer) <> "O"
		        m.loRenderer = NEWOBJECT("PdfiumReport_renderer_pdf", This.ClassLibrary, "", This.env)
		    ENDIF
		
		    m.lcTempFileName = This.RunRenderer(m.loRenderer)
		
		    IF FILE(m.lcTempFileName,1) = .F.
		        EXIT
		    ENDIF
		    *************************************************
		    
		    LOCAL llPreview
		    m.llPreview = (This.CommandClauses.PREVIEW OR This.CommandClauses.ISDESIGNERLOADED)
		
		    DO CASE
		    CASE This.CommandClauses.OUTPUTTO = This.API_FRX.CONST.OUTPUTTO_FILE() && output to the file
		        IF EMPTY(This.CommandClauses.TOFILE) = .F.
		            COPY FILE (m.lcTempFileName) TO (This.CommandClauses.TOFILE)
		        ENDIF
		        
		    CASE NOT (LOWER(m.loRenderer.Class) == "pdfiumreport_renderer_pdf")
		        LOCAL lcOutputFileName
		        m.lcOutputFileName = ALLTRIM(This.SaveAs_Filename)
		        m.lcOutputFileName = IIF(EMPTY(m.lcOutputFileName), "", FORCEEXT(m.lcOutputFileName, LTRIM(m.loRenderer.GetFileExtension(),1,' ', '.')))
		        m.lcOutputFileName = This.env.GetSaveFileName(m.lcOutputFileName, LTRIM(m.loRenderer.GetFileExtension(),1,' ', '.'))
		        IF EMPTY(m.lcOutputFileName) = .F.
		            COPY FILE (m.lcTempFileName) TO (m.lcOutputFileName)
		            IF m.llPreview
		                This.env.API_Win.ShellExecute(0, "Open", FULLPATH(m.lcOutputFileName), NULL, SYS(2023), 1)
		            ENDIF
		        ENDIF
		
		    CASE This.CommandClauses.OUTPUTTO = This.API_FRX.CONST.OUTPUTTO_PRINTER() AND This.CommandClauses.ISDESIGNERLOADED = .F. && output to the printer
		        This.PreviewContainer = NEWOBJECT("PdfiumReportViewer", This.ClassLibrary, "", This.env, This.PrintEnv)
		        This.PreviewContainer.SetReport(This)
		        This.PreviewContainer.OpenPDF(m.lcTempFileName, This.SaveAs_PDFMeta.UserPassword)
		
		        IF This.CommandClauses.PROMPT
		            This.PreviewContainer.Show()
		        ENDIF
		        
		        This.PreviewContainer.PrintReport()
		    
		    
		    CASE m.llPreview 
		        This.PreviewContainer = NEWOBJECT("PdfiumReportViewer", This.ClassLibrary, "", This.env, This.PrintEnv)
		        This.PreviewContainer.SetReport(This)
		        This.PreviewContainer.OpenPDF(m.lcTempFileName, This.SaveAs_PDFMeta.UserPassword)
		        This.PreviewContainer.SaveAs_Filename = EVL(NVL(This.SaveAs_Filename,""),"")
		        This.PreviewContainer.Show(1)
		    
		    ENDCASE
		
		
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		    This.errLogShow()
		
		FINALLY
		    This.StatusWindow = .F.
		    
		    SET SAFETY &lSaveSafety
		    
		    TRY
		        IF EMPTY(m.lcTempFileName) = .F.
		            DELETE FILE (m.lcTempFileName)
		        ENDIF
		    CATCH
		    ENDTRY
		    
		    This.RepObj = .F.
		
		    IF EMPTY(This.RepObjCursor) = .F. AND USED(This.RepObjCursor)
		        USE IN (This.RepObjCursor)
		    ENDIF
		    This.RepObjCursor = ""
		
		    IF EMPTY(This.RepObjDynamicsCursor) = .F. AND USED(This.RepObjDynamicsCursor)
		        USE IN (This.RepObjDynamicsCursor)
		    ENDIF
		    This.RepObjDynamicsCursor = ""
		
		    This.PreviewContainer = NULL
		    
		    This._PrintEnv = .F.
		
		    This.FontsRelease()
		    This.GdipPrivateFontsRelease()
		
		    IF EMPTY(This.ScreenGfx) = .F.
		        This.env.API_GDIP.GdipDeleteGraphics(This.ScreenGfx)
		        This.ScreenGfx = 0
		    ENDIF
		    
		ENDTRY
		
		
	ENDPROC

	HIDDEN PROCEDURE fontsrelease
		LOCAL loFont
		FOR EACH m.loFont IN This.Fonts FOXOBJECT
		    IF VARTYPE(m.loFont) <> "O"
		        LOOP
		    ENDIF
		    
		    IF EMPTY(m.loFont.GdipFont) = .F.
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipDeleteFont(m.loFont.GdipFont))
		        m.loFont.GdipFont = 0
		    ENDIF
		
		    IF EMPTY(m.loFont.GdipFontFamily) = .F.
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipDeleteFontFamily(m.loFont.GdipFontFamily))
		        m.loFont.GdipFontFamily = 0
		    ENDIF
		
		ENDFOR
		
		This.Fonts.Remove(-1)
		This.FontSubset.Remove(-1)
		
	ENDPROC

	HIDDEN PROCEDURE gdipprivatefontsload
		This.GdipPrivateFontsRelease()
		
		IF This.env.PrivateFonts.Count = 0
		    RETURN
		ENDIF
		
		LOCAL lhPrivateFontCollection
		m.lhPrivateFontCollection = 0
		
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipNewPrivateFontCollection(@m.lhPrivateFontCollection))
		
		IF EMPTY(m.lhPrivateFontCollection)
		    RETURN
		ENDIF
		
		This.GdipPrivateFontsHandle = m.lhPrivateFontCollection
		
		LOCAL lcFontPath
		m.lcFontPath = ""
		FOR EACH m.lcFontPath IN This.env.PrivateFonts FOXOBJECT
		
		    IF This.env.API_WIN.GetFileAttributesA(ALLTRIM(m.lcFontPath)) != -1
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipPrivateAddFontFile(This.GdipPrivateFontsHandle, STRCONV(ALLTRIM(m.lcFontPath),5) + CHR(0)))
		    ENDIF
		    
		ENDFOR
		
	ENDPROC

	HIDDEN PROCEDURE gdipprivatefontsrelease
		
		IF EMPTY(NVL(This.GdipPrivateFontsHandle,0)) = .F.
		    LOCAL lhPrivateFontCollection
		    m.lhPrivateFontCollection = This.GdipPrivateFontsHandle
		    
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipDeletePrivateFontCollection(@m.lhPrivateFontCollection))
		ENDIF
		
		This.GdipPrivateFontsHandle = 0
		
	ENDPROC

	HIDDEN PROCEDURE getfont
		LPARAMETERS loRepObj
		
		LOCAL lcFontID
		m.lcFontID = m.loRepObj.FontFace
		m.lcFontID = m.lcFontID + "<"+TRANSFORM(m.loRepObj.FontSize)+">"
		IF m.loRepObj.FontBold
		    m.lcFontID = m.lcFontID + "<B>"
		ENDIF
		IF m.loRepObj.FontItalic
		    m.lcFontID = m.lcFontID + "<I>"
		ENDIF
		IF m.loRepObj.FontUnderline
		    m.lcFontID = m.lcFontID + "<U>"
		ENDIF
		IF m.loRepObj.FontStrikeout
		    m.lcFontID = m.lcFontID + "<S>"
		ENDIF
		m.lcFontID = m.lcFontID + "<"+TRANSFORM(m.loRepObj.FontCharset)+">"
		
		***********************************************************
		* Font has been found
		***********************************************************
		LOCAL lnFontIndex
		m.lnFontIndex = This.Fonts.GetKey(m.lcFontID)
		IF m.lnFontIndex > 0
		    RETURN This.Fonts[m.lnFontIndex]
		ENDIF
		***********************************************************
		
		***********************************************************
		* Font hasn't been found, create it
		***********************************************************
		LOCAL llFontPrivate
		m.llFontPrivate = .F.
		
		LOCAL lhGdipFont, lhGdipFontFamily, liFont
		STORE 0 TO m.lhGdipFont, m.lhGdipFontFamily
		m.liFont = 1
		
		FOR m.liFont = 1 TO 3
		    
		    DO CASE
		    CASE m.liFont = 1
		        m.lhGdipFontFamily = 0
		        
		        IF This.env.API_GDIP.GdipCreateFontFamilyFromName(STRCONV(m.loRepObj.FontFace,5) + CHR(0), 0, @m.lhGdipFontFamily) != 0
		            m.lhGdipFontFamily = 0
		        ENDIF
		        
		    CASE m.liFont = 2
		        
		        m.lhGdipFontFamily = 0
		        
		        IF This.env.API_GDIP.GdipCreateFontFamilyFromName(STRCONV(m.loRepObj.FontFace,5) + CHR(0), This.GdipPrivateFontsHandle, @m.lhGdipFontFamily) != 0
		            m.lhGdipFontFamily = 0
		        ENDIF
		        
		        IF EMPTY(m.lhGdipFontFamily) = .F.
		            m.llFontPrivate = .T.
		        ENDIF
		        
		            
		    OTHERWISE && If report font is not found, take fallback font
		
		        m.lhGdipFontFamily = 0
		        
		        IF This.env.API_GDIP.GdipGetGenericFontFamilySansSerif(@m.lhGdipFontFamily) != 0
		            m.lhGdipFontFamily = 0
		        ENDIF
		
		    ENDCASE
		    
		
		    IF EMPTY(m.lhGdipFontFamily) = .T.
		        LOOP
		    ENDIF
		    
		    m.lhGdipFont = 0
		    
		    IF This.env.API_GDIP.GdipCreateFont( ;
		        m.lhGdipFontFamily, ;
		        m.loRepObj.FontSize, ;
		        ( ;
		            IIF(m.loRepObj.FontBold, This.env.API_GDIP.CONST.Gdip_FontStyleBold(), 0) + ;
		            IIF(m.loRepObj.FontItalic, This.env.API_GDIP.CONST.Gdip_FontStyleItalic(), 0) + ; 
		            IIF(m.loRepObj.FontUnderline, This.env.API_GDIP.CONST.Gdip_FontStyleUnderline(), 0) + ;
		            IIF(m.loRepObj.FontStrikeout, This.env.API_GDIP.CONST.Gdip_FontStyleStrikeout(), 0) ;
		        ),;
		        This.env.API_GDIP.CONST.Gdip_UnitPoint(), ;
		        @m.lhGdipFont) != 0
		    
		        m.lhGdipFont = 0
		        
		    ENDIF
		
		    IF EMPTY(m.lhGdipFont) = .F.
		        EXIT
		    ENDIF
		    
		ENDFOR
		***********************************************************
		
		IF EMPTY(m.lhGdipFont) = .T.
		    THROW TEXTMERGE("Error on creation GDI+ Font for the font face <<m.loRepObj.FontFace>>")
		ENDIF
		
		LOCAL lcFontFamilyNameUnicode, lcFontFamilyName
		m.lcFontFamilyNameUnicode = ""
		m.lcFontFamilyName = ""
		
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetFamilyName(m.lhGdipFontFamily, @m.lcFontFamilyNameUnicode, 0))
		
		m.lcFontFamilyName = RTRIM(STRCONV(m.lcFontFamilyNameUnicode, 6), 1, CHR(0), " ")
		
		
		***********************************************************
		* Font filename and simulations
		***********************************************************
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL llFontFileFound, lcFontFileName
		m.llFontFileFound = .F.
		m.lcFontFileName = ""
		
		LOCAL lnBoldSimulation, lnItalicSimulation
		STORE 0 TO m.lnBoldSimulation, m.lnItalicSimulation
		
		LOCAL lnIsSymbolFont
		m.lnIsSymbolFont = 0
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		    
		    m.lcFontFileName = REPLICATE(CHR(0),255*2)
		
		    LOCAL lnGetFont
		    m.lnGetFont = m.loFPDF.VFPDF_GetFontFileName( ;
		                    m.lcFontFamilyNameUnicode+CHR(0), ;
		                    IIF(m.loRepObj.FontBold,1,0), ;
		                    IIF(m.loRepObj.FontItalic,1,0), ;
		                    m.loRepObj.FontCharset, ;
		                    @m.lcFontFileName, ;
		                    LEN(m.lcFontFileName), ;
		                    @m.lnBoldSimulation, ;
		                    @m.lnItalicSimulation, ;
		                    @m.lnIsSymbolFont)
		                    
		    IF m.lnGetFont = 1
		        m.lcFontFileName = STRCONV(m.lcFontFileName,6)
		        m.lcFontFileName = ALLTRIM(m.lcFontFileName, 1, CHR(0), " ")
		        m.llFontFileFound = This.env.API_WIN.GetFileAttributesA(m.lcFontFileName) != -1
		    ENDIF
		    
		    IF m.llFontFileFound = .F.
		        * Font is not found
		        
		        * Private font collection searching
		        LOCAL lnPrivateFontKey
		        m.lnPrivateFontKey = This.env.PrivateFonts.GetKey(m.lcFontFamilyName) 
		        IF EMPTY(m.lnPrivateFontKey)
		            EXIT
		        ENDIF
		  
		        m.lcFontFileName = ALLTRIM(This.env.PrivateFonts.Item(m.lnPrivateFontKey))
		
		        m.llFontFileFound = This.env.API_WIN.GetFileAttributesA(m.lcFontFileName) != -1
		        
		        m.lnIsSymbolFont = INLIST(m.loRepObj.FontCharset, 2)
		        m.lnBoldSimulation = 1
		        m.lnItalicSimulation = 1
		        
		        IF EMPTY(m.lhGdipFontFamily) = .F.
		            IF This.env.API_GDIP.GdipIsStyleAvailable(m.lhGdipFontFamily, This.env.API_GDIP.CONST.Gdip_FontStyleBold(), @m.lnBoldSimulation) != 0
		                m.lnBoldSimulation = 0
		            ENDIF
		            m.lnBoldSimulation = IIF(m.lnBoldSimulation = 1, 0, 1)
		
		
		            IF This.env.API_GDIP.GdipIsStyleAvailable(m.lhGdipFontFamily, This.env.API_GDIP.CONST.Gdip_FontStyleItalic(), @m.lnItalicSimulation) != 0
		                m.lnItalicSimulation = 0
		            ENDIF
		            m.lnItalicSimulation = IIF(m.lnItalicSimulation = 1, 0, 1)
		
		        ENDIF
		
		    ENDIF
		
		CATCH TO m.loErr
		    m.llFontFileFound = .F.
		
		    This.ErrMsg(m.loErr)
		
		FINALLY
		    IF m.llFontFileFound = .F.
		        m.lcFontFileName = ""
		        m.lnBoldSimulation = 0
		        m.lnItalicSimulation = 0
		        m.lnIsSymbolFont = 0
		    ENDIF
		ENDTRY
		***********************************************************
		
		
		
		LOCAL loFont as PdfiumReport_repfont OF PdfiumReport.vcx
		m.loFont = NEWOBJECT("PdfiumReport_repfont", This.ClassLibrary)
		
		m.loFont.GdipFont = m.lhGdipFont
		m.loFont.GdipFontFamily = m.lhGdipFontFamily
		m.loFont.FontPrivate = m.llFontPrivate
		m.loFont.FontFace = m.lcFontFamilyName
		
		
		LOCAL lnFontHeight
		m.lnFontHeight = 0
		
		This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetFontHeightGivenDPI(m.lhGdipFont, 96, @m.lnFontHeight))
		
		m.loFont.FontSize = m.loRepObj.FontSize
		m.loFont.FontHeight = MAX(m.lnFontHeight, 0)
		m.loFont.FontHeightCeil = CEILING(m.loFont.FontHeight)
		
		m.loFont.LineHeight = m.loFont.FontHeight
		
		
		
		LOCAL lnCellDescent, lnCellAscent, lnLineSpacing, lnEmHeight
		
		m.lnCellDescent = 0
		IF This.env.API_GDIP.GdipGetCellDescent(m.lhGdipFontFamily, 0, @m.lnCellDescent) != 0
		    m.lnCellDescent = 0
		ENDIF
		
		
		m.lnCellAscent = 0
		IF This.env.API_GDIP.GdipGetCellAscent(m.lhGdipFontFamily, 0, @m.lnCellAscent) != 0
		    m.lnCellAscent = 0
		ENDIF
		
		m.lnLineSpacing = 0
		IF This.env.API_GDIP.GdipGetLineSpacing(m.lhGdipFontFamily, 0, @m.lnLineSpacing) != 0
		    m.lnLineSpacing = 0
		ENDIF
		
		
		m.lnEmHeight = 0
		IF This.env.API_GDIP.GdipGetEmHeight(m.lhGdipFontFamily, 0, @m.lnEmHeight) != 0
		    m.lnEmHeight = 0
		ENDIF
		
		IF EMPTY(m.lnEmHeight) = .F.
		    m.loFont.FontDescent = m.loFont.LineHeight * m.lnCellDescent / m.lnEmHeight
		    m.loFont.FontAscent = m.loFont.LineHeight * m.lnCellAscent / m.lnEmHeight
		    m.loFont.LineSpacing = m.loFont.LineHeight * m.lnLineSpacing / m.lnEmHeight
		ELSE
		    m.loFont.FontDescent = 0
		    m.loFont.FontAscent = 0
		    m.loFont.LineSpacing = 0
		ENDIF
		
		
		
		m.loFont.FontFileName = m.lcFontFileName
		m.loFont.FontBold = (m.loRepObj.FontBold and m.lnBoldSimulation = 0)
		m.loFont.FontItalic = (m.loRepObj.FontItalic and m.lnItalicSimulation = 0)
		m.loFont.FontSymbol = EMPTY(m.lnIsSymbolFont)=.F.
		
		
		This.Fonts.Add(m.loFont, m.lcFontID)
		
		RETURN m.loFont
		
	ENDPROC

	HIDDEN PROCEDURE getfontsubset
		LPARAMETERS loRepObj, llAddChars
		
		IF EMPTY(m.loRepObj.Font.FontFileName) = .T.
		    RETURN .F.
		ENDIF
		
		LOCAL loFontSubset
		IF This.FontSubset.GetKey(m.loRepObj.Font.FontFileName) = 0
		    m.loFontSubset = NEWOBJECT("Empty")
		    ADDPROPERTY(m.loFontSubset, "CharSubset", "")
		    ADDPROPERTY(m.loFontSubset, "FontFileName", m.loRepObj.Font.FontFileName)
		    This.FontSubset.Add(m.loFontSubset, m.loRepObj.Font.FontFileName)
		ELSE
		    m.loFontSubset = This.FontSubset.Item(m.loRepObj.Font.FontFileName)
		ENDIF
		
		IF m.llAddChars = .T.
		    LOCAL liChar, lcChar
		    m.liChar = 1
		    FOR m.liChar = 1 TO LEN(m.loRepObj.Text)/2
		        m.lcChar = 0h + SUBSTR(m.loRepObj.Text, m.liChar * 2 - 1, 2)
		        IF INLIST(m.lcChar, 0h0A00, 0h0D00)
		            LOOP
		        ENDIF
		        IF AT(m.lcChar, m.loFontSubset.CharSubset) = 0
		            m.loFontSubset.CharSubset = m.loFontSubset.CharSubset + m.lcChar
		        ENDIF
		    ENDFOR
		ENDIF
		
		RETURN m.loFontSubset
		
	ENDPROC

	PROCEDURE getrenderer		&& Get current renderer object. Not an object return value means that default pdfiumreport_renderer_pdf is used
		RETURN This.Renderer
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.env = NEWOBJECT("pdfium_env", "pdfium-vfp.vcx")
		This.env.Setup(m.toEnv)
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		This.API_FRX = NEWOBJECT("pdfium_api_frx", This.ClassLibrary)
		
		This.Renderer = .F.
		
		This.Fonts = NEWOBJECT("Collection")
		This.FontSubset = NEWOBJECT("Collection")
		
	ENDPROC

	PROCEDURE LoadReport
		This.env.FoxEnv_Set()
		
		IF VARTYPE(This.StatusWindow) != "O"
		    This.StatusWindowCreate()
		ENDIF
		
		This.Rep_PageCount = 0
		
		This.ListenerType = -1
		This.DynamicLineHeight = .F. && must be .F., otherwise text field height calculated incorrectly when font is not installed in system (Private Font)
		
		********************************************************
		LOCAL loPrintEnv
		m.loPrintEnv = NEWOBJECT("pdfium_print_env", "pdfium-vfp.vcx")
		m.loPrintEnv.Setup(This.PrintEnv)
		This.PrintEnv.Setup(m.loPrintEnv, .T.)
		m.loPrintEnv = .F.
		
		IF This.CommandClauses.OUTPUTTO = This.API_FRX.CONST.OUTPUTTO_PRINTER()
		    This.PrintEnv.AllowPrintSetupUI = This.CommandClauses.PROMPT
		ENDIF
		
		********************************************************
		
		********************************************************
		IF This.CommandClauses.OUTPUTTO = This.API_FRX.CONST.OUTPUTTO_PRINTER() AND This.ToPrinterNative = .T. && VFP native output to the printer, do nothing
		    This.ListenerType = 0
		    RETURN
		ENDIF
		********************************************************
		
		IF This.BatchModeAuto = .F. AND This.BatchMode = .F.
		    This.BatchPageCount = 0
		ENDIF
		
		This.BatchModeAuto = This.CommandClauses.NOPAGEEJECT
		This.CommandClauses.NOPAGEEJECT = .F.
		
	ENDPROC

	PROCEDURE OnPreviewClose
		LPARAMETERS lPrint
		
		This.PreviewContainer = NULL
		
	ENDPROC

	PROCEDURE printenvdefault_access
		
		IF VARTYPE(This._PrintEnvDefault) <> "O"
		    This._PrintEnvDefault = NEWOBJECT("pdfium_print_env", "pdfium-vfp.vcx")
		    This._PrintEnvDefault.Setup(NULL)
		ENDIF
		
		RETURN This._PrintEnvDefault
		
	ENDPROC

	PROCEDURE printenvdefault_assign
		LPARAMETERS vNewVal
		
		ERROR 1740, TEXTMERGE("<<This.Class>>.PrintEnvDefault")
		
	ENDPROC

	PROCEDURE printenv_access
		
		IF VARTYPE(This._PrintEnv) <> "O"
		    This._PrintEnv = NEWOBJECT("pdfium_print_env", "pdfium-vfp.vcx")
		    This._PrintEnv.Setup(This.PrintEnvDefault, .T.)
		ENDIF
		
		RETURN This._PrintEnv
		
	ENDPROC

	PROCEDURE printenv_assign
		LPARAMETERS vNewVal
		
		ERROR 1740, TEXTMERGE("<<This.Class>>.PrintEnv")
		
	ENDPROC

	HIDDEN PROCEDURE process_frxdynamics
		LPARAMETERS loRepObj, m.lcDynamicsXML
		
		IF EMPTY(NVL(m.lcDynamicsXML,""))
		    RETURN
		ENDIF
		
		LOCAL loFRXC
		m.loFRXC = This.API_FRX.CONST
		
		LOCAL lSaveArea
		m.lSaveArea = SELECT()
		
		LOCAL lSetNull
		m.lSetNull = SET("Null")
		
		TRY
		    SET NULL OFF
		
		    IF EMPTY(This.RepObjDynamicsCursor)
		        This.RepObjDynamicsCursor = This.env.GetUniqueTempCursorName()
		    ENDIF
		
		    CREATE CURSOR (This.RepObjDynamicsCursor) (Name c(100), Execute c(10), ExecWhen M, Script M, FName c(100), FSize c(10), FStyle c(10), Width c(10), Height c(10), penrgb c(10), pena c(5), fillrgb c(10), filla c(5))
		
		
		    LOCAL lcAliasCursor    
		    m.lcAliasCursor = This.RepObjDynamicsCursor
		
		
		    LOCAL llRes
		    m.llRes = .T.
		    TRY
		        XMLTOCURSOR(m.lcDynamicsXML, m.lcAliasCursor, 1024+8192)
		    CATCH
		        m.llRes = .F.
		    ENDTRY
		    IF m.llRes = .F.
		        EXIT        
		    ENDIF
		
		    LOCAL loDS
		    SELECT (m.lcAliasCursor)
		    GO TOP
		    SCAN
		        SELECT (m.lcAliasCursor)
		        SCATTER NAME m.loDS MEMO
		        
		        SELECT (m.lSaveArea)
		
		        DO CASE
		        CASE ALLTRIM(m.loDS.Name) == "Microsoft.VFP.Reporting.Builder.Rotate"
		            m.loRepObj.Rotate = CAST(m.loDS.Execute AS I)
		            
		        CASE EMPTY(m.loDS.ExecWhen)
		
		        CASE EVALUATE(m.loDS.ExecWhen) = .F.
		        
		        
		        CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_FIELD()
		            IF EMPTY(m.loDS.Script) = .F.
		                IF INLIST(m.loRepObj.FontCharset,0,1)=.F.
		                    m.loRepObj.Text = STRCONV(RTRIM(EVALUATE(m.loDS.Script)),5,m.loRepObj.FontCharset,2)
		                ELSE
		                    m.loRepObj.Text = STRCONV(RTRIM(EVALUATE(m.loDS.Script)),5)
		                ENDIF
		            ENDIF
		            
		            IF EMPTY(m.loDS.FName) = .F.
		                m.loRepObj.FontFace = LTRIM(ALLTRIM(m.loDS.FName), "@")
		            ENDIF
		
		            IF EMPTY(CAST(m.loDS.FSize as I)) = .F.
		                m.loRepObj.FontSize = CAST(m.loDS.FSize as I)
		            ENDIF
		
		            IF EMPTY(m.loDS.FStyle)=.F.
		                m.loRepObj.FontBold = BITTEST(CAST(m.loDS.FStyle as I),0)
		                m.loRepObj.FontItalic = BITTEST(CAST(m.loDS.FStyle as I),1)
		                m.loRepObj.FontUnderline = BITTEST(CAST(m.loDS.FStyle as I),2)
		                m.loRepObj.FontStrikeout = BITTEST(CAST(m.loDS.FStyle as I),7)
		            ENDIF
		            
		            IF CAST(m.loDS.FillRgb as I) >= 0 AND EMPTY(m.loDS.FillRgb)=.F.
		                m.loRepObj.FillRed = BITRSHIFT(BITAND(CAST(m.loDS.FillRgb as I), 0x0000FF),0)
		                m.loRepObj.FillGreen = BITRSHIFT(BITAND(CAST(m.loDS.FillRgb as I), 0x00FF00),8)
		                m.loRepObj.FillBlue = BITRSHIFT(BITAND(CAST(m.loDS.FillRgb as I), 0xFF0000),16)
		            ENDIF
		            
		            IF CAST(m.loDS.PenA as I) >= 0 AND EMPTY(m.loDS.PenA)=.F.
		                m.loRepObj.PenAlpha = BITAND(CAST(m.loDS.PenA as I), 0xFF)
		            ENDIF
		
		            IF CAST(m.loDS.PenRgb as I) >= 0 AND EMPTY(m.loDS.PenRgb)=.F.
		                m.loRepObj.PenRed = BITRSHIFT(BITAND(CAST(m.loDS.PenRgb as I), 0x0000FF),0)
		                m.loRepObj.PenGreen = BITRSHIFT(BITAND(CAST(m.loDS.PenRgb as I), 0x00FF00),8)
		                m.loRepObj.PenBlue = BITRSHIFT(BITAND(CAST(m.loDS.PenRgb as I), 0xFF0000),16)
		            ENDIF
		
		            IF CAST(m.loDS.FillA as I) >= 0 AND EMPTY(m.loDS.FillA)=.F.
		                m.loRepObj.FillAlpha = BITAND(CAST(m.loDS.FillA as I), 0xFF)
		                m.loRepObj.Transparent = IIF(m.loRepObj.FillAlpha = 0, 1, 0)
		            ENDIF
		
		        
		        CASE INLIST(m.loRepObj.ObjType, m.loFRXC.FRX_OBJ_RECTANGLE(), m.loFRXC.FRX_OBJ_PICTURE())
		            m.loRepObj.SizeWidth = IIF(CAST(m.loDS.Width AS I) >= 0, CAST(m.loDS.Width AS I) / 10, m.loRepObj.SizeWidth)
		            m.loRepObj.SizeHeight = IIF(CAST(m.loDS.Height AS I) >= 0, CAST(m.loDS.Height AS I) / 10, m.loRepObj.SizeHeight)
		        
		        ENDCASE
		        
		    ENDSCAN
		
		FINALLY    
		    SET NULL &lSetNull
		    SELECT (m.lSaveArea)
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE process_frxheader
		This.Rep_WholePage = .F.
		This.Rep_OffsetX = 0
		This.Rep_OffsetY = 0
		
		*************************************************
		IF (This.FRXDatasession > -1) AND (This.FRXDatasession <> SET("DATASESSION"))
		    SET DATASESSION TO (This.FRXDatasession)
		ENDIF
		
		LOCAL lnFRXRecNo
		m.lnFRXRecNo = RECNO("FRX")
		
		GO TOP IN FRX && Header record
		
		IF FRX.Top = .T.
		    This.Rep_WholePage = .T.
		ENDIF
		
		LOCAL lcPrinter
		m.lcPrinter = ALLTRIM(STREXTRACT(STREXTRACT(CHRTRAN(Frx.Expr,CHR(13),CHR(10)), "DEVICE",CHR(10),1,1)+CHR(10), "=", CHR(10),1,1), 1, " ", CHR(10))
		
		IF BETWEEN(m.lnFRXRecNo, 1, RECCOUNT("FRX"))
		    GO (m.lnFRXRecNo) IN FRX
		ENDIF
		
		SET DATASESSION TO (This.CurrentDataSession)
		*************************************************
		
		IF EMPTY(m.lcPrinter)=.F.
		    IF EMPTY(This.PrintEnv.GetPrinterTitle(m.lcPrinter))
		        m.lcPrinter = ""
		    ENDIF
		ENDIF
		
		IF EMPTY(m.lcPrinter)=.T.
		    m.lcPrinter = This.PrintEnv.SysDefaultPrinter_Get()
		ENDIF
		
		
		IF EMPTY(m.lcPrinter) = .F. AND This.Rep_WholePage = .F. 
		
		    #define PHYSICALOFFSETX 112
		    #define PHYSICALOFFSETY 113
		
		    LOCAL lnPrinterDPI
		    m.lnPrinterDPI = EVL(MAX(PRTINFO(11, m.lcPrinter),0), 600)
		
		    LOCAL lhPrinterDC
		    m.lhPrinterDC = This.env.API_WIN.CreateDC(NULL, m.lcPrinter + CHR(0), NULL, NULL)
		
		    IF EMPTY(m.lhPrinterDC) = .F.
		        TRY
		            This.Rep_OffsetX = This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETX) / m.lnPrinterDPI
		            This.Rep_OffsetY = This.env.API_WIN.GetDeviceCaps(m.lhPrinterDC, PHYSICALOFFSETY) / m.lnPrinterDPI
		            
		        FINALLY
		            This.env.API_WIN.DeleteDC(m.lhPrinterDC)
		        ENDTRY
		    ENDIF
		ENDIF
		
		
	ENDPROC

	HIDDEN PROCEDURE process_frxpicture
		LPARAMETERS loRepObj, GDIPlusImage as Long
		
		m.loRepObj.PictureVal = ""
		
		LOCAL lcTempFileName
		m.lcTempFileName = This.env.GetUniqueTempFileName("png")
		
		
		LOCAL lhImage
		m.lhImage = 0
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    DO CASE
		    CASE EMPTY(m.GDIPlusImage)=.F.
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateBitmapFromHBITMAP(m.GDIPlusImage, 0, @m.lhImage))
		        
		        m.loRepObj.PictureFilename = ""
		    
		    CASE EMPTY(m.loRepObj.PictureFilename) = .T. 
		    
		    CASE This.env.API_WIN.GetFileAttributesA(m.loRepObj.PictureFilename) != -1
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateBitmapFromFile(STRCONV(m.loRepObj.PictureFilename,5) + CHR(0), @m.lhImage))
		    
		    CASE EMPTY(This.Ext_Func_GetFileData) = .F.
		        
		        LOCAL lSaveSafety
		        m.lSaveSafety = SET("Safety")
		        SET SAFETY OFF
		        
		        TRY
		            LOCAL lcExt_Func_GetFileData
		            lcExt_Func_GetFileData = ALLTRIM(This.Ext_Func_GetFileData)
		
		            STRTOFILE(&lcExt_Func_GetFileData.(m.loRepObj.PictureFilename), m.lcTempFileName, 0)
		
		            This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateBitmapFromFile(STRCONV(m.lcTempFileName,5) + CHR(0), @m.lhImage))
		            
		        FINALLY
		            SET SAFETY &lSaveSafety
		        ENDTRY
		
		
		    OTHERWISE
		        ERROR 1, m.loRepObj.PictureFilename
		    
		    ENDCASE
		       
		    IF EMPTY(m.lhImage)
		        EXIT
		    ENDIF
		    
		    
		    **************************************************
		    * Image scaling
		    **************************************************
		    LOCAL lnImgWidth, lnImgHeight, lnImgPixelFormat
		    STORE 0 TO m.lnImgWidth, m.lnImgHeight, m.lnImgPixelFormat
		    
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetImageWidth(m.lhImage, @m.lnImgWidth))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetImageHeight(m.lhImage, @m.lnImgHeight))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetImagePixelFormat(m.lhImage, @m.lnImgPixelFormat))
		    
		
		    DO CASE
		    CASE m.loRepObj.PictureScale = 0 && Clip
		        m.lnImgWidth = MIN(m.lnImgWidth, m.loRepObj.SizeWidth)
		        m.lnImgHeight = MIN(m.lnImgHeight, m.loRepObj.SizeHeight)
		
		        LOCAL lhImageClipped, lhGfxClipped
		        STORE 0 TO m.lhImageClipped, m.lhGfxClipped
		        
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateBitmapFromScan0(m.lnImgWidth, m.lnImgHeight, 0, m.lnImgPixelFormat, NULL, @m.lhImageClipped))
		        
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetImageGraphicsContext(m.lhImageClipped, @m.lhGfxClipped))
		        
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipDrawImageI(m.lhGfxClipped, m.lhImage, 0, 0))
		
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipDisposeImage(m.lhImage))
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipDeleteGraphics(m.lhGfxClipped))
		        
		        m.lhImage = m.lhImageClipped
		        
		        m.lhGfxClipped = 0
		        m.lhImageClipped = 0
		        
		    CASE m.loRepObj.PictureScale = 1 && Scale Keep shape
		        LOCAL lnScale
		        m.lnScale = MIN(IIF(EMPTY(m.lnImgWidth), 0, m.loRepObj.SizeWidth / m.lnImgWidth), IIF(EMPTY(m.lnImgHeight), 0, m.loRepObj.SizeHeight / m.lnImgHeight))
		        
		        m.lnImgWidth = INT(m.lnImgWidth * m.lnScale)
		        m.lnImgHeight = INT(m.lnImgHeight * m.lnScale)
		
		    OTHERWISE && Scale Stretch
		        m.lnImgWidth = m.loRepObj.SizeWidth
		        m.lnImgHeight = m.loRepObj.SizeHeight
		
		    ENDCASE
		
		
		    LOCAL lcImgEncoder
		    m.lcImgEncoder = This.env.API_GDIP.GdipGetImageEncoder("image/png")
		    
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSaveImageToFile(m.lhImage, STRCONV(m.lcTempFileName,5)+CHR(0), m.lcImgEncoder, 0))
		    
		    m.loRepObj.SizeWidth = m.lnImgWidth
		    m.loRepObj.SizeHeight = m.lnImgHeight
		
		    m.loRepObj.PictureVal = FILETOSTR(m.lcTempFileName)
		    
		    
		CATCH TO m.loErr
		    This.ErrMsg(m.loErr)
		    
		FINALLY
		
		    IF EMPTY(m.lhImage) = .F.
		        This.env.API_GDIP.GdipDisposeImage(m.lhImage)
		        m.lhImage = 0
		    ENDIF
		    
		    IF EMPTY(m.lcTempFileName) = .F.
		        DELETE FILE (m.lcTempFileName)
		    ENDIF
		ENDTRY
		
	ENDPROC

	PROCEDURE Render
		LPARAMETERS nFRXRecno, nLeft, nTop, nWidth, nHeight, nObjectContinuationType, cContentsToBeRendered, GDIPlusImage
		
		IF This.IsReportCancelled = .T.
		    NODEFAULT
		    RETURN
		ENDIF
		
		IF This.ListenerType = 0 AND This.ToPrinterNative = .T. && VFP native output to the printer, do nothing
		    RETURN
		ENDIF
		
		NODEFAULT
		
		IF This.TwoPassProcess AND This.CurrentPass = 0
		    RETURN
		ENDIF
		
		IF This.PageNo < This.CommandClauses.RANGEFROM
		    RETURN 
		ENDIF
		
		IF This.PageNo > This.CommandClauses.RANGETO AND This.CommandClauses.RANGETO > 0
		    RETURN
		ENDIF
		
		IF This.env.ok() = .F.
		    RETURN
		ENDIF
		
		
		LOCAL loFRXC
		m.loFRXC = This.API_FRX.CONST
		
		LOCAL lSaveArea
		m.lSaveArea = SELECT()
		
		
		*************************************************
		* New page
		*************************************************
		IF This.PageNo > This.Rep_PageCount
		
		    This.Rep_PageCount = This.Rep_PageCount + 1
		    This.BatchPageCount = This.BatchPageCount + 1
		
		    IF This.Rep_PageCount = 1
		        This.Process_FrxHeader()
		    ENDIF
		    
		    IF This.BatchPageCount = 1
		        This.FontsRelease()
		        This.GdipPrivateFontsLoad()
		
		        IF EMPTY(This.ScreenGfx) = .F.
		            This.env.API_GDIP.GdipDeleteGraphics(This.ScreenGfx)
		            This.ScreenGfx = 0
		        ENDIF
		
		        LOCAL lnScreenGfx
		        This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateFromHWND(Application.HWnd, @m.lnScreenGfx))
		        This.ScreenGfx = m.lnScreenGfx
		
		        This.RepObj = NEWOBJECT("PdfiumReport_repobj", This.ClassLibrary, "", This.env, This.API_FRX, This.ScreenGfx)
		
		        IF EMPTY(This.RepObjCursor)
		            This.RepObjCursor = This.env.GetUniqueTempCursorName()
		        ENDIF
		    ENDIF
		ENDIF
		
		
		
		*************************************************
		* Frx record extraction
		*************************************************
		IF (This.FRXDatasession > -1) AND (This.FRXDatasession <> SET("DATASESSION"))
		    SET DATASESSION TO (This.FRXDatasession)
		ENDIF
		
		GO m.nFRXRecNo IN FRX
		
		LOCAL loFrx
		SCATTER NAME m.loFrx MEMO
		
		SET DATASESSION TO (This.CurrentDataSession)
		*************************************************
		
		
		*************************************************
		* RepObj creation
		*************************************************
		LOCAL loRepObj as PdfiumReport_repobj OF PdfiumReport.vcx
		m.loRepObj = This.RepObj
		
		*************************************************
		* RepObj setup
		*************************************************
		IF USED(This.RepObjCursor) = .F.
		    CREATE CURSOR (This.RepObjCursor) ( ;
		        ObjID i, ;
		        Rep_PageWidth n(12,2), ;
		        Rep_PageHeight n(12,2), ;
		        Rep_PageNo i, ;
		        Rep_PageTotal i, ;
		        Batch_PageNo i, ;
		        ObjType i, ;
		        Text M, ;
		        PictureFilename M, ;
		        PictureVal M, ;
		        PosLeft n(12,2), ;
		        PosTop n(12,2), ;
		        PosTopRev n(12,2), ;
		        SizeWidth n(12,2), ;
		        SizeHeight n(12,2), ;
		        FontFace M,;
		        FontSize i, ;
		        FontBold l, ;
		        FontItalic l, ;
		        FontUnderline l, ;
		        FontStrikeout l, ;
		        FontCharset i, ;
		        LineSpacing n(12,2), ;
		        FillRed i, ;
		        FillGreen i, ;
		        FillBlue i, ;
		        FillAlpha i, ;
		        PenRed i, ;
		        PenGreen i, ;
		        PenBlue i, ;
		        PenAlpha i, ;
		        PenPat i, ;
		        PenSize i, ;
		        FillPat i, ;
		        Transparent i, ;
		        Align i, ;
		        LineType i, ;
		        RectCurvature i, ;
		        ContinuationType i,;
		        PictureScale i, ;
		        Rotate i ;
		    )
		    
		    SELECT (m.lSaveArea)
		ENDIF
		
		m.loRepObj.Rep_PageWidth = This.GetPageWidth() / 10
		m.loRepObj.Rep_PageHeight = This.GetPageHeight() / 10
		
		m.loRepObj.Rep_PageNo = This.Rep_PageCount
		
		m.loRepObj.Rep_PageTotal = This.PageTotal
		
		m.loRepObj.Batch_PageNo = This.BatchPageCount
		
		m.loRepObj.ObjType = m.loFrx.ObjType
		
		m.loRepObj.Text = ""
		m.loRepObj.PictureFilename = ""
		m.loRepObj.PictureVal = ""
		
		IF INLIST(m.loFrx.ObjType, m.loFRXC.FRX_OBJ_FIELD(), m.loFRXC.FRX_OBJ_LABEL())
		    m.loRepObj.Text = m.cContentsToBeRendered
		ENDIF
		
		IF INLIST(m.loFrx.ObjType, m.loFRXC.FRX_OBJ_PICTURE())
		    m.loRepObj.PictureFilename = m.cContentsToBeRendered
		ENDIF
		
		
		m.loRepObj.PosLeft = m.nLeft / 10
		m.loRepObj.PosTop = m.nTop / 10
		m.loRepObj.PosTopRev = m.loRepObj.Rep_PageHeight - m.loRepObj.PosTop
		m.loRepObj.SizeWidth = m.nWidth / 10
		m.loRepObj.SizeHeight = m.nHeight / 10
		
		m.loRepObj.PosLeft = m.loRepObj.PosLeft - This.Rep_OffsetX * 96
		m.loRepObj.PosTop = m.loRepObj.PosTop - This.Rep_OffsetY * 96
		m.loRepObj.PosTopRev = m.loRepObj.PosTopRev + This.Rep_OffsetY * 96
		
		m.loRepObj.Font = .F.
		
		m.loRepObj.FontFace = LTRIM(ALLTRIM(m.loFrx.FontFace), "@")
		m.loRepObj.FontSize = m.loFrx.FontSize
		m.loRepObj.FontBold = BITTEST(m.loFrx.FontStyle,0)
		m.loRepObj.FontItalic = BITTEST(m.loFrx.FontStyle,1)
		m.loRepObj.FontUnderline = BITTEST(m.loFrx.FontStyle,2)
		m.loRepObj.FontStrikeout = BITTEST(m.loFrx.FontStyle,7)
		m.loRepObj.FontCharset = m.loFrx.ResOID
		
		m.loRepObj.LineSpacing = IIF(m.loFrx.ObjType = m.loFRXC.FRX_OBJ_LABEL(), m.loFrx.Spacing, 0)
		
		* (-1,-1,-1) - default color
		m.loRepObj.FillRed = IIF(m.loFrx.FillRed=-1, 255, m.loFrx.FillRed)
		m.loRepObj.FillGreen = IIF(m.loFrx.FillGreen=-1, 255, m.loFrx.FillGreen)
		m.loRepObj.FillBlue = IIF(m.loFrx.FillBlue=-1, 255, m.loFrx.FillBlue)
		m.loRepObj.FillAlpha = 255
		
		* (-1,-1,-1) - default color
		m.loRepObj.PenRed = IIF(m.loFrx.PenRed=-1, 0, m.loFrx.PenRed)
		m.loRepObj.PenGreen = IIF(m.loFrx.PenGreen=-1, 0, m.loFrx.PenGreen)
		m.loRepObj.PenBlue = IIF(m.loFrx.PenBlue=-1, 0, m.loFrx.PenBlue)
		m.loRepObj.PenAlpha = 255
		
		m.loRepObj.PenPat = m.loFrx.PenPat
		m.loRepObj.PenSize = m.loFrx.PenSize
		
		m.loRepObj.FillPat = m.loFrx.FillPat
		
		m.loRepObj.Transparent = IIF(BITTEST(m.loFrx.Mode,0),1,0) && Transparency: 0 - Opaque, 1 - Transparent
		
		m.loRepObj.Align = 0
		m.loRepObj.LineType = 0
		m.loRepObj.RectCurvature = 0
		
		DO CASE
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_FIELD()
		    m.loRepObj.Align = m.loFrx.Offset && FRX_OBJ_FIELD Alignment: 0 - left, 1 - right, 2 - center
		
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		    m.loRepObj.Align = ICASE(ATC("@I", m.loFrx.Picture)<>0, 2, ATC("@J", m.loFrx.Picture)<>0, 1, 0)
		
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_LINE()
		    m.loRepObj.LineType = IIF(m.loFrx.Offset = 1, 1, 2) && Line type: 1 - horizonal, 2 - vertical
		
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_RECTANGLE()
		    m.loRepObj.RectCurvature = m.loFrx.Offset
		    
		ENDCASE
		
		m.loRepObj.ContinuationType = m.nObjectContinuationType
		
		m.loRepObj.PictureScale = IIF(m.loFrx.ObjType = m.loFRXC.FRX_OBJ_PICTURE(), m.loFrx.General, 0)
		
		m.loRepObj.Rotate = 0
		
		
		
		*************************************************
		* Dynamic properties processing 
		*************************************************
		This.Process_FrxDynamics(m.loRepObj, m.loFrx.Style)
		*************************************************
		
		
		*************************************************
		* Additional processing before rendering
		*************************************************
		DO CASE
		CASE INLIST(m.loFrx.ObjType, m.loFRXC.FRX_OBJ_FIELD(), m.loFRXC.FRX_OBJ_LABEL()) && Text
		    
		    m.loRepObj.Font = This.GetFont(m.loRepObj) && Font object assignment
		    m.loRepObj.FontSubset = This.GetFontSubset(m.loRepObj, .T.)
		
		
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_PICTURE() && Picture
		
		    This.Process_FrxPicture(m.loRepObj, m.GDIPlusImage)
		
		
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_LINE() && Line
		
		    m.loRepObj.PosLeft = m.loRepObj.PosLeft + IIF(m.loRepObj.LineType = 1, 0, m.loRepObj.PenSize * 0.5)
		    m.loRepObj.PosTop = m.loRepObj.PosTop + IIF(m.loRepObj.LineType = 1, m.loRepObj.PenSize * 0.5, 0)
		    m.loRepObj.PosTopRev = m.loRepObj.PosTopRev - IIF(m.loRepObj.LineType = 1, m.loRepObj.PenSize * 0.5, 0)
		
		    
		CASE m.loFrx.ObjType = m.loFRXC.FRX_OBJ_RECTANGLE() && Rectangle
		
		    m.loRepObj.PosLeft = m.loRepObj.PosLeft + m.loRepObj.PenSize * 0.5
		    m.loRepObj.PosTop = m.loRepObj.PosTop + m.loRepObj.PenSize * 0.5
		    m.loRepObj.PosTopRev = m.loRepObj.PosTopRev - m.loRepObj.PenSize * 0.5
		    m.loRepObj.SizeWidth = m.loRepObj.SizeWidth - m.loRepObj.PenSize
		    m.loRepObj.SizeHeight = m.loRepObj.SizeHeight - m.loRepObj.PenSize
		
		ENDCASE
		
		
		m.loRepObj.ObjID = RECCOUNT(This.RepObjCursor) + 1
		
		SELECT (This.RepObjCursor)
		APPEND BLANK
		GATHER NAME m.loRepObj MEMO
		SELECT (m.lSaveArea)
		
	ENDPROC

	PROCEDURE runrenderer		&& Runs report rendering with specified renderer object (subclass of pdfiumreport_renderer_base). Returns path to the temporary file containing rendering output results or empty string if there is nothing to render. Temp file must be deleted by  a caller
		LPARAMETERS loRenderer as pdfiumreport_renderer_base OF PdfiumReport.vcx
		
		IF VARTYPE(m.loRenderer) <> "O"
		    RETURN ""
		ENDIF
		
		IF This.BatchPageCount = 0
		    RETURN ""
		ENDIF
		
		IF RECCOUNT(This.RepObjCursor) = 0
		    RETURN ""
		ENDIF
		
		LOCAL loFRXC
		m.loFRXC = This.API_FRX.CONST
		
		
		LOCAL lcTempFileName
		m.lcTempFileName = ""
		
		LOCAL lSaveArea
		m.lSaveArea = SELECT()
		TRY
		    IF This.IsReportCancelled = .T.
		        EXIT
		    ENDIF
		
		    This.StatusWindowCreate()
		
		    LOCAL llStatusWindow
		    m.llStatusWindow = (VARTYPE(This.StatusWindow) = "O")
		    
		    
		    m.loRenderer.Begin(This.SaveAs_PDFMeta)
		
		    LOCAL loRepObj, lnBatch_PageNo
		    m.loRepObj = NEWOBJECT("PdfiumReport_repobj", This.ClassLibrary, "", This.env, This.API_FRX, This.ScreenGfx)
		    m.lnBatch_PageNo = 0
		
		    SELECT (This.RepObjCursor)
		    GO TOP
		    SCAN
		        IF This.IsReportCancelled = .T.
		            EXIT
		        ENDIF
		    
		        SELECT (This.RepObjCursor)
		        SCATTER NAME m.loRepObj MEMO ADDITIVE
		
		        IF INLIST(m.loRepObj.ObjType, m.loFRXC.FRX_OBJ_FIELD(), m.loFRXC.FRX_OBJ_LABEL()) && Text
		            m.loRepObj.Font = This.GetFont(m.loRepObj) && Font object assignment
		            m.loRepObj.FontSubset = This.GetFontSubset(m.loRepObj)
		        ENDIF
		        
		        m.loRenderer.Render(m.loRepObj)
		        
		        IF m.llStatusWindow AND m.lnBatch_PageNo < m.loRepObj.Batch_PageNo
		            m.lnBatch_PageNo = m.loRepObj.Batch_PageNo
		            This.StatusWindow.UpdateStatus(TRANSFORM(m.lnBatch_PageNo) + " / " + TRANSFORM(This.BatchPageCount), CEILING(m.lnBatch_PageNo * 100 / This.BatchPageCount))
		        ENDIF
		    ENDSCAN
		
		    IF This.IsReportCancelled = .T.
		        EXIT
		    ENDIF
		    
		    m.lcTempFileName = m.loRenderer.Finalize(This.SaveAs_PDFMeta)
		
		    IF VARTYPE(m.lcTempFileName) != "C" 
		        m.lcTempFileName = ""
		    ENDIF
		
		    IF This.env.API_WIN.GetFileAttributesA(m.lcTempFileName) = -1
		        m.lcTempFileName = ""
		    ENDIF
		
		FINALLY
		    SELECT (m.lSaveArea)
		    This.IsReportCancelled = .F.
		    This.StatusWindow = .F.
		ENDTRY
		
		RETURN m.lcTempFileName
		
	ENDPROC

	PROCEDURE saveas_pdfmeta_access
		
		IF VARTYPE(This._SaveAs_PDFMeta) <> "O"
		    This._SaveAs_PDFMeta = NEWOBJECT("pdfium_pdfmeta", "pdfium-vfp.vcx")
		ENDIF
		
		RETURN This._SaveAs_PDFMeta
		
	ENDPROC

	PROCEDURE saveas_pdfmeta_assign
		LPARAMETERS vNewVal
		
		ERROR 1740, TEXTMERGE("<<This.Class>>.SaveAs_PDFMeta")
		
	ENDPROC

	PROCEDURE setrenderer		&& Sets renderer object (subclass of pdfiumreport_renderer_base). If not an object value is passed then default pdfiumreport_renderer_pdf is used
		LPARAMETERS toRenderer
		
		This.Renderer = IIF(VARTYPE(m.toRenderer)<>"O", .F., m.toRenderer)
		
	ENDPROC

	HIDDEN PROCEDURE statuswindowcreate
		IF SYS(2335) != '0' AND This.QuietMode = .F.
		    This.StatusWindow = NEWOBJECT("pdfiumreport_status_window", This.ClassLibrary, "", This.env)
		    BINDEVENT(This.StatusWindow, "OnCancel", This, "StatusWindowOnCancel", 1)
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE statuswindowoncancel
		This.StatusWindow.Visible = .F.
		This.CancelReport()
		
	ENDPROC

	PROCEDURE UnloadReport
		
		IF This.BatchModeAuto = .F. AND This.BatchMode = .F.
		    This.Finalize()
		ENDIF
		
		This.env.FoxEnv_Restore()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport_renderer_base AS custom 		&& PdfiumReport renderer implementor base class  (in the meaning of bridge design pattern);
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="API_FRX" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: begin
		*m: finalize
		*m: getfileextension
		*m: render		&& Occurs when Report Engine is ready to provide output for each layout object in a band.
		*p: env
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	PROTECTED env
	*<PropValue>
		env = .F.
		Height = 27
		Name = "pdfiumreport_renderer_base"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="finalize" type="method" display="Finalize"/>
			<memberdata name="render" type="method" display="Render"/>
			<memberdata name="begin" type="method" display="Begin"/>
			<memberdata name="env" type="property" display="env"/>
			<memberdata name="getfileextension" type="method" display="GetFileExtension"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'API_FRX' AS pdfium_api_frx WITH ;
		Height = 0, ;
		Left = 0, ;
		Name = "API_FRX", ;
		Top = 0, ;
		Width = 0, ;
		CONST.Name = "CONST"
		*< END OBJECT: ClassLib="pdfiumreport.vcx" BaseClass="custom" />
	
	PROCEDURE begin
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
	ENDPROC

	PROCEDURE finalize
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
	ENDPROC

	PROCEDURE getfileextension
		RETURN ""
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp.vcx
		
		This.env = NEWOBJECT("pdfium_env", "pdfium-vfp.vcx")
		This.env.Setup(m.toEnv)
		
	ENDPROC

	PROCEDURE render		&& Occurs when Report Engine is ready to provide output for each layout object in a band.
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport_renderer_docx AS pdfiumreport_renderer_base OF "pdfiumreport.vcx" 		&& DOCX rendering implementation
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: getfont
		*m: render_frxfield
		*m: render_frxlabel
		*m: render_frxline
		*m: render_frxpicture
		*m: render_frxrectangle
		*m: render_text
		*m: write_content_types
		*m: write_docprops
		*m: write_document
		*m: write_fonttable
		*m: write_rels
		*m: write_settings
		*m: write_styles
		*m: xmlescape
		*p: docrels
		*p: fontfiles
		*p: fonts
		*p: pages		&& An array used to access individual Pages in a PageFrame object.
		*p: vfpdf_zip_input
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,docrels,Error,fontfiles,fonts,HelpContextID,NewObject,Objects,pages,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,vfpdf_zip_input,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		docrels = .F.
		fontfiles = .F.
		fonts = .F.
		Name = "pdfiumreport_renderer_docx"
		pages = .F.
		vfpdf_zip_input = 0
		_memberdata = <VFPData>
			<memberdata name="pages" type="property" display="Pages"/>
			<memberdata name="render_frxfield" type="method" display="Render_FrxField"/>
			<memberdata name="render_frxlabel" type="method" display="Render_FrxLabel"/>
			<memberdata name="render_frxline" type="method" display="Render_FrxLine"/>
			<memberdata name="render_frxrectangle" type="method" display="Render_FrxRectangle"/>
			<memberdata name="render_frxpicture" type="method" display="Render_FrxPicture"/>
			<memberdata name="render_text" type="method" display="Render_Text"/>
			<memberdata name="write_settings" type="method" display="Write_Settings"/>
			<memberdata name="write_styles" type="method" display="Write_Styles"/>
			<memberdata name="xmlescape" type="method" display="XmlEscape"/>
			<memberdata name="fontfiles" type="property" display="FontFiles"/>
			<memberdata name="write_content_types" type="method" display="Write_Content_Types"/>
			<memberdata name="write_rels" type="method" display="Write_Rels"/>
			<memberdata name="write_docprops" type="method" display="Write_DocProps"/>
			<memberdata name="write_document" type="method" display="Write_Document"/>
			<memberdata name="write_fonttable" type="method" display="Write_FontTable"/>
			<memberdata name="fonts" type="property" display="Fonts"/>
			<memberdata name="getfont" type="method" display="GetFont"/>
			<memberdata name="docrels" type="property" display="DocRels"/>
			<memberdata name="vfpdf_zip_input" type="property" display="vfpdf_zip_input"/>
		</VFPData>
		API_FRX.CONST.Name = "CONST"
		API_FRX.Name = "API_FRX"
	*</PropValue>
	
	PROCEDURE begin
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
		This.vfpdf_zip_input = This.env.API_FPDF.VFPDF_CreateZipInput()
		
		This.Fonts = NEWOBJECT("Collection")
		This.FontFiles = NEWOBJECT("Collection")
		This.Pages = NEWOBJECT("Collection")
		This.DocRels = NEWOBJECT("Collection")
		
		
		LOCAL loRel
		m.loRel = NEWOBJECT("Empty")
		ADDPROPERTY(m.loRel, "Id", "rId1")
		ADDPROPERTY(m.loRel, "Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles")
		ADDPROPERTY(m.loRel, "Target", "styles.xml")
		This.DocRels.Add(m.loRel, m.loRel.Id)
		
		m.loRel = NEWOBJECT("Empty")
		ADDPROPERTY(m.loRel, "Id", "rId2")
		ADDPROPERTY(m.loRel, "Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings")
		ADDPROPERTY(m.loRel, "Target", "settings.xml")
		This.DocRels.Add(m.loRel, m.loRel.Id)
		
		m.loRel = NEWOBJECT("Empty")
		ADDPROPERTY(m.loRel, "Id", "rId3")
		ADDPROPERTY(m.loRel, "Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings")
		ADDPROPERTY(m.loRel, "Target", "webSettings.xml")
		This.DocRels.Add(m.loRel, m.loRel.Id)
		
		m.loRel = NEWOBJECT("Empty")
		ADDPROPERTY(m.loRel, "Id", "rId4")
		ADDPROPERTY(m.loRel, "Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable")
		ADDPROPERTY(m.loRel, "Target", "fontTable.xml")
		This.DocRels.Add(m.loRel, m.loRel.Id)
		
		
		
	ENDPROC

	PROCEDURE finalize
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
		IF EMPTY(This.vfpdf_zip_input)
		    RETURN
		ENDIF
		
		
		LOCAL lnZipFileData, lnZipFileDataSize
		STORE 0 TO m.lnZipFileData, m.lnZipFileDataSize
		
		LOCAL lcTempFileName
		m.lcTempFileName = ""
		
		TRY
		    This.Write_Content_Types()
		    This.Write_Settings()
		    This.Write_Styles()
		    This.Write_FontTable()
		
		    This.Write_Document()
		
		    This.Write_DocProps()
		    This.Write_Rels()
		    
		    m.lcTempFileName = This.env.GetUniqueTempFileName("docx")
		
		    IF This.env.API_FPDF.VFPDF_CreateZip(This.vfpdf_zip_input, @m.lnZipFileData, @m.lnZipFileDataSize) = 1
		        STRTOFILE(SYS(2600, m.lnZipFileData, m.lnZipFileDataSize), m.lcTempFileName)
		    ENDIF
		
		FINALLY
		    IF EMPTY(m.lnZipFileData) = .F.
		        This.env.API_FPDF.VFPDF_DestroyZip(m.lnZipFileData)
		        STORE 0 TO m.lnZipFileData, m.lnZipFileDataSize
		    ENDIF
		        
		    IF EMPTY(This.vfpdf_zip_input) = .F.
		        This.env.API_FPDF.VFPDF_DestroyZipInput(This.vfpdf_zip_input)
		        This.vfpdf_zip_input = 0
		    ENDIF
		    
		    This.Fonts = .F.
		    This.FontFiles = .F.
		    This.Pages = .F.
		    This.DocRels = .F.
		    
		ENDTRY
		
		RETURN m.lcTempFileName
		
	ENDPROC

	PROCEDURE getfileextension
		RETURN "docx"
		
	ENDPROC

	HIDDEN PROCEDURE getfont
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		
		LOCAL lcFontName
		m.lcFontName = m.loRepObj.FontFace
		
		
		***********************************************************
		* Font has been found
		***********************************************************
		LOCAL lnFontIndex
		m.lnFontIndex = This.Fonts.GetKey(m.lcFontName)
		IF m.lnFontIndex > 0
		    RETURN This.Fonts[m.lnFontIndex]
		ENDIF
		***********************************************************
		
		***********************************************************
		* Font hasn't been found, load it from file
		***********************************************************
		
		LOCAL lcFontsPath
		m.lcFontsPath = "word/fonts"
		
		
		LOCAL loFontFile
		m.loFontFile = .F.
		
		*!*    LOCAL lhHeap, lnFontDataPtr, lnSubsetData, lnSubsetDataSize
		*!*    STORE 0 TO m.lhHeap, m.lnFontDataPtr, m.lnSubsetData, m.lnSubsetDataSize
		
		*!*    TRY
		*!*        IF FILE(m.loRepObj.Font.FontFileName, 1) = .F.
		*!*            * Font file doesn't exist OR FILENAME HAS UNICODE SYMBOLS
		*!*            EXIT
		*!*        ENDIF
		
		*!*        IF This.FontFiles.GetKey(m.loRepObj.Font.FontFileName) > 0
		*!*            m.loFontFile = This.FontFiles.Item(m.loRepObj.Font.FontFileName)
		*!*            EXIT
		*!*        ENDIF
		*!*        
		
		*!*        m.loFontFile = NEWOBJECT("Empty")
		*!*        ADDPROPERTY(m.loFontFile, "rid", "rId" + TRANSFORM(This.FontFiles.Count+1))
		*!*        ADDPROPERTY(m.loFontFile, "FontFileName", "font" + TRANSFORM(This.FontFiles.Count+1) + ".odttf")
		
		*!*        LOCAL lcFontData, lnFontDataSize
		*!*        m.lcFontData = FILETOSTR(m.loRepObj.Font.FontFileName)
		*!*        m.lnFontDataSize = LEN(m.lcFontData)
		*!*        
		*!*        This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, m.lcFontsPath + "/" + m.loFontFile.FontFileName, m.lcFontData, m.lnFontDataSize)
		
		*!*        This.FontFiles.Add(m.loFontFile, m.loRepObj.Font.FontFileName)
		
		*!*        IF m.loRepObj.Font.FontSymbol
		*!*            EXIT
		*!*        ENDIF
		
		*!*        m.lhHeap = This.env.API_WIN.HeapCreate(0, m.lnFontDataSize, 0)
		*!*        IF EMPTY(m.lhHeap)
		*!*            EXIT
		*!*        ENDIF
		
		*!*        m.lnFontDataPtr = This.env.API_WIN.HeapAlloc(m.lhHeap, 0, m.lnFontDataSize)
		*!*        IF EMPTY(m.lnFontDataPtr)
		*!*            EXIT
		*!*        ENDIF
		
		*!*        SYS(2600, m.lnFontDataPtr, m.lnFontDataSize, m.lcFontData)
		
		*!*        IF m.loFPDF.VFPDF_CreateFontSubset(m.lnFontDataPtr, m.lnFontDataSize, m.loRepObj.FontSubset.CharSubset + CHR(0), @m.lnSubsetData, @m.lnSubsetDataSize) = 1
		*!*            This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, m.lcFontsPath + "/" + m.loFontFile.FontFileName, SYS(2600, m.lnSubsetData, m.lnSubsetDataSize), m.lnSubsetDataSize)
		*!*        ENDIF
		
		
		*!*    FINALLY
		*!*        
		*!*        IF EMPTY(m.lnSubsetData)=.F.
		*!*            m.loFPDF.VFPDF_DestroyFontSubset(m.lnSubsetData)
		*!*            m.lnSubsetData = 0
		*!*            m.lnSubsetDataSize = 0
		*!*        ENDIF
		
		*!*        IF EMPTY(m.lnFontDataPtr)=.F.
		*!*            This.env.API_WIN.HeapFree(m.lhHeap, 0, m.lnFontDataPtr)
		*!*            m.lnFontDataPtr = 0 
		*!*        ENDIF
		
		*!*        IF EMPTY(m.lhHeap)=.F.
		*!*            This.env.API_WIN.HeapDestroy(m.lhHeap)
		*!*            m.lhHeap = 0 
		*!*        ENDIF
		
		*!*    ENDTRY
		
		
		LOCAL loFont
		m.loFont = NEWOBJECT("empty")
		ADDPROPERTY(m.loFont, "Name", m.lcFontName)
		ADDPROPERTY(m.loFont, "FontFile", m.loFontFile)
		
		This.Fonts.Add(m.loFont, m.lcFontName)
		
		RETURN m.loFont
		
		
	ENDPROC

	PROCEDURE render
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		IF EMPTY(This.vfpdf_zip_input)
		    RETURN
		ENDIF
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL loFRXC
		m.loFRXC = This.API_FRX.CONST
		
		
		*************************************************
		* Create new page
		*************************************************
		IF m.loRepObj.Batch_PageNo > This.Pages.Count
		
		    LOCAL lnPageWidth, lnPageHeight
		    m.lnPageWidth = INT(m.loRepObj.Rep_PageWidth * m.lnDpiCoef)
		    m.lnPageHeight = INT(m.loRepObj.Rep_PageHeight * m.lnDpiCoef)
		
		    LOCAL loPage
		    m.loPage = NEWOBJECT("Empty")
		    ADDPROPERTY(m.loPage, "PageWidth", m.lnPageWidth)
		    ADDPROPERTY(m.loPage, "PageHeight", m.lnPageHeight)
		    ADDPROPERTY(m.loPage, "ContentXML", "")
		
		    This.Pages.Add(m.loPage)
		
		ENDIF
		
		
		*************************************************
		
		DO CASE
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_FIELD()
		    This.Render_FrxField(m.loRepObj)
		   
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		    This.Render_FrxLabel(m.loRepObj)
		
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_LINE()
		    This.Render_FrxLine(m.loRepObj)
		
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_RECTANGLE()
		    This.Render_FrxRectangle(m.loRepObj)
		
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_PICTURE()
		    This.Render_FrxPicture(m.loRepObj)
		
		ENDCASE
		*************************************************
		
	ENDPROC

	HIDDEN PROCEDURE render_frxfield
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		This.Render_Text(m.loRepObj)
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxlabel
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		This.Render_Text(m.loRepObj)
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxline
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		LOCAL loFRXC
		m.loFRXC = This.API_FRX.CONST
		
		
		LOCAL loPage
		m.loPage = This.Pages.Item(This.Pages.Count)
		
		LOCAL lnEmuCoef
		m.lnEmuCoef = 914400 / 96
		
		LOCAL lnLineWidth
		IF m.loRepObj.PenPat >= 1
		    m.lnLineWidth = INT(MAX(m.loRepObj.PenSize, 1) * m.lnEmuCoef)
		ELSE
		    m.lnLineWidth = 0
		ENDIF
		
		IF EMPTY(m.lnLineWidth)
		    RETURN
		ENDIF
		
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = INT(m.loRepObj.PosLeft * m.lnEmuCoef)
		m.lnTop = INT(m.loRepObj.PosTop * m.lnEmuCoef)
		m.lnWidth = INT(m.loRepObj.SizeWidth * m.lnEmuCoef)
		m.lnHeight = INT(m.loRepObj.SizeHeight * m.lnEmuCoef)
		
		IF m.loRepObj.LineType = 1
		    * Horizontal line
		    m.lnHeight = 0
		ELSE
		    * Vertical line
		    m.lnWidth = 0
		ENDIF
		
		
		m.lnLeft = m.lnLeft + INT((m.lnWidth * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) - m.lnWidth * 0.5)
		m.lnTop = m.lnTop + INT(-(m.lnWidth * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) - m.lnHeight * 0.5)
		
		
		
		LOCAL lnRotate
		m.lnRotate = INT(m.loRepObj.Rotate * 60000)
		
		
		LOCAL lcDash
		DO CASE
		CASE m.loRepObj.PenPat = 8 && Normal
		    m.lcDash = '<a:prstDash val="solid"/>'
		
		CASE m.loRepObj.PenPat = 1 && Dot
		    m.lcDash = '<a:prstDash val="dot"/>'
		    
		CASE m.loRepObj.PenPat = 2 && Dash
		    m.lcDash = '<a:prstDash val="dash"/>'
		    
		CASE m.loRepObj.PenPat = 3 && Dash-dot
		    m.lcDash = '<a:prstDash val="dashDot"/>'
		    
		CASE m.loRepObj.PenPat = 4 && Dash-dot-dot
		    m.lcDash = '<a:prstDash val="lgDashDotDot"/>'
		
		OTHERWISE && Normal
		    m.lcDash = '<a:prstDash val="solid"/>'
		
		ENDCASE
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		
		    TEXT TO m.loPage.ContentXML ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <w:drawing>
		        <wp:anchor distT="0" distB="0" distL="0" distR="0" simplePos="0" relativeHeight="<<m.loRepObj.ObjID>>" behindDoc="0" locked="0" layoutInCell="0" allowOverlap="1">
		            <wp:simplePos x="0" y="0" />
		            <wp:positionH relativeFrom="margin">
		                <wp:posOffset><<m.lnLeft>></wp:posOffset>
		            </wp:positionH>
		            <wp:positionV relativeFrom="margin">
		                <wp:posOffset><<m.lnTop>></wp:posOffset>
		            </wp:positionV>
		            <wp:extent cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		            <wp:effectExtent l="0" t="0" r="0" b="0"/>
		            <wp:wrapNone />
		            <wp:docPr id="<<m.loRepObj.ObjID>>" name="Line<<m.loRepObj.ObjID>>" />
		            <wp:cNvGraphicFramePr>
		                <a:graphicFrameLocks
		                    xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" 
		                    noDrilldown="1" noSelect="1" noMove="1" noResize="1"/>
		            </wp:cNvGraphicFramePr>
		            <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
		                <a:graphicData uri="http://schemas.microsoft.com/office/word/2010/wordprocessingShape">
		                    <wps:wsp>
		                        <wps:cNvCnPr />
		                        <wps:spPr>
		                            <a:xfrm rot="<<m.lnRotate>>">
		                                <a:off x="0" y="0" />
		                                <a:ext cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		                            </a:xfrm>
		                            <a:prstGeom prst="line">
		                                <a:avLst />
		                            </a:prstGeom>
		                            <a:ln w="<<m.lnLineWidth>>">
		                                <a:solidFill>
		                                   <a:srgbClr val="<<STRCONV(CHR(m.loRepObj.PenRed)+CHR(m.loRepObj.PenGreen)+CHR(m.loRepObj.PenBlue),15)>>">
		                                       <a:alpha val="<<INT(100000 * m.loRepObj.PenAlpha/255)>>" />
		                                   </a:srgbClr>
		                                 </a:solidFill>
		                                 <<m.lcDash>>
		                                <a:miter lim="800%" />
		                                <a:headEnd />
		                                <a:tailEnd />
		                            </a:ln>
		                        </wps:spPr>
		                        <wps:bodyPr />
		                    </wps:wsp>
		                </a:graphicData>
		            </a:graphic>
		        </wp:anchor>
		    </w:drawing>
		    ENDTEXT
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE render_frxpicture
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		LOCAL loFRXC
		m.loFRXC = This.API_FRX.CONST
		
		
		LOCAL loPage
		m.loPage = This.Pages.Item(This.Pages.Count)
		
		LOCAL lnEmuCoef
		m.lnEmuCoef = 914400 / 96
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = INT(m.loRepObj.PosLeft * m.lnEmuCoef)
		m.lnTop = INT(m.loRepObj.PosTop * m.lnEmuCoef)
		m.lnWidth = INT(m.loRepObj.SizeWidth * m.lnEmuCoef)
		m.lnHeight = INT(m.loRepObj.SizeHeight * m.lnEmuCoef)
		
		
		m.lnLeft = m.lnLeft + INT((m.lnWidth * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) - m.lnWidth * 0.5)
		m.lnTop = m.lnTop + INT(-(m.lnWidth * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) - m.lnHeight * 0.5)
		
		LOCAL lnRotate
		m.lnRotate = INT(m.loRepObj.Rotate * 60000)
		
		
		IF EMPTY(m.loRepObj.PictureVal) = .T.
		    RETURN
		ENDIF
		
		
		LOCAL lcMediaPath
		m.lcMediaPath = "word/media"
		
		LOCAL lcImageFile
		m.lcImageFile = TEXTMERGE("image<<m.loRepObj.ObjID>>.png")
		
		This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, m.lcMediaPath + "/" + m.lcImageFile, m.loRepObj.PictureVal, LEN(m.loRepObj.PictureVal))
		
		
		LOCAL loRel
		m.loRel = NEWOBJECT("Empty")
		ADDPROPERTY(m.loRel, "Id", TEXTMERGE("rId<<This.DocRels.Count + 1>>"))
		ADDPROPERTY(m.loRel, "Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image")
		ADDPROPERTY(m.loRel, "Target", TEXTMERGE("media/<<m.lcImageFile>>"))
		This.DocRels.Add(m.loRel, m.loRel.Id)
		
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		
		    TEXT TO m.loPage.ContentXML ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <w:drawing>
		        <wp:anchor distT="0" distB="0" distL="0" distR="0" simplePos="0" relativeHeight="<<m.loRepObj.ObjID>>" behindDoc="0" locked="0" layoutInCell="0" allowOverlap="1">
		            <wp:simplePos x="0" y="0" />
		            <wp:positionH relativeFrom="margin">
		                <wp:posOffset><<m.lnLeft>></wp:posOffset>
		            </wp:positionH>
		            <wp:positionV relativeFrom="margin">
		                <wp:posOffset><<m.lnTop>></wp:posOffset>
		            </wp:positionV>
		            <wp:extent cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		            <wp:effectExtent l="0" t="0" r="0" b="0"/>
		            <wp:wrapNone />
		            <wp:docPr id="<<m.loRepObj.ObjID>>" name="Picture<<m.loRepObj.ObjID>>" />
		            <wp:cNvGraphicFramePr>
		                <a:graphicFrameLocks
		                    xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" 
		                    noDrilldown="1" noSelect="1" noMove="1" noResize="1"/>
		            </wp:cNvGraphicFramePr>
		            <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
		                <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">
		                    <pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">
		                        <pic:nvPicPr>
		                            <pic:cNvPr id="<<m.loRepObj.ObjID>>" name="Picture<<m.loRepObj.ObjID>>" />
		                            <pic:cNvPicPr preferRelativeResize="0" />
		                        </pic:nvPicPr>
		                        <pic:blipFill>
		                            <a:blip r:embed="<<This.XmlEscape(m.loRel.Id)>>" />
		                            <a:stretch>
		                                <a:fillRect />
		                            </a:stretch>
		                        </pic:blipFill>
		                        <pic:spPr>
		                            <a:xfrm rot="<<m.lnRotate>>">
		                                <a:off x="0" y="0" />
		                                <a:ext cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		                            </a:xfrm>
		                            <a:prstGeom prst="rect">
		                                <a:avLst />
		                            </a:prstGeom>
		                        </pic:spPr>
		                    </pic:pic>
		                </a:graphicData>
		            </a:graphic>
		        </wp:anchor>
		    </w:drawing>
		    ENDTEXT
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE render_frxrectangle
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		LOCAL loFRXC
		m.loFRXC = This.API_FRX.CONST
		
		
		LOCAL loPage
		m.loPage = This.Pages.Item(This.Pages.Count)
		
		LOCAL lnEmuCoef
		m.lnEmuCoef = 914400 / 96
		
		LOCAL lnLineWidth
		IF m.loRepObj.PenPat >= 1
		    m.lnLineWidth = INT(MAX(m.loRepObj.PenSize, 1) * m.lnEmuCoef)
		ELSE
		    m.lnLineWidth = 0
		ENDIF
		
		   
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = INT(m.loRepObj.PosLeft * m.lnEmuCoef)
		m.lnTop = INT(m.loRepObj.PosTop * m.lnEmuCoef)
		m.lnWidth = INT(m.loRepObj.SizeWidth * m.lnEmuCoef)
		m.lnHeight = INT(m.loRepObj.SizeHeight * m.lnEmuCoef)
		
		
		m.lnLeft = m.lnLeft + INT((m.lnWidth * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) - m.lnWidth * 0.5)
		m.lnTop = m.lnTop + INT(-(m.lnWidth * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) - m.lnHeight * 0.5)
		
		
		LOCAL lnRotate
		m.lnRotate = INT(m.loRepObj.Rotate * 60000)
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		
		
		    LOCAL lcDash
		    DO CASE
		    CASE m.loRepObj.PenPat = 8 && Normal
		        m.lcDash = '<a:prstDash val="solid"/>'
		
		    CASE m.loRepObj.PenPat = 1 && Dot
		        m.lcDash = '<a:prstDash val="dot"/>'
		        
		    CASE m.loRepObj.PenPat = 2 && Dash
		        m.lcDash = '<a:prstDash val="dash"/>'
		        
		    CASE m.loRepObj.PenPat = 3 && Dash-dot
		        m.lcDash = '<a:prstDash val="dashDot"/>'
		        
		    CASE m.loRepObj.PenPat = 4 && Dash-dot-dot
		        m.lcDash = '<a:prstDash val="lgDashDotDot"/>'
		
		    OTHERWISE && Normal
		        m.lcDash = '<a:prstDash val="solid"/>'
		
		    ENDCASE
		
		
		    LOCAL llFill, llStroke
		    DO CASE
		    CASE m.loRepObj.Transparent = 0 AND m.loRepObj.FillPat > 0 AND m.loRepObj.PenPat = 0
		        m.llFill = .T.
		        m.llStroke = .F.
		    CASE m.loRepObj.Transparent = 0 AND m.loRepObj.FillPat > 0
		        m.llFill = .T.
		        m.llStroke = .T.
		    OTHERWISE 
		        m.llFill = .F.
		        m.llStroke = .T.
		    ENDCASE
		
		    LOCAL lcFill
		    IF m.llFill = .F.
		        m.lcFill = "<a:noFill />"
		    ELSE
		        TEXT TO m.lcFill TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <a:solidFill>
		           <a:srgbClr val="<<STRCONV(CHR(m.loRepObj.FillRed)+CHR(m.loRepObj.FillGreen)+CHR(m.loRepObj.FillBlue),15)>>">
		               <a:alpha val="<<INT(100000 * m.loRepObj.FillAlpha/255)>>" />
		           </a:srgbClr>
		         </a:solidFill>
		        ENDTEXT
		    ENDIF
		
		    LOCAL lcStroke
		    IF m.llStroke = .F. OR EMPTY(m.lnLineWidth)
		        m.lcStroke = "<a:noFill />"
		    ELSE
		        TEXT TO m.lcStroke TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <a:solidFill>
		           <a:srgbClr val="<<STRCONV(CHR(m.loRepObj.PenRed)+CHR(m.loRepObj.PenGreen)+CHR(m.loRepObj.PenBlue),15)>>">
		               <a:alpha val="<<INT(100000 * m.loRepObj.PenAlpha/255)>>" />
		           </a:srgbClr>
		         </a:solidFill>
		         <<m.lcDash>>
		        ENDTEXT
		    ENDIF
		
		
		    LOCAL lcRectGeom
		    DO CASE
		    CASE m.loRepObj.RectCurvature = 0 && Normal rectangle
		
		        TEXT TO m.lcRectGeom TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <a:prstGeom prst="rect">
		            <a:avLst />
		        </a:prstGeom>
		        ENDTEXT
		
		    CASE BETWEEN(m.loRepObj.RectCurvature, 1, 98) AND m.loRepObj.RectCurvature <= MAX(m.lnWidth, m.lnHeight)/2  && Rounded rectangle
		
		        LOCAL lnRay
		        m.lnRay = ROUND(IIF(m.lnWidth > m.lnHeight, MIN(m.loRepObj.RectCurvature * m.lnEmuCoef, INT(m.lnHeight / 2)), MIN(m.loRepObj.RectCurvature * m.lnEmuCoef, INT(m.lnWidth / 2))), 0)
		        
		        LOCAL lnRight, lnBottom
		        m.lnRight = m.lnWidth
		        m.lnBottom = m.lnHeight
		
		
		        TEXT TO m.lcRectGeom TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <a:custGeom>
		            <a:pathLst>
		                <a:path>
		                    <a:moveTo>
		                        <a:pt x="<<m.lnRay>>" y="<<m.lnBottom>>"/>
		                    </a:moveTo>
		                    <a:lnTo>
		                        <a:pt x="<<m.lnRight - m.lnRay>>" y="<<m.lnBottom>>"/>
		                    </a:lnTo>
		                    <a:cubicBezTo>
		                        <a:pt x="<<m.lnRight>>" y="<<m.lnBottom>>"/>
		                        <a:pt x="<<m.lnRight>>" y="<<m.lnBottom>>"/>
		                        <a:pt x="<<m.lnRight>>" y="<<m.lnBottom - m.lnRay>>"/>
		                    </a:cubicBezTo>
		                    <a:lnTo>
		                        <a:pt x="<<m.lnRight>>" y="<<m.lnRay>>"/>
		                    </a:lnTo>
		                    <a:cubicBezTo>
		                        <a:pt x="<<m.lnRight>>" y="0"/>
		                        <a:pt x="<<m.lnRight>>" y="0"/>
		                        <a:pt x="<<m.lnRight - m.lnRay>>" y="0"/>
		                    </a:cubicBezTo>
		                    <a:lnTo>
		                        <a:pt x="<<m.lnRay>>" y="0"/>
		                    </a:lnTo>
		                    <a:cubicBezTo>
		                        <a:pt x="0" y="0"/>
		                        <a:pt x="0" y="0"/>
		                        <a:pt x="0" y="<<m.lnRay>>"/>
		                    </a:cubicBezTo>
		                    <a:lnTo>
		                        <a:pt x="0" y="<<m.lnBottom - m.lnRay>>"/>
		                    </a:lnTo>
		                    <a:cubicBezTo>
		                        <a:pt x="0" y="<<m.lnBottom>>"/>
		                        <a:pt x="0" y="<<m.lnBottom>>"/>
		                        <a:pt x="<<m.lnRay>>" y="<<m.lnBottom>>"/>
		                    </a:cubicBezTo>
		                </a:path>
		            </a:pathLst>
		        </a:custGeom>
		        ENDTEXT
		
		    OTHERWISE && Ellipse
		
		        TEXT TO m.lcRectGeom TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <a:prstGeom prst="ellipse">
		            <a:avLst />
		        </a:prstGeom>
		        ENDTEXT
		            
		    ENDCASE
		
		
		    TEXT TO m.loPage.ContentXML ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <w:drawing>
		        <wp:anchor distT="0" distB="0" distL="0" distR="0" simplePos="0" relativeHeight="<<m.loRepObj.ObjID>>" behindDoc="0" locked="0" layoutInCell="0" allowOverlap="1">
		            <wp:simplePos x="0" y="0" />
		            <wp:positionH relativeFrom="margin">
		                <wp:posOffset><<m.lnLeft>></wp:posOffset>
		            </wp:positionH>
		            <wp:positionV relativeFrom="margin">
		                <wp:posOffset><<m.lnTop>></wp:posOffset>
		            </wp:positionV>
		            <wp:extent cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		            <wp:effectExtent l="0" t="0" r="0" b="0"/>
		            <wp:wrapNone />
		            <wp:docPr id="<<m.loRepObj.ObjID>>" name="Rectangle<<m.loRepObj.ObjID>>" />
		            <wp:cNvGraphicFramePr>
		                <a:graphicFrameLocks
		                    xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" 
		                    noDrilldown="1" noSelect="1" noMove="1" noResize="1"/>
		            </wp:cNvGraphicFramePr>
		            <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
		                <a:graphicData uri="http://schemas.microsoft.com/office/word/2010/wordprocessingShape">
		                    <wps:wsp>
		                        <wps:cNvCnPr />
		                        <wps:spPr>
		                            <a:xfrm rot="<<m.lnRotate>>">
		                                <a:off x="0" y="0" />
		                                <a:ext cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		                            </a:xfrm>
		                            <<m.lcRectGeom>>
		                            <<m.lcFill>>
		                            <a:ln w="<<m.lnLineWidth>>">
		                                <<m.lcStroke>>
		                                <a:miter lim="800%" />
		                                <a:headEnd />
		                                <a:tailEnd />
		                            </a:ln>
		                        </wps:spPr>
		                        <wps:bodyPr />
		                    </wps:wsp>
		                </a:graphicData>
		            </a:graphic>
		        </wp:anchor>
		    </w:drawing>
		    ENDTEXT
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE render_text
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		LOCAL loFRXC
		m.loFRXC = This.API_FRX.CONST
		
		LOCAL loPage
		m.loPage = This.Pages.Item(This.Pages.Count)
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL lnEmuCoef
		m.lnEmuCoef = 914400 / 96
		
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = INT(m.loRepObj.PosLeft * m.lnEmuCoef)
		m.lnTop = INT(m.loRepObj.PosTop * m.lnEmuCoef)
		m.lnWidth = INT(m.loRepObj.SizeWidth * m.lnEmuCoef)
		m.lnHeight = INT(m.loRepObj.SizeHeight * m.lnEmuCoef)
		
		LOCAL lnWidthAdd
		m.lnWidthAdd = 0
		DO CASE
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		    m.lnWidthAdd = m.loRepObj.Font.FontHeightCeil
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_FIELD()
		    m.lnWidthAdd = 2
		ENDCASE
		
		m.lnWidth = m.lnWidth + INT(m.lnWidthAdd * m.lnEmuCoef)
		
		DO CASE
		CASE m.loRepObj.Align = m.loFRXC.ALIGN_RIGHT()
		    m.lnLeft = m.lnLeft - INT(m.lnWidthAdd * m.lnEmuCoef)
		
		CASE m.loRepObj.Align = m.loFRXC.ALIGN_CENTER()
		    m.lnLeft = m.lnLeft - INT(m.lnWidthAdd * 0.5 * m.lnEmuCoef)
		
		ENDCASE
		
		
		m.lnLeft = m.lnLeft + INT((m.lnWidth * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) - m.lnWidth * 0.5)
		m.lnTop = m.lnTop + INT(-(m.lnWidth * 0.5) * SIN(-m.loRepObj.Rotate * PI() / 180) + (m.lnHeight * 0.5) * COS(-m.loRepObj.Rotate * PI() / 180) - m.lnHeight * 0.5)
		
		LOCAL lnLineSpacing
		m.lnLineSpacing = ROUND(m.loRepObj.Font.LineHeight * ICASE(m.loRepObj.LineSpacing = 1, 1.5, m.loRepObj.LineSpacing = 2, 2, 1) * m.lnDpiCoef,2)
		
		
		LOCAL lnRotate
		m.lnRotate = INT(m.loRepObj.Rotate * 60000)
		
		
		LOCAL loFont
		m.loFont = This.GetFont(m.loRepObj)
		
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		
		    LOCAL lcText
		    m.lcText = ""
		
		    LOCAL laLines(1), lnLinesCount, liLine, loLine
		    m.lnLinesCount = m.loRepObj.Render_Text(@m.laLines)
		
		    FOR m.liLine = 1 TO m.lnLinesCount
		        m.loLine = m.laLines[m.liLine]
		
		        LOCAL lcStyleTextFill
		        m.lcStyleTextFill = ""
		        IF m.loRepObj.PenAlpha < 255
		            TEXT TO m.lcStyleTextFill NOSHOW TEXTMERGE FLAGS 1 PRETEXT 15
		            <w14:textFill>
		                <w14:solidFill>
		                    <w14:srgbClr w14:val="<<STRCONV(CHR(m.loRepObj.PenRed)+CHR(m.loRepObj.PenGreen)+CHR(m.loRepObj.PenBlue),15)>>">
		                        <w14:alpha w14:val="<<100000 - INT(100000 * m.loRepObj.PenAlpha/255)>>"/>
		                    </w14:srgbClr>
		                </w14:solidFill>
		            </w14:textFill>
		            ENDTEXT
		        ENDIF
		
		        TEXT TO m.lcText ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <w:p>
		            <w:pPr>
		                <w:spacing w:line="<<m.lnLineSpacing>>pt" w:lineRule="exact" />
		                <w:jc w:val="<<ICASE(m.loRepObj.Align = m.loFRXC.ALIGN_CENTER(), 'center', m.loRepObj.Align = m.loFRXC.ALIGN_RIGHT(), 'right', 'left')>>"/>
		            </w:pPr>
		            <w:r>
		                <w:rPr>
		                    <w:rFonts 
		                        w:ascii="<<This.XmlEscape(STRCONV(m.loRepObj.FontFace,9))>>" 
		                        w:eastAsia="<<This.XmlEscape(STRCONV(m.loRepObj.FontFace,9))>>" 
		                        w:hAnsi="<<This.XmlEscape(STRCONV(m.loRepObj.FontFace,9))>>" 
		                        w:cs="<<This.XmlEscape(STRCONV(m.loRepObj.FontFace,9))>>"/>
		                    <w:sz w:val="<<m.loRepObj.FontSize * 2>>"/>
		                    <w:szCs w:val="<<m.loRepObj.FontSize * 2>>"/>
		                    <<IIF(m.loRepObj.FontBold, '<w:b/><w:bCs/>', '')>>
		                    <<IIF(m.loRepObj.FontItalic, '<w:i/><w:iCs/>', '')>>
		                    <<IIF(m.loRepObj.FontUnderline, '<w:u w:val="single"/>', '')>>
		                    <<IIF(m.loRepObj.FontStrikeout, '<w:strike/>', '')>>
		                    <w:color w:val="<<STRCONV(CHR(m.loRepObj.PenRed)+CHR(m.loRepObj.PenGreen)+CHR(m.loRepObj.PenBlue),15)>>" />
		                    <<m.lcStyleTextFill>>
		                </w:rPr>
		                <w:t><<This.XmlEscape(RTRIM(STRCONV(m.loLine.Text, 10), 1, CHR(10),CHR(13)))>></w:t>
		            </w:r>
		        </w:p>
		        ENDTEXT
		
		    ENDFOR
		
		    LOCAL lcFill
		    IF m.loRepObj.Transparent=1
		        m.lcFill = "<a:noFill />"
		    ELSE
		        TEXT TO m.lcFill TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <a:solidFill>
		           <a:srgbClr val="<<STRCONV(CHR(m.loRepObj.FillRed)+CHR(m.loRepObj.FillGreen)+CHR(m.loRepObj.FillBlue),15)>>">
		               <a:alpha val="<<INT(100000 * m.loRepObj.FillAlpha/255)>>" />
		           </a:srgbClr>
		         </a:solidFill>
		        ENDTEXT
		    ENDIF
		
		
		    TEXT TO m.loPage.ContentXML ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <w:drawing>
		        <wp:anchor distT="0" distB="0" distL="0" distR="0" simplePos="0" relativeHeight="<<m.loRepObj.ObjID>>" behindDoc="0" locked="0" layoutInCell="0" allowOverlap="1">
		            <wp:simplePos x="0" y="0" />
		            <wp:positionH relativeFrom="margin">
		                <wp:posOffset><<m.lnLeft>></wp:posOffset>
		            </wp:positionH>
		            <wp:positionV relativeFrom="margin">
		                <wp:posOffset><<m.lnTop>></wp:posOffset>
		            </wp:positionV>
		            <wp:extent cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		            <wp:effectExtent l="0" t="0" r="0" b="0"/>
		            <wp:wrapNone />
		            <wp:docPr id="<<m.loRepObj.ObjID>>" name="Field<<m.loRepObj.ObjID>>" />
		            <wp:cNvGraphicFramePr>
		                <a:graphicFrameLocks
		                    xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" 
		                    noDrilldown="1" noSelect="1" noMove="1" noResize="1"/>
		            </wp:cNvGraphicFramePr>
		            <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
		                <a:graphicData uri="http://schemas.microsoft.com/office/word/2010/wordprocessingShape">
		                    <wps:wsp>
		                        <wps:cNvSpPr txBox="1">
		                            <a:spLocks noChangeArrowheads="1" />
		                        </wps:cNvSpPr>
		                        <wps:spPr bwMode="auto">
		                            <a:xfrm rot="<<m.lnRotate>>">
		                                <a:off x="0" y="0" />
		                                <a:ext cx="<<m.lnWidth>>" cy="<<m.lnHeight>>" />
		                            </a:xfrm>
		                            <a:prstGeom prst="rect">
		                                <a:avLst />
		                            </a:prstGeom>
		                            <<m.lcFill>>
		                            <a:ln w="9525">
		                                <a:noFill />
		                                <a:miter lim="800%" />
		                                <a:headEnd />
		                                <a:tailEnd />
		                            </a:ln>
		                        </wps:spPr>
		                        <wps:txbx>
		                            <w:txbxContent>
		                                <<m.lcText>>
		                            </w:txbxContent>
		                        </wps:txbx>
		                        <wps:bodyPr rot="0" vert="horz" wrap="square" lIns="0" tIns="0" rIns="0" bIns="0" anchor="t" anchorCtr="0">
		                            <a:noAutofit />
		                        </wps:bodyPr>
		                    </wps:wsp>
		                </a:graphicData>
		            </a:graphic>
		        </wp:anchor>
		    </w:drawing>
		    ENDTEXT
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_content_types
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		        
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
		        <Default Extension="jpg" ContentType="image/jpeg" />
		        <Default Extension="png" ContentType="image/png" />
		        <Default Extension="odttf"
		            ContentType="application/vnd.openxmlformats-officedocument.obfuscatedFont" />
		        <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
		        <Default Extension="xml" ContentType="application/xml" />
		        <Override PartName="/word/document.xml"
		            ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml" />
		        <Override PartName="/word/styles.xml"
		            ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml" />
		        <Override PartName="/word/settings.xml"
		            ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml" />
		        <Override PartName="/word/webSettings.xml"
		            ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml" />
		        <Override PartName="/word/fontTable.xml"
		            ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml" />
		        <Override PartName="/docProps/core.xml"
		            ContentType="application/vnd.openxmlformats-package.core-properties+xml" />
		        <Override PartName="/docProps/app.xml"
		            ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml" />
		    </Types>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "[Content_Types].xml", m.lcXml, LEN(m.lcXml))
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_docprops
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		        
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties"
		        xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
		        <Template>Normal.dotm</Template>
		        <Application>Microsoft Office Word</Application>
		        <DocSecurity>0</DocSecurity>
		        <ScaleCrop>false</ScaleCrop>
		        <Company></Company>
		        <LinksUpToDate>false</LinksUpToDate>
		        <SharedDoc>false</SharedDoc>
		        <HyperlinksChanged>false</HyperlinksChanged>
		        <AppVersion>16.0000</AppVersion>
		    </Properties>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "docProps/app.xml", m.lcXml, LEN(m.lcXml))
		
		
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <cp:coreProperties
		        xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"
		        xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/"
		        xmlns:dcmitype="http://purl.org/dc/dcmitype/"
		        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		        <dc:creator></dc:creator>
		        <cp:lastModifiedBy></cp:lastModifiedBy>
		        <cp:revision>3</cp:revision>
		        <dcterms:created xsi:type="dcterms:W3CDTF"><<TTOC(DATETIME(),3)>>Z</dcterms:created>
		        <dcterms:modified xsi:type="dcterms:W3CDTF"><<TTOC(DATETIME(),3)>>Z</dcterms:modified>
		    </cp:coreProperties>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "docProps/core.xml", m.lcXml, LEN(m.lcXml))
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_document
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		    
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml ADDITIVE NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <w:document xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas"
		        xmlns:cx="http://schemas.microsoft.com/office/drawing/2014/chartex"
		        xmlns:cx1="http://schemas.microsoft.com/office/drawing/2015/9/8/chartex"
		        xmlns:cx2="http://schemas.microsoft.com/office/drawing/2015/10/21/chartex"
		        xmlns:cx3="http://schemas.microsoft.com/office/drawing/2016/5/9/chartex"
		        xmlns:cx4="http://schemas.microsoft.com/office/drawing/2016/5/10/chartex"
		        xmlns:cx5="http://schemas.microsoft.com/office/drawing/2016/5/11/chartex"
		        xmlns:cx6="http://schemas.microsoft.com/office/drawing/2016/5/12/chartex"
		        xmlns:cx7="http://schemas.microsoft.com/office/drawing/2016/5/13/chartex"
		        xmlns:cx8="http://schemas.microsoft.com/office/drawing/2016/5/14/chartex"
		        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		        xmlns:aink="http://schemas.microsoft.com/office/drawing/2016/ink"
		        xmlns:am3d="http://schemas.microsoft.com/office/drawing/2017/model3d"
		        xmlns:o="urn:schemas-microsoft-com:office:office"
		        xmlns:oel="http://schemas.microsoft.com/office/2019/extlst"
		        xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
		        xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
		        xmlns:v="urn:schemas-microsoft-com:vml"
		        xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing"
		        xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
		        xmlns:w10="urn:schemas-microsoft-com:office:word"
		        xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
		        xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
		        xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml"
		        xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex"
		        xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid"
		        xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml"
		        xmlns:w16du="http://schemas.microsoft.com/office/word/2023/wordml/word16du"
		        xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash"
		        xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex"
		        xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup"
		        xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk"
		        xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml"
		        xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
		        mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du wp14"
		        w:conformance="strict">
		        <w:body>
		    ENDTEXT
		
		    LOCAL loPage, liPage, lcSectPr, lcSectPrDefault
		    m.liPage = 0
		    m.lcSectPr = ""
		    m.lcSectPrDefault = ""
		    FOR EACH m.loPage IN This.Pages FOXOBJECT
		        m.liPage = m.liPage + 1
		        
		        TEXT TO m.lcSectPr TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <w:sectPr>
		            <w:pgSz w:w="<<m.loPage.PageWidth>>pt" w:h="<<m.loPage.PageHeight>>pt" w:orient="<<IIF(m.loPage.PageWidth > m.loPage.PageHeight, 'landscape', 'portrait')>>" />
		            <w:pgMar w:top="18pt" w:right="0pt" w:bottom="0pt" w:left="12.25pt" w:header="0pt" w:footer="0pt" w:gutter="0pt" />
		            <w:cols w:space="36pt" />
		        </w:sectPr>
		        ENDTEXT
		        
		        IF m.liPage = This.Pages.Count
		            m.lcSectPrDefault = m.lcSectPr
		            m.lcSectPr = ""
		        ENDIF
		        
		        TEXT TO m.lcXml ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <<m.loPage.ContentXML>>
		        <w:p>
		            <w:pPr>
		                <w:pStyle w:val="Default" />
		                <<m.lcSectPr>>
		            </w:pPr>
		        </w:p>
		        ENDTEXT
		    ENDFOR
		
		    IF EMPTY(m.lcSectPrDefault) = .T.
		        TEXT TO m.lcSectPrDefault NOSHOW FLAGS 1 PRETEXT 15
		        <w:sectPr>
		            <w:pgSz w:w="595.20pt" w:h="841.80pt" w:orient="portrait" />
		            <w:pgMar w:top="18pt" w:right="0pt" w:bottom="0pt" w:left="12.25pt" w:header="0pt" w:footer="0pt" w:gutter="0pt" />
		            <w:cols w:space="36pt" />
		        </w:sectPr>
		        ENDTEXT
		    ENDIF
		
		    TEXT TO m.lcXml ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		            <<m.lcSectPrDefault>>
		        </w:body>
		    </w:document>
		    ENDTEXT
		
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/document.xml", m.lcXml, LEN(m.lcXml))
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_fonttable
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		    
		    LOCAL lcFontsXml
		    m.lcFontsXml = ""
		
		    LOCAL loFont
		    FOR EACH m.loFont IN This.Fonts FOXOBJECT
		
		        LOCAL lcFontEmbedXML
		        m.lcFontEmbedXML = ""
		        IF VARTYPE(m.loFont.FontFile) = "O" 
		            TEXT TO m.lcFontEmbedXML TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		            <w:embedRegular r:id="<<m.loFont.FontFile.rid>>" w:subsetted="1"/>
		            <w:embedBold r:id="<<m.loFont.FontFile.rid>>" w:subsetted="1"/>    
		            ENDTEXT
		        ENDIF
		
		        TEXT TO m.lcFontsXml ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <w:font w:name="<<This.XmlEscape(STRCONV(m.loFont.name,9))>>">
		            <w:family w:val="auto" />
		            <w:pitch w:val="variable" />
		            <<m.lcFontEmbedXML>>
		        </w:font>
		        ENDTEXT
		    ENDFOR
		
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <w:fonts xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		        xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
		        xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
		        xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
		        xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml"
		        xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex"
		        xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid"
		        xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml"
		        xmlns:w16du="http://schemas.microsoft.com/office/word/2023/wordml/word16du"
		        xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash"
		        xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex"
		        mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du">
		        <<m.lcFontsXml>>
		    </w:fonts>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/fontTable.xml", m.lcXml, LEN(m.lcXml))
		
		    LOCAL lcFontRelsXml
		    m.lcFontRelsXml = ""
		
		    LOCAL loFontFile
		    FOR EACH m.loFontFile IN This.FontFiles FOXOBJECT
		        TEXT TO m.lcFontRelsXml ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <Relationship Id="<<m.loFontFile.rid>>"
		            Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/font"
		            Target="fonts/<<This.XmlEscape(STRCONV(m.loFontFile.FontFileName,9))>>" />
		        ENDTEXT
		    ENDFOR
		
		    IF EMPTY(m.lcFontRelsXml) = .F.
		        LOCAL lcXml
		        m.lcXml = ""
		
		        TEXT TO m.lcXml TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		        <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
		            <<m.lcFontRelsXml>>
		        </Relationships>
		        ENDTEXT
		
		        This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/_rels/fontTable.xml.rels", m.lcXml, LEN(m.lcXml))
		    ENDIF
		    
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_rels
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		    
		    LOCAL lcXml
		    m.lcXml = ""
		    TEXT TO m.lcXml NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
		        <Relationship Id="rId3"
		            Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties"
		            Target="docProps/app.xml" />
		        <Relationship Id="rId2"
		            Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties"
		            Target="docProps/core.xml" />
		        <Relationship Id="rId1"
		            Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument"
		            Target="word/document.xml" />
		    </Relationships>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "_rels/.rels", m.lcXml, LEN(m.lcXml))
		
		    LOCAL lcXml
		    m.lcXml = ""
		    TEXT TO m.lcXml ADDITIVE NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
		    ENDTEXT
		
		    LOCAL loRel
		    FOR EACH m.loRel IN This.DocRels FOXOBJECT
		        TEXT TO m.lcXml ADDITIVE TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		        <Relationship Id="<<This.XmlEscape(m.loRel.Id)>>" 
		            Type="<<This.XmlEscape(m.loRel.Type)>>" 
		            Target="<<This.XmlEscape(m.loRel.Target)>>" />
		        ENDTEXT
		    ENDFOR
		
		    TEXT TO m.lcXml ADDITIVE NOSHOW FLAGS 1 PRETEXT 15
		    </Relationships>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/_rels/document.xml.rels", m.lcXml, LEN(m.lcXml))
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_settings
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		    
		    LOCAL llFontEmbed
		    m.llFontEmbed = (This.FontFiles.Count > 0)
		    
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <w:settings xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		        xmlns:o="urn:schemas-microsoft-com:office:office"
		        xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
		        xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
		        xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w10="urn:schemas-microsoft-com:office:word"
		        xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
		        xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
		        xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml"
		        xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex"
		        xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid"
		        xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml"
		        xmlns:w16du="http://schemas.microsoft.com/office/word/2023/wordml/word16du"
		        xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash"
		        xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex"
		        xmlns:sl="http://schemas.openxmlformats.org/schemaLibrary/2006/main"
		        mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du">
		        <w:zoom w:percent="100" />
		        <w:embedTrueTypeFonts w:val="<<IIF(m.llFontEmbed, 1, 0)>>" />
		        <w:embedSystemFonts w:val="0" />
		        <w:saveSubsetFonts w:val="<<IIF(m.llFontEmbed, 1, 0)>>" />
		        <w:proofState w:grammar="clean" />
		        <w:defaultTabStop w:val="720" />
		        <w:autoHyphenation w:val="0" />
		        <w:characterSpacingControl w:val="doNotCompress" />
		        <w:compat>
		            <w:compatSetting w:name="compatibilityMode" w:uri="http://schemas.microsoft.com/office/word"
		                w:val="15" />
		            <w:compatSetting w:name="overrideTableStyleFontSizeAndJustification"
		                w:uri="http://schemas.microsoft.com/office/word" w:val="1" />
		            <w:compatSetting w:name="enableOpenTypeFeatures"
		                w:uri="http://schemas.microsoft.com/office/word" w:val="1" />
		            <w:compatSetting w:name="doNotFlipMirrorIndents"
		                w:uri="http://schemas.microsoft.com/office/word" w:val="1" />
		            <w:compatSetting w:name="differentiateMultirowTableHeaders"
		                w:uri="http://schemas.microsoft.com/office/word" w:val="1" />
		            <w:compatSetting w:name="useWord2013TrackBottomHyphenation"
		                w:uri="http://schemas.microsoft.com/office/word" w:val="1" />
		        </w:compat>
		    </w:settings>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/settings.xml", m.lcXml, LEN(m.lcXml))
		
		    LOCAL lcXml
		    m.lcXml = ""
		
		    TEXT TO m.lcXml NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <w:webSettings xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		        xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
		        xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
		        xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
		        xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml"
		        xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex"
		        xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid"
		        xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml"
		        xmlns:w16du="http://schemas.microsoft.com/office/word/2023/wordml/word16du"
		        xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash"
		        xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex"
		        mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du">
		        <w:optimizeForBrowser />
		        <w:allowPNG />
		    </w:webSettings>
		    ENDTEXT
		
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/webSettings.xml", m.lcXml, LEN(m.lcXml))
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE write_styles
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		    
		    LOCAL lcXml
		    m.lcXml = ""
		
		
		    TEXT TO m.lcXml TEXTMERGE NOSHOW FLAGS 1 PRETEXT 15
		    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		    <w:styles xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		        xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
		        xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
		        xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
		        xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml"
		        xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex"
		        xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid"
		        xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml"
		        xmlns:w16du="http://schemas.microsoft.com/office/word/2023/wordml/word16du"
		        xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash"
		        xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex"
		        mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du">
		        <w:docDefaults>
		            <w:rPrDefault>
		                <w:rPr>
		                    <w:rFonts w:asciiTheme="minorHAnsi" w:eastAsiaTheme="minorHAnsi" w:hAnsiTheme="minorHAnsi" w:cstheme="minorBidi" />
		                    <w:kern w:val="2" />
		                    <w:sz w:val="16" />
		                    <w:szCs w:val="16" />
		                    <w14:ligatures w14:val="standardContextual" />
		                </w:rPr>
		            </w:rPrDefault>
		            <w:pPrDefault>
		                <w:pPr>
		                    <w:spacing w:after="0" w:line="240" w:lineRule="auto"/>
		                </w:pPr>
		            </w:pPrDefault>
		        </w:docDefaults>
		        <w:latentStyles w:defLockedState="0" w:defUIPriority="99" w:defSemiHidden="0"
		            w:defUnhideWhenUsed="0" w:defQFormat="0" w:count="376">
		            <w:lsdException w:name="Normal" w:uiPriority="0" w:qFormat="1" />
		            <w:lsdException w:name="Default Paragraph Font" w:semiHidden="1" w:uiPriority="1" w:unhideWhenUsed="1" />
		        </w:latentStyles>
		        <w:style w:type="paragraph" w:default="1" w:styleId="a">
		            <w:name w:val="Normal" />
		            <w:qFormat />
		        </w:style>
		        <w:style w:type="character" w:default="1" w:styleId="a0">
		            <w:name w:val="Default Paragraph Font" />
		            <w:uiPriority w:val="1" />
		            <w:semiHidden />
		            <w:unhideWhenUsed />
		        </w:style>
		        <w:style w:type="paragraph" w:customStyle="1" w:styleId="Default">
		            <w:name w:val="_Default" />
		            <w:pPr>
		                <w:suppressAutoHyphens />
		            </w:pPr>
		        </w:style>
		    </w:styles>
		    ENDTEXT
		    
		    
		    This.env.API_FPDF.VFPDF_AddFileToZipInput(This.vfpdf_zip_input, "word/styles.xml", m.lcXml, LEN(m.lcXml))
		
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE xmlescape
		LPARAMETERS lcText
		
		RETURN STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(m.lcText, "<", "&lt;"), ">", "&gt;"), "&", "&amp;"), '"', "&quot;"), "'", "&apos;")
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport_renderer_pdf AS pdfiumreport_renderer_base OF "pdfiumreport.vcx" 		&& PDF rendering implementation
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: closepdf
		*m: createpdf
		*m: encrypt
		*m: getfontpdf
		*m: hash_md5
		*m: render_frxfield
		*m: render_frxlabel
		*m: render_frxline
		*m: render_frxpicture
		*m: render_frxrectangle
		*m: render_text
		*m: render_textasimage
		*p: fpdf_doc
		*p: fpdf_fonts		&& Font collection for caching purporses
		*p: fpdf_pagecount
		*p: pdftemplateheap
		*p: pdftemplateptr
		*a: fpdf_pages[1,0]
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,fpdf_doc,fpdf_fonts,fpdf_pagecount,fpdf_pages,HelpContextID,NewObject,Objects,pdftemplateheap,pdftemplateptr,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,WriteExpression,WriteMethod
	*<PropValue>
		fpdf_doc = 0
		fpdf_fonts = .F.
		fpdf_pagecount = 0
		Name = "pdfiumreport_renderer_pdf"
		pdftemplateheap = 0
		pdftemplateptr = 0
		_memberdata = <VFPData>
			<memberdata name="closepdf" type="method" display="ClosePDF"/>
			<memberdata name="createpdf" type="method" display="CreatePDF"/>
			<memberdata name="getfontpdf" type="method" display="GetFontPDF"/>
			<memberdata name="render_frxfield" type="method" display="Render_FrxField"/>
			<memberdata name="render_frxlabel" type="method" display="Render_FrxLabel"/>
			<memberdata name="render_frxline" type="method" display="Render_FrxLine"/>
			<memberdata name="render_frxpicture" type="method" display="Render_FrxPicture"/>
			<memberdata name="render_frxrectangle" type="method" display="Render_FrxRectangle"/>
			<memberdata name="render_text" type="method" display="Render_Text"/>
			<memberdata name="render_textasimage" type="method" display="Render_TextAsImage"/>
			<memberdata name="fpdf_doc" type="property" display="fpdf_doc"/>
			<memberdata name="fpdf_fonts" type="property" display="fpdf_fonts"/>
			<memberdata name="fpdf_pagecount" type="property" display="fpdf_pagecount"/>
			<memberdata name="fpdf_pages" type="property" display="fpdf_pages"/>
			<memberdata name="hash_md5" type="method" display="Hash_MD5"/>
			<memberdata name="encrypt" type="method" display="Encrypt"/>
			<memberdata name="pdftemplateheap" type="property" display="PDFTemplateHeap"/>
			<memberdata name="pdftemplateptr" type="property" display="PDFTemplatePtr"/>
		</VFPData>
		API_FRX.CONST.Name = "CONST"
		API_FRX.Name = "API_FRX"
	*</PropValue>
	
	PROCEDURE begin
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
		This.CreatePDF(m.loPDFMeta)
		
	ENDPROC

	HIDDEN PROCEDURE closepdf
		IF EMPTY(This.fpdf_doc)
		    RETURN
		ENDIF
		
		**************************************************
		* Release resources
		**************************************************
		LOCAL liPage, lnPage
		m.liPage = 1 
		FOR m.liPage = 1 TO This.fpdf_pagecount
		    m.lnPage = This.fpdf_pages[m.liPage]
		    IF EMPTY(m.lnPage) = .F.
		        This.env.API_FPDF.FPDF_ClosePage(m.lnPage)
		    ENDIF
		ENDFOR
		
		
		LOCAL lnPDFFont
		FOR EACH m.lnPDFFont IN This.fpdf_fonts FOXOBJECT
		    IF EMPTY(m.lnPDFFont) = .F.
		        This.env.API_FPDF.FPDFFont_Close(m.lnPDFFont)
		    ENDIF
		ENDFOR
		
		
		This.env.API_FPDF.FPDF_CloseDocument(This.fpdf_doc)
		
		
		DIMENSION This.fpdf_pages(1)
		This.fpdf_pages[1] = 0
		
		This.fpdf_pagecount = 0
		This.fpdf_doc = 0
		This.fpdf_fonts = .F.
		
		
		IF EMPTY(This.PDFTemplatePtr)=.F.
		    This.env.API_WIN.HeapFree(This.PDFTemplateHeap, 0, This.PDFTemplatePtr)
		    This.PDFTemplatePtr = 0 
		ENDIF
		
		IF EMPTY(This.PDFTemplateHeap)=.F.
		    This.env.API_WIN.HeapDestroy(This.PDFTemplateHeap)
		    This.PDFTemplateHeap = 0 
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE createpdf
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
		This.ClosePDF()
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		This.fpdf_fonts = NEWOBJECT("Collection")
		
		#define PWD_PAD 0h28BF4E5E4E758A4164004E56FFFA01082E2E00B6D0683E802F0CA9FE6453697A
		#define PWD_LEN 32
		
		LOCAL lSaveTextmerge
		m.lSaveTextmerge = SET("Textmerge")
		
		TRY
		    SET TEXTMERGE OFF
		    
		    IF VARTYPE(m.loPDFMeta) != "O"
		        This.fpdf_doc = m.loFPDF.FPDF_CreateNewDocument()
		
		        IF EMPTY(This.fpdf_doc)
		            ERROR "FPDF_CreateNewDocument returned empty value"
		        ENDIF
		
		        EXIT
		    ENDIF
		
		    *******************************************************
		    LOCAL lcFileID
		    m.lcFileID = ""
		    This.Hash_MD5(;
		        BINTOC(DATETIME() - DATETIME(1970,1,1,0,0,0), "4RS") + ;
		        TRANSFORM(NVL(m.loPDFMeta.Author,"")) + ;
		        TRANSFORM(NVL(m.loPDFMeta.Creator,"")) + ;
		        TRANSFORM(NVL(m.loPDFMeta.Producer,"")) + ;
		        TRANSFORM(NVL(m.loPDFMeta.Title,"")) + ;
		        TRANSFORM(NVL(m.loPDFMeta.Subject,"")) + ;
		        TRANSFORM(NVL(m.loPDFMeta.Keywords,"")) ;
		        , @m.lcFileID)
		        
		
		
		    *******************************************************    
		
		    LOCAL lcOwnerPassword, lcUserPassword
		    m.lcUserPassword = NVL(m.loPDFMeta.UserPassword,"")
		    m.lcOwnerPassword = EVL(NVL(m.loPDFMeta.OwnerPassword,""), m.lcUserPassword)
		
		    IF LEN(m.lcUserPassword) > PWD_LEN
		        ERROR TEXTMERGE("User password cannot be more than <<PWD_LEN>> characters")
		    ENDIF
		
		    IF LEN(m.lcOwnerPassword) > PWD_LEN
		        ERROR TEXTMERGE("Owner password cannot be more than <<PWD_LEN>> characters")
		    ENDIF
		
		    LOCAL llEncrypt
		    m.llEncrypt = (LEN(m.lcOwnerPassword) = 0 AND LEN(m.lcUserPassword) = 0) = .F.
		
		
		    IF m.llEncrypt
		        LOCAL lnPermit as Integer
		        m.lnPermit = BITCLEAR(BITCLEAR(0xFFFFFFFF,0),1)
		        m.lnPermit = IIF(m.loPDFMeta.Permit_Print, m.lnPermit, BITCLEAR(m.lnPermit,2))
		        m.lnPermit = IIF(m.loPDFMeta.Permit_Edit_All, m.lnPermit, BITCLEAR(m.lnPermit,3))
		        m.lnPermit = IIF(m.loPDFMeta.Permit_Copy, m.lnPermit, BITCLEAR(m.lnPermit,4))
		        m.lnPermit = IIF(m.loPDFMeta.Permit_Edit, m.lnPermit, BITCLEAR(m.lnPermit,5)) 
		
		        m.lcUserPassword = LEFT(m.lcUserPassword + PWD_PAD, PWD_LEN)
		        m.lcOwnerPassword = LEFT(m.lcOwnerPassword + PWD_PAD, PWD_LEN)
		
		
		        LOCAL lcOwnerPasswordHash, lcOwnerKey
		        STORE "" TO m.lcOwnerPasswordHash, m.lcOwnerKey
		        This.Hash_MD5(m.lcOwnerPassword, @m.lcOwnerPasswordHash)
		        
		        LOCAL liRepeat
		        FOR m.liRepeat = 1 TO 50
		            This.Hash_MD5(m.lcOwnerPasswordHash, @m.lcOwnerPasswordHash)
		        ENDFOR
		        
		        
		        m.lcOwnerKey = LEFT(m.lcOwnerPasswordHash, PWD_LEN)
		        This.Encrypt("RC4", m.lcUserPassword, m.lcOwnerKey,  @m.lcOwnerKey)
		        
		        LOCAL i
		        FOR m.i = 1 TO 19
		            LOCAL j, lcTempKey
		            m.lcTempKey = ""
		            FOR m.j = 1 TO LEN(m.lcOwnerPasswordHash)
		                m.lcTempKey = m.lcTempKey + BINTOC(BITXOR(CTOBIN(SUBSTR(m.lcOwnerPasswordHash, m.j, 1), "1"), m.i), "1")
		            ENDFOR
		            
		            This.Encrypt("RC4", m.lcOwnerKey, m.lcTempKey,  @m.lcOwnerKey)
		        ENDFOR
		        
		
		        LOCAL lcEncryptionKey
		        STORE "" TO m.lcEncryptionKey
		        This.Hash_MD5(;
		            m.lcUserPassword +;
		            m.lcOwnerKey + ;
		            BINTOC(m.lnPermit,"4RS") +;
		            m.lcFileID, ;
		            @m.lcEncryptionKey)
		            
		        LOCAL liRepeat
		        FOR m.liRepeat = 1 TO 50
		            This.Hash_MD5(LEFT(m.lcEncryptionKey, 16), @m.lcEncryptionKey)
		        ENDFOR
		        
		        
		        LOCAL lcUserHash, lcUserKey
		        STORE "" TO m.lcUserHash, m.lcUserKey
		        This.Hash_MD5(;
		            PWD_PAD + ;
		            m.lcFileID, ;
		            @m.lcUserHash)
		
		        This.Encrypt("RC4", m.lcUserHash, m.lcEncryptionKey,  @m.lcUserKey)
		        
		        LOCAL i
		        FOR m.i = 1 TO 19
		            LOCAL j, lcTempKey
		            m.lcTempKey = ""
		            FOR m.j = 1 TO LEN(m.lcEncryptionKey)
		                m.lcTempKey = m.lcTempKey + BINTOC(BITXOR(CTOBIN(SUBSTR(m.lcEncryptionKey, m.j, 1), "1"), m.i), "1")
		            ENDFOR
		            
		            This.Encrypt("RC4", m.lcUserKey, m.lcTempKey,  @m.lcUserKey)
		        ENDFOR
		        
		        m.lcUserKey = PADR(m.lcUserKey, PWD_LEN, CHR(0))
		
		
		        LOCAL lnInfoObjId, lnInfoObjGen, lcInfoObjEncryptionKey
		        m.lnInfoObjId = 4
		        m.lnInfoObjGen = 0
		        m.lcInfoObjEncryptionKey = m.lcEncryptionKey
		        m.lcInfoObjEncryptionKey = m.lcInfoObjEncryptionKey + CHR(BITAND(m.lnInfoObjId, 0xFF))
		        m.lcInfoObjEncryptionKey = m.lcInfoObjEncryptionKey + CHR(BITAND(BITRSHIFT(m.lnInfoObjId, 8), 0xFF))
		        m.lcInfoObjEncryptionKey = m.lcInfoObjEncryptionKey + CHR(BITAND(BITRSHIFT(m.lnInfoObjId, 16), 0xFF))
		        m.lcInfoObjEncryptionKey = m.lcInfoObjEncryptionKey + CHR(BITAND(m.lnInfoObjGen, 0xFF))
		        m.lcInfoObjEncryptionKey = m.lcInfoObjEncryptionKey + CHR(BITAND(BITRSHIFT(m.lnInfoObjGen, 8), 0xFF))
		        
		        This.Hash_MD5(m.lcInfoObjEncryptionKey, @m.lcInfoObjEncryptionKey)
		
		    ENDIF
		
		    LOCAL lcPDFInfo, laPDFInfoTags(6), lcPDFInfoTag, liPDFInfoTag, lcPDFInfoTagValue, lcPDFInfoTagValueUTF16
		    m.lcPDFInfo = ""
		    m.laPDFInfoTags[1] = "Title"
		    m.laPDFInfoTags[2] = "Author"
		    m.laPDFInfoTags[3] = "Subject"
		    m.laPDFInfoTags[4] = "Keywords"
		    m.laPDFInfoTags[5] = "Creator"
		    m.laPDFInfoTags[6] = "Producer"
		
		    m.liPDFInfoTag = 1
		    FOR m.liPDFInfoTag = 1 TO ALEN(m.laPDFInfoTags,1)
		        m.lcPDFInfoTag = m.laPDFInfoTags[m.liPDFInfoTag]
		        IF PEMSTATUS(m.loPDFMeta, m.lcPDFInfoTag, 5) = .F.
		            LOOP
		        ENDIF
		        
		        m.lcPDFInfoTagValue = m.loPDFMeta.&lcPDFInfoTag
		        
		        IF EMPTY(m.lcPDFInfoTagValue) = .T.
		            LOOP
		        ENDIF
		        
		        
		        m.lcPDFInfoTagValueUTF16 = ""
		        LOCAL i
		        FOR m.i = 1 TO LEN(m.lcPDFInfoTagValue)
		            m.lcPDFInfoTagValueUTF16 = m.lcPDFInfoTagValueUTF16 + BINTOC(CTOBIN(STRCONV(SUBSTR(m.lcPDFInfoTagValue,m.i,1),5), "2RS"), "2S")
		        ENDFOR
		        
		        m.lcPDFInfoTagValueUTF16 = 0hFEFF + m.lcPDFInfoTagValueUTF16
		        
		        IF m.llEncrypt
		            This.Encrypt("RC4", m.lcPDFInfoTagValueUTF16, m.lcInfoObjEncryptionKey,  @m.lcPDFInfoTagValueUTF16)
		        ENDIF
		        
		        m.lcPDFInfo = m.lcPDFInfo + TEXTMERGE("/{m.lcPDFInfoTag} <{STRCONV(m.lcPDFInfoTagValueUTF16, 15)}>", .F., "{", "}")
		        
		    ENDFOR
		
		    LOCAL ldtNow, lcCreationDate
		    m.ldtNow = DATETIME()
		    m.lcCreationDate = TEXTMERGE("D:<<TTOC(m.ldtNow,1)>>")
		
		    IF m.llEncrypt
		        This.Encrypt("RC4", m.lcCreationDate, m.lcInfoObjEncryptionKey,  @m.lcCreationDate)
		    ENDIF
		    m.lcCreationDate = "<" + STRCONV(m.lcCreationDate,15) + ">"    
		
		
		    *******************************************************    
		    LOCAL loPDFTemplate
		    m.loPDFTemplate = NEWOBJECT("Collection")
		    m.loPDFTemplate.Add("%PDF-1.7")
		    m.loPDFTemplate.Add("1 0 obj<</Pages 2 0 R>>endobj")
		    m.loPDFTemplate.Add("2 0 obj<</Kids[3 0 R]/Count 1>>endobj")
		    m.loPDFTemplate.Add("3 0 obj<</Parent 2 0 R>>endobj")
		    m.loPDFTemplate.Add(TEXTMERGE("4 0 obj<<{ m.lcPDFInfo }/CreationDate { m.lcCreationDate }/ModDate { m.lcCreationDate }>>endobj", .F., "{", "}"))
		
		    IF m.llEncrypt        
		        LOCAL lcPDFEncrypt
		        TEXT TO m.lcPDFEncrypt ADDITIVE NOSHOW FLAGS 1 PRETEXT 3
		        5 0 obj
		        <<
		        /Filter /Standard
		        /V 2
		        /Length 128
		        /R 3
		        /O { "<" + STRCONV(m.lcOwnerKey,15) + ">" }
		        /U { "<" + STRCONV(m.lcUserKey,15) + ">" }
		        /P {m.lnPermit}
		        >> endobj
		        ENDTEXT
		        
		        m.loPDFTemplate.Add(TEXTMERGE(m.lcPDFEncrypt, .F., "{", "}"))
		    ENDIF
		
		    LOCAL lcPDFTemplate
		    m.lcPDFTemplate = ""
		
		    LOCAL lcXRef, m.lnXRefCount
		    m.lcXRef = "0000000000 65535 f"
		    m.lnXRefCount = 1
		
		    LOCAL lcPDFLine
		    FOR EACH m.lcPDFLine IN m.loPDFTemplate FOXOBJECT
		        IF LEFT(m.lcPDFLine,1) != '%'
		            m.lnXRefCount = m.lnXRefCount + 1
		            m.lcXRef = m.lcXRef + CHR(13)+CHR(10) + PADL(TRANSFORM(LEN(m.lcPDFTemplate)), 10, '0') + " 00000 n"
		        ENDIF
		        m.lcPDFTemplate = m.lcPDFTemplate + m.lcPDFLine + CHR(13)+CHR(10)
		    ENDFOR
		
		    LOCAL lnStartXRef
		    m.lnStartXRef = LEN(m.lcPDFTemplate)
		
		    TEXT TO m.lcPDFTemplate ADDITIVE NOSHOW FLAGS 1 PRETEXT 3
		    xref
		    0 { m.lnXRefCount }
		    { m.lcXREF }
		    trailer
		    <<
		    /Root 1 0 R
		    /Info 4 0 R
		    { IIF(m.llEncrypt, "/Encrypt 5 0 R", "") }
		    /Size { m.lnXRefCount }
		    /ID { "[<" + STRCONV(m.lcFileID, 15) + "> <" + STRCONV(m.lcFileID, 15) + ">]" }
		    >>
		    startxref
		    { m.lnStartXRef }
		    %%EOF
		    ENDTEXT
		     
		    m.lcPDFTemplate = TEXTMERGE(m.lcPDFTemplate, .F., "{", "}")
		
		    LOCAL lnPDFTemplateSize
		    m.lnPDFTemplateSize = LEN(m.lcPDFTemplate)
		    
		
		    This.PDFTemplateHeap = This.env.API_WIN.HeapCreate(0, m.lnPDFTemplateSize, 0)
		    IF EMPTY(This.PDFTemplateHeap)
		        EXIT
		    ENDIF
		
		    This.PDFTemplatePtr = This.env.API_WIN.HeapAlloc(This.PDFTemplateHeap, 0, m.lnPDFTemplateSize)
		    IF EMPTY(This.PDFTemplatePtr)
		        EXIT
		    ENDIF
		
		    SYS(2600, This.PDFTemplatePtr, m.lnPDFTemplateSize, m.lcPDFTemplate)
		
		
		    This.fpdf_doc = m.loFPDF.FPDF_LoadMemDocument(This.PDFTemplatePtr, m.lnPDFTemplateSize, NVL(m.loPDFMeta.UserPassword,"")) 
		
		    IF EMPTY(This.fpdf_doc)
		        ERROR "FPDF_LoadMemDocument returned empty value"
		    ENDIF
		
		    m.loFPDF.FPDFPage_Delete(This.fpdf_doc,0)
		    
		    
		FINALLY
		    SET TEXTMERGE &lSaveTextmerge
		
		    IF EMPTY(This.PDFTemplatePtr)=.F. AND EMPTY(This.fpdf_doc)
		        This.env.API_WIN.HeapFree(This.PDFTemplateHeap, 0, This.PDFTemplatePtr)
		        This.PDFTemplatePtr = 0 
		    ENDIF
		
		    IF EMPTY(This.PDFTemplateHeap)=.F. AND EMPTY(This.fpdf_doc)
		        This.env.API_WIN.HeapDestroy(This.PDFTemplateHeap)
		        This.PDFTemplateHeap = 0 
		    ENDIF
		
		ENDTRY
		
		
	ENDPROC

	PROCEDURE Destroy
		DODEFAULT()
		
		This.ClosePDF()
		
		This.env = .F.
		
	ENDPROC

	HIDDEN PROCEDURE encrypt
		LPARAMETERS tcAlgorithm, tcData, tcKey, lcDataEncrypted
		
		lcDataEncrypted = ""
		
		LOCAL loWin
		m.loWin = This.env.API_WIN
		
		
		#define BCRYPT_BLOCK_PADDING  0x00000001
		
		LOCAL lnAlg, lnKey
		STORE 0 TO m.lnAlg, m.lnKey
		
		LOCAL llRes
		llRes = .F.
		
		TRY
		    IF m.loWin.BCryptOpenAlgorithmProvider(@m.lnAlg, STRCONV(m.tcAlgorithm+CHR(0),5), NULL, 0) != 0
		        EXIT
		    ENDIF
		
		    IF m.loWin.BCryptGenerateSymmetricKey(m.lnAlg, @m.lnKey, NULL, 0, @m.tcKey, LEN(m.tcKey), 0) != 0
		        EXIT
		    ENDIF
		
		    LOCAL lnSize
		    m.lnSize = 0
		    IF m.loWin.BCryptEncrypt(m.lnKey, m.tcData, LEN(m.tcData), NULL, NULL, 0, NULL, 0, @m.lnSize, BCRYPT_BLOCK_PADDING) != 0
		        EXIT
		    ENDIF
		
		
		    m.lcDataEncrypted = REPLICATE(CHR(0), m.lnSize)
		    
		    IF m.loWin.BCryptEncrypt(m.lnKey, m.tcData, LEN(m.tcData), NULL, NULL, 0, @m.lcDataEncrypted, LEN(m.lcDataEncrypted), @m.lnSize, BCRYPT_BLOCK_PADDING) != 0
		       EXIT
		    ENDIF
		    
		    m.llRes = .T.
		
		FINALLY
		    IF EMPTY(m.lnKey) = .F.
		        m.loWin.BCryptDestroyKey(m.lnKey)
		        m.lnKey = 0
		    ENDIF
		
		    IF EMPTY(m.lnAlg) = .F.
		        m.loWin.BCryptCloseAlgorithmProvider(m.lnAlg, 0)
		        m.lnAlg = 0
		    ENDIF
		ENDTRY
		
		IF m.llRes = .F.
		    m.lcDataEncrypted = ""
		ENDIF
		
		RETURN m.llRes
		
		
	ENDPROC

	PROCEDURE finalize
		LPARAMETERS loPDFMeta as pdfium_pdfmeta of pdfium-vfp.vcx
		
		IF EMPTY(This.fpdf_doc)
		    RETURN
		ENDIF
		
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		LOCAL lcTempFileName
		m.lcTempFileName = ""
		
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    LOCAL liPage, lnPage
		    m.liPage = 1 
		    FOR m.liPage = 1 TO This.fpdf_pagecount
		        m.lnPage = This.fpdf_pages[m.liPage]
		        IF EMPTY(m.lnPage) = .F.
		            m.loFPDF.FPDFPage_GenerateContent(m.lnPage)
		        ENDIF
		    ENDFOR
		    *******************************************************
		
		    m.lcTempFileName = This.env.GetUniqueTempFileName("pdf")
		
		    LOCAL lcSaveErrMsg
		    m.lcSaveErrMsg = REPLICATE(CHR(0), 500)
		    
		    IF m.loFPDF.VFPDF_SaveDocument(This.fpdf_doc, m.lcTempFileName, @m.lcSaveErrMsg, LEN(m.lcSaveErrMsg)) <> 1
		        m.lcTempFileName = ""
		        ERROR (RTRIM(m.lcSaveErrMsg, 1, CHR(0)))
		        EXIT
		    ENDIF
		
		FINALLY
		    This.ClosePDF()
		ENDTRY
		
		RETURN m.lcTempFileName
		
	ENDPROC

	PROCEDURE getfileextension
		RETURN "pdf"
		
	ENDPROC

	HIDDEN PROCEDURE getfontpdf
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		IF EMPTY(This.fpdf_doc)
		    RETURN 0
		ENDIF
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		
		LOCAL lcFontID
		m.lcFontID = m.loRepObj.Font.FontFileName
		
		***********************************************************
		* Font has been found
		***********************************************************
		LOCAL lnFontIndex
		m.lnFontIndex = This.fpdf_fonts.GetKey(m.lcFontID)
		IF m.lnFontIndex > 0
		    RETURN This.fpdf_fonts[m.lnFontIndex]
		ENDIF
		***********************************************************
		
		***********************************************************
		* Font hasn't been found, load it from file
		***********************************************************
		LOCAL lnFPDF_Font
		m.lnFPDF_Font = 0
		
		LOCAL lhHeap, lnFontDataPtr, lnSubsetData, lnSubsetDataSize
		STORE 0 TO m.lhHeap, m.lnFontDataPtr, m.lnSubsetData, m.lnSubsetDataSize
		
		TRY
		    IF m.loRepObj.Font.FontSymbol
		        EXIT
		    ENDIF
		
		    IF This.env.API_WIN.GetFileAttributesA(m.loRepObj.Font.FontFileName) = -1
		        * Font file doesn't exist OR FILENAME HAS UNICODE SYMBOLS
		        EXIT
		    ENDIF
		
		    LOCAL lcFontData, lnFontDataSize
		    m.lcFontData = FILETOSTR(m.loRepObj.Font.FontFileName)
		    m.lnFontDataSize = LEN(m.lcFontData)
		
		    m.lhHeap = This.env.API_WIN.HeapCreate(0, m.lnFontDataSize, 0)
		    IF EMPTY(m.lhHeap)
		        EXIT
		    ENDIF
		
		    m.lnFontDataPtr = This.env.API_WIN.HeapAlloc(m.lhHeap, 0, m.lnFontDataSize)
		    IF EMPTY(m.lnFontDataPtr)
		        EXIT
		    ENDIF
		    
		    SYS(2600, m.lnFontDataPtr, m.lnFontDataSize, m.lcFontData)
		    
		    IF m.loFPDF.VFPDF_CreateFontSubset(m.lnFontDataPtr, m.lnFontDataSize, m.loRepObj.FontSubset.CharSubset + CHR(0), @m.lnSubsetData, @m.lnSubsetDataSize) = 1
		        m.lnFPDF_Font = m.loFPDF.FPDFText_LoadFont(This.fpdf_doc, m.lnSubsetData, m.lnSubsetDataSize, m.loFPDFC.FPDF_FONT_TRUETYPE(), 1)
		    ELSE            
		        m.lnFPDF_Font = m.loFPDF.FPDFText_LoadFont(This.fpdf_doc, m.lnFontDataPtr, m.lnFontDataSize, m.loFPDFC.FPDF_FONT_TRUETYPE(), 1)
		    ENDIF
		
		
		FINALLY
		
		    IF EMPTY(m.lnSubsetData)=.F.
		        m.loFPDF.VFPDF_DestroyFontSubset(m.lnSubsetData)
		        m.lnSubsetData = 0
		        m.lnSubsetDataSize = 0
		    ENDIF
		    
		    IF EMPTY(m.lnFontDataPtr)=.F.
		        This.env.API_WIN.HeapFree(m.lhHeap, 0, m.lnFontDataPtr)
		        m.lnFontDataPtr = 0 
		    ENDIF
		    
		    IF EMPTY(m.lhHeap)=.F.
		        This.env.API_WIN.HeapDestroy(m.lhHeap)
		        m.lhHeap = 0 
		    ENDIF
		    
		ENDTRY
		
		
		
		IF EMPTY(m.lnFPDF_Font)=.T. AND m.loRepObj.Font.FontSymbol=.F. && Get a fallback font
		
		    m.lnFPDF_Font = m.loFPDF.FPDFText_LoadStandardFont( ;
		        This.fpdf_doc, ;
		        ICASE( ;
		            m.loRepObj.FontBold and m.loRepObj.FontItalic, "Helvetica-BoldItalic", ;
		            m.loRepObj.FontBold, "Helvetica-Bold", ;
		            m.loRepObj.FontItalic, "Helvetica-Italic", ;
		            "Helvetica"))
		ENDIF
		
		This.fpdf_fonts.Add(m.lnFPDF_Font, m.lcFontID)
		
		RETURN m.lnFPDF_Font
		
	ENDPROC

	HIDDEN PROCEDURE hash_md5
		LPARAMETERS tcData, tcDataHash
		
		m.tcDataHash = ""
		
		LOCAL loWin
		m.loWin = This.env.API_WIN
		
		LOCAL lcAlgorithm
		m.lcAlgorithm = "MD5"
		
		LOCAL lnAlg, lnHash, lhHashHeap, lnHashObjPtr
		STORE 0 TO m.lnAlg, m.lnHash, m.lhHashHeap, m.lnHashObjPtr
		
		LOCAL llRes
		m.llRes = .F.
		
		TRY
		
		    IF m.loWin.BCryptOpenAlgorithmProvider(@m.lnAlg, STRCONV(m.lcAlgorithm+CHR(0),5), NULL, 0) != 0
		        EXIT
		    ENDIF
		
		    LOCAL lnSizeObj, lnData
		    m.lnSizeObj = 0
		    m.lnData = 0
		    IF m.loWin.BCryptGetProperty(m.lnAlg, STRCONV("ObjectLength"+CHR(0),5), @m.lnSizeObj, 4, @m.lnData, 0 ) != 0
		        EXIT
		    ENDIF
		
		    LOCAL lnSizeHash
		    m.lnSizeHash = 0
		    IF m.loWin.BCryptGetProperty( m.lnAlg, STRCONV("HashDigestLength"+CHR(0),5), @m.lnSizeHash, 4, @m.lnData, 0 ) != 0
		        EXIT
		    ENDIF
		
		
		    m.lhHashHeap = m.loWin.HeapCreate(0, m.lnSizeObj, 0)
		    IF EMPTY(m.lhHashHeap)
		        EXIT
		    ENDIF
		
		    m.lnHashObjPtr = m.loWin.HeapAlloc(m.lhHashHeap, 0, m.lnSizeObj)
		    IF EMPTY(m.lnHashObjPtr)
		        EXIT
		    ENDIF
		
		    IF m.loWin.BCryptCreateHash(m.lnAlg, @m.lnHash, m.lnHashObjPtr, m.lnSizeObj, NULL, 0, 0 ) != 0
		        EXIT
		    ENDIF
		
		    IF m.loWin.BCryptHashData(m.lnHash, m.tcData, LEN(m.tcData), 0) != 0
		        EXIT
		    ENDIF 
		
		    m.tcDataHash = REPLICATE(CHR(0), m.lnSizeHash)
		    IF m.loWin.BCryptFinishHash(m.lnHash, @m.tcDataHash, m.lnSizeHash, 0) != 0
		        EXIT
		    ENDIF
		    
		    m.llRes = .T.
		
		FINALLY
		
		    IF EMPTY(m.lnHash) = .F.
		        m.loWin.BCryptDestroyHash(m.lnHash)
		        m.lnHash = 0
		    ENDIF
		
		    IF EMPTY(m.lnAlg) = .F.
		        m.loWin.BCryptCloseAlgorithmProvider(m.lnAlg, 0)
		        m.lnAlg = 0
		    ENDIF
		
		
		    IF EMPTY(m.lnHashObjPtr)=.F.
		        m.loWin.HeapFree(m.lhHashHeap, 0, m.lnHashObjPtr)
		        m.lnHashObjPtr = 0 
		    ENDIF
		    
		    IF EMPTY(m.lhHashHeap)=.F.
		        This.env.API_WIN.HeapDestroy(m.lhHashHeap)
		        m.lhHashHeap = 0 
		    ENDIF
		
		ENDTRY
		
		IF m.llRes = .F.
		    m.tcDataHash = ""
		ENDIF
		
		RETURN m.llRes
		
	ENDPROC

	PROCEDURE render
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		IF EMPTY(This.fpdf_doc)
		    RETURN
		ENDIF
		
		
		LOCAL loFRXC
		m.loFRXC = This.API_FRX.CONST
		
		LOCAL loFPDF
		m.loFPDF = This.env.API_FPDF
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		*************************************************
		* Create new page
		*************************************************
		IF m.loRepObj.Batch_PageNo > This.fpdf_pagecount
		
		    This.fpdf_pagecount = This.fpdf_pagecount + 1
		
		    DIMENSION This.fpdf_pages(This.fpdf_pagecount)
		
		    LOCAL lnFPDF_Page
		    m.lnFPDF_Page = m.loFPDF.FPDFPage_New(This.fpdf_doc, This.fpdf_pagecount - 1, m.loRepObj.Rep_PageWidth * m.lnDpiCoef, m.loRepObj.Rep_PageHeight * m.lnDpiCoef)
		
		    This.fpdf_pages[This.fpdf_pagecount] = m.lnFPDF_Page
		    
		ENDIF
		
		IF EMPTY(This.fpdf_pages[This.fpdf_pagecount])
		    RETURN
		ENDIF
		
		
		*************************************************
		
		DO CASE
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_FIELD()
		    This.Render_FrxField(m.loRepObj)
		   
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		    This.Render_FrxLabel(m.loRepObj)
		
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_LINE()
		    This.Render_FrxLine(m.loRepObj)
		
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_RECTANGLE()
		    This.Render_FrxRectangle(m.loRepObj)
		
		CASE m.loRepObj.ObjType = m.loFRXC.FRX_OBJ_PICTURE()
		    This.Render_FrxPicture(m.loRepObj)
		
		ENDCASE
		*************************************************
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxfield
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		This.Render_Text(m.loRepObj)
		
	ENDPROC

	HIDDEN PROCEDURE render_frxlabel
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		This.Render_Text(m.loRepObj)
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxline
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		
		LOCAL lnFPDF_Page
		m.lnFPDF_Page = This.fpdf_pages[This.fpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL lnLineWidth
		IF m.loRepObj.PenPat >= 1
		    m.lnLineWidth = MAX(m.loRepObj.PenSize, 0.5) * m.lnDpiCoef
		ELSE
		    m.lnLineWidth = 0
		ENDIF
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = m.loRepObj.PosLeft
		m.lnTop = m.loRepObj.PosTopRev
		m.lnWidth = m.loRepObj.SizeWidth
		m.lnHeight = m.loRepObj.SizeHeight
		
		
		LOCAL lnRad
		m.lnRad = -m.loRepObj.Rotate * PI() / 180
		
		LOCAL lcTrMatrix
		m.lcTrMatrix = ;
		    BINTOC(COS(m.lnRad), "F") + ;
		    BINTOC(SIN(m.lnRad), "F") + ;
		    BINTOC(-SIN(m.lnRad), "F") + ;
		    BINTOC(COS(m.lnRad), "F") + ;
		    BINTOC(m.lnDpiCoef * m.lnLeft, "F") + ;
		    BINTOC(m.lnDpiCoef * m.lnTop, "F")
		
		
		LOCAL lnLineObj
		m.lnLineObj = m.loFPDF.FPDFPageObj_CreateNewPath(0, 0)
		
		m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnLineObj)
		
		
		IF m.loRepObj.LineType = 1
		    * Horizontal line
		    m.loFPDF.FPDFPath_LineTo(m.lnLineObj, m.lnDpiCoef * m.lnWidth, 0)
		ELSE
		    * Vertical line
		    m.loFPDF.FPDFPath_LineTo(m.lnLineObj, 0, m.lnDpiCoef * -m.lnHeight)
		ENDIF
		
		
		m.loFPDF.FPDFPageObj_TransformF(m.lnLineObj, m.lcTrMatrix)
		
		
		m.loFPDF.FPDFPageObj_SetStrokeColor(m.lnLineObj, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue, m.loRepObj.PenAlpha)
		m.loFPDF.FPDFPageObj_SetStrokeWidth(m.lnLineObj, m.lnLineWidth)
		
		m.loFPDF.FPDFPath_SetDrawMode(m.lnLineObj, m.loFPDFC.FPDF_FILLMODE_NONE(), 1)
		
		
		LOCAL lcDash
		
		DO CASE
		CASE m.loRepObj.PenPat = 8 && Normal
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnLineObj, NULL, 0, 0)
		
		CASE m.loRepObj.PenPat = 1 && Dot
		    m.lcDash = BINTOC(1, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnLineObj, m.lcDash, 1, 1)
		    
		CASE m.loRepObj.PenPat = 2 && Dash
		    m.lcDash = BINTOC(6, "F") + BINTOC(6, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnLineObj, m.lcDash, 2, 2)
		    
		CASE m.loRepObj.PenPat = 3 && Dash-dot
		    m.lcDash = BINTOC(6, "F") + BINTOC(6, "F") + BINTOC(1, "F") + BINTOC(6, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnLineObj, m.lcDash, 4, 0)
		    
		CASE m.loRepObj.PenPat = 4 && Dash-dot-dot
		    m.lcDash = BINTOC(6, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnLineObj, m.lcDash, 6, 0)
		
		OTHERWISE && Normal
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnLineObj, NULL, 0, 0)
		
		ENDCASE
		
		
	ENDPROC

	HIDDEN PROCEDURE render_frxpicture
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		LOCAL loGDIP, loGDIPC
		m.loGDIP = This.env.API_GDIP
		m.loGDIPC = m.loGDIP.CONST
		
		
		LOCAL lnFPDF_Page
		m.lnFPDF_Page = This.fpdf_pages[This.fpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		LOCAL lcTempFileName
		m.lcTempFileName = This.env.GetUniqueTempFileName("png")
		
		LOCAL lSaveSafety
		m.lSaveSafety = SET("Safety")
		SET SAFETY OFF
		
		LOCAL lhGdipImage, lcImageBitmapData
		m.lhGdipImage = 0
		m.lcImageBitmapData = ""
		
		LOCAL lnFPDF_Bitmap
		m.lnFPDF_Bitmap = 0
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    LOCAL lnLeft, lnTop, lnWidth, lnHeight
		    m.lnLeft = m.loRepObj.PosLeft
		    m.lnTop = m.loRepObj.PosTopRev
		    m.lnWidth = m.loRepObj.SizeWidth
		    m.lnHeight = m.loRepObj.SizeHeight
		
		
		    **************************************************
		    * Draw image
		    **************************************************
		
		    IF EMPTY(m.loRepObj.PictureVal) = .T.
		        EXIT
		    ENDIF
		
		    STRTOFILE(m.loRepObj.PictureVal, m.lcTempFileName, 0)
		    
		    m.loGDIP.CheckError(m.loGDIP.GdipCreateBitmapFromFile(STRCONV(m.lcTempFileName,5) + CHR(0), @m.lhGdipImage))
		
		    LOCAL lnImgWidth, lnImgHeight
		    STORE 0 TO m.lnImgWidth, m.lnImgHeight
		    
		    m.loGDIP.CheckError(m.loGDIP.GdipGetImageWidth(m.lhGdipImage, @m.lnImgWidth))
		    m.loGDIP.CheckError(m.loGDIP.GdipGetImageHeight(m.lhGdipImage, @m.lnImgHeight))
		    
		    LOCAL lcImageRect
		    m.lcImageRect = BINTOC(0, "4RS") + BINTOC(0, "4RS") + BINTOC(m.lnImgWidth, "4RS") + BINTOC(m.lnImgHeight, "4RS")
		
		    m.lcImageBitmapData = REPLICATE(CHR(0), 24)
		    m.loGDIP.CheckError(m.loGDIP.GdipBitmapLockBits(m.lhGdipImage, m.lcImageRect, m.loGDIPC.Gdip_ImageLockModeRead(), m.loGDIPC.Gdip_PixelFormat32bppARGB(), @m.lcImageBitmapData))
		    
		    ************************************
		    LOCAL lnImageStride, lnImageScan0
		    m.lnImageStride = CTOBIN(SUBSTR(m.lcImageBitmapData, 9, 4), "4RS")
		    m.lnImageScan0 = CTOBIN(SUBSTR(m.lcImageBitmapData, 17, 4), "4RS")
		    
		    m.lnFPDF_Bitmap = m.loFPDF.FPDFBitmap_CreateEx(m.lnImgWidth, m.lnImgHeight, m.loFPDFC.FPDFBitmap_BGRA(), m.lnImageScan0, m.lnImageStride)
		
		    IF EMPTY(m.lnFPDF_Bitmap)
		        EXIT
		    ENDIF
		    
		    LOCAL lnImageObj
		    m.lnImageObj = m.loFPDF.FPDFPageObj_NewImageObj(This.fpdf_doc)
		    
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnImageObj)
		    
		    m.loFPDF.FPDFImageObj_SetBitmap(0, 0, m.lnImageObj, m.lnFPDF_Bitmap)
		
		
		    LOCAL lnRad
		    m.lnRad = -m.loRepObj.Rotate * PI() / 180
		
		    LOCAL lcTrMatrix
		    m.lcTrMatrix = ;
		        BINTOC(COS(m.lnRad), "F") + ;
		        BINTOC(SIN(m.lnRad), "F") + ;
		        BINTOC(-SIN(m.lnRad), "F") + ;
		        BINTOC(COS(m.lnRad), "F") + ;
		        BINTOC(m.lnDpiCoef * m.lnLeft, "F") + ;
		        BINTOC(m.lnDpiCoef * m.lnTop, "F")
		
		    
		    m.loFPDF.FPDFPageObj_Transform(m.lnImageObj, m.lnDpiCoef * MAX(m.lnWidth,1), 0, 0, m.lnDpiCoef * MAX(m.lnHeight,1), 0, m.lnDpiCoef * (-m.lnHeight))
		    m.loFPDF.FPDFPageObj_TransformF(m.lnImageObj, m.lcTrMatrix)
		    
		    
		    
		FINALLY
		    
		    SET SAFETY &lSaveSafety
		
		    IF EMPTY(m.lnFPDF_Bitmap) = .F.
		        m.loFPDF.FPDFBitmap_Destroy(m.lnFPDF_Bitmap)
		        m.lnFPDF_Bitmap = 0
		    ENDIF
		
		    IF EMPTY(m.lhGdipImage) = .F. AND EMPTY(RTRIM(m.lcImageBitmapData,1, CHR(0))) = .F.
		        m.loGDIP.GdipBitmapUnlockBits(m.lhGdipImage, m.lcImageBitmapData)
		        m.lcImageBitmapData = ""
		    ENDIF
		
		    IF EMPTY(m.lhGdipImage) = .F.
		        m.loGDIP.GdipDisposeImage(m.lhGdipImage)
		        m.lhGdipImage = 0
		    ENDIF
		        
		    IF EMPTY(m.lcTempFileName) = .F.
		        DELETE FILE (m.lcTempFileName)
		    ENDIF
		    
		ENDTRY
		
	ENDPROC

	HIDDEN PROCEDURE render_frxrectangle
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		
		LOCAL lnFPDF_Page
		m.lnFPDF_Page = This.fpdf_pages[This.fpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		LOCAL lnLineWidth
		IF m.loRepObj.PenPat >= 1
		    m.lnLineWidth = MAX(m.loRepObj.PenSize, 0.5) * m.lnDpiCoef
		ELSE
		    m.lnLineWidth = 0
		ENDIF
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = m.loRepObj.PosLeft
		m.lnTop = m.loRepObj.PosTopRev
		m.lnWidth = m.loRepObj.SizeWidth
		m.lnHeight = m.loRepObj.SizeHeight
		
		LOCAL lnRad
		m.lnRad = -m.loRepObj.Rotate * PI() / 180
		
		LOCAL lcTrMatrix
		m.lcTrMatrix = ;
		    BINTOC(COS(m.lnRad), "F") + ;
		    BINTOC(SIN(m.lnRad), "F") + ;
		    BINTOC(-SIN(m.lnRad), "F") + ;
		    BINTOC(COS(m.lnRad), "F") + ;
		    BINTOC(m.lnDpiCoef * m.lnLeft, "F") + ;
		    BINTOC(m.lnDpiCoef * m.lnTop, "F")
		
		
		LOCAL lnRectObj
		m.lnRectObj = 0
		
		DO CASE
		CASE m.loRepObj.RectCurvature = 0 && Normal rectangle
		    
		    m.lnRectObj = m.loFPDF.FPDFPageObj_CreateNewRect(;
		        0, ;
		        m.lnDpiCoef * -m.lnHeight, ;
		        m.lnDpiCoef * m.lnWidth, ;
		        m.lnDpiCoef * m.lnHeight)
		    
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnRectObj)
		
		
		CASE BETWEEN(m.loRepObj.RectCurvature, 1, 98) AND m.loRepObj.RectCurvature <= MAX(m.lnWidth, m.lnHeight)/2  && Rounded rectangle
		
		    m.lnRectObj = m.loFPDF.FPDFPageObj_CreateNewPath(0, 0)
		    
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnRectObj)
		    
		    LOCAL lnRay
		    m.lnRay = m.lnDpiCoef * ROUND(IIF(m.lnWidth > m.lnHeight, MIN(m.loRepObj.RectCurvature, INT(m.lnHeight / 2)), MIN(m.loRepObj.RectCurvature, INT(m.lnWidth / 2))), 0)
		    
		    LOCAL lnRight, lnBottom
		    m.lnRight = m.lnDpiCoef * m.lnWidth
		    m.lnBottom = m.lnDpiCoef * -m.lnHeight
		    
		    m.loFPDF.FPDFPath_MoveTo(m.lnRectObj, m.lnRay, m.lnBottom)
		    m.loFPDF.FPDFPath_LineTo(m.lnRectObj, m.lnRight - m.lnRay, m.lnBottom)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, m.lnRight, m.lnBottom, m.lnRight, m.lnBottom, m.lnRight, m.lnBottom + m.lnRay) 
		    m.loFPDF.FPDFPath_LineTo(m.lnRectObj, m.lnRight, -m.lnRay)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, m.lnRight, 0, m.lnRight, 0, m.lnRight - m.lnRay, 0)
		    m.loFPDF.FPDFPath_LineTo(m.lnRectObj, m.lnRay, 0)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, 0, 0, 0, 0, 0, -m.lnRay)
		    m.loFPDF.FPDFPath_LineTo(m.lnRectObj, 0 , m.lnBottom + m.lnRay)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, 0, m.lnBottom, 0, m.lnBottom, m.lnRay, m.lnBottom)
		
		
		OTHERWISE && Ellipse
		
		    LOCAL lnKappa
		    m.lnKappa = 0.552
		    
		    LOCAL lnCenterX, lnCenterY, lnRayX, lnRayY
		    m.lnCenterX = m.lnDpiCoef * m.lnWidth / 2
		    m.lnCenterY = m.lnDpiCoef * -m.lnHeight / 2
		    m.lnRayX = m.lnDpiCoef * (m.lnWidth / 2)
		    m.lnRayY = m.lnDpiCoef * (m.lnHeight / 2)
		    
		    m.lnRectObj = m.loFPDF.FPDFPageObj_CreateNewPath(0, 0)
		    
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnRectObj)
		
		    m.loFPDF.FPDFPath_MoveTo(m.lnRectObj, m.lnCenterX - m.lnRayX, m.lnCenterY)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, m.lnCenterX - m.lnRayX, m.lnCenterY + m.lnRayY * m.lnKappa, m.lnCenterX - m.lnRayX * m.lnKappa, m.lnCenterY + m.lnRayY, m.lnCenterX, m.lnCenterY + m.lnRayY)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, m.lnCenterX + m.lnRayX * m.lnKappa, m.lnCenterY + m.lnRayY, m.lnCenterX + m.lnRayX, m.lnCenterY + m.lnRayY * m.lnKappa, m.lnCenterX + m.lnRayX, m.lnCenterY)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, m.lnCenterX + m.lnRayX, m.lnCenterY - m.lnRayY * m.lnKappa, m.lnCenterX + m.lnRayX * m.lnKappa, m.lnCenterY - m.lnRayY, m.lnCenterX, m.lnCenterY - m.lnRayY)
		    m.loFPDF.FPDFPath_BezierTo(m.lnRectObj, m.lnCenterX - m.lnRayX * m.lnKappa, m.lnCenterY - m.lnRayY, m.lnCenterX - m.lnRayX, m.lnCenterY - m.lnRayY * m.lnKappa, m.lnCenterX - m.lnRayX, m.lnCenterY)
		        
		ENDCASE
		
		IF EMPTY(m.lnRectObj)
		    RETURN
		ENDIF
		
		
		m.loFPDF.FPDFPageObj_TransformF(m.lnRectObj, m.lcTrMatrix)
		
		
		m.loFPDF.FPDFPageObj_SetFillColor(m.lnRectObj, m.loRepObj.FillRed, m.loRepObj.FillGreen, m.loRepObj.FillBlue, m.loRepObj.FillAlpha)
		m.loFPDF.FPDFPageObj_SetStrokeColor(m.lnRectObj, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue, m.loRepObj.PenAlpha)
		m.loFPDF.FPDFPageObj_SetStrokeWidth(m.lnRectObj, m.lnLineWidth)
		
		DO CASE
		CASE m.loRepObj.Transparent = 0 AND m.loRepObj.FillPat > 0 AND m.loRepObj.PenPat = 0
		    m.loFPDF.FPDFPath_SetDrawMode(m.lnRectObj, m.loFPDFC.FPDF_FILLMODE_ALTERNATE(), 0)
		    
		CASE m.loRepObj.Transparent = 0 AND m.loRepObj.FillPat > 0
		    m.loFPDF.FPDFPath_SetDrawMode(m.lnRectObj, m.loFPDFC.FPDF_FILLMODE_ALTERNATE(), 1)
		
		OTHERWISE 
		    m.loFPDF.FPDFPath_SetDrawMode(m.lnRectObj, m.loFPDFC.FPDF_FILLMODE_NONE(), 1)
		
		ENDCASE
		
		
		*******************************************************
		LOCAL lcDash
		
		DO CASE
		CASE m.loRepObj.PenPat = 8 && Normal
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnRectObj, NULL, 0, 0)
		
		CASE m.loRepObj.PenPat = 1 && Dot
		    m.lcDash = BINTOC(1, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnRectObj, m.lcDash, 1, 1)
		    
		CASE m.loRepObj.PenPat = 2 && Dash
		    m.lcDash = BINTOC(6, "F") + BINTOC(6, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnRectObj, m.lcDash, 2, 2)
		    
		CASE m.loRepObj.PenPat = 3 && Dash-dot
		    m.lcDash = BINTOC(6, "F") + BINTOC(6, "F") + BINTOC(1, "F") + BINTOC(6, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnRectObj, m.lcDash, 4, 0)
		    
		CASE m.loRepObj.PenPat = 4 && Dash-dot-dot
		    m.lcDash = BINTOC(6, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F") + BINTOC(1, "F") + BINTOC(3, "F")
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnRectObj, m.lcDash, 6, 0)
		
		OTHERWISE && Normal
		    m.loFPDF.FPDFPageObj_SetDashArray(m.lnRectObj, NULL, 0, 0)
		
		ENDCASE
		*******************************************************
		
		
		
	ENDPROC

	HIDDEN PROCEDURE render_text
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		
		LOCAL loFRXC
		m.loFRXC = This.API_FRX.CONST
		
		
		LOCAL lnFPDF_Page
		m.lnFPDF_Page = This.fpdf_pages[This.fpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		LOCAL loFont
		m.loFont = m.loRepObj.Font
		
		LOCAL lnPDFFont
		m.lnPDFFont = This.GetFontPDF(m.loRepObj)
		
		IF EMPTY(m.lnPDFFont)
		    This.Render_TextAsImage(m.loRepObj)
		    RETURN
		ENDIF
		
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = m.loRepObj.PosLeft
		m.lnTop = m.loRepObj.PosTopRev
		m.lnWidth = m.loRepObj.SizeWidth
		m.lnHeight = m.loRepObj.SizeHeight
		
		
		LOCAL lnRad
		m.lnRad = -m.loRepObj.Rotate * PI() / 180
		
		LOCAL lcTrMatrix
		m.lcTrMatrix = ;
		    BINTOC(COS(m.lnRad), "F") + ;
		    BINTOC(SIN(m.lnRad), "F") + ;
		    BINTOC(-SIN(m.lnRad), "F") + ;
		    BINTOC(COS(m.lnRad), "F") + ;
		    BINTOC(m.lnDpiCoef * m.lnLeft, "F") + ;
		    BINTOC(m.lnDpiCoef * m.lnTop, "F")
		
		
		*******************************************************
		* Background mode 0 - Opaque, 1 - Transparent
		IF m.loRepObj.Transparent = 0 
		
		    LOCAL lnTextBgRect
		    m.lnTextBgRect = m.loFPDF.FPDFPageObj_CreateNewRect(;
		        0, ;
		        m.lnDpiCoef * -m.lnHeight, ;
		        m.lnDpiCoef * m.lnWidth, ;
		        m.lnDpiCoef * m.lnHeight)
		
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnTextBgRect)
		    
		    m.loFPDF.FPDFPageObj_TransformF(m.lnTextBgRect, m.lcTrMatrix)
		        
		    m.loFPDF.FPDFPageObj_SetFillColor(m.lnTextBgRect, m.loRepObj.FillRed, m.loRepObj.FillGreen, m.loRepObj.FillBlue, m.loRepObj.FillAlpha)
		    
		    m.loFPDF.FPDFPath_SetDrawMode(m.lnTextBgRect, m.loFPDFC.FPDF_FILLMODE_ALTERNATE(), 0)
		
		ENDIF
		*******************************************************
		
		
		
		*******************************************************
		LOCAL laLines(1), lnLinesCount, liLine, loLine
		m.lnLinesCount = m.loRepObj.Render_Text(@m.laLines)
		m.liLine = 1
		FOR m.liLine = 1 TO m.lnLinesCount
		
		    m.loLine = m.laLines[m.liLine]
		
		
		    LOCAL lnTextObj
		    m.lnTextObj = m.loFPDF.FPDFPageObj_CreateTextObj(This.fpdf_doc, m.lnPDFFont, m.loRepObj.FontSize)
		    
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnTextObj)
		    
		    
		    m.loFPDF.FPDFText_SetText(m.lnTextObj, m.loLine.Text + CHR(0))
		    
		    
		    m.loFPDF.FPDFPageObj_SetFillColor(m.lnTextObj, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue, m.loRepObj.PenAlpha)
		    m.loFPDF.FPDFPageObj_SetStrokeColor(m.lnTextObj, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue, m.loRepObj.PenAlpha)
		    
		    m.loFPDF.FPDFPath_SetDrawMode(m.lnTextObj, m.loFPDFC.FPDF_FILLMODE_ALTERNATE(), 0)
		    
		    m.loFPDF.FPDFTextObj_SetTextRenderMode(m.lnTextObj, m.loFPDFC.FPDF_TEXTRENDERMODE_FILL())
		    
		    IF m.loRepObj.FontBold AND m.loRepObj.Font.FontBold = .F.
		        m.loFPDF.FPDFTextObj_SetTextRenderMode(m.lnTextObj, m.loFPDFC.FPDF_TEXTRENDERMODE_FILL_STROKE()) && Bold imitation
		        m.loFPDF.FPDFPageObj_SetStrokeWidth(m.lnTextObj, 0.5)
		    ENDIF
		    
		    LOCAL llFakeItalic
		    m.llFakeItalic = m.loRepObj.FontItalic AND m.loRepObj.Font.FontItalic = .F.
		    IF m.llFakeItalic
		        m.loFPDF.FPDFPageObj_Transform(m.lnTextObj, 1, 0, 0.3333, 1, 0, 0) && Italic imitation
		    ENDIF
		
		
		    LOCAL lnAlignOffsetX
		    m.lnAlignOffsetX = ICASE(m.loRepObj.Align = m.loFRXC.ALIGN_RIGHT(), m.loLine.Width - m.loLine.TextWidth, m.loRepObj.Align = m.loFRXC.ALIGN_CENTER(), (m.loLine.Width - m.loLine.TextWidth) * 0.5, 0)
		
		    m.loFPDF.FPDFPageObj_Transform(m.lnTextObj, ;
		        1, ;
		        0, ;
		        0, ;
		        1, ;
		        m.lnDpiCoef * (m.loLine.Left + m.lnAlignOffsetX) + IIF(m.llFakeItalic, m.loRepObj.FontSize * 0.5, 0),;
		        m.lnDpiCoef * (-m.loLine.Top - m.loLine.Height + m.loFont.FontDescent + 2) )
		
		
		    m.loFPDF.FPDFPageObj_TransformF(m.lnTextObj, m.lcTrMatrix)
		    
		    
		    IF m.loRepObj.FontUnderline
		        LOCAL lnTextUnderline
		        m.lnTextUnderline = m.loFPDF.FPDFPageObj_CreateNewPath(;
		            m.lnDpiCoef * (m.loLine.Left + m.lnAlignOffsetX),;
		            m.lnDpiCoef * (-m.loLine.Top - m.loLine.Height + m.loFont.FontDescent))
		        
		        m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnTextUnderline)
		        
		        m.loFPDF.FPDFPath_LineTo(m.lnTextUnderline, ;
		            m.lnDpiCoef * (m.loLine.Left + m.lnAlignOffsetX + m.loLine.TextWidth),;
		            m.lnDpiCoef * (-m.loLine.Top - m.loLine.Height + m.loFont.FontDescent))
		            
		        m.loFPDF.FPDFPageObj_TransformF(m.lnTextUnderline, m.lcTrMatrix)
		
		        m.loFPDF.FPDFPageObj_SetStrokeColor(m.lnTextUnderline, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue, m.loRepObj.PenAlpha)
		        m.loFPDF.FPDFPageObj_SetStrokeWidth(m.lnTextUnderline, 0.5)
		        
		        m.loFPDF.FPDFPath_SetDrawMode(m.lnTextUnderline, m.loFPDFC.FPDF_FILLMODE_NONE(), 1)
		
		    ENDIF
		
		
		    IF m.loRepObj.FontStrikeout
		        LOCAL lnTextStrikeout
		        m.lnTextStrikeout = m.loFPDF.FPDFPageObj_CreateNewPath(;
		            m.lnDpiCoef * (m.loLine.Left + m.lnAlignOffsetX),;
		            m.lnDpiCoef * (-m.loLine.Top - m.loLine.Height + (m.loFont.FontDescent + m.loFont.FontAscent) * 0.5))
		        
		        m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnTextStrikeout)
		        
		        m.loFPDF.FPDFPath_LineTo(m.lnTextStrikeout, ;
		            m.lnDpiCoef * (m.loLine.Left + m.lnAlignOffsetX + m.loLine.TextWidth),;
		            m.lnDpiCoef * (-m.loLine.Top - m.loLine.Height + (m.loFont.FontDescent + m.loFont.FontAscent) * 0.5))
		            
		        m.loFPDF.FPDFPageObj_TransformF(m.lnTextStrikeout, m.lcTrMatrix)
		
		        m.loFPDF.FPDFPageObj_SetStrokeColor(m.lnTextStrikeout, m.loRepObj.PenRed, m.loRepObj.PenGreen, m.loRepObj.PenBlue, m.loRepObj.PenAlpha)
		        m.loFPDF.FPDFPageObj_SetStrokeWidth(m.lnTextStrikeout, 0.5)
		        
		        m.loFPDF.FPDFPath_SetDrawMode(m.lnTextStrikeout, m.loFPDFC.FPDF_FILLMODE_NONE(), 1)
		
		    ENDIF
		   
		    
		ENDFOR
		
		
		
	ENDPROC

	HIDDEN PROCEDURE render_textasimage
		LPARAMETERS loRepObj as pdfiumreport_repobj of PdfiumReport.vcx
		
		LOCAL loFPDF, loFPDFC
		m.loFPDF = This.env.API_FPDF
		m.loFPDFC = m.loFPDF.CONST
		
		LOCAL loGDIP, loGDIPC
		m.loGDIP = This.env.API_GDIP
		m.loGDIPC = m.loGDIP.CONST
		
		
		LOCAL lnFPDF_Page
		m.lnFPDF_Page = This.fpdf_pages[This.fpdf_pagecount]
		
		LOCAL lnDpiCoef
		m.lnDpiCoef = This.env.GetPDFDPI() / 96
		
		
		LOCAL lcTempFileName
		m.lcTempFileName = This.env.GetUniqueTempFileName("png")
		
		LOCAL lSaveSafety
		m.lSaveSafety = SET("Safety")
		SET SAFETY OFF
		
		LOCAL lhGdipImage, lcImageBitmapData
		m.lhGdipImage = 0
		m.lcImageBitmapData = ""
		
		LOCAL lnFPDF_Bitmap
		m.lnFPDF_Bitmap = 0
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    LOCAL lnLeft, lnTop, lnWidth, lnHeight, lcPictureVal
		    m.lnLeft = m.loRepObj.PosLeft
		    m.lnTop = m.loRepObj.PosTopRev
		    m.lnWidth = m.loRepObj.SizeWidth
		    m.lnHeight = m.loRepObj.SizeHeight
		    m.lcPictureVal = ""
		
		    ************************************
		    m.loRepObj.Render_TextAsImage(@m.lcPictureVal, @m.lnWidth, @m.lnHeight)
		    
		    STRTOFILE(m.lcPictureVal, m.lcTempFileName, 0)
		    m.lcPictureVal = ""
		    
		    m.loGDIP.CheckError(m.loGDIP.GdipCreateBitmapFromFile(STRCONV(m.lcTempFileName,5) + CHR(0), @m.lhGdipImage))
		
		    LOCAL lnImgWidth, lnImgHeight
		    STORE 0 TO m.lnImgWidth, m.lnImgHeight
		    
		    m.loGDIP.CheckError(m.loGDIP.GdipGetImageWidth(m.lhGdipImage, @m.lnImgWidth))
		    m.loGDIP.CheckError(m.loGDIP.GdipGetImageHeight(m.lhGdipImage, @m.lnImgHeight))
		    
		    LOCAL lcImageRect
		    m.lcImageRect = BINTOC(0, "4RS") + BINTOC(0, "4RS") + BINTOC(m.lnImgWidth, "4RS") + BINTOC(m.lnImgHeight, "4RS")
		
		    m.lcImageBitmapData = REPLICATE(CHR(0), 24)
		    m.loGDIP.CheckError(m.loGDIP.GdipBitmapLockBits(m.lhGdipImage, m.lcImageRect, m.loGDIPC.Gdip_ImageLockModeRead(), m.loGDIPC.Gdip_PixelFormat32bppARGB(), @m.lcImageBitmapData))
		    
		    ************************************
		    LOCAL lnImageStride, lnImageScan0
		    m.lnImageStride = CTOBIN(SUBSTR(m.lcImageBitmapData, 9, 4), "4RS")
		    m.lnImageScan0 = CTOBIN(SUBSTR(m.lcImageBitmapData, 17, 4), "4RS")
		
		
		    m.lnFPDF_Bitmap = m.loFPDF.FPDFBitmap_CreateEx(m.lnImgWidth, m.lnImgHeight, m.loFPDFC.FPDFBitmap_BGRA(), m.lnImageScan0, m.lnImageStride)
		
		    IF EMPTY(m.lnFPDF_Bitmap)
		        EXIT
		    ENDIF
		    
		    LOCAL lnImageObj
		    m.lnImageObj = m.loFPDF.FPDFPageObj_NewImageObj(This.fpdf_doc)
		    
		    m.loFPDF.FPDFPage_InsertObject(m.lnFPDF_Page, m.lnImageObj)
		    
		    m.loFPDF.FPDFImageObj_SetBitmap(0, 0, m.lnImageObj, m.lnFPDF_Bitmap)
		
		
		    LOCAL lnRad
		    m.lnRad = -m.loRepObj.Rotate * PI() / 180
		
		    LOCAL lcTrMatrix
		    m.lcTrMatrix = ;
		        BINTOC(COS(m.lnRad), "F") + ;
		        BINTOC(SIN(m.lnRad), "F") + ;
		        BINTOC(-SIN(m.lnRad), "F") + ;
		        BINTOC(COS(m.lnRad), "F") + ;
		        BINTOC(m.lnDpiCoef * m.lnLeft, "F") + ;
		        BINTOC(m.lnDpiCoef * m.lnTop, "F")
		
		    
		    m.loFPDF.FPDFPageObj_Transform(m.lnImageObj, m.lnDpiCoef * MAX(m.lnWidth,1), 0, 0, m.lnDpiCoef * MAX(m.lnHeight,1), 0, m.lnDpiCoef * (-m.lnHeight))
		    m.loFPDF.FPDFPageObj_TransformF(m.lnImageObj, m.lcTrMatrix)
		    
		FINALLY
		
		    SET SAFETY &lSaveSafety
		
		    IF EMPTY(m.lnFPDF_Bitmap) = .F.
		        m.loFPDF.FPDFBitmap_Destroy(m.lnFPDF_Bitmap)
		        m.lnFPDF_Bitmap = 0
		    ENDIF
		
		    IF EMPTY(m.lhGdipImage) = .F. AND EMPTY(RTRIM(m.lcImageBitmapData,1, CHR(0))) = .F.
		        m.loGDIP.GdipBitmapUnlockBits(m.lhGdipImage, m.lcImageBitmapData)
		        m.lcImageBitmapData = ""
		    ENDIF
		
		    IF EMPTY(m.lhGdipImage) = .F.
		        m.loGDIP.GdipDisposeImage(m.lhGdipImage)
		        m.lhGdipImage = 0
		    ENDIF
		
		    IF EMPTY(m.lcTempFileName) = .F.
		        DELETE FILE (m.lcTempFileName)
		    ENDIF
		ENDTRY
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport_repfont AS custom 		&& Frx font representation; Referenced in PdfiumReport.Fonts collection and PdfiumReport_repobj.Font
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: fontascent
		*p: fontbold		&& Specifies if the text is bold.
		*p: fontdescent
		*p: fontface
		*p: fontfilename
		*p: fontheight
		*p: fontheightceil
		*p: fontitalic		&& Specifies if the text is italic.
		*p: fontprivate
		*p: fontsize		&& Specifies the font size for text displayed with an object.
		*p: fontsymbol
		*p: gdipfont
		*p: gdipfontfamily
		*p: lineheight
		*p: linespacing
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,CloneObject,Comment,ControlCount,Controls,Error,Height,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		fontascent = 0
		fontbold = .F.
		fontdescent = 0
		fontface = ("")
		fontfilename = ("")
		fontheight = 0
		fontheightceil = 0
		fontitalic = .F.
		fontprivate = .F.
		fontsize = 0
		fontsymbol = .F.
		gdipfont = .F.
		gdipfontfamily = 0
		Height = 27
		lineheight = 0
		linespacing = 0
		Name = "pdfiumreport_repfont"
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="fontbold" type="property" display="FontBold"/>
			<memberdata name="fontface" type="property" display="FontFace"/>
			<memberdata name="fontfilename" type="property" display="FontFileName"/>
			<memberdata name="fontheight" type="property" display="FontHeight"/>
			<memberdata name="fontheightceil" type="property" display="FontHeightCeil"/>
			<memberdata name="fontitalic" type="property" display="FontItalic"/>
			<memberdata name="fontsymbol" type="property" display="FontSymbol"/>
			<memberdata name="lineheight" type="property" display="LineHeight"/>
			<memberdata name="fontascent" type="property" display="FontAscent"/>
			<memberdata name="fontdescent" type="property" display="FontDescent"/>
			<memberdata name="fontprivate" type="property" display="FontPrivate"/>
			<memberdata name="gdipfont" type="property" display="GdipFont"/>
			<memberdata name="gdipfontfamily" type="property" display="GdipFontFamily"/>
			<memberdata name="fontsize" type="property" display="FontSize"/>
			<memberdata name="linespacing" type="property" display="LineSpacing"/>
		</VFPData>
	*</PropValue>

ENDDEFINE

DEFINE CLASS pdfiumreport_repobj AS custom 		&& Input object for Render  method of PdfiumReport_renderer_base  class; Produced by PdfiumReport Render method
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: measurestring
		*m: render_text
		*m: render_textasimage		&& Render text as an image; Returns character representation in PNG format
		*p: align		&& Alignment: 0 - left, 1 - right, 2 - center
		*p: api_frx
		*p: batch_pageno
		*p: continuationtype		&& Object ContinuationType Indicates the current continuation state for the rendered element. When layout elements span pages, they are rendered in multiple sections
		*p: env		&& Pdfium_env object
		*p: fillalpha		&& Object background color alpha transparency of RGBA (0 - 255)
		*p: fillblue		&& Object background color blue component of RGBA (0 - 255)
		*p: fillgreen		&& Object background color green component of RGBA (0 - 255)
		*p: fillpat
		*p: fillred		&& Object background color red component of RGBA (0 - 255)
		*p: font		&& Font representation (PdfiumReport_repfont)
		*p: fontbold		&& Specifies if the text is bold.
		*p: fontcharset		&& Specifies the script for the font used to display text.
		*p: fontface
		*p: fontitalic		&& Specifies if the text is italic.
		*p: fontsize		&& Specifies the font size for text displayed with an object.
		*p: fontstrikeout
		*p: fontsubset
		*p: fontunderline		&& Specifies if the text is underlined.
		*p: linespacing		&& Spacing between lines of text: 0 - normal, 1 - normal * 1.5, 2 - double spacing
		*p: linetype		&& Line object type: 1 - horizontal, 2 - vertical
		*p: objid
		*p: objtype		&& Frx control type id: 5 - Label, 6 - Line, 7 - Rectangle, 8 - Field, 17 - Picture
		*p: penalpha
		*p: penblue
		*p: pengreen
		*p: penpat
		*p: penred
		*p: pensize
		*p: picturefilename		&& Filename for Picture report control
		*p: picturescale		&& Picture scale mode: 0 = Clip , 1 = Scale Retain Shape, 2 = Scale and fill frame
		*p: pictureval		&& Character represetation of Picture object in PNG
		*p: posleft		&& Object position: Left (pixels)
		*p: postop		&& Object position: Top (pixels)
		*p: postoprev		&& Object position: Reverse Top (from page bottom, pixels)
		*p: rectcurvature		&& Rectange Curvature; specifies % curvature:
		*p: rep_pageheight		&& Page height (pixels)
		*p: rep_pageno		&& Number of page where object were rendered
		*p: rep_pagetotal		&& Total number of pages in report (may be 0 if ReportListener.TwoPassProcess was  equal to.F.)
		*p: rep_pagewidth		&& Page width (pixels)
		*p: rotate		&& Rotation (degrees)
		*p: screengfx
		*p: sizeheight		&& Object height (pixels)
		*p: sizewidth		&& Object width (pixels)
		*p: text		&& Text in UTF-16 LE for Field and Label
		*p: transparent		&& Transparency: 0 - Opague, 1 - Transparent
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN AddObject,AddProperty,api_frx,CloneObject,Comment,ControlCount,Controls,env,Error,Height,HelpContextID,NewObject,Objects,Picture,ReadExpression,ReadMethod,RemoveObject,SaveAsClass,screengfx,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	*<PropValue>
		align = 0
		api_frx = .F.
		batch_pageno = 0
		continuationtype = 0
		env = .F.
		fillalpha = 0
		fillblue = 0
		fillgreen = 0
		fillpat = 0
		fillred = 0
		font = .F.
		fontbold = .F.
		fontcharset = 0
		fontface = ("")
		fontitalic = .F.
		fontsize = 0
		fontstrikeout = .F.
		fontsubset = .F.
		fontunderline = .F.
		Height = 27
		linespacing = 0
		linetype = 0
		Name = "pdfiumreport_repobj"
		objid = 0
		objtype = 0
		penalpha = 0
		penblue = 0
		pengreen = 0
		penpat = 0
		penred = 0
		pensize = 0
		picturefilename = ("")
		picturescale = 0
		pictureval = ("")
		posleft = 0
		postop = 0
		postoprev = 0
		rectcurvature = 0
		rep_pageheight = 0
		rep_pageno = 0
		rep_pagetotal = 0
		rep_pagewidth = 0
		rotate = 0
		screengfx = .F.
		sizeheight = 0
		sizewidth = 0
		text = ("")
		transparent = 0
		Width = 27
		_memberdata = <VFPData>
			<memberdata name="align" type="property" display="Align"/>
			<memberdata name="continuationtype" type="property" display="ContinuationType"/>
			<memberdata name="fillalpha" type="property" display="FillAlpha"/>
			<memberdata name="fillblue" type="property" display="FillBlue"/>
			<memberdata name="fillgreen" type="property" display="FillGreen"/>
			<memberdata name="fillpat" type="property" display="FillPat"/>
			<memberdata name="fillred" type="property" display="FillRed"/>
			<memberdata name="fontbold" type="property" display="FontBold"/>
			<memberdata name="fontcharset" type="property" display="FontCharset"/>
			<memberdata name="fontface" type="property" display="FontFace"/>
			<memberdata name="fontitalic" type="property" display="FontItalic"/>
			<memberdata name="fontsize" type="property" display="FontSize"/>
			<memberdata name="fontstrikeout" type="property" display="FontStrikeout"/>
			<memberdata name="fontunderline" type="property" display="FontUnderline"/>
			<memberdata name="linespacing" type="property" display="LineSpacing"/>
			<memberdata name="objtype" type="property" display="ObjType"/>
			<memberdata name="penalpha" type="property" display="PenAlpha"/>
			<memberdata name="penblue" type="property" display="PenBlue"/>
			<memberdata name="pengreen" type="property" display="PenGreen"/>
			<memberdata name="penpat" type="property" display="PenPat"/>
			<memberdata name="penred" type="property" display="PenRed"/>
			<memberdata name="pensize" type="property" display="PenSize"/>
			<memberdata name="posleft" type="property" display="PosLeft"/>
			<memberdata name="postop" type="property" display="PosTop"/>
			<memberdata name="rep_pageheight" type="property" display="Rep_PageHeight"/>
			<memberdata name="rep_pageno" type="property" display="Rep_PageNo"/>
			<memberdata name="rep_pagetotal" type="property" display="Rep_PageTotal"/>
			<memberdata name="rep_pagewidth" type="property" display="Rep_PageWidth"/>
			<memberdata name="rotate" type="property" display="Rotate"/>
			<memberdata name="sizeheight" type="property" display="SizeHeight"/>
			<memberdata name="sizewidth" type="property" display="SizeWidth"/>
			<memberdata name="text" type="property" display="Text"/>
			<memberdata name="postoprev" type="property" display="PosTopRev"/>
			<memberdata name="linetype" type="property" display="LineType"/>
			<memberdata name="rectcurvature" type="property" display="RectCurvature"/>
			<memberdata name="transparent" type="property" display="Transparent"/>
			<memberdata name="font" type="property" display="Font"/>
			<memberdata name="picturescale" type="property" display="PictureScale"/>
			<memberdata name="picturefilename" type="property" display="PictureFilename"/>
			<memberdata name="env" type="property" display="env"/>
			<memberdata name="pictureval" type="property" display="PictureVal"/>
			<memberdata name="render_textasimage" type="method" display="Render_TextAsImage"/>
			<memberdata name="measurestring" type="method" display="MeasureString"/>
			<memberdata name="screengfx" type="property" display="ScreenGfx"/>
			<memberdata name="render_text" type="method" display="Render_Text"/>
			<memberdata name="batch_pageno" type="property" display="Batch_PageNo"/>
			<memberdata name="fontsubset" type="property" display="FontSubset"/>
			<memberdata name="objid" type="property" display="ObjID"/>
			<memberdata name="api_frx" type="property" display="API_FRX"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE Destroy
		This.env = .F.
		This.ScreenGfx = 0
		
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv, toAPI_FRX, tnScreenGfx
		
		This.env = m.toEnv
		This.API_FRX = m.toAPI_FRX
		This.ScreenGfx = m.tnScreenGfx
		
		IF VARTYPE(This.env) != "O"
		    RETURN .F.
		ENDIF
		
		IF EMPTY(NVL(This.ScreenGfx,0))
		    RETURN .F.
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE measurestring
		LPARAMETERS m.tcTextUnicode, toLayoutRectF, thStringFormat, toObjRectF, tnCharsFitted, tnLinesFitted
		
		STORE 0 TO m.tnCharsFitted, m.tnLinesFitted
		
		m.toObjRectF = NEWOBJECT("empty")
		ADDPROPERTY(m.toObjRectF, "x", 0.0)
		ADDPROPERTY(m.toObjRectF, "y", 0.0)
		ADDPROPERTY(m.toObjRectF, "width", 0.0)
		ADDPROPERTY(m.toObjRectF, "height", 0.0)
		
		LOCAL lnDPICoefX, lnDPICoefY
		This.env.API_GDIP.GdipGetDpiX(This.ScreenGfx, @m.lnDPICoefX)
		This.env.API_GDIP.GdipGetDpiY(This.ScreenGfx, @m.lnDPICoefY)
		m.lnDPICoefX = EVL(m.lnDPICoefX, 96) / 96
		m.lnDPICoefY = EVL(m.lnDPICoefY, 96) / 96
		
		LOCAL lcLayoutRectF
		m.lcLayoutRectF = 0h + ;
		    BINTOC(m.toLayoutRectF.x * m.lnDPICoefX, "F") + ;
		    BINTOC(m.toLayoutRectF.y * m.lnDPICoefY, "F") + ;
		    BINTOC(m.toLayoutRectF.width * m.lnDPICoefX, "F") + ;
		    BINTOC(m.toLayoutRectF.height * m.lnDPICoefY, "F")
		
		LOCAL lcObjBBox
		m.lcObjBBox = 0h + BINTOC(0.0, "F") + BINTOC(0.0, "F") + BINTOC(0.0, "F") + BINTOC(0.0, "F")
		
		
		This.env.API_GDIP.GdipMeasureString (;
		    This.ScreenGfx, ;
		    m.tcTextUnicode + CHR(0), ;
		    LEN(m.tcTextUnicode) / 2, ;
		    This.Font.GdipFont, ;
		    m.lcLayoutRectF, ;
		    m.thStringFormat, ;
		    @m.lcObjBBox, ;
		    @m.tnCharsFitted, ;
		    @m.tnLinesFitted)
		
		
		m.toObjRectF.x = CTOBIN(SUBSTR(m.lcObjBBox,1,4), "N") / m.lnDPICoefX
		m.toObjRectF.y = CTOBIN(SUBSTR(m.lcObjBBox,5,4), "N") / m.lnDPICoefY
		m.toObjRectF.width = CTOBIN(SUBSTR(m.lcObjBBox,9,4), "N") / m.lnDPICoefX
		m.toObjRectF.height = CTOBIN(SUBSTR(m.lcObjBBox,13,4), "N") / m.lnDPICoefY
		
	ENDPROC

	PROCEDURE render_text
		LPARAMETERS laTextLines
		
		DIMENSION m.laTextLines(1)
		
		LOCAL lnTextLinesCount
		m.lnTextLinesCount = 0
		
		
		LOCAL loFRXC
		m.loFRXC = This.API_FRX.CONST
		
		LOCAL loFont
		m.loFont = This.Font
		
		LOCAL lnLeft, lnTop, lnWidth, lnHeight
		m.lnLeft = This.PosLeft
		m.lnTop = This.PosTop
		m.lnWidth = This.SizeWidth
		m.lnHeight = This.SizeHeight
		
		
		*******************************************************
		IF This.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		    m.lnWidth = m.lnWidth + This.Font.FontHeightCeil * 2
		ENDIF
		
		LOCAL lnTextOffsetX, lnTextOffsetY
		m.lnTextOffsetX = 2
		m.lnTextOffsetY = 2
		
		DO CASE
		CASE This.Align = m.loFRXC.ALIGN_RIGHT()
		    m.lnTextOffsetX = -2 + IIF(This.ObjType = m.loFRXC.FRX_OBJ_LABEL(), -This.Font.FontHeightCeil * 2, 0)
		
		CASE This.Align = m.loFRXC.ALIGN_CENTER()
		    m.lnTextOffsetX = IIF(This.ObjType = m.loFRXC.FRX_OBJ_LABEL(), -This.Font.FontHeightCeil, 0)
		
		ENDCASE
		
		
		*******************************************************
		LOCAL loLineRect
		m.loLineRect = NEWOBJECT("empty")
		ADDPROPERTY(m.loLineRect, "x", 0.0)
		ADDPROPERTY(m.loLineRect, "y", 0.0)
		ADDPROPERTY(m.loLineRect, "width", CEILING(m.lnWidth) + 0.0)
		ADDPROPERTY(m.loLineRect, "height", m.loFont.FontHeightCeil + 0.0)
		
		
		LOCAL lnLineHeight
		m.lnLineHeight = m.loFont.LineHeight
		
		IF m.lnLineHeight <= 0
		    ERROR 2005, (This.Class + ".Font.LineHeight <= 0")
		ENDIF
		
		LOCAL lhStringFormat
		m.lhStringFormat = 0
		
		TRY
		    IF This.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		        This.env.API_GDIP.GdipStringFormatGetGenericTypographic(@m.lhStringFormat)
		    ELSE
		        IF m.loFont.FontPrivate
		            * VFP is unable to use private gdi+ fonts, thus it renders field with fallback font, this font can be smaller than actual report font
		            * thus GenerericTypographic is used to make resulting text lines more condensed 
		            This.env.API_GDIP.GdipStringFormatGetGenericTypographic(@m.lhStringFormat)
		        ELSE
		            This.env.API_GDIP.GdipStringFormatGetGenericDefault(@m.lhStringFormat)
		            This.env.API_GDIP.GdipSetStringFormatFlags(m.lhStringFormat, This.env.API_GDIP.CONST.Gdip_StringFormatFlagsLineLimit())
		        ENDIF
		
		        This.env.API_GDIP.GdipSetStringFormatTrimming(m.lhStringFormat, ;
		            IIF(FLOOR(m.lnHeight / EVL(m.lnLineHeight,1)) <= 1, ;
		                This.env.API_GDIP.CONST.Gdip_StringTrimmingCharacter(), ;
		                This.env.API_GDIP.CONST.Gdip_StringTrimmingNone()) ;
		            )
		    ENDIF
		
		    This.env.API_GDIP.GdipSetStringFormatAlign(m.lhStringFormat, ;
		        ICASE(;
		            This.Align = m.loFRXC.ALIGN_LEFT(), This.env.API_GDIP.CONST.Gdip_StringAlignmentNear(), ;
		            This.Align = m.loFRXC.ALIGN_RIGHT(), This.env.API_GDIP.CONST.Gdip_StringAlignmentFar(), ;
		            This.Align = m.loFRXC.ALIGN_CENTER(), This.env.API_GDIP.CONST.Gdip_StringAlignmentCenter(), ;
		            This.env.API_GDIP.CONST.Gdip_StringAlignmentNear() ;
		            ))
		
		
		    *******************************************************
		    LOCAL liLine, lnCharIndex, lnLineCharsFitted, lcLineText
		    m.liLine = 0
		    m.lnCharIndex = 1
		    DO WHILE .T.
		
		        m.liLine = m.liLine + 1
		
		        IF m.liLine > 1
		            m.liLine = m.liLine + ICASE(This.LineSpacing = 1, 0.5, This.LineSpacing = 2, 1, 0)
		
		            IF FLOOR(m.liLine * m.lnLineHeight) > m.lnHeight
		                EXIT
		            ENDIF
		        ENDIF
		        
		        m.lcLineText = SUBSTR(This.Text, m.lnCharIndex * 2 - 1)
		
		        m.lnLineCharsFitted = 0
		
		        LOCAL loLineTextRect
		        This.MeasureString(m.lcLineText, m.loLineRect, m.lhStringFormat, @m.loLineTextRect, @m.lnLineCharsFitted)
		
		        m.lcLineText = RTRIM(SUBSTR(m.lcLineText, 1, m.lnLineCharsFitted * 2), 1, CHR(13)+CHR(0), CHR(10)+CHR(0))
		        
		        m.lnCharIndex = m.lnCharIndex + m.lnLineCharsFitted
		
		        IF EMPTY(m.lcLineText) = .F.
		            LOCAL loTextLine
		            m.loTextLine = NEWOBJECT("Empty")
		            ADDPROPERTY(m.loTextLine, "Text", m.lcLineText)
		            ADDPROPERTY(m.loTextLine, "Left", m.lnTextOffsetX)
		            ADDPROPERTY(m.loTextLine, "Top", (m.liLine-1) * m.lnLineHeight + m.lnTextOffsetY)
		            ADDPROPERTY(m.loTextLine, "Width", m.lnWidth)
		            ADDPROPERTY(m.loTextLine, "Height", m.lnLineHeight)
		            ADDPROPERTY(m.loTextLine, "TextWidth", m.loLineTextRect.Width)
		            ADDPROPERTY(m.loTextLine, "TextHeight", m.loLineTextRect.Height)
		            
		
		            m.lnTextLinesCount = m.lnTextLinesCount + 1
		            
		            DIMENSION m.laTextLines(m.lnTextLinesCount)    
		            m.laTextLines[m.lnTextLinesCount] = m.loTextLine
		        ENDIF
		                        
		    ENDDO
		    *******************************************************
		
		FINALLY
		    
		    IF EMPTY(m.lhStringFormat) = .F.
		        This.env.API_GDIP.GdipDeleteStringFormat(m.lhStringFormat)
		        m.lhStringFormat = 0
		    ENDIF
		    
		ENDTRY
		
		RETURN m.lnTextLinesCount
		
	ENDPROC

	PROCEDURE render_textasimage		&& Render text as an image; Returns character representation in PNG format
		LPARAMETERS ResPictureVal as String, ResImgWidth as Long, ResImgHeight as Long
		
		LOCAL loFont
		m.loFont = This.Font
		
		LOCAL lcTempFileName
		m.lcTempFileName = This.env.GetUniqueTempFileName("png")
		
		
		LOCAL loFRXC
		m.loFRXC = This.API_FRX.CONST
		
		m.ResPictureVal = ""
		m.ResImgWidth = This.SizeWidth
		m.ResImgHeight = This.SizeHeight
		
		LOCAL lhStringFormat
		m.lhStringFormat = 0
		
		LOCAL lhImage, lhGfx, lhBrush
		STORE 0 TO m.lhImage, m.lhGfx, m.lhBrush
		
		TRY
		
		    LOCAL lnWidth, lnHeight
		    m.lnWidth = m.ResImgWidth
		    m.lnHeight = m.ResImgHeight
		    
		    IF This.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		        m.lnWidth = m.lnWidth + This.Font.FontHeightCeil * 2
		        m.ResImgWidth = m.lnWidth
		    ENDIF
		      
		    LOCAL lnTextOffsetX, lnTextOffsetY
		    m.lnTextOffsetX = 1
		    m.lnTextOffsetY = 1
		
		    DO CASE
		    CASE This.Align = m.loFRXC.ALIGN_RIGHT()
		        m.lnTextOffsetX = -1 + IIF(This.ObjType = m.loFRXC.FRX_OBJ_LABEL(), -This.Font.FontHeightCeil * 2, 0)
		
		    CASE This.Align = m.loFRXC.ALIGN_CENTER()
		        m.lnTextOffsetX = IIF(This.ObjType = m.loFRXC.FRX_OBJ_LABEL(), -This.Font.FontHeightCeil, 0)
		
		    ENDCASE
		
		    LOCAL lnLineHeight
		    m.lnLineHeight = m.loFont.LineHeight
		    
		    
		    LOCAL lnImgScale, lnImgWidth, lnImgHeight, lnImgPixelFormat
		    m.lnImgScale = 2
		    m.lnImgWidth = m.lnWidth * m.lnImgScale
		    m.lnImgHeight = m.lnHeight * m.lnImgScale
		    m.lnImgPixelFormat = This.env.API_GDIP.CONST.Gdip_PixelFormat32bppARGB()
		
		    
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipCreateBitmapFromScan0(m.lnImgWidth, m.lnImgHeight, 0, m.lnImgPixelFormat, NULL, @m.lhImage))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipBitmapSetResolution(lhImage, 96, 96))
		    
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipGetImageGraphicsContext(m.lhImage, @m.lhGfx))
		
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSetCompositingMode(m.lhGfx, 0))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSetCompositingQuality(m.lhGfx, 2))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSetPixelOffsetMode(m.lhGfx, 2))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSetTextRenderingHint(m.lhGfx, 4))
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSetTextContrast(m.lhGfx, 0))
		
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipScaleWorldTransform(m.lhGfx, m.lnImgScale, m.lnImgScale))
		    
		    
		    *******************************************************
		    * Background mode 0 - Opaque, 1 - Transparent
		    IF This.Transparent = 0
		        LOCAL lnColor
		        m.lnColor = This.env.API_GDIP.ARGB(This.FillAlpha, This.FillRed, This.FillGreen, This.FillBlue)
		        This.env.API_GDIP.GdipCreateSolidFill(m.lnColor, @m.lhBrush)
		        This.env.API_GDIP.GdipFillRectangleI(m.lhGfx, m.lhBrush, 0, 0, m.lnImgWidth, m.lnImgHeight)
		        This.env.API_GDIP.GdipDeleteBrush(m.lhBrush)
		        m.lhBrush = 0
		    ENDIF
		    *******************************************************
		    
		    LOCAL lnColor
		    m.lnColor = This.env.API_GDIP.ARGB(This.PenAlpha, This.PenRed, This.PenGreen, This.PenBlue)
		    This.env.API_GDIP.GdipCreateSolidFill(m.lnColor, @m.lhBrush)
		    
		    
		    IF This.ObjType = m.loFRXC.FRX_OBJ_LABEL()
		
		        This.env.API_GDIP.GdipStringFormatGetGenericTypographic(@m.lhStringFormat)
		        
		        This.env.API_GDIP.GdipSetStringFormatAlign(m.lhStringFormat, ;
		            ICASE(;
		                This.Align = m.loFRXC.ALIGN_LEFT(), This.env.API_GDIP.CONST.Gdip_StringAlignmentNear(), ;
		                This.Align = m.loFRXC.ALIGN_RIGHT(), This.env.API_GDIP.CONST.Gdip_StringAlignmentFar(), ;
		                This.Align = m.loFRXC.ALIGN_CENTER(), This.env.API_GDIP.CONST.Gdip_StringAlignmentCenter(), ;
		                This.env.API_GDIP.CONST.Gdip_StringAlignmentNear() ;
		                ))
		        
		        
		        LOCAL laLines(1), lnLineCnt, lnLine, lcLineText, lnLineTop
		        m.lnLineCnt = ALINES(m.laLines, STRTRAN(This.Text, CHR(10)+CHR(0), CHR(10)), 0, CHR(10))
		        
		        m.lnLineTop = 0
		        
		        FOR m.lnLine = 1 TO m.lnLineCnt
		            
		            m.lcLineText = m.laLines[m.lnLine]
		            
		            m.lnLineTop = m.lnLineTop + 1
		            IF m.lnLine > 1
		                m.lnLineTop = m.lnLineTop + ICASE(This.LineSpacing = 1, 0.5, This.LineSpacing = 2, 1, 0)
		            ENDIF
		            
		            LOCAL lqLayoutRect
		            m.lqLayoutRect = ;
		                BINTOC(m.lnTextOffsetX + ICASE(This.Align = m.loFRXC.ALIGN_RIGHT(), m.lnWidth, This.Align = m.loFRXC.ALIGN_CENTER(), m.lnWidth * 0.5, 0), "F") +;
		                BINTOC(m.lnTextOffsetY + (m.lnLineTop - 1) * m.lnLineHeight, "F") + ;
		                BINTOC(0, "F") + ;
		                BINTOC(0, "F")
		            
		
		            This.env.API_GDIP.GdipDrawString(;
		                m.lhGfx, ;
		                m.lcLineText + CHR(0), ;
		                LEN(m.lcLineText) / 2, ;
		                m.loFont.GdipFont, ;
		                @m.lqLayoutRect, ;
		                m.lhStringFormat, ;
		                m.lhBrush)
		                
		        ENDFOR    
		
		    ELSE
		
		        IF m.loFont.FontPrivate 
		            * VFP is unable to use private gdi+ fonts, thus it renders field with fallback font, this font can be smaller than actual report font
		            * thus GenerericTypographic is used to make resulting text lines more condensed 
		            This.env.API_GDIP.GdipStringFormatGetGenericTypographic(@m.lhStringFormat)
		        ELSE
		            This.env.API_GDIP.GdipStringFormatGetGenericDefault(@m.lhStringFormat)
		            This.env.API_GDIP.GdipSetStringFormatFlags(m.lhStringFormat, This.env.API_GDIP.CONST.Gdip_StringFormatFlagsLineLimit())
		        ENDIF
		
		        This.env.API_GDIP.GdipSetStringFormatTrimming(m.lhStringFormat, ;
		            IIF(FLOOR(m.lnHeight / EVL(m.lnLineHeight,1)) <= 1, ;
		                This.env.API_GDIP.CONST.Gdip_StringTrimmingCharacter(), ;
		                This.env.API_GDIP.CONST.Gdip_StringTrimmingNone()) ;
		            )
		
		        This.env.API_GDIP.GdipSetStringFormatAlign(m.lhStringFormat, ;
		            ICASE(;
		                This.Align = m.loFRXC.ALIGN_LEFT(), This.env.API_GDIP.CONST.Gdip_StringAlignmentNear(), ;
		                This.Align = m.loFRXC.ALIGN_RIGHT(), This.env.API_GDIP.CONST.Gdip_StringAlignmentFar(), ;
		                This.Align = m.loFRXC.ALIGN_CENTER(), This.env.API_GDIP.CONST.Gdip_StringAlignmentCenter(), ;
		                This.env.API_GDIP.CONST.Gdip_StringAlignmentNear() ;
		                ))
		
		
		        LOCAL lqLayoutRect
		        m.lqLayoutRect = ;
		            BINTOC(m.lnTextOffsetX, "F") +;
		            BINTOC(m.lnTextOffsetY, "F") + ;
		            BINTOC(CEILING(m.lnWidth), "F") + ;
		            BINTOC(CEILING(m.lnHeight), "F")
		        
		
		        This.env.API_GDIP.GdipDrawString(;
		            m.lhGfx, ;
		            This.Text + CHR(0), ;
		            LEN(This.Text) / 2, ;
		            m.loFont.GdipFont, ;
		            @m.lqLayoutRect, ;
		            m.lhStringFormat, ;
		            m.lhBrush)
		    
		    ENDIF
		
		    LOCAL lcImgEncoder
		    m.lcImgEncoder = This.env.API_GDIP.GdipGetImageEncoder("image/png")
		    
		    This.env.API_GDIP.CheckError(This.env.API_GDIP.GdipSaveImageToFile(m.lhImage, STRCONV(m.lcTempFileName,5)+CHR(0), m.lcImgEncoder, 0))
		    
		    m.ResPictureVal = FILETOSTR(m.lcTempFileName)
		
		
		FINALLY
		
		    IF EMPTY(m.lhStringFormat) = .F.
		        This.env.API_GDIP.GdipDeleteStringFormat(m.lhStringFormat)
		        m.lhStringFormat = 0
		    ENDIF
		    
		    IF EMPTY(m.lhGfx) = .F.
		        This.env.API_GDIP.GdipDeleteGraphics(m.lhGfx)
		    ENDIF
		    
		    IF EMPTY(m.lhImage) = .F.
		        This.env.API_GDIP.GdipDisposeImage(m.lhImage)
		        m.lhImage = 0
		    ENDIF
		    
		    IF EMPTY(m.lhBrush) = .F.
		        This.env.API_GDIP.GdipDeleteBrush(m.lhBrush)
		        m.lhBrush = 0
		    ENDIF
		
		
		    IF EMPTY(m.lcTempFileName) = .F.
		        DELETE FILE (m.lcTempFileName)
		    ENDIF
		ENDTRY
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreport_status_window AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpProgress" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblProgress" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblStatus" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: oncancel
		*m: updatestatus		&& Triggers a change of information in the user interface elements provided by DoStatus.
		*m: wndproc
		*p: cancelbuttonhandle
		*p: cancelbuttonid
		*p: env
		*p: starttime
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN cancelbuttonhandle,cancelbuttonid,env,starttime
	*<PropValue>
		AllowOutput = .F.
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BorderStyle = 3
		cancelbuttonhandle = 0
		cancelbuttonid = 0
		Caption = "Form"
		Closable = .F.
		DoCreate = .T.
		env = .F.
		Height = 74
		MaxButton = .F.
		MinButton = .F.
		Name = "pdfiumreport_status_window"
		ScrollBars = 0
		ShowWindow = 1
		starttime = ({. :})
		Themes = .T.
		TitleBar = 0
		Visible = .F.
		Width = 445
		WindowState = 0
		_memberdata = <VFPData>
			<memberdata name="env" type="property" display="env"/>
			<memberdata name="wndproc" type="method" display="WndProc"/>
			<memberdata name="cancelbuttonhandle" type="property" display="CancelButtonHandle"/>
			<memberdata name="cancelbuttonid" type="property" display="CancelButtonId"/>
			<memberdata name="oncancel" type="method" display="OnCancel"/>
			<memberdata name="updatestatus" type="method" display="UpdateStatus"/>
			<memberdata name="starttime" type="property" display="StartTime"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		Caption = "Cancel", ;
		Height = 27, ;
		Left = 168, ;
		Name = "cmdCancel", ;
		Top = 36, ;
		Width = 108
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 408, ;
		Name = "i18n", ;
		Top = 0, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'lblProgress' AS label WITH ;
		Alignment = 2, ;
		BackStyle = 0, ;
		Caption = "Progress", ;
		FontBold = .F., ;
		ForeColor = 255,255,255, ;
		Height = 17, ;
		Left = 13, ;
		Name = "lblProgress", ;
		Top = 12, ;
		Visible = .F., ;
		Width = 420
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblStatus' AS label WITH ;
		Alignment = 0, ;
		BackStyle = 0, ;
		Caption = "Status", ;
		Height = 17, ;
		Left = 12, ;
		Name = "lblStatus", ;
		Top = 12, ;
		Visible = .F., ;
		Width = 420
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'shpProgress' AS shape WITH ;
		BackColor = 0,128,128, ;
		Height = 17, ;
		Left = 12, ;
		Name = "shpProgress", ;
		Top = 12, ;
		Visible = .F., ;
		Width = 423
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp
		
		This.BorderStyle = 1
		This.Visible = .F.
		This.StartTime = DATETIME()
		
		This.env = NEWOBJECT("pdfium_env", "pdfium-vfp.vcx")
		This.env.Setup(m.toEnv)
		
		#DEFINE GWL_HINSTANCE -6
		#define WS_CHILD            0x40000000
		#define WS_VISIBLE          0x10000000
		#define WM_COMMAND 0x0111
		
		LOCAL lhInstance
		m.lhInstance = This.env.API_WIN.GetWindowLong(This.HWnd, GWL_HINSTANCE)
		
		This.CancelButtonId = 10
		
		This.CancelButtonHandle = This.env.API_WIN.CreateWindowEx( ;
		    0, ;
		    "BUTTON", ;
		    This.cmdCancel.Caption, ;
		    WS_CHILD + WS_VISIBLE, ;
		    This.cmdCancel.Left, ;
		    This.cmdCancel.Top, ;
		    This.cmdCancel.Width, ;
		    This.cmdCancel.Height, ;
		    This.HWnd, ;
		    This.CancelButtonId, ;
		    m.lhInstance, ;
		    0)
		
		This.RemoveObject(This.cmdCancel.Name)
		
		BINDEVENT(This.HWnd, WM_COMMAND, This, "WndProc")
		
		
	ENDPROC

	PROCEDURE oncancel
	ENDPROC

	PROCEDURE updatestatus		&& Triggers a change of information in the user interface elements provided by DoStatus.
		LPARAMETERS cMessage, tnPercent
		
		IF EMPTY(m.tnPercent)
		    This.lblStatus.Caption = EVL(m.cMessage, "")
		    IF This.lblStatus.Visible = .F.
		        This.lblStatus.Visible = .T.
		        This.lblProgress.Visible = .F.
		        This.shpProgress.Visible = .F.
		    ENDIF
		ELSE
		    This.lblProgress.Caption = EVL(m.cMessage, "")
		    This.shpProgress.Width = This.lblStatus.Width * m.tnPercent / 100
		    This.lblProgress.Width = This.shpProgress.Width
		    IF This.lblProgress.Visible = .F.
		        This.lblStatus.Visible = .F.
		        This.lblProgress.Visible = .T.
		        This.shpProgress.Visible = .T.
		    ENDIF
		ENDIF
		
		IF This.Visible = .F. AND (DATETIME() - This.StartTime) > 1
		    This.Show()
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE wndproc
		LPARAMETERS thWnd, tnMsg, tnWParam, tnLParam
		
		#define GWL_WNDPROC -4
		#define WM_COMMAND 0x0111
		
		LOCAL lnRetVal
		m.lnRetVal = 0
		
		DO CASE
		CASE m.tnMsg = WM_COMMAND AND m.tnLParam = This.CancelButtonHandle
		    This.OnCancel()
		
		OTHERWISE
		    LOCAL lnWndProcDefault
		    m.lnWndProcDefault = This.env.API_WIN.GetWindowLong(m.thWnd, GWL_WNDPROC)
		    m.lnRetVal = This.env.API_WIN.CallWindowProc(m.lnWndProcDefault, m.thWnd, m.tnMsg, m.tnWParam, m.tnLParam)
		ENDCASE
		
		RETURN m.lnRetVal
		
	ENDPROC

	PROCEDURE cmdCancel.Init
		This.Caption = Thisform.i18n.Text("PDFIUMREPORT_CANCEL")
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pdfiumreportviewer AS form 		&& Report preview for PdfiumReport. Library consumer shouldn't use this class directly
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="PdfiumViewer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="i18n" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSaveAs" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFitWidth" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFitPage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmbScale" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPageInfo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExportDocx" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="env" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: close		&& Close preview window
		*m: exportdocument
		*m: openpdf		&& Open pdf file
		*m: printreport		&& Print report
		*m: savedocument
		*m: scalechanged		&& Scale change handling
		*m: setreport		&& ReportPreviewer interface requirement (reead docs on ReportPreviewer, ReportListener)
		*p: listenerref
		*p: saveas_filename		&& Filename suggestion for "save as" dialog
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN listenerref
	*<PropValue>
		Caption = "Pdfium report preview"
		Desktop = .F.
		DoCreate = .T.
		Height = 741
		Icon = ("images\wwrite.ico")
		KeyPreview = .T.
		Left = 0
		listenerref = .F.
		MaxButton = .T.
		MinButton = .F.
		Name = "pdfiumreportviewer"
		saveas_filename = ("")
		ScrollBars = 0
		ShowWindow = 1
		Top = 0
		Visible = .T.
		Width = 792
		WindowState = 0
		WindowType = 0
		_memberdata = <VFPData>
			<memberdata name="openpdf" type="method" display="OpenPDF"/>
			<memberdata name="setreport" type="method" display="SetReport"/>
			<memberdata name="listenerref" type="property" display="ListenerRef"/>
			<memberdata name="printreport" type="method" display="PrintReport"/>
			<memberdata name="close" type="method" display="Close"/>
			<memberdata name="scalechanged" type="method" display="ScaleChanged"/>
			<memberdata name="saveas_filename" type="property" display="SaveAs_Filename"/>
			<memberdata name="savedocument" type="method" display="SaveDocument"/>
			<memberdata name="exportdocument" type="method" display="ExportDocument"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cmbScale' AS combobox WITH ;
		BoundColumn = 1, ;
		BoundTo = .F., ;
		ColumnCount = 1, ;
		ColumnLines = .F., ;
		ColumnWidths = "80,0", ;
		ControlSource = "", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 27, ;
		Left = 579, ;
		Name = "cmbScale", ;
		Style = 2, ;
		TabIndex = 9, ;
		TabStop = .F., ;
		Top = 11, ;
		Width = 65
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdClose' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 736, ;
		Name = "cmdClose", ;
		Picture = images\close.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 10, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdExportDocx' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 431, ;
		Name = "cmdExportDocx", ;
		Picture = images\docx.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 6, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFitPage' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 528, ;
		Name = "cmdFitPage", ;
		Picture = images\fitpage.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 8, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFitWidth' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 482, ;
		Name = "cmdFitWidth", ;
		Picture = images\fitwidth.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 7, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrint' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "  Print", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 237, ;
		Name = "cmdPrint", ;
		Picture = images\print.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 4, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 135
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSaveAs' AS commandbutton WITH ;
		Alignment = 2, ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 384, ;
		Name = "cmdSaveAs", ;
		Picture = images\saveas.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 1, ;
		PictureSpacing = 0, ;
		TabIndex = 5, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSearch' AS commandbutton WITH ;
		Anchor = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontName = "Segoe UI", ;
		FontSize = 12, ;
		Height = 32, ;
		Left = 189, ;
		Name = "cmdSearch", ;
		Picture = images\search.bmp, ;
		PictureMargin = 0, ;
		PicturePosition = 14, ;
		PictureSpacing = 0, ;
		TabIndex = 3, ;
		TabStop = .F., ;
		Top = 8, ;
		Width = 41
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'env' AS pdfium_env WITH ;
		Left = 456, ;
		Name = "env", ;
		Top = 60, ;
		API_FPDF.CONST.Name = "CONST", ;
		API_FPDF.Name = "API_FPDF", ;
		API_WIN.Name = "API_WIN", ;
		API_GDIP.CONST.Name = "CONST", ;
		API_GDIP.Name = "API_GDIP", ;
		API_FPDF_FORMS.CONST.Name = "CONST", ;
		API_FPDF_FORMS.Name = "API_FPDF_FORMS", ;
		API_FPDF_ANNOT.CONST.Name = "CONST", ;
		API_FPDF_ANNOT.Name = "API_FPDF_ANNOT"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'i18n' AS pdfium_i18n WITH ;
		Left = 192, ;
		Name = "i18n", ;
		Top = 72, ;
		API_WIN.Name = "API_WIN"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="custom" />

	ADD OBJECT 'lblPageInfo' AS label WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "1234 / 1234", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Height = 19, ;
		Left = 648, ;
		Name = "lblPageInfo", ;
		TabIndex = 11, ;
		Top = 15, ;
		Width = 76
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'PdfiumViewer' AS pdfiumviewer WITH ;
		Anchor = 15, ;
		Enabled = .T., ;
		Height = 681, ;
		Left = 12, ;
		Name = "PdfiumViewer", ;
		scrollbars = 3, ;
		TabIndex = 1, ;
		TabStop = .T., ;
		Top = 48, ;
		Visible = .T., ;
		Width = 768, ;
		cmdFocus.Name = "cmdFocus", ;
		env.API_FPDF.CONST.Name = "CONST", ;
		env.API_FPDF.Name = "API_FPDF", ;
		env.API_FPDF_ANNOT.CONST.Name = "CONST", ;
		env.API_FPDF_ANNOT.Name = "API_FPDF_ANNOT", ;
		env.API_FPDF_FORMS.CONST.Name = "CONST", ;
		env.API_FPDF_FORMS.Name = "API_FPDF_FORMS", ;
		env.API_GDIP.CONST.Name = "CONST", ;
		env.API_GDIP.Name = "API_GDIP", ;
		env.API_WIN.Name = "API_WIN", ;
		env.Name = "env", ;
		i18n.API_WIN.Name = "API_WIN", ;
		i18n.Name = "i18n", ;
		UIState.Name = "UIState"
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="control" />

	ADD OBJECT 'txtSearch' AS pdfium_textbox WITH ;
		Anchor = 0, ;
		InputMask = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", ;
		Left = 12, ;
		Name = "txtSearch", ;
		TabIndex = 2, ;
		TabStop = .F., ;
		Top = 11
		*< END OBJECT: ClassLib="pdfium-vfp.vcx" BaseClass="textbox" />
	
	PROCEDURE close		&& Close preview window
		IF VARTYPE(This.ListenerRef)="O"
		    This.ListenerRef.OnPreviewClose()
		    This.ListenerRef = .F.
		ENDIF
		
		This.Hide()
		
	ENDPROC

	PROCEDURE Destroy
		This.Pdfiumviewer.Destroy()
		
	ENDPROC

	PROCEDURE exportdocument
		LPARAMETERS tcExt
		
		LOCAL lcExt
		m.lcExt = LOWER(EVL(m.tcExt, "docx"))
		
		LOCAL lcTempFileName
		m.lcTempFileName = ""
		
		LOCAL loErr
		m.loErr = .F.
		TRY
		
		    LOCAL loRenderer
		    m.loRenderer = .F.
		    DO CASE
		    CASE m.lcExt == "docx"
		        m.loRenderer = NEWOBJECT("pdfiumreport_renderer_docx", Thisform.ClassLibrary, "", This.env)
		    ENDCASE
		
		    IF VARTYPE(m.loRenderer) <> "O"
		        EXIT
		    ENDIF
		
		    LOCAL lcOutputFileName
		    m.lcOutputFileName = This.env.GetSaveFileName(Thisform.SaveAs_Filename, m.lcExt)
		
		    IF EMPTY(m.lcOutputFileName)
		        EXIT
		    ENDIF
		
		    m.lcTempFileName = This.ListenerRef.RunRenderer(m.loRenderer)
		    IF FILE(m.lcTempFileName,1)
		        COPY FILE (m.lcTempFileName) TO (m.lcOutputFileName)
		        This.env.API_Win.ShellExecute(0, "Open", FULLPATH(m.lcOutputFileName), NULL, SYS(2023), 1)
		    ENDIF
		    
		CATCH TO m.loErr
		    IF SYS(2335) != '0'
		        MESSAGEBOX(This.env.ErrFmt(m.loErr), 0+48, This.Class + " ("+This.ClassLibrary+")")
		    ENDIF
		    
		FINALLY
		    TRY
		        IF EMPTY(m.lcTempFileName) = .F.
		            DELETE FILE (m.lcTempFileName)
		        ENDIF
		    CATCH
		    ENDTRY
		
		ENDTRY    
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toEnv as pdfium_env of pdfium-vfp, toPrintEnv as Pdfium_print_env of pdfium-vfp.vcx
		
		This.env.Setup(m.toEnv)
		
		This.Pdfiumviewer.Init(m.toEnv)
		
		This.Pdfiumviewer.PrintEnv.Setup(m.toPrintEnv)
		
		
		BINDEVENT(This.PdfiumViewer, "scale", This, "scalechanged", 1)
		
		This.Caption = This.i18n.text("REPORTVIEWER_TITLE")
		
		This.MinWidth = This.Width
		This.MinHeight = 300
		
		
		LOCAL loTopLevelForm
		IF TYPE("Application.ActiveForm") = "O"
		    m.loTopLevelForm = Application.ActiveForm
		ELSE
		    m.loTopLevelForm = _SCREEN    
		ENDIF
		
		IF m.loTopLevelForm.ShowWindow <> 2
		    m.loTopLevelForm = _SCREEN
		ENDIF
		
		
		IF m.loTopLevelForm = _SCREEN
		    LOCAL lnTop, lnBottom
		    m.lnTop = 0
		    m.lnBottom = m.loTopLevelForm.Height
		
		
		    LOCAL i, loForm
		    FOR m.i = 1 TO m.loTopLevelForm.FormCount
		        m.loForm = m.loTopLevelForm.Forms[m.i]
		        
		        IF m.loForm = Thisform
		            LOOP
		        ENDIF
		
		        IF m.loForm.DockPosition = 0
		            m.lnTop = MAX(m.lnTop, m.loForm.Top + m.loForm.Height)
		        ENDIF
		
		        IF m.loForm.DockPosition = 3
		            m.lnBottom = MIN(m.lnBottom, m.loForm.Height - laDockState[m.i,6].Top)
		        ENDIF
		        
		    ENDFOR
		
		    This.Width = MAX(MIN(m.loTopLevelForm.Height, m.loTopLevelForm.Width) - SYSMETRIC(3) , This.MinWidth) 
		    This.Height = MAX(MAX(m.lnBottom - m.lnTop, This.Height) - SYSMETRIC(4), This.MinHeight)
		
		ENDIF
		
		This.WindowState = 2
		This.TitleBar = 0
		This.BorderStyle = 0
		
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		DO CASE
		CASE m.nKeyCode = 6 AND m.nShiftAltCtrl = 2 && Ctrl + F
		    NODEFAULT
		    This.txtSearch.SetFocus()
		
		CASE m.nKeyCode = -2 AND m.nShiftAltCtrl = 0 && F3
		    NODEFAULT
		    Thisform.cmdSearch.Click()
		
		ENDCASE
		
	ENDPROC

	PROCEDURE openpdf		&& Open pdf file
		LPARAMETERS tcFilename, tcPassword
		
		RETURN This.pdfiumviewer.OpenPDF(m.tcFilename, m.tcPassword)
		
	ENDPROC

	PROCEDURE printreport		&& Print report
		This.PdfiumViewer.PrintDocument()
		
	ENDPROC

	PROCEDURE QueryUnload
		
		This.Close()
		
		
	ENDPROC

	PROCEDURE Resize
		IF This.ScrollBars > 0 AND Thisform.WindowState = 2
		    This.Cls()
		ENDIF
		This.Refresh()
		
	ENDPROC

	PROCEDURE savedocument
		LOCAL lcFilename
		m.lcFilename = This.env.GetSaveFileName(Thisform.SaveAs_Filename, "pdf")
		
		IF EMPTY(m.lcFilename)
		    RETURN
		ENDIF
		
		Thisform.pdfiumviewer.SaveDocument(m.lcFileName)
		
	ENDPROC

	PROCEDURE scalechanged		&& Scale change handling
		LOCAL lnScale, lcScale
		m.lnScale = This.PdfiumViewer.Scale
		m.lcScale = TRANSFORM(INT(m.lnScale*100)) + "%"
		
		IF INLIST(m.lnScale,1,2,3,4)=.F.
		    This.cmbScale.List[1] = m.lcScale
		ELSE
		    This.cmbScale.List[1] = ""
		ENDIF
		
		This.cmbScale.Value = m.lcScale
		
	ENDPROC

	PROCEDURE setreport		&& ReportPreviewer interface requirement (reead docs on ReportPreviewer, ReportListener)
		LPARAMETERS toListenerRef 
		
		This.ListenerRef = m.toListenerRef 
		
	ENDPROC

	PROCEDURE cmbScale.Init
		This.AddItem("")
		This.AddItem("100%")
		This.AddItem("200%")
		This.AddItem("300%")
		This.AddItem("400%")
		
	ENDPROC

	PROCEDURE cmbScale.InteractiveChange
		Thisform.pdfiumviewer.Scale = MIN(MAX(INT(VAL(EVL(This.Value,"100")))/100,0.25),4)
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdClose.Click
		Thisform.Close()
		
		
	ENDPROC

	PROCEDURE cmdExportDocx.Click
		Thisform.ExportDocument("docx")
		
	ENDPROC

	PROCEDURE cmdFitPage.Click
		Thisform.pdfiumviewer.FitWidth = .F.
		Thisform.pdfiumviewer.Scale = 1
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdFitPage.Refresh
		IF Thisform.pdfiumviewer.FitWidth = .T. and This.Enabled = .F.
		    This.Enabled = .T.
		ENDIF
		
		IF Thisform.pdfiumviewer.FitWidth = .F. and This.Enabled = .T.
		    This.Enabled = .F.
		ENDIF
		
		
	ENDPROC

	PROCEDURE cmdFitWidth.Click
		Thisform.pdfiumviewer.FitWidth = .T.
		Thisform.pdfiumviewer.Scale = 1
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdFitWidth.Refresh
		IF Thisform.pdfiumviewer.FitWidth = .T. and This.Enabled = .T.
		    This.Enabled = .F.
		ENDIF
		
		IF Thisform.pdfiumviewer.FitWidth = .F. and This.Enabled = .F.
		    This.Enabled = .T.
		ENDIF
		
		
	ENDPROC

	PROCEDURE cmdPrint.Click
		Thisform.PrintReport()
		
	ENDPROC

	PROCEDURE cmdPrint.Refresh
		This.Caption = SPACE(2) + Thisform.i18n.text("BTN_PRINT")
		
	ENDPROC

	PROCEDURE cmdSaveAs.Click
		Thisform.SaveDocument()
		
	ENDPROC

	PROCEDURE cmdSearch.Click
		CLEAR TYPEAHEAD 
		
		IF EMPTY(Thisform.txtSearch.Value)
		    Thisform.pdfiumviewer.SearchClose()
		ELSE
		    LOCAL lnRes
		    m.lnRes = Thisform.Pdfiumviewer.SearchText(Thisform.txtSearch.Value)
		    DO CASE
		    CASE m.lnRes = 0
		        WAIT WINDOW Thisform.i18n.text("SEARCH_NOT_FOUND") NOWAIT
		    CASE m.lnRes = 2
		        WAIT WINDOW Thisform.i18n.text("SEARCH_ENDED") NOWAIT
		    ENDCASE
		    
		ENDIF
		
	ENDPROC

	PROCEDURE lblPageInfo.Refresh
		This.Caption = TRANSFORM(Thisform.PdfiumViewer.GetCurrentPage()) + " / " + TRANSFORM(Thisform.PdfiumViewer.GetPageCount())
		
	ENDPROC

	PROCEDURE PdfiumViewer.afterviewportupdate
		Thisform.lblPageInfo.Refresh()
		
	ENDPROC

	PROCEDURE txtSearch.GotFocus
		Thisform.pdfiumviewer.SearchClose()
		
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE txtSearch.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 13 AND EMPTY(m.nShiftAltCtrl) AND EMPTY(This.Value)=.F.
		    NODEFAULT
		    Thisform.cmdSearch.Click()
		ENDIF    
		
		DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		
		
	ENDPROC

ENDDEFINE
